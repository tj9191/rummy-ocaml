// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: CamlinternalFormatBasics
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib
//# unitInfo: Requires: CamlinternalFormatBasics
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_atomic_cas = runtime.caml_atomic_cas,
    caml_atomic_load = runtime.caml_atomic_load,
    caml_blit_string = runtime.caml_blit_string,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = "%,",
    cst = ".",
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module,
    cst_really_input = "really_input",
    cst_input = "input",
    _l_ = [0, 0, [0, 6, 0]],
    _k_ = [0, 0, [0, 7, 0]],
    cst_output_substring = "output_substring",
    cst_output = "output",
    _j_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    _i_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _g_ = [0, 1],
    _h_ = [0, 0],
    cst_bool_of_string = "bool_of_string",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_char_of_int = "char_of_int",
    cst_Stdlib_Exit = "Stdlib.Exit",
    _a_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 32752),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 65520),
    _c_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 32760),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751),
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 16),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 15536);
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, cst_Stdlib_Exit, runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity = caml_int64_float_of_bits(_a_),
    neg_infinity = caml_int64_float_of_bits(_b_),
    nan = caml_int64_float_of_bits(_c_),
    max_float = caml_int64_float_of_bits(_d_),
    min_float = caml_int64_float_of_bits(_e_),
    epsilon_float = caml_int64_float_of_bits(_f_),
    max_int = 2147483647,
    min_int = -2147483648;
   function symbol(s1, s2){
    var
     l1 = caml_ml_string_length(s1),
     l2 = caml_ml_string_length(s2),
     s = caml_create_bytes(l1 + l2 | 0);
    caml_blit_string(s1, 0, s, 0, l1);
    caml_blit_string(s2, 0, s, l1, l2);
    return caml_string_of_bytes(s);
   }
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return caml_string_notequal(param, cst_false$0)
            ? caml_string_notequal
               (param, cst_true$0)
              ? invalid_arg(cst_bool_of_string)
              : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return caml_string_notequal(param, cst_false$0)
            ? caml_string_notequal(param, cst_true$0) ? 0 : _g_
            : _h_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _D_ = [0, caml_int_of_string(s)]; return _D_;}
    catch(_E_){
     var _C_ = caml_wrap_exception(_E_);
     if(_C_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_C_, 0);
    }
   }
   function valid_float_lexem(s){
    var l = caml_ml_string_length(s), i = 0;
    for(;;){
     if(l <= i) return symbol(s, cst);
     var match = runtime.caml_string_get(s, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s;
     }
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _A_ = [0, caml_float_of_string(s)]; return _A_;}
    catch(_B_){
     var _z_ = caml_wrap_exception(_B_);
     if(_z_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function symbol$0(l1, l2){
    if(! l1) return l2;
    var _x_ = l1[2], h1 = l1[1];
    if(! _x_) return [0, h1, l2];
    var match = _x_[2], h2 = _x_[1];
    if(! match) return [0, h1, [0, h2, l2]];
    var
     tl = match[2],
     h3 = match[1],
     block = [0, h3, 24029],
     dst = block,
     offset = 1,
     l1$0 = tl;
    for(;;){
     if(l1$0){
      var _y_ = l1$0[2], h1$0 = l1$0[1];
      if(_y_){
       var match$0 = _y_[2], h2$0 = _y_[1];
       if(match$0){
        var tl$0 = match$0[2], h3$0 = match$0[1], dst$0 = [0, h3$0, 24029];
        dst[1 + offset] = [0, h1$0, [0, h2$0, dst$0]];
        var dst = dst$0, offset = 1, l1$0 = tl$0;
        continue;
       }
       dst[1 + offset] = [0, h1$0, [0, h2$0, l2]];
      }
      else
       dst[1 + offset] = [0, h1$0, l2];
     }
     else
      dst[1 + offset] = l2;
     return [0, h1, [0, h2, block]];
    }
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2);
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_i_, 438, name);}
   function open_out_bin(name){return open_out_gen(_j_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_w_){
      var _v_ = caml_wrap_exception(_w_);
      if(_v_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_v_, 0);
     }
     var param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_u_){}
    try{var _s_ = caml_ml_close_channel(oc); return _s_;}catch(_t_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_k_, 0, name);}
   function open_in_bin(name){return open_in_gen(_l_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var
      len$1 = len$0 - r | 0,
      ofs$1 = ofs$0 + r | 0,
      ofs$0 = ofs$1,
      len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0, pos$0 = pos$1, param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _r_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var
        len$1 = len - n | 0,
        accu$0 = [0, beg, accu],
        accu = accu$0,
        len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _r_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _r_ = res;
     }
     return caml_string_of_bytes(_r_);
    }
   }
   function close_in_noerr(ic){
    try{var _p_ = caml_ml_close_channel(ic); return _p_;}catch(_q_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$1(param, _n_){
    var
     str2 = _n_[2],
     fmt2 = _n_[1],
     str1 = param[2],
     fmt1 = param[1],
     _o_ = symbol(str1, symbol(cst$0, str2));
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), _o_];
   }
   var exit_function = [0, flush_all];
   function at_exit(f){
    for(;;){
     var
      f_yet_to_run = [0, 1],
      old_exit = caml_atomic_load(exit_function),
      new_exit$0 =
        function(f_yet_to_run, old_exit){
         function new_exit(param){
          if(caml_atomic_cas(f_yet_to_run, 1, 0)) caml_call1(f, 0);
          return caml_call1(old_exit, 0);
         }
         return new_exit;
        },
      new_exit = new_exit$0(f_yet_to_run, old_exit),
      success = caml_atomic_cas(exit_function, old_exit, new_exit),
      _m_ = 1 - success;
     if(! _m_) return _m_;
    }
   }
   var do_domain_local_at_exit = [0, function(param){return 0;}];
   function do_at_exit(param){
    caml_call1(do_domain_local_at_exit[1], 0);
    return caml_call1(caml_atomic_load(exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol$0,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$1,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit];
   runtime.caml_register_global(45, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Either
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function left(v){return [0, v];}
   function right(v){return [1, v];}
   function is_left(param){return 0 === param[0] ? 1 : 0;}
   function is_right(param){return 0 === param[0] ? 0 : 1;}
   function find_left(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function find_right(param){
    if(0 === param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function map_left(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_right(f, e){
    if(0 === e[0]) return e;
    var v = e[1];
    return [1, caml_call1(f, v)];
   }
   function map(left, right, param){
    if(0 === param[0]){var v = param[1]; return [0, caml_call1(left, v)];}
    var v$0 = param[1];
    return [1, caml_call1(right, v$0)];
   }
   function fold(left, right, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(left, v);}
    var v$0 = param[1];
    return caml_call1(right, v$0);
   }
   function equal(left, right, e1, e2){
    if(0 === e1[0]){
     var v1 = e1[1];
     if(0 === e2[0]){var v2 = e2[1]; return caml_call2(left, v1, v2);}
    }
    else{
     var v1$0 = e1[1];
     if(0 !== e2[0]){var v2$0 = e2[1]; return caml_call2(right, v1$0, v2$0);}
    }
    return 0;
   }
   function compare(left, right, e1, e2){
    if(0 === e1[0]){
     var v1 = e1[1];
     if(0 !== e2[0]) return -1;
     var v2 = e2[1];
     return caml_call2(left, v1, v2);
    }
    var v1$0 = e1[1];
    if(0 === e2[0]) return 1;
    var v2$0 = e2[1];
    return caml_call2(right, v1$0, v2$0);
   }
   var
    Stdlib_Either =
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map,
       fold,
       fold,
       fold,
       equal,
       compare];
   runtime.caml_register_global(0, Stdlib_Either, "Stdlib__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Sys
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "5.1.1",
    ocaml_release = [0, 5, 1, 1, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0,
    cst_Stdlib_Sys_Break = "Stdlib.Sys.Break",
    big_endian = 0,
    word_size = 32,
    int_size = 32;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var
    Break = [248, cst_Stdlib_Sys_Break, runtime.caml_fresh_oo_id(0)],
    sigabrt = -1,
    sigalrm = -2,
    sigfpe = -3,
    sighup = -4,
    sigill = -5,
    sigint = -6,
    sigkill = -7,
    sigpipe = -8,
    sigquit = -9,
    sigsegv = -10,
    sigterm = -11,
    sigusr1 = -12,
    sigusr2 = -13,
    sigchld = -14,
    sigcont = -15,
    sigstop = -16,
    sigtstp = -17,
    sigttin = -18,
    sigttou = -19,
    sigvtalrm = -20,
    sigprof = -21,
    sigbus = -22,
    sigpoll = -23,
    sigsys = -24,
    sigtrap = -25,
    sigurg = -26,
    sigxcpu = -27,
    sigxfsz = -28;
   function catch_break(on){return on ? 0 : 0;}
   var development_version = 0;
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       word_size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       development_version,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Obj
//# unitInfo: Requires: Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    _a_ = [0, "obj.ml", 94, 4];
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   var
    double_field = runtime.caml_array_get,
    set_double_field = runtime.caml_array_set,
    first_non_constant_constructor = 0,
    last_non_constant_constructor_ = 243,
    forcing_tag = 244,
    cont_tag = 245,
    lazy_tag = 246,
    closure_tag = 247,
    object_tag = 248,
    infix_tag = 249,
    forward_tag = 250,
    no_scan_tag = 251,
    abstract_tag = 251,
    string_tag = 252,
    double_tag = 253,
    double_array_tag = 254,
    custom_tag = 255,
    int_tag = 1000,
    out_of_heap_tag = 1001,
    unaligned_tag = 1002;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function of_val(x){
    a:
    {
     if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; break a;}
     var slot = x;
    }
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0;
   function create(l){
    var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
    if(1 - _h_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 1 - 2 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _d_ = 0 <= o ? 1 : 0,
     _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_,
     _f_ = 1 - _e_;
    return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _b_ = 0 !== l ? 1 : 0,
      _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
     return _c_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       forcing_tag,
       cont_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0, info],
       Extension_constructor,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Type
//# unitInfo: Requires: Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    _a_ = [0, 0],
    cst_Id = "Id";
   function make(param){
    var Id = [248, cst_Id, runtime.caml_fresh_oo_id(0)];
    return [0, Id];
   }
   function uid(A){
    var _b_ = caml_call1(Stdlib_Obj[23][1], A[1]);
    return caml_call1(Stdlib_Obj[23][3], _b_);
   }
   function provably_equal(A, B){return A[1] === B[1] ? _a_ : 0;}
   var Id = [0, make, uid, provably_equal], Stdlib_Type = [0, Id];
   runtime.caml_register_global(3, Stdlib_Type, "Stdlib__Type");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Atomic
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_atomic_exchange = runtime.caml_atomic_exchange,
    caml_atomic_fetch_add = runtime.caml_atomic_fetch_add;
   function set(r, x){caml_atomic_exchange(r, x); return 0;}
   function incr(r){caml_atomic_fetch_add(r, 1); return 0;}
   function decr(r){caml_atomic_fetch_add(r, -1); return 0;}
   var
    _a_ = caml_atomic_fetch_add,
    _b_ = runtime.caml_atomic_cas,
    _c_ = caml_atomic_exchange,
    _d_ = runtime.caml_atomic_load,
    Stdlib_Atomic =
      [0,
       function(_e_){return [0, _e_];},
       _d_,
       set,
       _c_,
       _b_,
       _a_,
       incr,
       decr];
   runtime.caml_register_global(0, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalLazy
//# unitInfo: Requires: Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_lazy_update_to_forward = runtime.caml_lazy_update_to_forward,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function force_gen_lazy_block(only_val, blk){
    if(0 !== runtime.caml_lazy_update_to_forcing(blk))
     throw caml_maybe_attach_backtrace(Undefined, 1);
    if(only_val){
     var closure$0 = blk[1];
     blk[1] = 0;
     var result$0 = caml_call1(closure$0, 0);
     blk[1] = result$0;
     caml_lazy_update_to_forward(blk);
     return result$0;
    }
    var closure = blk[1];
    blk[1] = 0;
    try{
     var result = caml_call1(closure, 0);
     blk[1] = result;
     caml_lazy_update_to_forward(blk);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     runtime.caml_lazy_reset_to_lazy(blk);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_lazy_block(blk){return force_gen_lazy_block(0, blk);}
   function force_gen(only_val, lzv){
    var t = runtime.caml_obj_tag(lzv);
    if(t === Stdlib_Obj[12]) return lzv[1];
    if(t === Stdlib_Obj[6]) throw caml_maybe_attach_backtrace(Undefined, 1);
    return t !== Stdlib_Obj[8] ? lzv : force_gen_lazy_block(only_val, lzv);
   }
   var CamlinternalLazy = [0, Undefined, force_lazy_block, force_gen];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Lazy
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1];
   function force_val(l){return caml_call2(CamlinternalLazy[3], 1, l);}
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[8], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if
     (t !== Stdlib_Obj[12]
      && t !== Stdlib_Obj[8] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[16])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[8];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var _g_ = caml_obj_tag(x);
             a:
             if(250 === _g_)
              var _h_ = x[1];
             else{
              if(246 !== _g_ && 244 !== _g_){var _h_ = x; break a;}
              var _h_ = caml_call1(CamlinternalLazy[2], x);
             }
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var _d_ = caml_obj_tag(x);
              a:
              if(250 === _d_)
               var _e_ = x[1];
              else{
               if(246 !== _d_ && 244 !== _d_){var _e_ = x; break a;}
               var _e_ = caml_call1(CamlinternalLazy[2], x);
              }
              return caml_call1(f, _e_);
             }];
    var _a_ = caml_obj_tag(x);
    a:
    if(250 === _a_)
     var _b_ = x[1];
    else{
     if(246 !== _a_ && 244 !== _a_){var _b_ = x; break a;}
     var _b_ = caml_call1(CamlinternalLazy[2], x);
    }
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0, Undefined, map, is_val, from_val, map_val, from_fun, force_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Seq
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Atomic, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    _a_ = [0, "seq.ml", 616, 4],
    cst_Seq_drop = "Seq.drop",
    cst_Seq_take = "Seq.take",
    cst_Seq_init = "Seq.init",
    cst_Stdlib_Seq_Forced_twice = "Stdlib.Seq.Forced_twice";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_aM_){return append(next, seq2, _aM_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    function _aK_(_aL_){return map(f, next, _aL_);}
    return [0, caml_call1(f, x), _aK_];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_aJ_){return filter_map(f, next, _aJ_);}];
     }
     var seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_aI_){return filter(f, next, _aI_);}];
     var seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1], _aG_ = 0;
    return append(x, function(_aH_){return concat(next, _aH_);}, _aG_);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1], _aD_ = 0;
    function _aE_(_aF_){return flat_map(f, next, _aF_);}
    return append(caml_call1(f, x), _aE_, _aD_);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var
      next = match[2],
      x = match[1],
      acc$1 = caml_call2(f, acc$0, x),
      acc$0 = acc$1,
      seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     var seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_aC_){return unfold(f, u$0, _aC_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0, accu = accu$0, xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0, i = i$0, xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0,
      accu = accu$0,
      i = i$0,
      xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _aB_ = caml_call1(p, x);
     if(! _aB_) return _aB_;
     var xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _aA_ = caml_call1(p, x);
     if(_aA_) return _aA_;
     var xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     var xs$0 = xs$1;
    }
   }
   function find_index(p, xs){
    var i = 0, xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, i];
     var i$0 = i + 1 | 0, i = i$0, xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     var xs$0 = xs$1;
    }
   }
   function find_mapi(f, xs){
    var i = 0, xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = i + 1 | 0, i = i$0, xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y),
      accu$0 = accu$1,
      xs$0 = xs$1,
      ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _az_ = caml_call2(f, x, y);
     if(! _az_) return _az_;
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _ay_ = caml_call2(f, x, y);
     if(_ay_) return _ay_;
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _ax_ = caml_call2(eq, x, y);
       if(! _ax_) return _ax_;
       var xs$0 = xs$1, ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _au_ = i + 1 | 0;
    function _av_(_aw_){return init_aux(f, _au_, j, _aw_);}
    return [0, caml_call1(f, i), _av_];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _as_ = 0;
    return function(_at_){return init_aux(f, _as_, n, _at_);};
   }
   function repeat(x, param){
    return [0, x, function(_ar_){return repeat(x, _ar_);}];
   }
   function forever(f, param){
    function _ap_(_aq_){return forever(f, _aq_);}
    return [0, caml_call1(f, 0), _ap_];
   }
   function cycle_nonempty(xs, param){
    var _an_ = 0;
    return append(xs, function(_ao_){return cycle_nonempty(xs, _ao_);}, _an_);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _ak_(_am_){return cycle_nonempty(xs, _am_);}
    return [0, x, function(_al_){return append(xs$0, _ak_, _al_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(_aj_){return iterate1(f, y, _aj_);}];
   }
   function iterate(f, x){
    function _ag_(_ai_){return iterate1(f, x, _ai_);}
    return function(_ah_){return [0, x, _ag_];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _ad_ = i + 1 | 0;
    function _ae_(_af_){return mapi_aux(f, _ad_, xs$0, _af_);}
    return [0, caml_call2(f, i, x), _ae_];
   }
   function mapi(f, xs){
    var _ab_ = 0;
    return function(_ac_){return mapi_aux(f, _ab_, xs, _ac_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_aa_){return tail_scan(f, s$0, xs$0, _aa_);}];
   }
   function scan(f, s, xs){
    function _Z_(_$_){return tail_scan(f, s, xs, _$_);}
    return function(___){return [0, s, _Z_];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 var n$0 = n$1, xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_Y_){return take_while(p, xs$0, _Y_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     var xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _P_ = caml_call1(eq, x);
    function _Q_(_X_){return drop_while(_P_, xs$0, _X_);}
    function _R_(_W_){return group(eq, _Q_, _W_);}
    var _S_ = caml_call1(eq, x);
    function _T_(_V_){return take_while(_S_, xs$0, _V_);}
    return [0, function(_U_){return [0, x, _T_];}, _R_];
   }
   var
    Forced_twice =
      [248, cst_Stdlib_Seq_Forced_twice, runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(_O_){
     var _N_ = runtime.caml_obj_tag(s);
     if(250 === _N_) return s[1];
     if(246 !== _N_ && 244 !== _N_) return s;
     return caml_call1(CamlinternalLazy[2], s);};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(Stdlib_Atomic[1], f);
    return function(param){
     var f = caml_call2(Stdlib_Atomic[4], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_M_){return zip(xs$0, ys$0, _M_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    function _K_(_L_){return map2(f, xs$0, ys$0, _L_);}
    return [0, caml_call2(f, x, y), _K_];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_J_){return interleave(ys, xs$0, _J_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_H_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_I_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_G_){return map_fst(xys$0, _G_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_F_){return map_snd(xys$0, _F_);}];
   }
   function unzip(xys){
    function _C_(_E_){return map_snd(xys, _E_);}
    return [0, function(_D_){return map_fst(xys, _D_);}, _C_];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_B_){return filter_map_find_left_map(f, xs$1, _B_);}];
     }
     var xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]){
      var z = match$0[1];
      return [0,
              z,
              function(_A_){return filter_map_find_right_map(f, xs$1, _A_);}];
     }
     var xs$0 = xs$1;
    }
   }
   function partition_map(f, xs){
    function _x_(_z_){return filter_map_find_right_map(f, xs, _z_);}
    return [0,
            function(_y_){return filter_map_find_left_map(f, xs, _y_);},
            _x_];
   }
   function partition(p, xs){
    function _t_(x){return 1 - caml_call1(p, x);}
    function _u_(_w_){return filter(_t_, xs, _w_);}
    return [0, function(_v_){return filter(p, xs, _v_);}, _u_];
   }
   function peel(xss){
    return unzip(function(_s_){return filter_map(uncons, xss, _s_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_r_){return transpose(tails, _r_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_q_){return [0, xs$0, tails];},
      _m_ = function(_p_){return _b_(_l_, xss$0, _p_);};
     return [0, function(_o_){return [0, x, heads];}, _m_];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_n_){return _b_(tails$0, xss$0, _n_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_index,
       find_map,
       find_mapi,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Option
//# unitInfo: Requires: Stdlib, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_option_is_None = "option is None",
    none = 0;
   function some(v){return [0, v];}
   function value(o, default$0){
    if(! o) return default$0;
    var v = o[1];
    return v;
   }
   function get(param){
    if(! param) return caml_call1(Stdlib[1], cst_option_is_None);
    var v = param[1];
    return v;
   }
   function bind(o, f){
    if(! o) return 0;
    var v = o[1];
    return caml_call1(f, v);
   }
   function join(param){if(! param) return 0; var o = param[1]; return o;}
   function map(f, o){
    if(! o) return 0;
    var v = o[1];
    return [0, caml_call1(f, v)];
   }
   function fold(none, some, param){
    if(! param) return none;
    var v = param[1];
    return caml_call1(some, v);
   }
   function iter(f, param){
    if(! param) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function equal(eq, o0, o1){
    if(o0){
     if(o1){var v1 = o1[1], v0 = o0[1]; return caml_call2(eq, v0, v1);}
    }
    else if(! o1) return 1;
    return 0;
   }
   function compare(cmp, o0, o1){
    if(! o0) return o1 ? -1 : 0;
    var v0 = o0[1];
    if(! o1) return 1;
    var v1 = o1[1];
    return caml_call2(cmp, v0, v1);
   }
   function to_result(none, param){
    if(! param) return [1, none];
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(! param) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(! param) return Stdlib_Seq[20];
    var v = param[1];
    return caml_call1(Stdlib_Seq[21], v);
   }
   var
    Stdlib_Option =
      [0,
       none,
       some,
       value,
       get,
       bind,
       join,
       map,
       fold,
       iter,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
   runtime.caml_register_global(3, Stdlib_Option, "Stdlib__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Result
//# unitInfo: Requires: Stdlib, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_result_is_Ok = "result is Ok _",
    cst_result_is_Error = "result is Error _";
   function ok(v){return [0, v];}
   function error(e){return [1, e];}
   function value(r, default$0){
    if(0 !== r[0]) return default$0;
    var v = r[1];
    return v;
   }
   function get_ok(param){
    if(0 !== param[0]) return caml_call1(Stdlib[1], cst_result_is_Error);
    var v = param[1];
    return v;
   }
   function get_error(param){
    if(0 === param[0]) return caml_call1(Stdlib[1], cst_result_is_Ok);
    var e = param[1];
    return e;
   }
   function bind(r, f){
    if(0 !== r[0]) return r;
    var v = r[1];
    return caml_call1(f, v);
   }
   function join(e){if(0 !== e[0]) return e; var r = e[1]; return r;}
   function map(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_error(f, v){
    if(0 === v[0]) return v;
    var e = v[1];
    return [1, caml_call1(f, e)];
   }
   function fold(ok, error, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(ok, v);}
    var e = param[1];
    return caml_call1(error, e);
   }
   function iter(f, param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function iter_error(f, param){
    if(0 === param[0]) return 0;
    var e = param[1];
    return caml_call1(f, e);
   }
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function equal(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 === r1[0]){var v1 = r1[1]; return caml_call2(ok, v0, v1);}
    }
    else{
     var e0 = r0[1];
     if(0 !== r1[0]){var e1 = r1[1]; return caml_call2(error, e0, e1);}
    }
    return 0;
   }
   function compare(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 !== r1[0]) return -1;
     var v1 = r1[1];
     return caml_call2(ok, v0, v1);
    }
    var e0 = r0[1];
    if(0 === r1[0]) return 1;
    var e1 = r1[1];
    return caml_call2(error, e0, e1);
   }
   function to_option(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(0 !== param[0]) return Stdlib_Seq[20];
    var v = param[1];
    return caml_call1(Stdlib_Seq[21], v);
   }
   var
    Stdlib_Result =
      [0,
       ok,
       error,
       value,
       get_ok,
       get_error,
       bind,
       join,
       map,
       map_error,
       fold,
       iter,
       iter_error,
       is_ok,
       is_error,
       equal,
       compare,
       to_option,
       to_list,
       to_seq];
   runtime.caml_register_global(4, Stdlib_Result, "Stdlib__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bool
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_hash = runtime.caml_hash,
    cst_true = "true",
    cst_false = "false";
   function equal(_e_, _d_){return _e_ === _d_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function to_float(param){return param ? 1. : 0.;}
   function to_string(param){return param ? cst_true : cst_false;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   function _a_(_c_){return _c_;}
   var
    Stdlib_Bool =
      [0,
       function(_b_){return 1 - _b_;},
       equal,
       compare,
       _a_,
       to_float,
       to_string,
       seeded_hash,
       hash];
   runtime.caml_register_global(4, Stdlib_Bool, "Stdlib__Bool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Char
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_hash = runtime.caml_hash,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r",
    cst_Char_chr = "Char.chr";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 > c) break a;
     }
     else{
      if(32 <= c){if(39 <= c) return cst$0; break a;}
      if(14 > c)
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
       }
     }
     var s = caml_create_bytes(4);
     caml_bytes_unsafe_set(s, 0, 92);
     caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
     caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
     caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
     return caml_string_of_bytes(s);
    }
    var s$0 = caml_create_bytes(1);
    caml_bytes_unsafe_set(s$0, 0, c);
    return caml_string_of_bytes(s$0);
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal,
       seeded_hash,
       hash];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Uchar
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    _d_ = [0, cst_uchar_ml, 88, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _a_ = [0, cst_uchar_ml, 85, 7],
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    min = 0,
    max = 1114111,
    lo_bound = 55295,
    hi_bound = 57344,
    bom = 65279,
    rep = 65533;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _o_ = 0 <= i ? 1 : 0, _p_ = _o_ ? i <= 55295 ? 1 : 0 : _o_;
    if(_p_)
     var _q_ = _p_;
    else
     var _r_ = 57344 <= i ? 1 : 0, _q_ = _r_ ? i <= 1114111 ? 1 : 0 : _r_;
    return _q_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _n_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _n_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _l_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _m_ = caml_call2(Stdlib[28], cst_U, _l_);
    return caml_call1(Stdlib[1], _m_);
   }
   function unsafe_to_char(_k_){return _k_;}
   function equal(_j_, _i_){return _j_ === _i_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function hash(_h_){return _h_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   function _e_(_g_){return _g_;}
   var
    Stdlib_Uchar =
      [0,
       min,
       max,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       _e_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__List
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_map2$1 = "List.map2",
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_List_map2 = cst_List_map2$1,
    cst_List_map2$0 = cst_List_map2$1,
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _a_ = [0, 0, 0],
    cst_List_combine = "List.combine",
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_init = "List.init",
    cst_List_nth$0 = cst_List_nth$1,
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_tl = "tl",
    cst_hd = "hd";
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0, len = len$0, param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
    }
   }
   var append = Stdlib[37];
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var
      l1$1 = l1$0[2],
      a = l1$0[1],
      l2$1 = [0, a, l2$0],
      l1$0 = l1$1,
      l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    var last = len - 1 | 0, i$1 = 0;
    if(last < 0) return 0;
    if(0 === last) return [0, caml_call1(f, i$1), 0];
    var
     r1 = caml_call1(f, i$1),
     r2 = caml_call1(f, 1),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     i = 2;
    for(;;){
     if(last < i)
      dst[1 + offset] = 0;
     else{
      if(i !== last){
       var
        r1$0 = caml_call1(f, i),
        r2$0 = caml_call1(f, i + 1 | 0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$0, dst$0];
       var i$0 = i + 2 | 0, dst = dst$0, offset = 1, i = i$0;
       continue;
      }
      dst[1 + offset] = [0, caml_call1(f, i), 0];
     }
     return [0, r1, block];
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _I_ = flatten(r);
    return caml_call2(Stdlib[37], l, _I_);
   }
   function map(f, param){
    if(! param) return 0;
    var match = param[2], a1 = param[1];
    if(! match){var r1$0 = caml_call1(f, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call1(f, a1),
     r2 = caml_call1(f, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     param$0 = l;
    for(;;){
     if(param$0){
      var match$0 = param$0[2], a1$0 = param$0[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call1(f, a1$0),
        r2$0 = caml_call1(f, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       var dst = dst$0, offset = 1, param$0 = l$0;
       continue;
      }
      var r1$2 = caml_call1(f, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function mapi(f, l$1){
    var i$1 = 0;
    if(! l$1) return 0;
    var match = l$1[2], a1 = l$1[1];
    if(! match){var r1$0 = caml_call2(f, i$1, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call2(f, i$1, a1),
     r2 = caml_call2(f, 1, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     i = 2,
     param = l;
    for(;;){
     if(param){
      var match$0 = param[2], a1$0 = param[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call2(f, i, a1$0),
        r2$0 = caml_call2(f, i + 1 | 0, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       var i$0 = i + 2 | 0, dst = dst$0, offset = 1, i = i$0, param = l$0;
       continue;
      }
      var r1$2 = caml_call2(f, i, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var
      l$0 = param[2],
      a = param[1],
      accu$0 = [0, caml_call1(f, a), accu],
      accu = accu$0,
      param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     var param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0, i = i$0, param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var
      l$1 = l$0[2],
      a = l$0[1],
      accu$1 = caml_call2(f, accu$0, a),
      accu$0 = accu$1,
      l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     var _G_ = l1[2], a1 = l1[1];
     if(_G_){
      if(l2){
       var match = l2[2];
       if(match){
        var
         l2$0 = match[2],
         b2 = match[1],
         b1 = l2[1],
         l1$0 = _G_[2],
         a2 = _G_[1],
         r1 = caml_call2(f, a1, b1),
         r2 = caml_call2(f, a2, b2),
         block = [0, r2, 24029],
         dst = block,
         offset = 1,
         l1$1 = l1$0,
         l2$1 = l2$0;
        for(;;){
         a:
         {
          if(l1$1){
           var _H_ = l1$1[2], a1$0 = l1$1[1];
           if(_H_){
            if(l2$1){
             var match$0 = l2$1[2];
             if(match$0){
              var
               l2$2 = match$0[2],
               b2$0 = match$0[1],
               b1$1 = l2$1[1],
               l1$2 = _H_[2],
               a2$0 = _H_[1],
               r1$1 = caml_call2(f, a1$0, b1$1),
               r2$0 = caml_call2(f, a2$0, b2$0),
               dst$0 = [0, r2$0, 24029];
              dst[1 + offset] = [0, r1$1, dst$0];
              var dst = dst$0, offset = 1, l1$1 = l1$2, l2$1 = l2$2;
              continue;
             }
            }
           }
           else if(l2$1 && ! l2$1[2]){
            var b1$2 = l2$1[1], r1$2 = caml_call2(f, a1$0, b1$2);
            dst[1 + offset] = [0, r1$2, 0];
            break a;
           }
          }
          else if(! l2$1){dst[1 + offset] = 0; break a;}
          dst[1 + offset] = caml_call1(Stdlib[1], cst_List_map2$0);
         }
         return [0, r1, block];
        }
       }
      }
     }
     else if(l2 && ! l2[2]){
      var b1$0 = l2[1], r1$0 = caml_call2(f, a1, b1$0);
      return [0, r1$0, 0];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu],
        accu = accu$0,
        l1$0 = l1$1,
        l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2),
        accu$0 = accu$1,
        l1$0 = l1$1,
        l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
     if(! _F_) return _F_;
     var param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _E_ = caml_call1(p, a);
     if(_E_) return _E_;
     var param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _D_ = caml_call2(p, a1, a2);
       if(! _D_) return _D_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _C_ = caml_call2(p, a1, a2);
       if(_C_) return _C_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _B_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_B_) return _B_;
     var param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _A_ = a === x ? 1 : 0;
     if(_A_) return _A_;
     var param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     var param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     var param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     var param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     var param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _z_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_z_) return _z_;
     var param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _y_ = a === x ? 1 : 0;
     if(_y_) return _y_;
     var param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     var param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     var param$0 = l;
    }
   }
   function find_index(p){
    var i = 0;
    return function(param$0){
     var i$0 = i, param = param$0;
     for(;;){
      if(! param) return 0;
      var l = param[2], a = param[1];
      if(caml_call1(p, a)) return [0, i$0];
      var i$1 = i$0 + 1 | 0, i$0 = i$1, param = l;
     }};
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     var param$0 = l;
    }
   }
   function find_mapi(f){
    var i = 0;
    return function(param$0){
     var i$0 = i, param = param$0;
     for(;;){
      if(! param) return 0;
      var l = param[2], x = param[1], result = caml_call2(f, i$0, x);
      if(result) return result;
      var i$1 = i$0 + 1 | 0, i$0 = i$1, param = l;
     }};
   }
   function find_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)){
      var block = [0, x, 24029], dst = block, offset = 1, param$1 = l;
      for(;;){
       if(! param$1){dst[1 + offset] = 0; return block;}
       var l$0 = param$1[2], x$0 = param$1[1];
       if(caml_call1(p, x$0)){
        var dst$0 = [0, x$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, param$1 = l$0;
       }
       else
        var param$1 = l$0;
      }
     }
     else
      var param$0 = l;
    }
   }
   function filteri(p, l$1){
    var i = 0, param = l$1;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], i$0 = i + 1 | 0;
     if(caml_call2(p, i, x)) break;
     var i = i$0, param = l;
    }
    var
     block = [0, x, 24029],
     dst = block,
     offset = 1,
     i$1 = i$0,
     param$0 = l;
    for(;;){
     if(! param$0){dst[1 + offset] = 0; return block;}
     var l$0 = param$0[2], x$0 = param$0[1], i$2 = i$1 + 1 | 0;
     if(caml_call2(p, i$1, x$0)){
      var dst$0 = [0, x$0, 24029];
      dst[1 + offset] = dst$0;
      var dst = dst$0, offset = 1, i$1 = i$2, param$0 = l$0;
     }
     else
      var i$1 = i$2, param$0 = l$0;
    }
   }
   function filter_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], match = caml_call1(f, x);
     if(match){
      var
       v = match[1],
       block = [0, v, 24029],
       dst = block,
       offset = 1,
       param$1 = l;
      for(;;){
       if(! param$1){dst[1 + offset] = 0; return block;}
       var l$0 = param$1[2], x$0 = param$1[1], match$0 = caml_call1(f, x$0);
       if(match$0){
        var v$0 = match$0[1], dst$0 = [0, v$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, param$1 = l$0;
       }
       else
        var param$1 = l$0;
      }
     }
     else
      var param$0 = l;
    }
   }
   function concat_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var xs = param$0[2], x = param$0[1], ys = caml_call1(f, x);
     if(ys){
      var
       ys$1 = ys[2],
       y = ys[1],
       block = [0, y, 24029],
       dst = block,
       offset = 1,
       ys$2 = ys$1,
       xs$1 = xs;
      for(;;)
       if(ys$2){
        var ys$3 = ys$2[2], y$0 = ys$2[1], dst$0 = [0, y$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, ys$2 = ys$3;
       }
       else{
        if(! xs$1){dst[1 + offset] = 0; return block;}
        var
         xs$0 = xs$1[2],
         x$0 = xs$1[1],
         ys$0 = caml_call1(f, x$0),
         ys$2 = ys$0,
         xs$1 = xs$0;
       }
     }
     else
      var param$0 = xs;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu],
      accu$0 = accu$1,
      l_accu = l_accu$0,
      param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _x_ = rev(no); return [0, rev(yes), _x_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x))
      var yes$0 = [0, x, yes], yes = yes$0, param = l$0;
     else
      var no$0 = [0, x, no], no = no$0, param = l$0;
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _w_ = rev(right); return [0, rev(left), _w_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0])
      var v = match[1], left$0 = [0, v, left], left = left$0, param = l$0;
     else
      var
       v$0 = match[1],
       right$0 = [0, v$0, right],
       right = right$0,
       param = l$0;
    }
   }
   function split(param){
    if(! param) return _a_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _v_ = l[2];
      if(_v_){
       var match$2 = _v_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _v_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
        continue;
       }
       var _u_ = rev_append(l1, accu);
      }
      else
       var _u_ = rev_append(l2, accu);
      return [0, _u_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _t_ = l[2];
      if(_t_){
       var match$2 = _t_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _t_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
        continue;
       }
       var _s_ = rev_append(l1, accu);
      }
      else
       var _s_ = rev_append(l2, accu);
      return [0, _s_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _m_ = l[2];
      if(_m_){
       var match$2 = _m_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _m_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _n_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _n_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _o_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _p_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _o_ = _p_;
         else
          var _o_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _o_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _q_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _r_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _q_ = _r_;
         else
          var _q_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _q_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu], l1 = t1, l2 = t2, accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu], l2 = t2, accu = accu$2;
        continue;
       }
       var _l_ = rev_append(l1, accu);
      }
      else
       var _l_ = rev_append(l2, accu);
      return [0, _l_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _f_ = l[2];
      if(_f_){
       var match$2 = _f_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _f_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _g_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _g_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _h_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _h_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _i_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _h_ = _i_;
         var s$0 = _h_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _j_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _j_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _k_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _j_ = _k_;
         var s$0 = _j_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu], l1 = t1, l2 = t2, accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu], l1 = t1, accu = accu$2;
        continue;
       }
       var _e_ = rev_append(l1, accu);
      }
      else
       var _e_ = rev_append(l2, accu);
      return [0, _e_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2], l1$0 = l1$1, l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
    }
   }
   function is_empty(param){return param ? 0 : 1;}
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _d_ = caml_call2(eq, a1, a2);
       if(! _d_) return _d_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     var l1$0 = l1$1, l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_c_){return aux(tail, _c_);}];
    }
    return function(_b_){return aux(l, _b_);};
   }
   function of_seq(seq){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var seq$0 = match[2], x1 = match[1], match$0 = caml_call1(seq$0, 0);
    if(! match$0) return [0, x1, 0];
    var
     seq$1 = match$0[2],
     x2 = match$0[1],
     block = [0, x2, 24029],
     dst = block,
     offset = 1,
     seq$2 = seq$1;
    for(;;){
     var match$1 = caml_call1(seq$2, 0);
     if(match$1){
      var
       seq$3 = match$1[2],
       x1$0 = match$1[1],
       match$2 = caml_call1(seq$3, 0);
      if(match$2){
       var seq$4 = match$2[2], x2$0 = match$2[1], dst$0 = [0, x2$0, 24029];
       dst[1 + offset] = [0, x1$0, dst$0];
       var dst = dst$0, offset = 1, seq$2 = seq$4;
       continue;
      }
      dst[1 + offset] = [0, x1$0, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, x1, block];
    }
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       is_empty,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(17, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_hash = runtime.caml_hash,
    zero = 0,
    one = 1,
    minus_one = -1;
   function abs(x){return 0 <= x ? x : - x | 0;}
   var max_int = 2147483647, min_int = -2147483648;
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int =
      [0,
       zero,
       one,
       minus_one,
       abs,
       max_int,
       min_int,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string,
       seeded_hash,
       hash];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bytes
//# unitInfo: Requires: Stdlib, Stdlib__Char, Stdlib__Int, Stdlib__Seq, Stdlib__Sys, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _f_ = [0, cst_bytes_ml, 820, 20],
    _e_ = [0, cst_bytes_ml, 831, 9],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _d_ = [0, cst_bytes_ml, 766, 20],
    _c_ = [0, cst_bytes_ml, 777, 9],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    _b_ = [0, cst_bytes_ml, 654, 20],
    _a_ = [0, cst_bytes_ml, 679, 9],
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub";
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _aq_ = n - 1 | 0, _ap_ = 0;
    if(_aq_ >= 0){
     var i = _ap_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _ar_ = i + 1 | 0;
      if(_aq_ === i) break;
      var i = _ar_;
     }
    }
    return s;
   }
   var empty = caml_create_bytes(0);
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, _ao_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(_ao_ && ! match) break a;} else if(! _ao_ && match) break a;
     return c;
    }
    return caml_call1(Stdlib[1], cst_Bytes_extend);
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _am_ = caml_ml_bytes_length(a) - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var i = _al_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _an_ = i + 1 | 0;
      if(_am_ === i) break;
      var i = _an_;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _aj_ = caml_ml_bytes_length(a) - 1 | 0, _ai_ = 0;
    if(_aj_ >= 0){
     var i = _ai_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _ak_ = i + 1 | 0;
      if(_aj_ === i) break;
      var i = _ak_;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat),
        acc = acc$0,
        param = tl;
      }
      var _ah_ = acc;
      break a;
     }
     var _ah_ = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_ah_), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var
      pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0,
      pos = pos$0,
      param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _ag_ = param - 9 | 0;
    a:
    {
     if(4 < _ag_ >>> 0){if(23 !== _ag_) break a;} else if(2 === _ag_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1] += -1; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function unsafe_escape(s){
    var n = [0, 0], _$_ = caml_ml_bytes_length(s) - 1 | 0, ___ = 0;
    if(_$_ >= 0){
     var i$0 = ___;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ad_ = match - 34 | 0;
          if(58 < _ad_ >>> 0){
           if(93 <= _ad_) break c;
          }
          else if(56 < _ad_ - 1 >>> 0) break b;
          var _ae_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ae_ = 4;
        break a;
       }
       var _ae_ = 2;
      }
      n[1] = n[1] + _ae_ | 0;
      var _af_ = i$0 + 1 | 0;
      if(_$_ === i$0) break;
      var i$0 = _af_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _ab_ = caml_ml_bytes_length(s) - 1 | 0, _aa_ = 0;
    if(_ab_ >= 0){
     var i = _aa_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _ac_ = i + 1 | 0;
      if(_ab_ === i) break;
      var i = _ac_;
     }
    }
    return s$0;
   }
   function escaped(b){var b$0 = copy(b); return unsafe_escape(b$0);}
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _Y_ = l - 1 | 0, _X_ = 0;
    if(_Y_ >= 0){
     var i = _X_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Z_ = i + 1 | 0;
      if(_Y_ === i) break;
      var i = _Z_;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _V_ = l - 1 | 0, _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _W_ = i + 1 | 0;
      if(_V_ === i) break;
      var i = _W_;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _S_ = caml_ml_bytes_length(a) - 1 | 0, _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _T_ = i + 1 | 0;
      if(_S_ === i) break;
      var i = _T_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _P_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_P_ >= 0){
     var i = _P_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _Q_ = i - 1 | 0;
      if(0 === i) break;
      var i = _Q_;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[4], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[3], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[3], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _O_ = len_pre <= len_s ? 1 : 0;
    if(! _O_) return _O_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _N_ = 0 <= diff ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _L_ = 1; return _L_;}
     catch(_M_){
      var _K_ = caml_wrap_exception(_M_);
      if(_K_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_K_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _I_ = 1; return _I_;}
     catch(_J_){
      var _H_ = caml_wrap_exception(_J_);
      if(_H_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_H_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var compare = runtime.caml_bytes_compare;
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _D_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_D_ >= 0){
     var i = _D_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _F_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _F_];
       j[1] = i;
      }
      var _G_ = i - 1 | 0;
      if(0 === i) break;
      var i = _G_;
     }
    }
    var _E_ = r[1];
    return [0, sub(s, 0, j[1]), _E_];
   }
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _B_ = i + 1 | 0;
     return [0, x, function(_C_){return aux(_B_, _C_);}];
    }
    var _z_ = 0;
    return function(_A_){return aux(_z_, _A_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _x_ = i + 1 | 0;
     return [0, [0, i, x], function(_y_){return aux(_x_, _y_);}];
    }
    var _v_ = 0;
    return function(_w_){return aux(_v_, _w_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    function _u_(c){
     if(n[1] === caml_ml_bytes_length(buf[1])){
      var
       new_len =
         caml_call2
          (Stdlib_Int[10],
           2 * caml_ml_bytes_length(buf[1]) | 0,
           Stdlib_Sys[12]);
      if(caml_ml_bytes_length(buf[1]) === new_len)
       caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
      var new_buf = make(new_len, 0);
      blit(buf[1], 0, new_buf, 0, n[1]);
      buf[1] = new_buf;
     }
     caml_bytes_set(buf[1], n[1], c);
     n[1]++;
     return 0;
    }
    caml_call2(Stdlib_Seq[4], _u_, i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
    return;
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
    return;
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1, b2));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$1, b3));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$3 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$3)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2$3)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$3, b2$3, b3$1));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$2 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$2)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$2, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$4 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$4)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$0 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$0)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$0 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$0)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$0, b2$0));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1$5 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1$5)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1$5 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){caml_bytes_unsafe_set(_i_, _h_, _g_); return;}
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0, i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0, i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0, i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0, i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0, i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0, i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0, i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0, i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0, i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0, i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0, i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0, i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le,
       unsafe_escape];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__String
//# unitInfo: Requires: Stdlib, Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_hash = runtime.caml_string_hash,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[44],
    bos = Stdlib_Bytes[45],
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_concat = "String.concat";
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _X_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _X_, ofs, len));
   }
   var blit = Stdlib_Bytes[12];
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat),
        acc = acc$0,
        param = tl;
      }
      var _W_ = acc;
      break a;
     }
     var _W_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(_W_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var
        pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0,
        pos = pos$0,
        param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_call1(bts, dst);
    }
   }
   var cat = Stdlib[28];
   function iter(f, s){
    var _U_ = caml_ml_string_length(s) - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      var i = _V_;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _R_ = caml_ml_string_length(s) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      var i = _S_;
     }
    }
    return 0;
   }
   function map(f, s){
    var _P_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _P_));
   }
   function mapi(f, s){
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _O_));
   }
   function fold_right(f, x, a){
    var _N_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _N_, a);
   }
   function fold_left(f, a, x){
    var _M_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _M_);
   }
   function exists(f, s){
    var _L_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _L_);
   }
   function for_all(f, s){
    var _K_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _K_);
   }
   function is_space(param){
    var _J_ = param - 9 | 0;
    a:
    {
     if(4 < _J_ >>> 0){if(23 !== _J_) break a;} else if(2 === _J_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(caml_string_equal(s, cst$0)) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _I_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _I_));
   }
   function escaped(s){
    var b = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[87], b));
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _G_ = 1; return _G_;}
     catch(_H_){
      var _F_ = caml_wrap_exception(_H_);
      if(_F_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_F_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _D_ = 1; return _D_;}
     catch(_E_){
      var _C_ = caml_wrap_exception(_E_);
      if(_C_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_C_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _B_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _B_));
   }
   function lowercase_ascii(s){
    var _A_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _A_));
   }
   function capitalize_ascii(s){
    var _z_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _z_));
   }
   function uncapitalize_ascii(s){
    var _y_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _y_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _x_ = len_pre <= len_s ? 1 : 0;
    if(! _x_) return _x_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _w_ = 0 <= diff ? 1 : 0;
    if(! _w_) return _w_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function hash(x){return caml_string_hash(0, x);}
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _s_ = caml_ml_string_length(s) - 1 | 0;
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _u_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _u_];
       j[1] = i;
      }
      var _v_ = i - 1 | 0;
      if(0 === i) break;
      var i = _v_;
     }
    }
    var _t_ = r[1];
    return [0, sub(s, 0, j[1]), _t_];
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[47], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[48], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[49], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[50], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[53], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[55], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[56], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[58], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[63], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[62], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[65], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[71], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       blit,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       hash,
       caml_string_hash,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Unit
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "()";
   function equal(param, _b_){return 1;}
   function compare(param, _a_){return 0;}
   function to_string(param){return cst;}
   var Stdlib_Unit = [0, equal, compare, to_string];
   runtime.caml_register_global(1, Stdlib_Unit, "Stdlib__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Marshal
//# unitInfo: Requires: Stdlib, Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Marshal_from_bytes$1 = "Marshal.from_bytes",
    caml_marshal_data_size = runtime.caml_marshal_data_size,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    cst_Marshal_from_bytes = cst_Marshal_from_bytes$1,
    cst_Marshal_from_bytes$0 = cst_Marshal_from_bytes$1,
    cst_Marshal_data_size = "Marshal.data_size",
    cst_Marshal_to_buffer_substrin =
      "Marshal.to_buffer: substring out of bounds";
   function to_buffer(buff, ofs, len, v, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buff) - len | 0) >= ofs)
     return runtime.caml_output_value_to_buffer(buff, ofs, len, v, flags);
    return caml_call1(Stdlib[1], cst_Marshal_to_buffer_substrin);
   }
   var header_size = 16;
   function data_size(buff, ofs){
    if(0 <= ofs && (caml_ml_bytes_length(buff) - 16 | 0) >= ofs)
     return caml_marshal_data_size(buff, ofs);
    return caml_call1(Stdlib[1], cst_Marshal_data_size);
   }
   function total_size(buff, ofs){return 16 + data_size(buff, ofs) | 0;}
   function from_bytes(buff, ofs){
    if(0 <= ofs && (caml_ml_bytes_length(buff) - 16 | 0) >= ofs){
     var len = caml_marshal_data_size(buff, ofs);
     return (caml_ml_bytes_length(buff) - (16 + len | 0) | 0) < ofs
             ? caml_call1(Stdlib[1], cst_Marshal_from_bytes$0)
             : runtime.caml_input_value_from_bytes(buff, ofs);
    }
    return caml_call1(Stdlib[1], cst_Marshal_from_bytes);
   }
   function from_string(buff, ofs){
    return from_bytes(caml_call1(Stdlib_Bytes[45], buff), ofs);
   }
   var
    Stdlib_Marshal =
      [0,
       runtime.caml_output_value,
       to_buffer,
       runtime.caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
   runtime.caml_register_global(6, Stdlib_Marshal, "Stdlib__Marshal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Array
//# unitInfo: Requires: Stdlib, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Floatarray = [0],
    _a_ = [0, "array.ml", 348, 4],
    cst_Array_combine = "Array.combine",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_blit = "Array.blit",
    cst_Array_fill = "Array.fill",
    cst_Array_sub = "Array.sub",
    cst_Array_init = "Array.init",
    cst_Stdlib_Array_Bottom = "Stdlib.Array.Bottom";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _ay_ = l - 1 | 0, _ax_ = 1;
    if(_ay_ >= 1){
     var i = _ax_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _az_ = i + 1 | 0;
      if(_ay_ === i) break;
      var i = _az_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), _av_ = sx - 1 | 0, _au_ = 0;
    if(_av_ >= 0){
     var x = _au_;
     for(;;){
      res[1 + x] = caml_make_vect(sy, init);
      var _aw_ = x + 1 | 0;
      if(_av_ === x) break;
      var x = _aw_;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _as_ = a.length - 1 - 1 | 0, _ar_ = 0;
    if(_as_ >= 0){
     var i = _ar_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _at_ = i + 1 | 0;
      if(_as_ === i) break;
      var i = _at_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _ap_ = a.length - 1 - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      var i = _aq_;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _am_ = l - 1 | 0,
     _al_ = 1;
    if(_am_ >= 1){
     var i = _al_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _an_ = i + 1 | 0;
      if(_am_ === i) break;
      var i = _an_;
     }
    }
    return r;
   }
   function map_inplace(f, a){
    var _aj_ = a.length - 1 - 1 | 0, _ai_ = 0;
    if(_aj_ >= 0){
     var i = _ai_;
     for(;;){
      a[1 + i] = caml_call1(f, a[1 + i]);
      var _ak_ = i + 1 | 0;
      if(_aj_ === i) break;
      var i = _ak_;
     }
    }
    return 0;
   }
   function mapi_inplace(f, a){
    var _ag_ = a.length - 1 - 1 | 0, _af_ = 0;
    if(_ag_ >= 0){
     var i = _af_;
     for(;;){
      a[1 + i] = caml_call2(f, i, a[1 + i]);
      var _ah_ = i + 1 | 0;
      if(_ag_ === i) break;
      var i = _ah_;
     }
    }
    return 0;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ad_ = la - 1 | 0,
     _ac_ = 1;
    if(_ad_ >= 1){
     var i = _ac_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ae_ = i + 1 | 0;
      if(_ad_ === i) break;
      var i = _ae_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var _aa_ = a.length - 1 - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      var i = _ab_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _Z_ = l - 1 | 0,
     _Y_ = 1;
    if(_Z_ >= 1){
     var i = _Y_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var ___ = i + 1 | 0;
      if(_Z_ === i) break;
      var i = ___;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 1 - 1 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0, i = i$0, res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var
      t = param$0[2],
      accu$1 = accu$0 + 1 | 0,
      accu$0 = accu$1,
      param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0, i = i$0, param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _W_ = a.length - 1 - 1 | 0, _V_ = 0;
    if(_W_ >= 0){
     var i = _V_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _X_ = i + 1 | 0;
      if(_W_ === i) break;
      var i = _X_;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _T_ = len - 1 | 0,
     _S_ = 1;
    if(_T_ >= 1){
     var i = _S_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _U_ = i + 1 | 0;
      if(_T_ === i) break;
      var i = _U_;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _Q_ = a.length - 1 - 1 | 0;
    if(_Q_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _R_ = i - 1 | 0;
      if(0 === i) break;
      var i = _R_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_index(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return [0, i];
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_mapi(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call2(f, i, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _O_ = n - 1 | 0,
     _N_ = 1;
    if(_O_ >= 1){
     var i = _N_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _P_ = i + 1 | 0;
      if(_O_ === i) break;
      var i = _P_;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _L_ = na - 1 | 0, _K_ = 1;
    if(_L_ >= 1){
     var i = _K_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _M_ = i + 1 | 0;
      if(_L_ === i) break;
      var i = _M_;
     }
    }
    return x;
   }
   var Bottom = [248, cst_Stdlib_Array_Bottom, runtime.caml_fresh_oo_id(0)];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _D_ = i31 + 1 | 0, _E_ = caml_check_bound(a, _D_)[1 + _D_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _E_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _F_ = i31 + 2 | 0,
       _G_ = caml_check_bound(a, _F_)[1 + _F_],
       _H_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _H_)[1 + _H_], _G_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _I_ = i31 + 1 | 0, _J_ = caml_check_bound(a, _I_)[1 + _I_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _J_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _x_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_x_ >= 0){
     var i$6 = _x_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)) break;
        var _u_ = caml_check_bound(a, j)[1 + j];
        caml_check_bound(a, i)[1 + i] = _u_;
        var i = j;
       }
       caml_check_bound(a, i)[1 + i] = e$1;
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _C_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      var i$6 = _C_;
     }
    }
    var _y_ = l - 1 | 0;
    if(_y_ >= 2){
     var i$4 = _y_;
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _v_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _v_;
        var i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          if
           (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
           break;
          var _w_ = caml_check_bound(a, father)[1 + father];
          caml_check_bound(a, i$3)[1 + i$3] = _w_;
          if(0 >= father) break b;
          var i$3 = father;
         }
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
         break a;
        }
        caml_check_bound(a, 0)[1] = e$0;
       }
       var _B_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       var i$4 = _B_;
      }
     }
    }
    var _z_ = 1 < l ? 1 : 0;
    if(_z_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _A_ = 0;
    }
    else
     var _A_ = _z_;
    return _A_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var
        d$0 = d + 1 | 0,
        s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0],
        i2 = i2$0,
        s2 = s2$0,
        d = d$0;
      }
      else{
       caml_check_bound(dst, d)[1 + d] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var
        d$1 = d + 1 | 0,
        s1$0 = caml_check_bound(a, i1$0)[1 + i1$0],
        i1 = i1$0,
        s1 = s1$0,
        d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _m_ = len - 1 | 0, _l_ = 0;
     if(_m_ >= 0){
      var i = _l_;
      for(;;){
       var
        _n_ = srcofs + i | 0,
        e = caml_check_bound(a, _n_)[1 + _n_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        var _o_ = j[1];
        if(0 >= caml_call2(cmp, caml_check_bound(dst, _o_)[1 + _o_], e))
         break;
        var
         _p_ = j[1],
         _q_ = caml_check_bound(dst, _p_)[1 + _p_],
         _r_ = j[1] + 1 | 0;
        caml_check_bound(dst, _r_)[1 + _r_] = _q_;
        j[1] += -1;
       }
       var _s_ = j[1] + 1 | 0;
       caml_check_bound(dst, _s_)[1 + _s_] = e;
       var _t_ = i + 1 | 0;
       if(_m_ === i) break;
       var i = _t_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _j_ = i + 1 | 0;
     return [0, x, function(_k_){return aux(_j_, _k_);}];
    }
    var _h_ = 0;
    return function(_i_){return aux(_h_, _i_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _f_ = i + 1 | 0;
     return [0, [0, i, x], function(_g_){return aux(_f_, _g_);}];
    }
    var _d_ = 0;
    return function(_e_){return aux(_d_, _e_);};
   }
   function of_seq(i$2){
    var _b_ = 0;
    function _c_(acc, x){return [0, x, acc];}
    var l = caml_call3(Stdlib_Seq[5], _c_, _b_, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0, i = i$0, param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       init,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       map_inplace,
       mapi,
       mapi_inplace,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Float
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Float_array_blit$1 = "Float.array.blit",
    cst_float_ml = "float.ml",
    caml_array_get = runtime.caml_array_get,
    caml_array_set = runtime.caml_array_set,
    caml_float_compare = runtime.caml_float_compare,
    caml_floatarray_blit = runtime.caml_floatarray_blit,
    caml_floatarray_create = runtime.caml_floatarray_create,
    caml_hash = runtime.caml_hash,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_nextafter_float = runtime.caml_nextafter_float,
    caml_signbit_float = runtime.caml_signbit_float,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    infinity = Stdlib[22],
    neg_infinity = Stdlib[23],
    nan = Stdlib[24],
    signaling_nan =
      runtime.caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32752)),
    _b_ = [0, cst_float_ml, 458, 6],
    cst_Float_Array_map2_arrays_mu =
      "Float.Array.map2: arrays must have the same length",
    cst_Float_Array_iter2_arrays_m =
      "Float.Array.iter2: arrays must have the same length",
    cst_Float_array_blit = cst_Float_array_blit$1,
    cst_Float_array_blit$0 = cst_Float_array_blit$1,
    cst_Float_Array_fill = "Float.Array.fill",
    cst_Float_Array_sub = "Float.Array.sub",
    _a_ = [0, cst_float_ml, 228, 14],
    cst_Float_Array_concat = "Float.Array.concat",
    cst_Float_Array_init = "Float.Array.init",
    cst_Stdlib_Float_Array_Bottom = "Stdlib.Float.Array.Bottom",
    zero = 0.,
    one = 1.,
    minus_one = -1.;
   function is_finite(x){return x - x == 0. ? 1 : 0;}
   function is_infinite(x){return 1. / x == 0. ? 1 : 0;}
   function is_nan(x){return x != x ? 1 : 0;}
   var
    max_float = Stdlib[25],
    min_float = Stdlib[26],
    epsilon = Stdlib[27],
    of_string_opt = Stdlib[36],
    to_string = Stdlib[35],
    pi = 3.141592653589793;
   function is_integer(x){
    var _aw_ = x == runtime.caml_trunc_float(x) ? 1 : 0;
    return _aw_ ? is_finite(x) : _aw_;
   }
   function succ(x){return caml_nextafter_float(x, infinity);}
   function pred(x){return caml_nextafter_float(x, neg_infinity);}
   function equal(x, y){return 0 === caml_float_compare(x, y) ? 1 : 0;}
   function min(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return x != x ? x : y;
    }
    return y != y ? y : x;
   }
   function max(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return y != y ? y : x;
    }
    return x != x ? x : y;
   }
   function min_max(x, y){
    if(x == x && y == y){
     a:
     if(! (x < y)){
      if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
      return [0, y, x];
     }
     return [0, x, y];
    }
    return [0, nan, nan];
   }
   function min_num(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return y != y ? x : y;
    }
    return x != x ? y : x;
   }
   function max_num(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return x != x ? y : x;
    }
    return y != y ? x : y;
   }
   function min_max_num(x, y){
    if(x != x) return [0, y, y];
    if(y != y) return [0, x, x];
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return [0, y, x];
    }
    return [0, x, y];
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   function unsafe_fill(a, ofs, len, v){
    var _au_ = (ofs + len | 0) - 1 | 0;
    if(_au_ >= ofs){
     var i = ofs;
     for(;;){
      a[1 + i] = v;
      var _av_ = i + 1 | 0;
      if(_au_ === i) break;
      var i = _av_;
     }
    }
    return 0;
   }
   function check(a, ofs, len, msg){
    var _aq_ = ofs < 0 ? 1 : 0;
    if(_aq_)
     var _ar_ = _aq_;
    else{
     var _as_ = len < 0 ? 1 : 0;
     if(_as_)
      var _ar_ = _as_;
     else
      var
       _at_ = (ofs + len | 0) < 0 ? 1 : 0,
       _ar_ = _at_ || (a.length - 1 < (ofs + len | 0) ? 1 : 0);
    }
    return _ar_ ? caml_call1(Stdlib[1], msg) : _ar_;
   }
   function make(n, v){
    var result = caml_floatarray_create(n);
    unsafe_fill(result, 0, n, v);
    return result;
   }
   function init(l, f){
    if(0 > l) return caml_call1(Stdlib[1], cst_Float_Array_init);
    var res = caml_floatarray_create(l), _ao_ = l - 1 | 0, _an_ = 0;
    if(_ao_ >= 0){
     var i = _an_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _ap_ = i + 1 | 0;
      if(_ao_ === i) break;
      var i = _ap_;
     }
    }
    return res;
   }
   function append(a1, a2){
    var
     l1 = a1.length - 1,
     l2 = a2.length - 1,
     result = caml_floatarray_create(l1 + l2 | 0);
    caml_floatarray_blit(a1, 0, result, 0, l1);
    caml_floatarray_blit(a2, 0, result, l1, l2);
    return result;
   }
   function concat(l){
    var acc = 0, param = l;
    for(;;){
     if(! param) break;
     var
      tl = param[2],
      hd = param[1],
      x = hd.length - 1 + acc | 0,
      acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Float_Array_concat),
      acc = acc$0,
      param = tl;
    }
    var result = caml_floatarray_create(acc), l$0 = l, i = 0;
    for(;;){
     if(! l$0){
      if(i === acc) return result;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
     var tl$0 = l$0[2], hd$0 = l$0[1], hlen = hd$0.length - 1;
     caml_floatarray_blit(hd$0, 0, result, i, hlen);
     var i$0 = i + hlen | 0, l$0 = tl$0, i = i$0;
    }
   }
   function sub(a, ofs, len){
    check(a, ofs, len, cst_Float_Array_sub);
    var result = caml_floatarray_create(len);
    caml_floatarray_blit(a, ofs, result, 0, len);
    return result;
   }
   function copy(a){
    var l = a.length - 1, result = caml_floatarray_create(l);
    caml_floatarray_blit(a, 0, result, 0, l);
    return result;
   }
   function fill(a, ofs, len, v){
    check(a, ofs, len, cst_Float_Array_fill);
    return unsafe_fill(a, ofs, len, v);
   }
   function blit(src, sofs, dst, dofs, len){
    check(src, sofs, len, cst_Float_array_blit);
    check(dst, dofs, len, cst_Float_array_blit$0);
    return caml_floatarray_blit(src, sofs, dst, dofs, len);
   }
   function to_list(a){
    function _al_(_am_){return a[1 + _am_];}
    return caml_call2(Stdlib_List[11], a.length - 1, _al_);
   }
   function of_list(l){
    var
     result = caml_floatarray_create(caml_call1(Stdlib_List[1], l)),
     i = 0,
     l$0 = l;
    for(;;){
     if(! l$0) return result;
     var t = l$0[2], h = l$0[1];
     result[1 + i] = h;
     var i$0 = i + 1 | 0, i = i$0, l$0 = t;
    }
   }
   function iter(f, a){
    var _aj_ = a.length - 1 - 1 | 0, _ai_ = 0;
    if(_aj_ >= 0){
     var i = _ai_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _ak_ = i + 1 | 0;
      if(_aj_ === i) break;
      var i = _ak_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Float_Array_iter2_arrays_m);
    var _ag_ = a.length - 1 - 1 | 0, _af_ = 0;
    if(_ag_ >= 0){
     var i = _af_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _ah_ = i + 1 | 0;
      if(_ag_ === i) break;
      var i = _ah_;
     }
    }
    return 0;
   }
   function map(f, a){
    var
     l = a.length - 1,
     r = caml_floatarray_create(l),
     _ad_ = l - 1 | 0,
     _ac_ = 0;
    if(_ad_ >= 0){
     var i = _ac_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _ae_ = i + 1 | 0;
      if(_ad_ === i) break;
      var i = _ae_;
     }
    }
    return r;
   }
   function map_inplace(f, a){
    var _aa_ = a.length - 1 - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      a[1 + i] = caml_call1(f, a[1 + i]);
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      var i = _ab_;
     }
    }
    return 0;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Float_Array_map2_arrays_mu);
    var r = caml_floatarray_create(la), _Z_ = la - 1 | 0, _Y_ = 0;
    if(_Z_ >= 0){
     var i = _Y_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var ___ = i + 1 | 0;
      if(_Z_ === i) break;
      var i = ___;
     }
    }
    return r;
   }
   function iteri(f, a){
    var _W_ = a.length - 1 - 1 | 0, _V_ = 0;
    if(_W_ >= 0){
     var i = _V_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _X_ = i + 1 | 0;
      if(_W_ === i) break;
      var i = _X_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var
     l = a.length - 1,
     r = caml_floatarray_create(l),
     _T_ = l - 1 | 0,
     _S_ = 0;
    if(_T_ >= 0){
     var i = _S_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var _U_ = i + 1 | 0;
      if(_T_ === i) break;
      var i = _U_;
     }
    }
    return r;
   }
   function mapi_inplace(f, a){
    var _Q_ = a.length - 1 - 1 | 0, _P_ = 0;
    if(_Q_ >= 0){
     var i = _P_;
     for(;;){
      a[1 + i] = caml_call2(f, i, a[1 + i]);
      var _R_ = i + 1 | 0;
      if(_Q_ === i) break;
      var i = _R_;
     }
    }
    return 0;
   }
   function fold_left(f, x, a){
    var r = [0, x], _N_ = a.length - 1 - 1 | 0, _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      var i = _O_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _K_ = a.length - 1 - 1 | 0;
    if(_K_ >= 0){
     var i = _K_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _L_ = i - 1 | 0;
      if(0 === i) break;
      var i = _L_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === caml_float_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function mem_ieee(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x == a[1 + i]) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_index(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return [0, i];
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_mapi(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call2(f, i, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   var
    Bottom = [248, cst_Stdlib_Float_Array_Bottom, runtime.caml_fresh_oo_id(0)];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      if
       (caml_call2
         (cmp, caml_array_get(a, i31), caml_array_get(a, i31 + 1 | 0))
        < 0)
       x[1] = i31 + 1 | 0;
      if
       (caml_call2
         (cmp, caml_array_get(a, x[1]), caml_array_get(a, i31 + 2 | 0))
        < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if
      ((i31 + 1 | 0) < l
       &&
        0
        >
         caml_call2
          (cmp, caml_array_get(a, i31), caml_array_get(a, i31 + 1 | 0)))
      return i31 + 1 | 0;
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _E_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_E_ >= 0){
     var i$6 = _E_;
     for(;;){
      var e$1 = caml_array_get(a, i$6);
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_array_get(a, j), e$1)) break;
        caml_array_set(a, i, caml_array_get(a, j));
        var i = j;
       }
       caml_array_set(a, i, e$1);
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_array_set(a, i$0, e$1);
      }
      var _J_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      var i$6 = _J_;
     }
    }
    var _F_ = l - 1 | 0;
    if(_F_ >= 2){
     var i$4 = _F_;
     for(;;){
      var e$0 = caml_array_get(a, i$4);
      caml_array_set(a, i$4, caml_array_get(a, 0));
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1);
        caml_array_set(a, i$1, caml_array_get(a, j$0));
        var i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          if(0 <= caml_call2(cmp, caml_array_get(a, father), e$0)) break;
          caml_array_set(a, i$3, caml_array_get(a, father));
          if(0 >= father) break b;
          var i$3 = father;
         }
         caml_array_set(a, i$3, e$0);
         break a;
        }
        caml_array_set(a, 0, e$0);
       }
       var _I_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       var i$4 = _I_;
      }
     }
    }
    var _G_ = 1 < l ? 1 : 0;
    if(_G_){
     var e = caml_array_get(a, 1);
     caml_array_set(a, 1, caml_array_get(a, 0));
     var _H_ = caml_array_set(a, 0, e);
    }
    else
     var _H_ = _G_;
    return _H_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_array_get(src2, src2ofs),
      s1$1 = caml_array_get(a, src1ofs),
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_array_set(dst, d, s2);
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var
        d$0 = d + 1 | 0,
        s2$0 = caml_array_get(src2, i2$0),
        i2 = i2$0,
        s2 = s2$0,
        d = d$0;
      }
      else{
       caml_array_set(dst, d, s1);
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var
        d$1 = d + 1 | 0,
        s1$0 = caml_array_get(a, i1$0),
        i1 = i1$0,
        s1 = s1$0,
        d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _C_ = len - 1 | 0, _B_ = 0;
     if(_C_ >= 0){
      var i = _B_;
      for(;;){
       var
        e = caml_array_get(a, srcofs + i | 0),
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        if(0 >= caml_call2(cmp, caml_array_get(dst, j[1]), e)) break;
        caml_array_set(dst, j[1] + 1 | 0, caml_array_get(dst, j[1]));
        j[1] += -1;
       }
       caml_array_set(dst, j[1] + 1 | 0, e);
       var _D_ = i + 1 | 0;
       if(_C_ === i) break;
       var i = _D_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var l1 = l / 2 | 0, l2 = l - l1 | 0, t = caml_floatarray_create(l2);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _z_ = i + 1 | 0;
     return [0, x, function(_A_){return aux(_z_, _A_);}];
    }
    var _x_ = 0;
    return function(_y_){return aux(_x_, _y_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _v_ = i + 1 | 0;
     return [0, [0, i, x], function(_w_){return aux(_v_, _w_);}];
    }
    var _t_ = 0;
    return function(_u_){return aux(_t_, _u_);};
   }
   function of_seq(i$2){
    var _r_ = 0;
    function _s_(acc, x){return [0, x, acc];}
    var
     l = caml_call3(Stdlib_Seq[5], _s_, _r_, i$2),
     len = caml_call1(Stdlib_List[1], l),
     a = caml_floatarray_create(len),
     i$1 = len - 1 | 0,
     i = i$1,
     param = l;
    for(;;){
     if(! param) return a;
     var tl = param[2], hd = param[1];
     a[1 + i] = hd;
     var i$0 = i - 1 | 0, i = i$0, param = tl;
    }
   }
   function map_to_array(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = runtime.caml_make_vect(l, caml_call1(f, a[1])),
     _p_ = l - 1 | 0,
     _o_ = 1;
    if(_p_ >= 1){
     var i = _o_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return r;
   }
   function map_from_array(f, a){
    var
     l = a.length - 1,
     r = caml_floatarray_create(l),
     _m_ = l - 1 | 0,
     _l_ = 0;
    if(_m_ >= 0){
     var i = _l_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _n_ = i + 1 | 0;
      if(_m_ === i) break;
      var i = _n_;
     }
    }
    return r;
   }
   var
    _c_ = caml_floatarray_create,
    _d_ = caml_array_set,
    _e_ = caml_array_get,
    _f_ =
      [0,
       function(_k_){return _k_.length - 1;},
       _e_,
       _d_,
       make,
       _c_,
       init,
       append,
       concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       map_inplace,
       mapi,
       mapi_inplace,
       fold_left,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       mem,
       mem_ieee,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       map_to_array,
       map_from_array],
    _g_ = caml_floatarray_create,
    _h_ = caml_array_set,
    _i_ = caml_array_get,
    Stdlib_Float =
      [0,
       zero,
       one,
       minus_one,
       succ,
       pred,
       infinity,
       neg_infinity,
       nan,
       signaling_nan,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal,
       min,
       max,
       min_max,
       min_num,
       max_num,
       min_max_num,
       seeded_hash,
       hash,
       [0,
        function(_j_){return _j_.length - 1;},
        _i_,
        _h_,
        make,
        _g_,
        init,
        append,
        concat,
        sub,
        copy,
        fill,
        blit,
        to_list,
        of_list,
        iter,
        iteri,
        map,
        map_inplace,
        mapi,
        mapi_inplace,
        fold_left,
        fold_right,
        iter2,
        map2,
        for_all,
        exists,
        mem,
        mem_ieee,
        find_opt,
        find_index,
        find_map,
        find_mapi,
        sort,
        stable_sort,
        stable_sort,
        to_seq,
        to_seqi,
        of_seq,
        map_to_array,
        map_from_array],
       _f_];
   runtime.caml_register_global(23, Stdlib_Float, "Stdlib__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int32
//# unitInfo: Requires: Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, "int32.ml", 69, 6],
    zero = 0,
    one = 1,
    minus_one = -1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var min_int = -2147483648, max_int = 2147483647;
   function lognot(n){return n ^ -1;}
   var _a_ = Stdlib_Sys[9];
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    return caml_int_compare(n + 2147483648 | 0, m + 2147483648 | 0);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int64
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function succ(n){return runtime.caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _f_ = [0, runtime.caml_int64_of_string(s)]; return _f_;}
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    return caml_int64_compare
            (caml_int64_sub(n, min_int), caml_int64_sub(m, min_int));
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? succ(q) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Nativeint
//# unitInfo: Requires: Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1,
    minus_one = -1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    return caml_int_compare(n - min_int | 0, m - min_int | 0);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Lexing
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Int, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_pos = [0, cst, 0, 0, -1],
    zero_pos = [0, cst, 1, 0, 0],
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_Lexing_lex_refill_cannot_g = "Lexing.lex_refill: cannot grow buffer";
   function engine(tbl, state, buf){
    var
     result = runtime.caml_lex_engine(tbl, state, buf),
     _F_ = 0 <= result ? 1 : 0,
     _G_ = _F_ ? buf[12] !== dummy_pos ? 1 : 0 : _F_;
    if(_G_){
     buf[11] = buf[12];
     var _H_ = buf[12];
     buf[12] = [0, _H_[1], _H_[2], _H_[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function new_engine(tbl, state, buf){
    var
     result = runtime.caml_new_lex_engine(tbl, state, buf),
     _C_ = 0 <= result ? 1 : 0,
     _D_ = _C_ ? buf[12] !== dummy_pos ? 1 : 0 : _C_;
    if(_D_){
     buf[11] = buf[12];
     var _E_ = buf[12];
     buf[12] = [0, _E_[1], _E_[2], _E_[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function from_function(opt, read_fun){
    if(opt)
     var sth = opt[1], with_positions = sth;
    else
     var with_positions = 1;
    var
     _o_ = with_positions ? zero_pos : dummy_pos,
     _p_ = with_positions ? zero_pos : dummy_pos,
     aux_buffer = caml_create_bytes(512),
     _q_ = [0],
     _r_ = 0,
     _s_ = 0,
     _t_ = 0,
     _u_ = 0,
     _v_ = 0,
     _w_ = 0,
     _x_ = 0,
     _y_ = caml_create_bytes(1024);
    return [0,
            function(lexbuf){
             var
              read =
                caml_call2
                 (read_fun, aux_buffer, caml_ml_bytes_length(aux_buffer)),
              n = 0 < read ? read : (lexbuf[9] = 1, 0);
             if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0)){
              if
               (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                <= caml_ml_bytes_length(lexbuf[2]))
               caml_call5
                (Stdlib_Bytes[11],
                 lexbuf[2],
                 lexbuf[5],
                 lexbuf[2],
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
              else{
               var
                newlen =
                  caml_call2
                   (Stdlib_Int[10],
                    2 * caml_ml_bytes_length(lexbuf[2]) | 0,
                    Stdlib_Sys[12]);
               if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                caml_call1(Stdlib[2], cst_Lexing_lex_refill_cannot_g);
               var newbuf = caml_create_bytes(newlen);
               caml_call5
                (Stdlib_Bytes[11],
                 lexbuf[2],
                 lexbuf[5],
                 newbuf,
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
               lexbuf[2] = newbuf;
              }
              var s = lexbuf[5];
              lexbuf[4] = lexbuf[4] + s | 0;
              lexbuf[6] = lexbuf[6] - s | 0;
              lexbuf[5] = 0;
              lexbuf[7] = lexbuf[7] - s | 0;
              lexbuf[3] = lexbuf[3] - s | 0;
              var t = lexbuf[10], _A_ = t.length - 1 - 1 | 0, _z_ = 0;
              if(_A_ >= 0){
               var i = _z_;
               for(;;){
                var v = caml_check_bound(t, i)[1 + i];
                if(0 <= v) caml_check_bound(t, i)[1 + i] = v - s | 0;
                var _B_ = i + 1 | 0;
                if(_A_ === i) break;
                var i = _B_;
               }
              }
             }
             caml_call5
              (Stdlib_Bytes[11], aux_buffer, 0, lexbuf[2], lexbuf[3], n);
             lexbuf[3] = lexbuf[3] + n | 0;
             return 0;
            },
            _y_,
            _x_,
            _w_,
            _v_,
            _u_,
            _t_,
            _s_,
            _r_,
            _q_,
            _p_,
            _o_];
   }
   function from_channel(with_positions, ic){
    return from_function
            (with_positions,
             function(buf, n){return caml_call4(Stdlib[84], ic, buf, 0, n);});
   }
   function from_string(opt, s){
    if(opt)
     var sth = opt[1], with_positions = sth;
    else
     var with_positions = 1;
    var
     _d_ = with_positions ? zero_pos : dummy_pos,
     _e_ = with_positions ? zero_pos : dummy_pos,
     _f_ = [0],
     _g_ = 1,
     _h_ = 0,
     _i_ = 0,
     _j_ = 0,
     _k_ = 0,
     _l_ = 0,
     _m_ = runtime.caml_ml_string_length(s),
     _n_ = caml_call1(Stdlib_Bytes[5], s);
    return [0,
            function(lexbuf){lexbuf[9] = 1; return 0;},
            _n_,
            _m_,
            _l_,
            _k_,
            _j_,
            _i_,
            _h_,
            _g_,
            _f_,
            _e_,
            _d_];
   }
   function set_position(lexbuf, position){
    lexbuf[12] = [0, lexbuf[12][1], position[2], position[3], position[4]];
    lexbuf[4] = position[4];
    return 0;
   }
   function set_filename(lexbuf, fname){
    var _c_ = lexbuf[12];
    lexbuf[12] = [0, fname, _c_[2], _c_[3], _c_[4]];
    return 0;
   }
   function with_positions(lexbuf){return lexbuf[12] !== dummy_pos ? 1 : 0;}
   function lexeme(lexbuf){
    var len = lexbuf[6] - lexbuf[5] | 0;
    return caml_call3(Stdlib_Bytes[8], lexbuf[2], lexbuf[5], len);
   }
   function sub_lexeme(lexbuf, i1, i2){
    var len = i2 - i1 | 0;
    return caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len);
   }
   function sub_lexeme_opt(lexbuf, i1, i2){
    if(0 > i1) return 0;
    var len = i2 - i1 | 0;
    return [0, caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len)];
   }
   function sub_lexeme_char(lexbuf, i){return caml_bytes_get(lexbuf[2], i);}
   function sub_lexeme_char_opt(lexbuf, i){
    return 0 <= i ? [0, caml_bytes_get(lexbuf[2], i)] : 0;
   }
   function lexeme_char(lexbuf, i){
    return caml_bytes_get(lexbuf[2], lexbuf[5] + i | 0);
   }
   function lexeme_start(lexbuf){return lexbuf[11][4];}
   function lexeme_end(lexbuf){return lexbuf[12][4];}
   function lexeme_start_p(lexbuf){return lexbuf[11];}
   function lexeme_end_p(lexbuf){return lexbuf[12];}
   function new_line(lexbuf){
    var
     lcp = lexbuf[12],
     _a_ = lcp !== dummy_pos ? 1 : 0,
     _b_ =
       _a_
        ? (lexbuf[12] = [0, lcp[1], lcp[2] + 1 | 0, lcp[4], lcp[4]], 0)
        : _a_;
    return _b_;
   }
   function flush_input(lb){
    lb[6] = 0;
    lb[4] = 0;
    var lcp = lb[12];
    if(lcp !== dummy_pos)
     lb[12] = [0, lcp[1], zero_pos[2], zero_pos[3], zero_pos[4]];
    lb[3] = 0;
    return 0;
   }
   var
    Stdlib_Lexing =
      [0,
       dummy_pos,
       from_channel,
       from_string,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
   runtime.caml_register_global(7, Stdlib_Lexing, "Stdlib__Lexing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Parsing
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Lexing, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    YYexit = [248, "Stdlib.Parsing.YYexit", caml_fresh_oo_id(0)],
    Parse_error = [248, "Stdlib.Parsing.Parse_error", caml_fresh_oo_id(0)],
    env =
      [0,
       caml_make_vect(100, 0),
       caml_make_vect(100, 0),
       caml_make_vect(100, Stdlib_Lexing[1]),
       caml_make_vect(100, Stdlib_Lexing[1]),
       100,
       0,
       0,
       0,
       Stdlib_Lexing[1],
       Stdlib_Lexing[1],
       0,
       0,
       0,
       0,
       0,
       0],
    cst_syntax_error = "syntax error";
   function grow_stacks(param){
    var
     oldsize = env[5],
     newsize = oldsize * 2 | 0,
     new_s = caml_make_vect(newsize, 0),
     new_v = caml_make_vect(newsize, 0),
     new_start = caml_make_vect(newsize, Stdlib_Lexing[1]),
     new_end = caml_make_vect(newsize, Stdlib_Lexing[1]);
    caml_call5(Stdlib_Array[8], env[1], 0, new_s, 0, oldsize);
    env[1] = new_s;
    caml_call5(Stdlib_Array[8], env[2], 0, new_v, 0, oldsize);
    env[2] = new_v;
    caml_call5(Stdlib_Array[8], env[3], 0, new_start, 0, oldsize);
    env[3] = new_start;
    caml_call5(Stdlib_Array[8], env[4], 0, new_end, 0, oldsize);
    env[4] = new_end;
    env[5] = newsize;
    return;
   }
   function clear_parser(param){
    caml_call4(Stdlib_Array[7], env[2], 0, env[5], 0);
    env[8] = 0;
    return 0;
   }
   var current_lookahead_fun = [0, function(param){return 0;}];
   function yyparse(tables, start, lexer, lexbuf){
    var
     init_asp = env[11],
     init_sp = env[14],
     init_stackbase = env[6],
     init_state = env[15],
     init_curr_char = env[7],
     init_lval = env[8],
     init_errflag = env[16];
    env[6] = env[14] + 1 | 0;
    env[7] = start;
    env[10] = lexbuf[12];
    try{
     var cmd = 0, arg = 0;
     for(;;)
      switch(runtime.caml_parse_engine(tables, env, cmd, arg)){
        case 0:
         var arg$0 = caml_call1(lexer, lexbuf);
         env[9] = lexbuf[11];
         env[10] = lexbuf[12];
         var cmd = 1, arg = arg$0;
         break;
        case 1:
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        case 2:
         grow_stacks(0); var cmd = 2, arg = 0; break;
        case 3:
         grow_stacks(0); var cmd = 3, arg = 0; break;
        case 4:
         try{
          var
           _i_ = env[13],
           _j_ = caml_call1(caml_check_bound(tables[1], _i_)[1 + _i_], env),
           _k_ = 4,
           value = _j_,
           action = _k_;
         }
         catch(_m_){
          var _h_ = caml_wrap_exception(_m_);
          if(_h_ !== Parse_error) throw caml_maybe_attach_backtrace(_h_, 0);
          var value = 0, action = 5;
         }
         var cmd = action, arg = value;
         break;
        default:
         caml_call1(tables[14], cst_syntax_error); var cmd = 5, arg = 0;
      }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), curr_char = env[7];
     env[11] = init_asp;
     env[14] = init_sp;
     env[6] = init_stackbase;
     env[15] = init_state;
     env[7] = init_curr_char;
     env[8] = init_lval;
     env[16] = init_errflag;
     if(exn[1] === YYexit){var v = exn[2]; return v;}
     current_lookahead_fun[1] =
      function(tok){
       if(! caml_call1(Stdlib_Obj[1], tok))
        return caml_check_bound(tables[2], tok)[1 + tok] === curr_char ? 1 : 0;
       var _l_ = runtime.caml_obj_tag(tok);
       return caml_check_bound(tables[3], _l_)[1 + _l_] === curr_char ? 1 : 0;
      };
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function peek_val(env, n){
    var _g_ = env[11] - n | 0;
    return caml_check_bound(env[2], _g_)[1 + _g_];
   }
   function symbol_start_pos(param){
    var i$1 = env[12], i = i$1;
    for(;;){
     if(0 >= i){
      var _f_ = env[11];
      return caml_check_bound(env[4], _f_)[1 + _f_];
     }
     var
      _d_ = (env[11] - i | 0) + 1 | 0,
      st = caml_check_bound(env[3], _d_)[1 + _d_],
      _e_ = (env[11] - i | 0) + 1 | 0,
      en = caml_check_bound(env[4], _e_)[1 + _e_];
     if(runtime.caml_notequal(st, en)) return st;
     var i$0 = i - 1 | 0, i = i$0;
    }
   }
   function symbol_end_pos(param){
    var _c_ = env[11];
    return caml_check_bound(env[4], _c_)[1 + _c_];
   }
   function rhs_start_pos(n){
    var _b_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[3], _b_)[1 + _b_];
   }
   function rhs_end_pos(n){
    var _a_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[4], _a_)[1 + _a_];
   }
   function symbol_start(param){return symbol_start_pos(0)[4];}
   function symbol_end(param){return symbol_end_pos(0)[4];}
   function rhs_start(n){return rhs_start_pos(n)[4];}
   function rhs_end(n){return rhs_end_pos(n)[4];}
   function is_current_lookahead(tok){
    return caml_call1(current_lookahead_fun[1], tok);
   }
   function parse_error(param){return 0;}
   var
    Stdlib_Parsing =
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       runtime.caml_set_parser_trace,
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
   runtime.caml_register_global(7, Stdlib_Parsing, "Stdlib__Parsing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Set
//# unitInfo: Requires: Stdlib, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Set_bal$3 = "Set.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, 0, 0],
    _c_ = [0, "set.ml", 571, 18],
    cst_Set_bal = cst_Set_bal$3,
    cst_Set_bal$0 = cst_Set_bal$3,
    cst_Set_bal$1 = cst_Set_bal$3,
    cst_Set_bal$2 = cst_Set_bal$3,
    Stdlib_Set =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[4];
         return h;
        }
        function create(l, v, r){
         if(l) var h = l[4], hl = h; else var hl = 0;
         if(r) var h$0 = r[4], hr = h$0; else var hr = 0;
         var _Z_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, v, r, _Z_];
        }
        function bal(l, v, r){
         if(l) var h = l[4], hl = h; else var hl = 0;
         if(r) var h$0 = r[4], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Set_bal$0);
          var lr = l[3], lv = l[2], ll = l[1], _U_ = height(lr);
          if(_U_ <= height(ll)) return create(ll, lv, create(lr, v, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Set_bal);
          var lrr = lr[3], lrv = lr[2], lrl = lr[1], _V_ = create(lrr, v, r);
          return create(create(ll, lv, lrl), lrv, _V_);
         }
         if((hl + 2 | 0) >= hr){
          var _Y_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, v, r, _Y_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Set_bal$2);
         var rr = r[3], rv = r[2], rl = r[1], _W_ = height(rl);
         if(_W_ <= height(rr)) return create(create(l, v, rl), rv, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Set_bal$1);
         var rlr = rl[3], rlv = rl[2], rll = rl[1], _X_ = create(rlr, rv, rr);
         return create(create(l, v, rll), rlv, _X_);
        }
        function add(x, t){
         if(! t) return [0, 0, x, 0, 1];
         var r = t[3], v = t[2], l = t[1], c = caml_call2(Ord[1], x, v);
         if(0 === c) return t;
         if(0 <= c){var rr = add(x, r); return r === rr ? t : bal(l, v, rr);}
         var ll = add(x, l);
         return l === ll ? t : bal(ll, v, r);
        }
        function singleton(x){return [0, 0, x, 0, 1];}
        function add_min_element(x, param){
         if(! param) return singleton(x);
         var r = param[3], v = param[2], l = param[1];
         return bal(add_min_element(x, l), v, r);
        }
        function add_max_element(x, param){
         if(! param) return singleton(x);
         var r = param[3], v = param[2], l = param[1];
         return bal(l, v, add_max_element(x, r));
        }
        function join(l, v, r){
         if(! l) return add_min_element(v, r);
         if(! r) return add_max_element(v, l);
         var
          rh = r[4],
          rr = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[4],
          lr = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, join(lr, v, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, rl), rv, rr)
                   : create(l, v, r);
        }
        function min_elt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var v = param$0[2]; return v;}
          var param$0 = l;
         }
        }
        function min_elt_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var v = param$0[2]; return [0, v];}
          var param$0 = l;
         }
        }
        function max_elt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[3]){var v = param$0[2]; return v;}
          var r = param$0[3], param$0 = r;
         }
        }
        function max_elt_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[3]){var v = param$0[2]; return [0, v];}
          var r = param$0[3], param$0 = r;
         }
        }
        function remove_min_elt(param){
         if(! param) return caml_call1(Stdlib[1], cst_Set_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[3], v = param[2];
          return bal(remove_min_elt(l), v, r);
         }
         var r$0 = param[3];
         return r$0;
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var _T_ = remove_min_elt(t2);
         return join(t1, min_elt(t2), _T_);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, 1, r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, r)];
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _S_ = 0 === c ? 1 : 0;
          if(_S_) return _S_;
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function remove(x, t){
         if(! t) return 0;
         var t2 = t[3], v = t[2], t1 = t[1], c = caml_call2(Ord[1], x, v);
         if(0 === c){
          if(! t1) return t2;
          if(! t2) return t1;
          var _R_ = remove_min_elt(t2);
          return bal(t1, min_elt(t2), _R_);
         }
         if(0 <= c){
          var rr = remove(x, t2);
          return t2 === rr ? t : bal(t1, v, rr);
         }
         var ll = remove(x, t1);
         return t1 === ll ? t : bal(ll, v, t2);
        }
        function union(s1, s2){
         if(! s1) return s2;
         if(! s2) return s1;
         var
          h2 = s2[4],
          r2 = s2[3],
          v2 = s2[2],
          l2 = s2[1],
          h1 = s1[4],
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1];
         if(h2 <= h1){
          if(1 === h2) return add(v2, s1);
          var
           match = split(v1, s2),
           r2$0 = match[3],
           l2$0 = match[1],
           _P_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1, _P_);
         }
         if(1 === h1) return add(v1, s2);
         var
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _Q_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2, _Q_);
        }
        function inter(s1, s2){
         if(! s1) return 0;
         if(! s2) return 0;
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _M_ = split(v1, s2),
          l2 = _M_[1];
         if(_M_[2]){
          var r2 = _M_[3], _N_ = inter(r1, r2);
          return join(inter(l1, l2), v1, _N_);
         }
         var r2$0 = _M_[3], _O_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _O_);
        }
        function split_bis(x, param){
         if(! param) return [0, 0, function(param){return 0;}];
         var
          r = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return 0;
         if(0 <= c){
          var match = split_bis(x, r);
          if(! match) return 0;
          var rr = match[2], lr = match[1];
          return [0, join(l, v, lr), rr];
         }
         var match$0 = split_bis(x, l);
         if(! match$0) return 0;
         var rl = match$0[2], ll = match$0[1];
         return [0, ll, function(param){return join(rl(0), v, r);}];
        }
        function disjoint(s1, s2){
         var s1$0 = s1, s2$0 = s2;
         for(;;){
          if(s1$0 && s2$0){
           var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
           if(s1$0 === s2$0) return 0;
           var match = split_bis(v1, s2$0);
           if(! match) return 0;
           var r2 = match[2], l2 = match[1], _L_ = disjoint(l1, l2);
           if(! _L_) return _L_;
           var s2$1 = r2(0), s1$0 = r1, s2$0 = s2$1;
           continue;
          }
          return 1;
         }
        }
        function diff(s1, s2){
         if(! s1) return 0;
         if(! s2) return s1;
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _I_ = split(v1, s2),
          l2 = _I_[1];
         if(_I_[2]){
          var r2 = _I_[3], _J_ = diff(r1, r2);
          return concat(diff(l1, l2), _J_);
         }
         var r2$0 = _I_[3], _K_ = diff(r1, r2$0);
         return join(diff(l1, l2), v1, _K_);
        }
        function cons_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, r, e$0],
           s$0 = l,
           e$0 = e$1;
         }
        }
        function compare(s1, s2){
         var
          e2$2 = cons_enum(s2, 0),
          e1$2 = cons_enum(s1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[3],
           r2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[3],
           r1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var
           e2$1 = cons_enum(r2, e2$0),
           e1$1 = cons_enum(r1, e1$0),
           e1 = e1$1,
           e2 = e2$1;
         }
        }
        function equal(s1, s2){return 0 === compare(s1, s2) ? 1 : 0;}
        function subset(s1, s2){
         var s1$0 = s1, s2$0 = s2;
         for(;;){
          if(! s1$0) return 1;
          if(! s2$0) return 0;
          var
           r2 = s2$0[3],
           v2 = s2$0[2],
           l2 = s2$0[1],
           r1 = s1$0[3],
           v1 = s1$0[2],
           l1 = s1$0[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 === c){
           var _F_ = subset(l1, l2);
           if(! _F_) return _F_;
           var s1$0 = r1, s2$0 = r2;
          }
          else if(0 <= c){
           var _G_ = subset([0, 0, v1, r1, 0], r2);
           if(! _G_) return _G_;
           var s1$0 = l1;
          }
          else{
           var _H_ = subset([0, l1, v1, 0, 0], l2);
           if(! _H_) return _H_;
           var s1$0 = r1;
          }
         }
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call1(f, v);
          var param$0 = r;
         }
        }
        function fold(f, s, accu){
         var s$0 = s, accu$0 = accu;
         for(;;){
          if(! s$0) return accu$0;
          var
           r = s$0[3],
           v = s$0[2],
           l = s$0[1],
           accu$1 = caml_call2(f, v, fold(f, l, accu$0)),
           s$0 = r,
           accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _C_ = caml_call1(p, v);
          if(_C_){
           var _D_ = for_all(p, l);
           if(_D_){var param$0 = r; continue;}
           var _E_ = _D_;
          }
          else
           var _E_ = _C_;
          return _E_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _z_ = caml_call1(p, v);
          if(_z_)
           var _A_ = _z_;
          else{
           var _B_ = exists(p, l);
           if(! _B_){var param$0 = r; continue;}
           var _A_ = _B_;
          }
          return _A_;
         }
        }
        function filter(p, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          l$0 = filter(p, l),
          pv = caml_call1(p, v),
          r$0 = filter(p, r);
         if(! pv) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return t;
         return join(l$0, v, r$0);
        }
        function partition(p, param){
         if(! param) return _b_;
         var
          r = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pv = caml_call1(p, v),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pv){var _x_ = concat(lf, rf); return [0, join(lt, v, rt), _x_];}
         var _y_ = join(lf, v, rf);
         return [0, concat(lt, rt), _y_];
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[3], l = param[1], _w_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _w_ | 0;
        }
        function elements_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, v, elements_aux(accu$0, r)],
           accu$0 = accu$1,
           param$0 = l;
         }
        }
        function elements(s){return elements_aux(0, s);}
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return v;
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = l$0;
           for(;;){
            if(! param) return v0;
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, param = l;
            else
             var param = r;
           }
          }
          else
           var param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0];
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, param = l;
            else
             var param = r;
           }
          }
          else
           var param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = r$0;
           for(;;){
            if(! param) return v0;
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, param = r;
            else
             var param = l;
           }
          }
          else
           var param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0];
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, param = r;
            else
             var param = l;
           }
          }
          else
           var param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, v];
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function try_join(l, v, r){
         a:
         {
          if(0 !== l){
           var _v_ = max_elt(l);
           if(0 <= caml_call2(Ord[1], _v_, v)) break a;
          }
          if(0 !== r){
           var _u_ = min_elt(r);
           if(0 <= caml_call2(Ord[1], v, _u_)) break a;
          }
          return join(l, v, r);
         }
         return union(l, add(v, r));
        }
        function map(f, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          l$0 = map(f, l),
          v$0 = caml_call1(f, v),
          r$0 = map(f, r);
         if(l === l$0 && v === v$0 && r === r$0) return t;
         return try_join(l$0, v$0, r$0);
        }
        function filter_map(f, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          t1 = filter_map(f, l),
          v$0 = caml_call1(f, v),
          t2 = filter_map(f, r);
         if(v$0){
          var v$1 = v$0[1];
          if(l === t1 && v === v$1 && r === t2) return t;
          return try_join(t1, v$1, t2);
         }
         if(! t1) return t2;
         if(! t2) return t1;
         var _t_ = remove_min_elt(t2);
         return try_join(t1, min_elt(t2), _t_);
        }
        function of_list(l){
         if(! l) return empty;
         var _o_ = l[2], x0 = l[1];
         if(! _o_) return singleton(x0);
         var _p_ = _o_[2], x1 = _o_[1];
         if(! _p_) return add(x1, singleton(x0));
         var _q_ = _p_[2], x2 = _p_[1];
         if(! _q_) return add(x2, add(x1, singleton(x0)));
         var _r_ = _q_[2], x3 = _q_[1];
         if(! _r_) return add(x3, add(x2, add(x1, singleton(x0))));
         if(_r_[2]){
          var
           l$0 = caml_call2(Stdlib_List[62], Ord[1], l),
           sub =
             function(n, l){
              if(3 >= n >>> 0)
               switch(n){
                 case 0:
                  return [0, 0, l];
                 case 1:
                  if(l){
                   var l$3 = l[2], x0 = l[1];
                   return [0, [0, 0, x0, 0, 1], l$3];
                  }
                  break;
                 case 2:
                  if(l){
                   var match$1 = l[2];
                   if(match$1){
                    var l$4 = match$1[2], x1 = match$1[1], x0$0 = l[1];
                    return [0, [0, [0, 0, x0$0, 0, 1], x1, 0, 2], l$4];
                   }
                  }
                  break;
                 default:
                  if(l){
                   var _s_ = l[2];
                   if(_s_){
                    var match$2 = _s_[2];
                    if(match$2){
                     var
                      l$5 = match$2[2],
                      x2 = match$2[1],
                      x1$0 = _s_[1],
                      x0$1 = l[1];
                     return [0,
                             [0, [0, 0, x0$1, 0, 1], x1$0, [0, 0, x2, 0, 1], 2],
                             l$5];
                    }
                   }
                  }
               }
              var
               nl = n / 2 | 0,
               match = sub(nl, l),
               l$0 = match[2],
               left = match[1];
              if(! l$0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
              var
               l$1 = l$0[2],
               mid = l$0[1],
               match$0 = sub((n - nl | 0) - 1 | 0, l$1),
               l$2 = match$0[2],
               right = match$0[1];
              return [0, create(left, mid, right), l$2];
             };
          return sub(caml_call1(Stdlib_List[1], l$0), l$0)[1];
         }
         var x4 = _r_[1];
         return add(x4, add(x3, add(x2, add(x1, singleton(x0)))));
        }
        function add_seq(i, m){
         function _n_(s, x){return add(x, s);}
         return caml_call3(Stdlib_Seq[5], _n_, m, i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var rest = c[3], t = c[2], x = c[1], _l_ = cons_enum(t, rest);
         return [0, x, function(_m_){return seq_of_enum(_l_, _m_);}];
        }
        function to_seq(c){
         var _j_ = cons_enum(c, 0);
         return function(_k_){return seq_of_enum(_j_, _k_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, l, e$0],
           s$0 = r,
           e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var rest = c[3], t = c[2], x = c[1], _h_ = snoc_enum(t, rest);
         return [0, x, function(_i_){return rev_seq_of_enum(_h_, _i_);}];
        }
        function to_rev_seq(c){
         var _f_ = snoc_enum(c, 0);
         return function(_g_){return rev_seq_of_enum(_f_, _g_);};
        }
        function to_seq_from(low, s){
         var s$0 = s, c = 0;
         for(;;){
          if(s$0){
           var
            r = s$0[3],
            v = s$0[2],
            l = s$0[1],
            n = caml_call2(Ord[1], v, low);
           if(0 !== n){
            if(0 <= n){var c$0 = [0, v, r, c], s$0 = l, c = c$0; continue;}
            var s$0 = r;
            continue;
           }
           var _d_ = [0, v, r, c];
          }
          else
           var _d_ = c;
          return function(_e_){return seq_of_enum(_d_, _e_);};
         }
        }
        return [0,
                empty,
                add,
                singleton,
                remove,
                union,
                inter,
                disjoint,
                diff,
                cardinal,
                elements,
                min_elt,
                min_elt_opt,
                max_elt,
                max_elt_opt,
                min_elt,
                min_elt_opt,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                iter,
                fold,
                map,
                filter,
                filter_map,
                partition,
                split,
                is_empty,
                mem,
                equal,
                compare,
                subset,
                for_all,
                exists,
                elements,
                of_list,
                to_seq_from,
                to_seq,
                to_rev_seq,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(12, Stdlib_Set, "Stdlib__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Map
//# unitInfo: Requires: Stdlib, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 408, 10],
    _c_ = [0, 0, 0],
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _M_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _M_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _H_ = height(lr);
          if(_H_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _I_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _I_);
         }
         if((hl + 2 | 0) >= hr){
          var _L_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _L_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _J_ = height(rl);
         if(_J_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _K_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _K_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, d0 = d0$0, param = l;
            else
             var param = r;
           }
          }
          else
           var param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, d0 = d0$0, param = l;
            else
             var param = r;
           }
          }
          else
           var param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, d0 = d0$0, param = r;
            else
             var param = l;
           }
          }
          else
           var param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0))
             var v0 = v0$0, d0 = d0$0, param = r;
            else
             var param = l;
           }
          }
          else
           var param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _G_ = 0 === c ? 1 : 0;
          if(_G_) return _G_;
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, v, d];}
          var param$0 = l;
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, [0, v, d]];}
          var param$0 = l;
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, v, d];
          }
          var r = param$0[4], param$0 = r;
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, [0, v, d]];
          }
          var r = param$0[4], param$0 = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function add_to_list(x, data, m){
         function add(param){
          if(! param) return [0, [0, data, 0]];
          var l = param[1];
          return [0, [0, data, l]];
         }
         return update(x, add, m);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          var param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0)),
           m$0 = r,
           accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _D_ = caml_call2(p, v, d);
          if(_D_){
           var _E_ = for_all(p, l);
           if(_E_){var param$0 = r; continue;}
           var _F_ = _E_;
          }
          else
           var _F_ = _D_;
          return _F_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _A_ = caml_call2(p, v, d);
          if(_A_)
           var _B_ = _A_;
          else{
           var _C_ = exists(p, l);
           if(! _C_){var param$0 = r; continue;}
           var _B_ = _C_;
          }
          return _B_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _w_ = merge(f, r1, r2),
            _x_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _x_, _w_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _y_ = merge(f, r1$0, r2$0),
          _z_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _z_, _y_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _u_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _u_];
         }
         var _v_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _v_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0],
           m$0 = l,
           e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var
           e2$1 = cons_enum(r2, e2$0),
           e1$1 = cons_enum(r1, e1$0),
           e1 = e1$1,
           e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _r_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_r_){
           var _s_ = caml_call2(cmp, d1, d2);
           if(_s_){
            var
             e2$1 = cons_enum(r2, e2$0),
             e1$1 = cons_enum(r1, e1$0),
             e1 = e1$1,
             e2 = e2$1;
            continue;
           }
           var _t_ = _s_;
          }
          else
           var _t_ = _r_;
          return _t_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _q_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _q_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)],
           accu$0 = accu$1,
           param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function of_list(bs){
         function _p_(m, param){
          var v = param[2], k = param[1];
          return add(k, v, m);
         }
         return caml_call3(Stdlib_List[26], _p_, empty, bs);
        }
        function add_seq(i, m){
         function _o_(m, param){
          var v = param[2], k = param[1];
          return add(k, v, m);
         }
         return caml_call3(Stdlib_Seq[5], _o_, m, i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0],
           s$0 = r,
           e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         var m$0 = m, c = 0;
         for(;;){
          if(m$0){
           var
            r = m$0[4],
            d = m$0[3],
            v = m$0[2],
            l = m$0[1],
            n = caml_call2(Ord[1], v, low);
           if(0 !== n){
            if(0 <= n){var c$0 = [0, v, d, r, c], m$0 = l, c = c$0; continue;}
            var m$0 = r;
            continue;
           }
           var _e_ = [0, v, d, r, c];
          }
          else
           var _e_ = c;
          return function(_f_){return seq_of_enum(_e_, _f_);};
         }
        }
        return [0,
                empty,
                add,
                add_to_list,
                update,
                singleton,
                remove,
                merge,
                union,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                iter,
                fold,
                map,
                mapi,
                filter,
                filter_map,
                partition,
                split,
                is_empty,
                mem,
                equal,
                compare,
                for_all,
                exists,
                bindings,
                of_list,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(12, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Stack
//# unitInfo: Requires: Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Empty = [248, "Stdlib.Stack.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0];}
   function clear(s){s[1] = 0; s[2] = 0; return 0;}
   function copy(s){return [0, s[1], s[2]];}
   function push(x, s){s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0;}
   function pop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return hd;
   }
   function pop_opt(s){
    var match = s[1];
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd];
   }
   function drop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return 0;
   }
   function top(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var hd = match[1];
    return hd;
   }
   function top_opt(s){
    var match = s[1];
    if(! match) return 0;
    var hd = match[1];
    return [0, hd];
   }
   function is_empty(s){return 0 === s[1] ? 1 : 0;}
   function length(s){return s[2];}
   function iter(f, s){return caml_call2(Stdlib_List[18], f, s[1]);}
   function fold(f, acc, s){return caml_call3(Stdlib_List[26], f, acc, s[1]);}
   function to_seq(s){return caml_call1(Stdlib_List[64], s[1]);}
   function add_seq(q, i){
    function _a_(x){return push(x, q);}
    return caml_call2(Stdlib_Seq[4], _a_, i);
   }
   function of_seq(g){var s = create(0); add_seq(s, g); return s;}
   var
    Stdlib_Stack =
      [0,
       Empty,
       create,
       push,
       pop,
       pop_opt,
       drop,
       top,
       top_opt,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(3, Stdlib_Stack, "Stdlib__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Queue
//# unitInfo: Requires: Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0, 0];}
   function clear(q){q[1] = 0; q[2] = 0; q[3] = 0; return 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    return match
            ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0)
            : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
   }
   function peek(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    return content;
   }
   function peek_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    return [0, content];
   }
   function take(q){
    var _g_ = q[2];
    if(! _g_) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = _g_[1];
    if(_g_[2]){
     var next = _g_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return content;
    }
    clear(q);
    return content;
   }
   function take_opt(q){
    var _f_ = q[2];
    if(! _f_) return 0;
    var content = _f_[1];
    if(_f_[2]){
     var next = _f_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return [0, content];
    }
    clear(q);
    return [0, content];
   }
   function copy(q){
    var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
    for(;;){
     if(! cell){q_res[3] = prev; return q_res;}
     var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
     if(prev) prev[2] = prev$0; else q_res[2] = prev$0;
     var prev = prev$0, cell = next;
    }
   }
   function is_empty(q){return 0 === q[1] ? 1 : 0;}
   function length(q){return q[1];}
   function iter(f, q){
    var cell$0 = q[2], cell = cell$0;
    for(;;){
     if(! cell) return 0;
     var content = cell[1], next = cell[2];
     caml_call1(f, content);
     var cell = next;
    }
   }
   function fold(f, accu$1, q){
    var cell$0 = q[2], accu = accu$1, cell = cell$0;
    for(;;){
     if(! cell) return accu;
     var
      content = cell[1],
      next = cell[2],
      accu$0 = caml_call2(f, accu, content),
      accu = accu$0,
      cell = next;
    }
   }
   function transfer(q1, q2){
    var _e_ = 0 < q1[1] ? 1 : 0;
    if(! _e_) return _e_;
    var match = q2[3];
    return match
            ? (q2
               [1]
              = q2[1] + q1[1] | 0,
              match[2] = q1[2],
              q2[3] = q1[3],
              clear(q1))
            : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
   }
   function to_seq(q){
    function aux(c, param){
     if(! c) return 0;
     var x = c[1], next = c[2];
     return [0, x, function(_d_){return aux(next, _d_);}];
    }
    var _b_ = q[2];
    return function(_c_){return aux(_b_, _c_);};
   }
   function add_seq(q, i){
    function _a_(x){return add(x, q);}
    return caml_call2(Stdlib_Seq[4], _a_, i);
   }
   function of_seq(g){var q = create(0); add_seq(q, g); return q;}
   var
    Stdlib_Queue =
      [0,
       Empty,
       create,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Buffer
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Seq, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_truncate = "Buffer.truncate",
    _a_ = [0, "buffer.ml", 220, 9],
    cst_Buffer_add_channel = "Buffer.add_channel",
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer",
    cst_Buffer_nth = "Buffer.nth",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_sub = "Buffer.sub";
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, [0, s, n$1], 0, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1][1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1][1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1][1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return caml_call5(Stdlib_Bytes[11], src[1][1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    var position = b[2], match = b[1], length = match[2], buffer = match[1];
    if(0 <= ofs && position > ofs && length >= position)
     return runtime.caml_bytes_unsafe_get(buffer, ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    var inner = [0, b[3], caml_ml_bytes_length(b[3])];
    b[1] = inner;
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[1][2], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    caml_call5(Stdlib_Bytes[11], b[1][1], 0, new_buffer, 0, b[2]);
    b[1] = [0, new_buffer, new_len[1]];
    return;
   }
   function add_char(b, c){
    var pos = b[2], match = b[1], length = match[2], buffer = match[1];
    if(length <= pos){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], c);
    }
    else
     caml_bytes_unsafe_set(buffer, pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var uchar_utf_8_byte_length_max = 4, uchar_utf_16_byte_length_max = 4;
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[51], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[54], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[57], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var _r_ = offset < 0 ? 1 : 0;
    if(_r_)
     var _s_ = _r_;
    else
     var
      _t_ = len < 0 ? 1 : 0,
      _s_ = _t_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_s_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, offset, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, offset, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[44], s), offset, len);
   }
   function add_string(b, s){
    var
     len = caml_ml_string_length(s),
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, 0, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, 0, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[44], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1][1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _p_ = to_read$1 < 0 ? 1 : 0,
     _q_ = _p_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_q_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[1][2] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1][1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0,
        already_read = already_read$0,
        ofs = ofs$0,
        to_read = to_read$0;
       continue;
      }
     }
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1][1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _o_ = 92 === previous ? 1 : 0;
      return _o_ ? add_char(b, previous) : _o_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0, previous = 32, i$4 = i$5;
      }
      else{
       var start$0 = i$4 + 1 | 0;
       if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var opening = caml_string_get(s, start$0);
       a:
       {
        if(40 !== opening && 123 !== opening){
         var start = start$0 + 1 | 0, lim$0 = caml_ml_string_length(s);
         b:
         {
          c:
          {
           d:
           {
            var i$2 = start;
            for(;;){
             if(lim$0 <= i$2) break c;
             var match = caml_string_get(s, i$2);
             if(91 <= match){
              if(97 <= match){
               if(123 <= match) break d;
              }
              else if(95 !== match) break d;
             }
             else
              if(58 <= match){
               if(65 > match) break;
              }
              else if(48 > match) break d;
             var i$3 = i$2 + 1 | 0, i$2 = i$3;
            }
           }
           var stop$0 = i$2;
           break b;
          }
          var stop$0 = lim$0;
         }
         var
          match$0 =
            [0,
             caml_call3(Stdlib_String[16], s, start$0, stop$0 - start$0 | 0),
             stop$0];
         break a;
        }
        var new_start = start$0 + 1 | 0, k$2 = 0;
        if(40 === opening)
         var closing = 41;
        else{
         if(123 !== opening)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         var closing = 125;
        }
        var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
        for(;;){
         if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         if(caml_string_get(s, stop) === opening)
          var i = stop + 1 | 0, k$0 = k + 1 | 0, k = k$0, stop = i;
         else if(caml_string_get(s, stop) === closing){
          if(0 === k) break;
          var i$0 = stop + 1 | 0, k$1 = k - 1 | 0, k = k$1, stop = i$0;
         }
         else
          var i$1 = stop + 1 | 0, stop = i$1;
        }
        var
         match$0 =
           [0,
            caml_call3
             (Stdlib_String[16], s, new_start, (stop - start$0 | 0) - 1 | 0),
            stop + 1 | 0];
       }
       var next_i = match$0[2], ident = match$0[1];
       add_string(b, caml_call1(f, ident));
       var previous = 32, i$4 = next_i;
      }
     else if(92 === previous){
      add_char(b, 92);
      add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0, previous = 32, i$4 = i$6;
     }
     else if(92 === previous$0)
      var i$7 = i$4 + 1 | 0, previous = previous$0, i$4 = i$7;
     else{
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0, previous = previous$0, i$4 = i$8;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _m_ = i + 1 | 0;
     return [0, x, function(_n_){return aux(_m_, _n_);}];
    }
    var _k_ = 0;
    return function(_l_){return aux(_k_, _l_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _i_ = i + 1 | 0;
     return [0, [0, i, x], function(_j_){return aux(_i_, _j_);}];
    }
    var _g_ = 0;
    return function(_h_){return aux(_g_, _h_);};
   }
   function add_seq(b, seq){
    function _e_(_f_){return add_char(b, _f_);}
    return caml_call2(Stdlib_Seq[4], _e_, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 1 | 0;
    if(length < new_position){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], x);
    }
    else
     caml_bytes_unsafe_set(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 2 | 0;
    if(length < new_position){
     resize(b, 2);
     caml_bytes_set16(b[1][1], b[2], x);
    }
    else
     caml_bytes_set16(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 4 | 0;
    if(length < new_position){
     resize(b, 4);
     caml_bytes_set32(b[1][1], b[2], x);
    }
    else
     caml_bytes_set32(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 8 | 0;
    if(length < new_position){
     resize(b, 8);
     caml_bytes_set64(b[1][1], b[2], x);
    }
    else
     caml_bytes_set64(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _d_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _d_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _c_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _c_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _b_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _b_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(14, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Mutex
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_mutex_lock = runtime.caml_ml_mutex_lock,
    caml_ml_mutex_unlock = runtime.caml_ml_mutex_unlock,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function protect(m, f){
    caml_ml_mutex_lock(m);
    try{var x = caml_call1(f, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_ml_mutex_unlock(m);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_ml_mutex_unlock(m);
    return x;
   }
   var
    Stdlib_Mutex =
      [0,
       runtime.caml_ml_mutex_new,
       caml_ml_mutex_lock,
       runtime.caml_ml_mutex_try_lock,
       caml_ml_mutex_unlock,
       protect];
   runtime.caml_register_global(0, Stdlib_Mutex, "Stdlib__Mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Condition
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Stdlib_Condition =
      [0,
       runtime.caml_ml_condition_new,
       runtime.caml_ml_condition_wait,
       runtime.caml_ml_condition_signal,
       runtime.caml_ml_condition_broadcast];
   runtime.caml_register_global(0, Stdlib_Condition, "Stdlib__Condition");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Semaphore
//# unitInfo: Requires: Stdlib, Stdlib__Condition, Stdlib__Mutex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib = global_data.Stdlib,
    cst_Semaphore_Counting_release = "Semaphore.Counting.release: overflow",
    cst_Semaphore_Counting_init_wr =
      "Semaphore.Counting.init: wrong initial value";
   function make(v){
    if(v < 0) caml_call1(Stdlib[1], cst_Semaphore_Counting_init_wr);
    var _c_ = caml_call1(Stdlib_Condition[1], 0);
    return [0, caml_call1(Stdlib_Mutex[1], 0), v, _c_];
   }
   function release(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    if(s[2] < Stdlib[19]){
     s[2] = s[2] + 1 | 0;
     caml_call1(Stdlib_Condition[3], s[3]);
     return caml_call1(Stdlib_Mutex[4], s[1]);
    }
    caml_call1(Stdlib_Mutex[4], s[1]);
    throw caml_maybe_attach_backtrace
           ([0, Stdlib[11], cst_Semaphore_Counting_release], 1);
   }
   function acquire(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    for(;;){
     if(0 !== s[2]){
      s[2] = s[2] - 1 | 0;
      return caml_call1(Stdlib_Mutex[4], s[1]);
     }
     caml_call2(Stdlib_Condition[2], s[3], s[1]);
    }
   }
   function try_acquire(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    var ret = 0 === s[2] ? 0 : (s[2] = s[2] - 1 | 0, 1);
    caml_call1(Stdlib_Mutex[4], s[1]);
    return ret;
   }
   function get_value(s){return s[2];}
   var Counting = [0, make, release, acquire, try_acquire, get_value];
   function make$0(b){
    var _a_ = caml_call1(Stdlib_Condition[1], 0), _b_ = b ? 1 : 0;
    return [0, caml_call1(Stdlib_Mutex[1], 0), _b_, _a_];
   }
   function release$0(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    s[2] = 1;
    caml_call1(Stdlib_Condition[3], s[3]);
    return caml_call1(Stdlib_Mutex[4], s[1]);
   }
   function acquire$0(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    for(;;){
     if(0 !== s[2]){s[2] = 0; return caml_call1(Stdlib_Mutex[4], s[1]);}
     caml_call2(Stdlib_Condition[2], s[3], s[1]);
    }
   }
   function try_acquire$0(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    var ret = 0 === s[2] ? 0 : (s[2] = 0, 1);
    caml_call1(Stdlib_Mutex[4], s[1]);
    return ret;
   }
   var
    Binary = [0, make$0, release$0, acquire$0, try_acquire$0],
    Stdlib_Semaphore = [0, Counting, Binary];
   runtime.caml_register_global(5, Stdlib_Semaphore, "Stdlib__Semaphore");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Domain
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Atomic, Stdlib__Condition, Stdlib__List, Stdlib__Mutex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_domain_dls_set = runtime.caml_domain_dls_set,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_domain_id = runtime.caml_ml_domain_id,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_internal_error_Am_I_alread = "internal error: Am I already finished?",
    cst_first_domain_already_spawn = "first domain already spawned";
   function cpu_relax(param){return runtime.caml_ml_domain_cpu_relax(0);}
   var unique_value = [0, 0];
   function create_dls(param){
    var st = caml_make_vect(8, unique_value);
    caml_domain_dls_set(st);
    return;
   }
   create_dls(0);
   var
    key_counter = caml_call1(Stdlib_Atomic[1], 0),
    parent_keys = caml_call1(Stdlib_Atomic[1], 0);
   function new_key(split_from_parent, init_orphan){
    var
     idx = caml_call2(Stdlib_Atomic[6], key_counter, 1),
     k = [0, idx, init_orphan];
    if(split_from_parent){
     var split = split_from_parent[1], ki = [0, k, split];
     for(;;){
      var l = caml_call1(Stdlib_Atomic[2], parent_keys);
      if(! (1 - caml_call3(Stdlib_Atomic[5], parent_keys, l, [0, ki, l])))
       break;
     }
    }
    return k;
   }
   function maybe_grow(idx){
    var st = runtime.caml_domain_dls_get(0), sz = st.length - 1;
    if(idx < sz) return st;
    var new_sz = sz;
    for(;;){
     if(idx < new_sz){
      var new_st = caml_make_vect(new_sz, unique_value);
      caml_call5(Stdlib_Array[8], st, 0, new_st, 0, sz);
      caml_domain_dls_set(new_st);
      return new_st;
     }
     var s = 2 * new_sz | 0, new_sz = s;
    }
   }
   function set(param, x){
    var idx = param[1], st = maybe_grow(idx);
    caml_check_bound(st, idx)[1 + idx] = x;
    return 0;
   }
   function get(param){
    var
     init = param[2],
     idx = param[1],
     st = maybe_grow(idx),
     v = caml_check_bound(st, idx)[1 + idx];
    if(v !== unique_value) return v;
    var v$0 = caml_call1(init, 0);
    caml_check_bound(st, idx)[1 + idx] = v$0;
    return v$0;
   }
   function get_id(param){var domain = param[1]; return domain;}
   function self(param){return caml_ml_domain_id(0);}
   function is_main_domain(param){return 0 === caml_ml_domain_id(0) ? 1 : 0;}
   var
    first_domain_spawned = caml_call1(Stdlib_Atomic[1], 0),
    first_spawn_function = [0, function(param){return;}];
   function before_first_spawn(f){
    if(caml_call1(Stdlib_Atomic[2], first_domain_spawned))
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_first_domain_already_spawn], 1);
    var old_f = first_spawn_function[1];
    function new_f(param){caml_call1(old_f, 0); return caml_call1(f, 0);}
    first_spawn_function[1] = new_f;
    return 0;
   }
   var at_exit_key = new_key(0, function(param, _e_){return 0;});
   function at_exit(f){
    var old_exit = get(at_exit_key);
    function new_exit(param){
     caml_call1(f, 0);
     return caml_call1(old_exit, 0);
    }
    return set(at_exit_key, new_exit);
   }
   function do_at_exit(param){
    var f = get(at_exit_key);
    return caml_call1(f, 0);
   }
   Stdlib[104][1] = do_at_exit;
   function spawn(f){
    if(1 - caml_call1(Stdlib_Atomic[2], first_domain_spawned)){
     caml_call2(Stdlib_Atomic[3], first_domain_spawned, 1);
     caml_call1(first_spawn_function[1], 0);
     first_spawn_function[1] = function(param){return 0;};
    }
    var _a_ = caml_call1(Stdlib_Atomic[2], parent_keys);
    function _b_(param){
     var split = param[2], k = param[1], idx = k[1];
     return [0, idx, caml_call1(split, get(k))];
    }
    var
     pk = caml_call2(Stdlib_List[20], _b_, _a_),
     term_mutex = caml_call1(Stdlib_Mutex[1], 0),
     term_condition = caml_call1(Stdlib_Condition[1], 0),
     term_state = [0, 0];
    function body(param){
     a:
     {
      try{
       create_dls(0);
       var
        _c_ =
          function(param){
           var v = param[2], idx = param[1], st = maybe_grow(idx);
           caml_check_bound(st, idx)[1 + idx] = v;
           return 0;
          };
       caml_call2(Stdlib_List[18], _c_, pk);
       var res = caml_call1(f, 0);
      }
      catch(ex$0){
       var ex = caml_wrap_exception(ex$0), result = [1, ex];
       break a;
      }
      var result = [0, res];
     }
     try{do_at_exit(0); var result$0 = result;}
     catch(ex){
      var
       ex$0 = caml_wrap_exception(ex),
       _d_ = 0 === result[0] ? [1, ex$0] : result,
       result$0 = _d_;
     }
     caml_call1(Stdlib_Mutex[2], term_mutex);
     return term_state[1]
             ? caml_call1(Stdlib[2], cst_internal_error_Am_I_alread)
             : (term_state
                [1]
               = [0, result$0],
               caml_call1(Stdlib_Condition[4], term_condition));
    }
    return [0,
            runtime.caml_domain_spawn(body, term_mutex),
            term_mutex,
            term_condition,
            term_state];
   }
   function join(param){
    var
     term_state = param[4],
     term_condition = param[3],
     term_mutex = param[2];
    caml_call1(Stdlib_Mutex[2], term_mutex);
    for(;;){
     var match = term_state[1];
     if(match){
      var res = match[1];
      caml_call1(Stdlib_Mutex[4], term_mutex);
      if(0 === res[0]){var x = res[1]; return x;}
      var ex = res[1];
      throw caml_maybe_attach_backtrace(ex, 1);
     }
     caml_call2(Stdlib_Condition[2], term_condition, term_mutex);
    }
   }
   var
    recommended_domain_count = runtime.caml_recommended_domain_count,
    Stdlib_Domain =
      [0,
       spawn,
       join,
       get_id,
       self,
       before_first_spawn,
       at_exit,
       cpu_relax,
       is_main_domain,
       recommended_domain_count,
       [0, new_key, get, set]];
   runtime.caml_register_global(8, Stdlib_Domain, "Stdlib__Domain");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalFormat
//# unitInfo: Requires: CamlinternalFormatBasics, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Int, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_0 = cst_0$3,
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_0$2 = "'0'",
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    cst_digit = "digit",
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    cst_unexpected_end_of_format = "unexpected end of format",
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _x_ = [0, 0, 4],
    cst_nan = "nan",
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    _r_ = [0, 103],
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nd = "%nd",
    cst_ni$0 = cst_ni$3,
    cst_nu = "%nu",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_ld = "%ld",
    cst_li$0 = cst_li$3,
    cst_lu = "%lu",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Ld = "%Ld",
    cst_Li$0 = cst_Li$3,
    cst_Lu = "%Lu",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_d = "%d",
    cst_i$0 = cst_i$3,
    cst_u = cst_u$0,
    cst_0c = "0c",
    _a_ = [0, 0, 0],
    cst_CamlinternalFormat_Type_mi = "CamlinternalFormat.Type_mismatch";
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _dS_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _dS_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _dQ_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _dQ_));
     var _dR_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[44], char_set$0);
     var i = _dR_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _dP_ = [0, ndec];
       else
        var _dP_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _dP_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
    return;
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[6], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    if(prec) return buffer_add_string(buf, cst);
    return;
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
    return;
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _dO_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _dO_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _dM_ = caml_ml_string_length(str) - 1 | 0, _dL_ = 0;
    if(_dM_ >= 0){
     var i = _dL_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _dN_ = i + 1 | 0;
      if(_dM_ === i) break;
      var i = _dN_;
     }
    }
    return;
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        var fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        var fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        var fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        var fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        var fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        var fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        var fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        var fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        var fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        var fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        var fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        var fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        var fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        var fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        var fmtty$0 = fmtty$15;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     for(;;){
      if(typeof fmt$0 === "number") return;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         var fmt$0 = rest, ign_flag$0 = 0;
         break;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         var fmt$0 = rest$0, ign_flag$0 = 0;
         break;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         var fmt$0 = rest$1, ign_flag$0 = 0;
         break;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         var fmt$0 = rest$2, ign_flag$0 = 0;
         break;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         var fmt$0 = rest$3, ign_flag$0 = 0;
         break;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         var fmt$0 = rest$4, ign_flag$0 = 0;
         break;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         var fmt$0 = rest$5, ign_flag$0 = 0;
         break;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         var fmt$0 = rest$6, ign_flag$0 = 0;
         break;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         var fmt$0 = rest$7, ign_flag$0 = 0;
         break;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         var fmt$0 = rest$8, ign_flag$0 = 0;
         break;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         var fmt$0 = rest$9;
         break;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         var fmt$0 = rest$10;
         break;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         var fmt$0 = rest$11;
         break;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         var fmt$0 = rest$12, ign_flag$0 = 0;
         break;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         var fmt$0 = rest$13, ign_flag$0 = 0;
         break;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         var fmt$0 = rest$14, ign_flag$0 = 0;
         break;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         var fmt$0 = rest$15, ign_flag$0 = 0;
         break;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         var fmt$0 = rest$16;
         break;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         var fmt$0 = rest$17;
         break;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         var fmt$0 = rest$18, ign_flag$0 = 0;
         break;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set,
          is_alone$0 =
            function(set){
             function is_alone(c){
              var
               after = caml_call1(Stdlib_Char[1], c + 1 | 0),
               before = caml_call1(Stdlib_Char[1], c - 1 | 0),
               _dH_ = is_in_char_set(set, c);
              if(_dH_)
               var
                _dI_ = is_in_char_set(set, before),
                _dJ_ = _dI_ ? is_in_char_set(set, after) : _dI_,
                _dK_ = 1 - _dJ_;
              else
               var _dK_ = _dH_;
              return _dK_;
             }
             return is_alone;
            },
          is_alone = is_alone$0(set);
         if(is_alone(93)) buffer_add_char(buf, 93);
         a:
         b:
         {
          c:
          {
           d:
           {
            var i = 1;
            for(;;){
             if(i >= 256) break;
             if(is_in_char_set(set, caml_call1(Stdlib[29], i))){
              var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
              if(48 < switcher >>> 0){
               if(210 <= switcher) break d;
              }
              else if(46 < switcher - 1 >>> 0){
               var i$2 = i + 1 | 0, i = i$2;
               continue;
              }
              var i$1 = i + 1 | 0;
              if(is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
               var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
               if(48 < switcher$0 >>> 0){
                if(210 <= switcher$0) break c;
               }
               else if
                (46 < switcher$0 - 1 >>> 0
                 && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                print_char(buf, i$1 - 1 | 0);
                var i$5 = i$1 + 1 | 0, i = i$5;
                continue;
               }
               if(is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                for(;;){
                 if(256 === j$0) break;
                 if(! is_in_char_set(set, caml_call1(Stdlib[29], j$0))) break;
                 var j$1 = j$0 + 1 | 0, j$0 = j$1;
                }
                print_char(buf, i$3);
                print_char(buf, 45);
                print_char(buf, j$0 - 1 | 0);
                if(j$0 >= 256) break b;
                var i$7 = j$0 + 1 | 0, i = i$7;
               }
               else{
                print_char(buf, i$1 - 1 | 0);
                print_char(buf, i$1);
                var i$4 = i$1 + 2 | 0, i = i$4;
               }
              }
              else{
               print_char(buf, i$1 - 1 | 0);
               var i$6 = i$1 + 1 | 0, i = i$6;
              }
             }
             else
              var i$0 = i + 1 | 0, i = i$0;
            }
            break a;
           }
           print_char(buf, 255);
           break a;
          }
          print_char(buf, 254);
          print_char(buf, 255);
          break a;
         }
         if(is_alone(45)) buffer_add_char(buf, 45);
         buffer_add_char(buf, 93);
         var fmt$0 = rest$19, ign_flag$0 = 0;
         break;
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _dD_ = 108; break;
           case 1:
            var _dD_ = 110; break;
           default: var _dD_ = 78;
         }
         buffer_add_char(buf, _dD_);
         var fmt$0 = rest$20, ign_flag$0 = 0;
         break;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         var fmt$0 = rest$21, ign_flag$0 = 0;
         break;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1],
          fmt$0 = fmt$1,
          ign_flag$0 = 1;
         break;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _dF_ = int_of_custom_arity(arity),
          _dE_ = 1;
         if(_dF_ >= 1){
          var i$8 = _dE_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _dG_ = i$8 + 1 | 0;
           if(_dF_ === i$8) break;
           var i$8 = _dG_;
          }
         }
         var fmt$0 = rest$23, ign_flag$0 = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param !== "number")
     switch(param[0]){
       case 0:
        var
         rest = param[1],
         match = fmtty_rel_det(rest),
         de = match[4],
         ed = match[3],
         af = match[2],
         fa = match[1],
         _di_ = function(param){af(0); return;};
        return [0, function(param){fa(0); return;}, _di_, ed, de];
       case 1:
        var
         rest$0 = param[1],
         match$0 = fmtty_rel_det(rest$0),
         de$0 = match$0[4],
         ed$0 = match$0[3],
         af$0 = match$0[2],
         fa$0 = match$0[1],
         _dj_ = function(param){af$0(0); return;};
        return [0, function(param){fa$0(0); return;}, _dj_, ed$0, de$0];
       case 2:
        var
         rest$1 = param[1],
         match$1 = fmtty_rel_det(rest$1),
         de$1 = match$1[4],
         ed$1 = match$1[3],
         af$1 = match$1[2],
         fa$1 = match$1[1],
         _dk_ = function(param){af$1(0); return;};
        return [0, function(param){fa$1(0); return;}, _dk_, ed$1, de$1];
       case 3:
        var
         rest$2 = param[1],
         match$2 = fmtty_rel_det(rest$2),
         de$2 = match$2[4],
         ed$2 = match$2[3],
         af$2 = match$2[2],
         fa$2 = match$2[1],
         _dl_ = function(param){af$2(0); return;};
        return [0, function(param){fa$2(0); return;}, _dl_, ed$2, de$2];
       case 4:
        var
         rest$3 = param[1],
         match$3 = fmtty_rel_det(rest$3),
         de$3 = match$3[4],
         ed$3 = match$3[3],
         af$3 = match$3[2],
         fa$3 = match$3[1],
         _dm_ = function(param){af$3(0); return;};
        return [0, function(param){fa$3(0); return;}, _dm_, ed$3, de$3];
       case 5:
        var
         rest$4 = param[1],
         match$4 = fmtty_rel_det(rest$4),
         de$4 = match$4[4],
         ed$4 = match$4[3],
         af$4 = match$4[2],
         fa$4 = match$4[1],
         _dn_ = function(param){af$4(0); return;};
        return [0, function(param){fa$4(0); return;}, _dn_, ed$4, de$4];
       case 6:
        var
         rest$5 = param[1],
         match$5 = fmtty_rel_det(rest$5),
         de$5 = match$5[4],
         ed$5 = match$5[3],
         af$5 = match$5[2],
         fa$5 = match$5[1],
         _do_ = function(param){af$5(0); return;};
        return [0, function(param){fa$5(0); return;}, _do_, ed$5, de$5];
       case 7:
        var
         rest$6 = param[1],
         match$6 = fmtty_rel_det(rest$6),
         de$6 = match$6[4],
         ed$6 = match$6[3],
         af$6 = match$6[2],
         fa$6 = match$6[1],
         _dp_ = function(param){af$6(0); return;};
        return [0, function(param){fa$6(0); return;}, _dp_, ed$6, de$6];
       case 8:
        var
         rest$7 = param[2],
         match$7 = fmtty_rel_det(rest$7),
         de$7 = match$7[4],
         ed$7 = match$7[3],
         af$7 = match$7[2],
         fa$7 = match$7[1],
         _dq_ = function(param){af$7(0); return;};
        return [0, function(param){fa$7(0); return;}, _dq_, ed$7, de$7];
       case 9:
        var
         rest$8 = param[3],
         ty2 = param[2],
         ty1 = param[1],
         match$8 = fmtty_rel_det(rest$8),
         de$8 = match$8[4],
         ed$8 = match$8[3],
         af$8 = match$8[2],
         fa$8 = match$8[1],
         ty = trans(symm(ty1), ty2),
         match$9 = fmtty_rel_det(ty),
         jd = match$9[4],
         dj = match$9[3],
         ga = match$9[2],
         ag = match$9[1],
         _dr_ = function(param){jd(0); de$8(0); return;},
         _ds_ = function(param){ed$8(0); dj(0); return;},
         _dt_ = function(param){ga(0); af$8(0); return;};
        return [0, function(param){fa$8(0); ag(0); return;}, _dt_, _ds_, _dr_];
       case 10:
        var
         rest$9 = param[1],
         match$10 = fmtty_rel_det(rest$9),
         de$9 = match$10[4],
         ed$9 = match$10[3],
         af$9 = match$10[2],
         fa$9 = match$10[1],
         _du_ = function(param){af$9(0); return;};
        return [0, function(param){fa$9(0); return;}, _du_, ed$9, de$9];
       case 11:
        var
         rest$10 = param[1],
         match$11 = fmtty_rel_det(rest$10),
         de$10 = match$11[4],
         ed$10 = match$11[3],
         af$10 = match$11[2],
         fa$10 = match$11[1],
         _dv_ = function(param){af$10(0); return;};
        return [0, function(param){fa$10(0); return;}, _dv_, ed$10, de$10];
       case 12:
        var
         rest$11 = param[1],
         match$12 = fmtty_rel_det(rest$11),
         de$11 = match$12[4],
         ed$11 = match$12[3],
         af$11 = match$12[2],
         fa$11 = match$12[1],
         _dw_ = function(param){af$11(0); return;};
        return [0, function(param){fa$11(0); return;}, _dw_, ed$11, de$11];
       case 13:
        var
         rest$12 = param[1],
         match$13 = fmtty_rel_det(rest$12),
         de$12 = match$13[4],
         ed$12 = match$13[3],
         af$12 = match$13[2],
         fa$12 = match$13[1],
         _dx_ = function(param){de$12(0); return;},
         _dy_ = function(param){ed$12(0); return;},
         _dz_ = function(param){af$12(0); return;};
        return [0, function(param){fa$12(0); return;}, _dz_, _dy_, _dx_];
       default:
        var
         rest$13 = param[1],
         match$14 = fmtty_rel_det(rest$13),
         de$13 = match$14[4],
         ed$13 = match$14[3],
         af$13 = match$14[2],
         fa$13 = match$14[1],
         _dA_ = function(param){de$13(0); return;},
         _dB_ = function(param){ed$13(0); return;},
         _dC_ = function(param){af$13(0); return;};
        return [0, function(param){fa$13(0); return;}, _dC_, _dB_, _dA_];
     }
    function _df_(param){return;}
    function _dg_(param){return;}
    function _dh_(param){return;}
    return [0, function(param){return;}, _dh_, _dg_, _df_];
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _de_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _de_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1], fmtty$0 = fmtty$1; break;
       case 11:
        var fmtty$2 = fmtty$0[2], fmtty$0 = fmtty$2; break;
       case 12:
        var fmtty$3 = fmtty$0[2], fmtty$0 = fmtty$3; break;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2], fmtty$0 = fmtty$4; break;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _db_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _dc_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _dc_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _dc_, _db_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            var fmtty$0 = fmtty$5; break;
           case 1:
            var fmtty$0 = fmtty$5; break;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: var fmtty$0 = fmtty$5;
         }
        else
         switch(ign[0]){
           case 0:
            var fmtty$0 = fmtty$5; break;
           case 1:
            var fmtty$0 = fmtty$5; break;
           case 2:
            var fmtty$0 = fmtty$5; break;
           case 3:
            var fmtty$0 = fmtty$5; break;
           case 4:
            var fmtty$0 = fmtty$5; break;
           case 5:
            var fmtty$0 = fmtty$5; break;
           case 6:
            var fmtty$0 = fmtty$5; break;
           case 7:
            var fmtty$0 = fmtty$5; break;
           case 8:
            var fmtty$0 = fmtty$5; break;
           case 9:
            var fmtty$6 = ign[2], _dd_ = fmtty_of_fmt(fmtty$5);
            return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _dd_);
           case 10:
            var fmtty$0 = fmtty$5; break;
           default: var fmtty$0 = fmtty$5;
         }
        break;
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, cst_CamlinternalFormat_Type_mi, runtime.caml_fresh_oo_id(0)];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _da_ = type_format_gen(fmt, fmtty);
    if(typeof _da_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _da_[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _c__ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _c__))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _c$_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _c$_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _c$_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _c8_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _c8_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _c9_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _c9_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _c7_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _c7_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _c6_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _c6_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[6], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        caml_call5
         (Stdlib_String[6],
          str,
          1,
          res,
          (width$0 - len | 0) + 1 | 0,
          len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        caml_call5
         (Stdlib_String[6],
          str,
          2,
          res,
          (width$0 - len | 0) + 2 | 0,
          len - 2 | 0);
        break;
       }
       caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
    }
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            caml_call5
             (Stdlib_String[6],
              str,
              2,
              res$1,
              (prec$0 - len | 0) + 4 | 0,
              len - 2 | 0);
            return caml_call1(Stdlib_Bytes[44], res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       caml_call5
        (Stdlib_String[6],
         str,
         1,
         res$0,
         (prec$0 - len | 0) + 2 | 0,
         len - 1 | 0);
       return caml_call1(Stdlib_Bytes[44], res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
      caml_call5(Stdlib_String[6], str, 0, res, prec$0 - len | 0, len);
      return caml_call1(Stdlib_Bytes[44], res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[25], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _c1_ = caml_ml_string_length(s) - 1 | 0, _c0_ = 0;
    if(_c1_ >= 0){
     var i$0 = _c0_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _c5_ = i$0 + 1 | 0;
      if(_c1_ === i$0) break;
      var i$0 = _c5_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++; return;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _c3_ = caml_ml_string_length(s) - 1 | 0,
     _c2_ = 0;
    if(_c3_ >= 0){
     var i = _c2_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1] += -1; put(c);}
      var _c4_ = i + 1 | 0;
      if(_c3_ === i) break;
      var i = _c4_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cZ_ = cst_d$0; break;
      case 2:
       var _cZ_ = cst_d$1; break;
      case 4:
       var _cZ_ = cst_i$1; break;
      case 5:
       var _cZ_ = cst_i$2; break;
      case 6:
       var _cZ_ = cst_x; break;
      case 7:
       var _cZ_ = cst_x$0; break;
      case 8:
       var _cZ_ = cst_X; break;
      case 9:
       var _cZ_ = cst_X$0; break;
      case 10:
       var _cZ_ = cst_o; break;
      case 11:
       var _cZ_ = cst_o$0; break;
      case 0:
      case 13:
       var _cZ_ = cst_d; break;
      case 3:
      case 14:
       var _cZ_ = cst_i$0; break;
      default: var _cZ_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cZ_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cY_ = cst_ld$0; break;
      case 2:
       var _cY_ = cst_ld$1; break;
      case 4:
       var _cY_ = cst_li$1; break;
      case 5:
       var _cY_ = cst_li$2; break;
      case 6:
       var _cY_ = cst_lx; break;
      case 7:
       var _cY_ = cst_lx$0; break;
      case 8:
       var _cY_ = cst_lX; break;
      case 9:
       var _cY_ = cst_lX$0; break;
      case 10:
       var _cY_ = cst_lo; break;
      case 11:
       var _cY_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cY_ = cst_ld; break;
      case 3:
      case 14:
       var _cY_ = cst_li$0; break;
      default: var _cY_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cY_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cX_ = cst_nd$0; break;
      case 2:
       var _cX_ = cst_nd$1; break;
      case 4:
       var _cX_ = cst_ni$1; break;
      case 5:
       var _cX_ = cst_ni$2; break;
      case 6:
       var _cX_ = cst_nx; break;
      case 7:
       var _cX_ = cst_nx$0; break;
      case 8:
       var _cX_ = cst_nX; break;
      case 9:
       var _cX_ = cst_nX$0; break;
      case 10:
       var _cX_ = cst_no; break;
      case 11:
       var _cX_ = cst_no$0; break;
      case 0:
      case 13:
       var _cX_ = cst_nd; break;
      case 3:
      case 14:
       var _cX_ = cst_ni$0; break;
      default: var _cX_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cX_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _cW_ = cst_Ld$0; break;
      case 2:
       var _cW_ = cst_Ld$1; break;
      case 4:
       var _cW_ = cst_Li$1; break;
      case 5:
       var _cW_ = cst_Li$2; break;
      case 6:
       var _cW_ = cst_Lx; break;
      case 7:
       var _cW_ = cst_Lx$0; break;
      case 8:
       var _cW_ = cst_LX; break;
      case 9:
       var _cW_ = cst_LX$0; break;
      case 10:
       var _cW_ = cst_Lo; break;
      case 11:
       var _cW_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _cW_ = cst_Ld; break;
      case 3:
      case 14:
       var _cW_ = cst_Li$0; break;
      default: var _cW_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_cW_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _cT_ = 0;
        else{
         var _cS_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _cS_ >>> 0){
           if(55 === _cS_) break a;
          }
          else if(21 < _cS_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0, i = i$0;
          continue;
         }
         var _cT_ = 1;
        }
        var _cU_ = _cT_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_cU_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cV_ = hex(0); return caml_call1(Stdlib_String[26], _cV_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[44], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var
         rest$9 = fmt$0[1],
         acc$1 = [7, acc$0],
         acc$0 = acc$1,
         fmt$0 = rest$9;
        break;
       case 11:
        var
         rest$10 = fmt$0[2],
         str = fmt$0[1],
         acc$2 = [2, acc$0, str],
         acc$0 = acc$2,
         fmt$0 = rest$10;
        break;
       case 12:
        var
         rest$11 = fmt$0[2],
         chr = fmt$0[1],
         acc$3 = [3, acc$0, chr],
         acc$0 = acc$3,
         fmt$0 = rest$11;
        break;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cR_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cR_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit],
         acc$0 = acc$4,
         fmt$0 = rest$16;
        break;
       case 18:
        var _cP_ = fmt$0[1];
        if(0 === _cP_[0])
         var
          rest$17 = fmt$0[2],
          fmt$1 = _cP_[1][1],
          k$3 =
            function(acc, k, rest){
             function k$0(kacc){
              return make_printf(k, [1, acc, [0, kacc]], rest);
             }
             return k$0;
            },
          k$1 = k$3(acc$0, k$0, rest$17),
          k$0 = k$1,
          acc$0 = 0,
          fmt$0 = fmt$1;
        else
         var
          rest$18 = fmt$0[2],
          fmt$2 = _cP_[1][1],
          k$4 =
            function(acc, k, rest){
             function k$0(kacc){
              return make_printf(k, [1, acc, [1, kacc]], rest);
             }
             return k$0;
            },
          k$2 = k$4(acc$0, k$0, rest$18),
          k$0 = k$2,
          acc$0 = 0,
          fmt$0 = fmt$2;
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$0 = counter + 1 | 0;
        return make_ignored_param$0(counter$0, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _cQ_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _cQ_]);
        var counter$1 = counter + 1 | 0;
        return make_custom$0(counter$1, k$0, acc$0, rest$23, arity, _cQ_);
     }
    }
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$3 = counter + 1 | 0;
        return make_invalid_arg(counter$3, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$0 = counter + 1 | 0;
       return make_from_fmtty$0(counter$0, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_invalid_arg(counter$14, k, acc, fmt);
    }
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, _cO_){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cN_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cN_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cN_, fmt);
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _cM_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cM_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cM_, rest);
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], _b2_ = make_iprintf(k$0, o, rest);
        return function(_cL_){return _b2_;};
       case 1:
        var rest$0 = fmt$0[1], _b3_ = make_iprintf(k$0, o, rest$0);
        return function(_cK_){return _b3_;};
       case 2:
        var _b4_ = fmt$0[1];
        if(typeof _b4_ === "number"){
         var rest$1 = fmt$0[2], _b5_ = make_iprintf(k$0, o, rest$1);
         return function(_cJ_){return _b5_;};
        }
        if(0 === _b4_[0]){
         var rest$2 = fmt$0[2], _b6_ = make_iprintf(k$0, o, rest$2);
         return function(_cI_){return _b6_;};
        }
        var
         rest$3 = fmt$0[2],
         _b7_ = make_iprintf(k$0, o, rest$3),
         _b8_ = function(_cH_){return _b7_;};
        return function(_cG_){return _b8_;};
       case 3:
        var _b9_ = fmt$0[1];
        if(typeof _b9_ === "number"){
         var rest$4 = fmt$0[2], _b__ = make_iprintf(k$0, o, rest$4);
         return function(_cF_){return _b__;};
        }
        if(0 === _b9_[0]){
         var rest$5 = fmt$0[2], _b$_ = make_iprintf(k$0, o, rest$5);
         return function(_cE_){return _b$_;};
        }
        var
         rest$6 = fmt$0[2],
         _ca_ = make_iprintf(k$0, o, rest$6),
         _cb_ = function(_cD_){return _ca_;};
        return function(_cC_){return _cb_;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _cc_ = fmt$0[1];
        if(typeof _cc_ === "number"){
         var rest$12 = fmt$0[2], _cd_ = make_iprintf(k$0, o, rest$12);
         return function(_cB_){return _cd_;};
        }
        if(0 === _cc_[0]){
         var rest$13 = fmt$0[2], _ce_ = make_iprintf(k$0, o, rest$13);
         return function(_cA_){return _ce_;};
        }
        var
         rest$14 = fmt$0[2],
         _cf_ = make_iprintf(k$0, o, rest$14),
         _cg_ = function(_cz_){return _cf_;};
        return function(_cy_){return _cg_;};
       case 10:
        var rest$15 = fmt$0[1], fmt$0 = rest$15; break;
       case 11:
        var rest$16 = fmt$0[2], fmt$0 = rest$16; break;
       case 12:
        var rest$17 = fmt$0[2], fmt$0 = rest$17; break;
       case 13:
        var rest$18 = fmt$0[3], _ch_ = make_iprintf(k$0, o, rest$18);
        return function(_cx_){return _ch_;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cw_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _cw_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         _ci_ = make_iprintf(k$0, o, rest$20),
         _cj_ = function(_cv_){return _ci_;};
        return function(_cu_){return _cj_;};
       case 16:
        var rest$21 = fmt$0[1], _ck_ = make_iprintf(k$0, o, rest$21);
        return function(_ct_){return _ck_;};
       case 17:
        var rest$22 = fmt$0[2], fmt$0 = rest$22; break;
       case 18:
        var _cl_ = fmt$0[1];
        if(0 === _cl_[0])
         var
          rest$23 = fmt$0[2],
          fmt$1 = _cl_[1][1],
          k$3 =
            function(k, rest){
             function k$0(koc){return make_iprintf(k, koc, rest);}
             return k$0;
            },
          k$1 = k$3(k$0, rest$23),
          k$0 = k$1,
          fmt$0 = fmt$1;
        else
         var
          rest$24 = fmt$0[2],
          fmt$2 = _cl_[1][1],
          k$4 =
            function(k, rest){
             function k$0(koc){return make_iprintf(k, koc, rest);}
             return k$0;
            },
          k$2 = k$4(k$0, rest$24),
          k$0 = k$2,
          fmt$0 = fmt$2;
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], _cm_ = make_iprintf(k$0, o, rest$25);
        return function(_cs_){return _cm_;};
       case 21:
        var rest$26 = fmt$0[2], _cn_ = make_iprintf(k$0, o, rest$26);
        return function(_cr_){return _cn_;};
       case 22:
        var rest$27 = fmt$0[1], _co_ = make_iprintf(k$0, o, rest$27);
        return function(_cq_){return _co_;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1], _cp_ = 0;
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);},
                 _cp_,
                 ign,
                 rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], _b0_ = fn_of_custom_arity(k, o, fmt, arity);
     return function(_b1_){return _b0_;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var _bz_ = make_iprintf(k, o, fmt);
      return function(_bZ_){return _bz_;};
     }
     if(prec){
      var _bw_ = make_iprintf(k, o, fmt), _bx_ = function(_bY_){return _bw_;};
      return function(_bX_){return _bx_;};
     }
     var _by_ = make_iprintf(k, o, fmt);
     return function(_bW_){return _by_;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var _bD_ = make_iprintf(k, o, fmt);
      return function(_bV_){return _bD_;};
     }
     if(prec){
      var _bA_ = make_iprintf(k, o, fmt), _bB_ = function(_bU_){return _bA_;};
      return function(_bT_){return _bB_;};
     }
     var _bC_ = make_iprintf(k, o, fmt);
     return function(_bS_){return _bC_;};
    }
    if(typeof prec !== "number"){
     var _bJ_ = make_iprintf(k, o, fmt), _bK_ = function(_bR_){return _bJ_;};
     return function(_bQ_){return _bK_;};
    }
    if(prec){
     var
      _bE_ = make_iprintf(k, o, fmt),
      _bF_ = function(_bP_){return _bE_;},
      _bG_ = function(_bO_){return _bF_;};
     return function(_bN_){return _bG_;};
    }
    var _bH_ = make_iprintf(k, o, fmt);
    function _bI_(_bM_){return _bH_;}
    return function(_bL_){return _bI_;};
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         var acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$19);
         var acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         var acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$21);
         var acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1], acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         var acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$23);
         var acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1], acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(runtime.caml_string_equal(str, cst$43)) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0, i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0);
    a:
    b:
    {
     var wend = wstart;
     for(;;){
      if(wend === len) break b;
      if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
      var j = wend + 1 | 0, wend = j;
     }
     break a;
    }
    var
     box_name = caml_call3(Stdlib_String[16], str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend);
    a:
    b:
    {
     var nend = nstart;
     for(;;){
      if(nend === len) break b;
      var match = caml_string_get(str, nend);
      if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
      var j$0 = nend + 1 | 0, nend = j$0;
     }
     break a;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       _bs_ =
         runtime.caml_int_of_string
          (caml_call3(Stdlib_String[16], str, nstart, nend - nstart | 0)),
       indent = _bs_;
     }
     catch(_bt_){
      var _br_ = caml_wrap_exception(_bt_);
      if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if
      (caml_string_notequal(box_name, cst$43)
       && caml_string_notequal(box_name, "b")){
      if(! caml_string_notequal(box_name, "h")){var box_type = 0; break a;}
      if(! caml_string_notequal(box_name, "hov")){var box_type = 3; break a;}
      if(! caml_string_notequal(box_name, "hv")){var box_type = 2; break a;}
      if(caml_string_notequal(box_name, "v")){
       var box_type = invalid_box(0);
       break a;
      }
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function unexpected_end_of_format(end_ind){
     return invalid_format_message(end_ind, cst_unexpected_end_of_format);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     a:
     {
      var str_ind = lit_start;
      for(;;){
       if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
       var match = caml_string_get(str, str_ind);
       if(37 === match) break;
       if(64 === match) break a;
       var str_ind$1 = str_ind + 1 | 0, str_ind = str_ind$1;
      }
      var str_ind$2 = str_ind + 1 | 0;
      if(str_ind$2 === end_ind) unexpected_end_of_format(end_ind);
      var
       match$1 =
         95 === caml_string_get(str, str_ind$2)
          ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
          : parse_flags(str_ind, str_ind$2, end_ind, 0),
       fmt_rest = match$1[1];
      return add_literal(lit_start, str_ind, fmt_rest);
     }
     var str_ind$0 = str_ind + 1 | 0;
     a:
     if(str_ind$0 === end_ind)
      var match$0 = _N_;
     else{
      var c = caml_string_get(str, str_ind$0);
      if(65 <= c){
       if(94 <= c){
        var switcher = c - 123 | 0;
        if(2 >= switcher >>> 0)
         switch(switcher){
           case 0:
            var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break a;
           case 1: break;
           default:
            var
             fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 1, fmt_rest$2]];
            break a;
         }
       }
       else if(91 <= c)
        switch(c - 91 | 0){
          case 0:
           var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break a;
          case 1: break;
          default:
           var
            fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 0, fmt_rest$3]];
           break a;
        }
      }
      else{
       if(10 === c){
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
        break a;
       }
       if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break a;
          case 5:
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0)){
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
            break a;
           }
           var
            fmt_rest$7 = parse(str_ind$0, end_ind)[1],
            match$0 = [0, [12, 64, fmt_rest$7]];
           break a;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break a;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break a;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           b:
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1);
            c:
            {
             if(48 <= match$2){
              if(58 > match$2) break c;
             }
             else if(45 === match$2) break c;
             throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            }
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 caml_call3
                  (Stdlib_String[16],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
              break b;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[16],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
             break b;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break a;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0);
            b:
            {
             c:
             {
              if(48 <= match$6){
               if(58 > match$6) break c;
              }
              else if(45 === match$6) break c;
              var _bo_ = 0;
              break b;
             }
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[16],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break a;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break a;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break a;
        }
      }
      var
       fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
       match$0 = [0, [17, [2, c], fmt_rest$1]];
     }
     var fmt_rest$0 = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest$0);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _bb_ = flag[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
      if(_bc_){
       var _bd_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _bd_);
      }
      flag[1] = 1;
      return;
     }
     a:
     b:
     {
      var str_ind$0 = str_ind;
      c:
      for(;;){
       if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
       var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
       if(16 < switcher >>> 0) break b;
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
          break;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$2;
          break;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$3;
          break;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$4;
          break;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$5;
          break;
         default: break c;
       }
      }
      break a;
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 _D_);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind) unexpected_end_of_format(end_ind);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _ba_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _ba_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind) unexpected_end_of_format(end_ind);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0))
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
          else
           var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          var fmt_result = _aJ_;
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var
           fmt_rest$10 = parse(str_ind, end_ind)[1],
           _aL_ =
             get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
           fmt_result = _aL_;
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0))
           var
            ignored$6 = [11, counter$0],
            _aR_ = [0, [23, ignored$6, fmt_rest$14]];
          else
           var _aR_ = [0, [21, counter$0, fmt_rest$14]];
          var fmt_result = _aR_;
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$7 = [1, get_padprec_opt(95)],
            _aS_ = [0, [23, ignored$7, fmt_rest$15]];
          else
           var
            match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
            fmt_rest$16 = match$5[2],
            pad$7 = match$5[1],
            _aS_ = [0, [3, pad$7, fmt_rest$16]];
          var fmt_result = _aS_;
          break a;
         case 91:
          if(str_ind === end_ind) unexpected_end_of_format(end_ind);
          var
           char_set = create_char_set(0),
           add_char = function(c){return add_in_char_set(char_set, c);},
           add_range =
             function(c$0, c){
              if(c >= c$0){
               var i = c$0;
               for(;;){
                add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                var _a$_ = i + 1 | 0;
                if(c === i) break;
                var i = _a$_;
               }
              }
              return;
             },
           fail_single_percent =
             function(str_ind){
              return caml_call2(failwith_message(_R_), str, str_ind);
             },
           parse_char_set_content =
             function(counter, str_ind, end_ind){
              var str_ind$0 = str_ind;
              for(;;){
               if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
               var c = caml_string_get(str, str_ind$0);
               if(45 !== c){
                if(93 === c) return str_ind$0 + 1 | 0;
                var _a__ = str_ind$0 + 1 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_after_char$0, [0, _a__, end_ind, c]);
                var counter$0 = counter + 1 | 0;
                return parse_char_set_after_char$0
                        (counter$0, _a__, end_ind, c);
               }
               add_char(45);
               var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
              }
             },
           parse_char_set_after_char$0 =
             function(counter, str_ind, end_ind, c){
              var str_ind$0 = str_ind, c$0 = c;
              for(;;){
               if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
               var c$1 = caml_string_get(str, str_ind$0);
               a:
               {
                if(46 <= c$1){
                 if(64 !== c$1){
                  if(93 !== c$1) break a;
                  add_char(c$0);
                  return str_ind$0 + 1 | 0;
                 }
                }
                else if(37 !== c$1){
                 if(45 > c$1) break a;
                 var str_ind$2 = str_ind$0 + 1 | 0;
                 if(str_ind$2 === end_ind) unexpected_end_of_format(end_ind);
                 var c$2 = caml_string_get(str, str_ind$2);
                 if(37 === c$2){
                  if((str_ind$2 + 1 | 0) === end_ind)
                   unexpected_end_of_format(end_ind);
                  var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                  if(37 !== c$3 && 64 !== c$3)
                   return fail_single_percent(str_ind$2);
                  add_range(c$0, c$3);
                  var _a8_ = str_ind$2 + 2 | 0;
                  if(counter >= 50)
                   return caml_trampoline_return
                           (parse_char_set_content, [0, _a8_, end_ind]);
                  var counter$2 = counter + 1 | 0;
                  return parse_char_set_content(counter$2, _a8_, end_ind);
                 }
                 if(93 === c$2){
                  add_char(c$0);
                  add_char(45);
                  return str_ind$2 + 1 | 0;
                 }
                 add_range(c$0, c$2);
                 var _a9_ = str_ind$2 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a9_, end_ind]);
                 var counter$1 = counter + 1 | 0;
                 return parse_char_set_content(counter$1, _a9_, end_ind);
                }
                if(37 === c$0){
                 add_char(c$1);
                 var _a7_ = str_ind$0 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a7_, end_ind]);
                 var counter$0 = counter + 1 | 0;
                 return parse_char_set_content(counter$0, _a7_, end_ind);
                }
               }
               if(37 === c$0) fail_single_percent(str_ind$0);
               add_char(c$0);
               var
                str_ind$1 = str_ind$0 + 1 | 0,
                str_ind$0 = str_ind$1,
                c$0 = c$1;
              }
             },
           parse_char_set_after_char =
             function(str_ind, end_ind, c){
              return caml_trampoline
                      (parse_char_set_after_char$0(0, str_ind, end_ind, c));
             };
          if(str_ind === end_ind) unexpected_end_of_format(end_ind);
          if(94 === caml_string_get(str, str_ind))
           var
            str_ind$0 = str_ind + 1 | 0,
            reverse = 1,
            str_ind$1 = str_ind$0;
          else
           var reverse = 0, str_ind$1 = str_ind;
          if(str_ind$1 === end_ind) unexpected_end_of_format(end_ind);
          var
           c = caml_string_get(str, str_ind$1),
           next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
           char_set$0 = freeze_char_set(char_set),
           char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$9 = [10, get_pad_opt(95), char_set$1],
            _aX_ = [0, [23, ignored$9, fmt_rest$19]];
          else
           var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
          var fmt_result = _aX_;
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$7 = get_pad_opt(99);
          if(match$7){
           if(0 === match$7[1])
            var
             _aY_ =
               get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
             _aZ_ = _aY_;
           else
            var
             _aZ_ =
               legacy_behavior$0
                ? char_format(fmt_rest$21)
                : invalid_format_message
                  (str_ind, cst_non_zero_widths_are_unsupp);
           var _a0_ = _aZ_;
          }
          else
           var _a0_ = char_format(fmt_rest$21);
          var fmt_result = _a0_;
          break a;
         case 114:
          var
           fmt_rest$22 = parse(str_ind, end_ind)[1],
           _a1_ =
             get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
           fmt_result = _a1_;
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$10 = [0, get_padprec_opt(95)],
            _a2_ = [0, [23, ignored$10, fmt_rest$23]];
          else
           var
            match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
            fmt_rest$24 = match$8[2],
            pad$10 = match$8[1],
            _a2_ = [0, [2, pad$10, fmt_rest$24]];
          var fmt_result = _a2_;
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0))
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            _a3_ = [0, [23, ignored$11, fmt_rest$26]];
          else
           var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          var fmt_result = _a3_;
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$3 = [7, get_padprec_opt(95)],
            _aK_ = [0, [23, ignored$3, fmt_rest$8]];
          else
           var
            match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
            fmt_rest$9 = match$3[2],
            pad$4 = match$3[1],
            _aK_ = [0, [9, pad$4, fmt_rest$9]];
          var fmt_result = _aK_;
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), _a4_ = symb$0 - 88 | 0;
           b:
           {
            if(32 >= _a4_ >>> 0)
             switch(_a4_){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var _aQ_ = 1; break b;
             }
            var _aQ_ = 0;
           }
           if(_aQ_) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 1: break;
               default: var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          }
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aP_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aP_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aP_;
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           _aT_ = get_space(0),
           _aU_ = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            _aV_ = [0, [23, ignored$8, fmt_rest$17]];
          else
           var
            _aW_ = get_prec(0),
            match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17),
            fmt_rest$18 = match$6[3],
            prec$4 = match$6[2],
            pad$8 = match$6[1],
            _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          var fmt_result = _aV_;
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           c:
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0){
             switch(switcher){
               case 0:
                var _a5_ = 1; break;
               case 1:
                var _a5_ = 0; break;
               case 2:
                var _a5_ = 3; break;
               default: var _a5_ = 6;
             }
             var kind = _a5_;
             break b;
            }
           }
           else if(69 <= symb){
            switch(symb - 69 | 0){
              case 0:
               var _a6_ = 2; break;
              case 1:
               break c;
              case 2:
               var _a6_ = 4; break;
              default: var _a6_ = 7;
            }
            var kind = _a6_;
            break b;
           }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var match = get_prec(0);
           if(typeof match === "number")
            var
             _aM_ =
               match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
           else
            var ndec = match[1], _aM_ = [0, ndec];
           var
            ignored$4 = [6, get_pad_opt(95), _aM_],
            _aN_ = [0, [23, ignored$4, fmt_rest$11]];
          }
          else
           var
            _aO_ = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
          var fmt_result = _aN_;
          break a;
       }
      b:
      if(108 <= symb){
       if(111 > symb){
        switch(symb - 108 | 0){
          case 0:
           var
            _at_ = caml_string_get(str, str_ind),
            _au_ = get_space(0),
            _av_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aw_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _ay_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _ax_ = _aw_;
           break;
          case 1:
           break b;
          default:
           var
            _az_ = caml_string_get(str, str_ind),
            _aA_ = get_space(0),
            _aB_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aC_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aD_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _ax_ = _aC_;
        }
        var fmt_result = _ax_;
        break a;
       }
      }
      else if(76 === symb){
       var
        _aE_ = caml_string_get(str, str_ind),
        _aF_ = get_space(0),
        _aG_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aH_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aI_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aH_;
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _an_ = 1 - pad_used[1],
       _ao_ = _an_ ? caml_notequal([0, pad], _K_) : _an_;
      if(_ao_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _ap_ = 1 - prec_used[1],
       _aq_ = _ap_ ? caml_notequal([0, prec], _L_) : _ap_;
      if(_aq_){
       var _ar_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[32], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[16], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var
       str_ind$1 = str_ind$0 + 1 | 0,
       str_ind$0 = str_ind$1,
       acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind) unexpected_end_of_format(end_ind);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind) unexpected_end_of_format(end_ind);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[16], str, lit_start, size),
                  fmt]];
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind$0)){
       if((str_ind$0 + 1 | 0) === end_ind) unexpected_end_of_format(end_ind);
       if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
       var match = caml_string_get(str, str_ind$0 + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
              str_ind$2 = sub_end + 2 | 0,
              str_ind$0 = str_ind$2;
             continue;
            case 1: break;
            default:
             return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind$0 + 2 | 0) === end_ind)
          unexpected_end_of_format(end_ind);
         var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
           str_ind$3 = sub_end$0 + 2 | 0,
           str_ind$0 = str_ind$3;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
           str_ind$4 = sub_end$1 + 2 | 0,
           str_ind$0 = str_ind$4;
          continue;
         }
         var str_ind$5 = str_ind$0 + 3 | 0, str_ind$0 = str_ind$5;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
          str_ind$6 = sub_end$2 + 2 | 0,
          str_ind$0 = str_ind$6;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
       }
       var str_ind$1 = str_ind$0 + 2 | 0, str_ind$0 = str_ind$1;
      }
      else
       var str_ind$7 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$7;
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      a:
      {
       if(plus$0){
        if(! hash$0){
         if(space$0) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash$0){
         if(space$0){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space$0){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           var hash$0 = 0;
           continue;
        }
      }
      if(plus$0)
       if(space$0){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        var space$0 = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        var plus$0 = 0;
       }
      else{
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       var space$0 = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[16], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Printf
//# unitInfo: Requires: CamlinternalFormat, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1], _g_ = 0;
    function _h_(acc){
     caml_call2(CamlinternalFormat[9], o, acc);
     return caml_call1(k, o);
    }
    return caml_call3(CamlinternalFormat[7], _h_, _g_, fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1], _e_ = 0;
    function _f_(acc){
     caml_call2(CamlinternalFormat[10], b, acc);
     return caml_call1(k, b);
    }
    return caml_call3(CamlinternalFormat[7], _f_, _e_, fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Arg
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Int, Stdlib__List, Stdlib__Printf, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$8 = "",
    cst$10 = "  ",
    cst_Display_this_list_of_optio$1 = " Display this list of options",
    cst_s = "%s",
    cst_help$4 = "--help",
    cst_help$3 = "-help",
    cst$9 = ".\n",
    cst_a_float$1 = "a float",
    cst_an_integer$1 = "an integer",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$7 = "\n",
    cst$4 = cst$8,
    cst$5 = " ",
    cst$6 = cst$8,
    cst$2 = "(?)",
    cst$3 = "-",
    cst = "}",
    cst$0 = "|",
    cst$1 = "{",
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Int = global_data.Stdlib__Int,
    Bad = [248, "Stdlib.Arg.Bad", caml_fresh_oo_id(0)],
    Help = [248, "Stdlib.Arg.Help", caml_fresh_oo_id(0)],
    Stop = [248, "Stdlib.Arg.Stop", caml_fresh_oo_id(0)],
    _v_ = [0, [2, 0, [0, 0]], "%s%c"],
    _p_ = [0, [2, 0, 0], cst_s],
    _q_ = [0, [2, 0, 0], cst_s],
    _n_ = [0, [2, 0, 0], cst_s],
    _o_ = [0, [2, 0, 0], cst_s],
    _l_ = [0, [2, 0, 0], cst_s],
    _m_ = [0, [2, 0, 0], cst_s],
    cst_a_boolean = "a boolean",
    cst_an_integer = cst_an_integer$1,
    cst_an_integer$0 = cst_an_integer$1,
    cst_a_float = cst_a_float$1,
    cst_a_float$0 = cst_a_float$1,
    cst_one_of = "one of: ",
    cst_Arg_Expand_is_is_only_allo =
      "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic",
    cst_no_argument = "no argument",
    _f_ =
      [0,
       [2, 0, [11, ": unknown option '", [2, 0, [11, "'.\n", 0]]]],
       "%s: unknown option '%s'.\n"],
    _i_ =
      [0,
       [2,
        0,
        [11,
         ": wrong argument '",
         [2,
          0,
          [11,
           "'; option '",
           [2, 0, [11, "' expects ", [2, 0, [11, cst$9, 0]]]]]]]],
       "%s: wrong argument '%s'; option '%s' expects %s.\n"],
    _j_ =
      [0,
       [2, 0, [11, ": option '", [2, 0, [11, "' needs an argument.\n", 0]]]],
       "%s: option '%s' needs an argument.\n"],
    _k_ = [0, [2, 0, [11, ": ", [2, 0, [11, cst$9, 0]]]], "%s: %s.\n"],
    _g_ = [0, cst_help$3],
    _h_ = [0, cst_help$4],
    _e_ = [0, [2, 0, 0], cst_s],
    _d_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    cst_help$2 = cst_help$3,
    cst_Display_this_list_of_optio = cst_Display_this_list_of_optio$1,
    cst_help = cst_help$3,
    cst_help$1 = cst_help$4,
    cst_Display_this_list_of_optio$0 = cst_Display_this_list_of_optio$1,
    cst_help$0 = cst_help$4,
    _c_ = [0, cst_help$3],
    _a_ =
      [0, [11, cst$10, [2, 0, [12, 32, [2, 0, [12, 10, 0]]]]], "  %s %s\n"],
    _b_ =
      [0,
       [11, cst$10, [2, 0, [12, 32, [2, 0, [2, 0, [12, 10, 0]]]]]],
       "  %s %s%s\n"],
    cst_none = "<none>";
   function assoc3(x, l){
    var l$0 = l;
    for(;;){
     if(! l$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = l$0[1], y2 = match[2], y1 = match[1];
     if(caml_equal(y1, x)) return y2;
     var t = l$0[2], l$0 = t;
    }
   }
   function make_symlist(prefix, sep, suffix, l){
    if(! l) return cst_none;
    var t = l[2], h = l[1], _aD_ = caml_call2(Stdlib[28], prefix, h);
    function _aE_(x, y){
     var _aG_ = caml_call2(Stdlib[28], sep, y);
     return caml_call2(Stdlib[28], x, _aG_);
    }
    var _aF_ = caml_call3(Stdlib_List[26], _aE_, _aD_, t);
    return caml_call2(Stdlib[28], _aF_, suffix);
   }
   function help_action(param){
    throw caml_maybe_attach_backtrace([0, Stop, _c_], 1);
   }
   function add_help(speclist){
    try{assoc3(cst_help$2, speclist); var _aA_ = 0, add1 = _aA_;}
    catch(_aC_){
     var _aw_ = caml_wrap_exception(_aC_);
     if(_aw_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_aw_, 0);
     var
      add1 =
        [0,
         [0, cst_help, [0, help_action], cst_Display_this_list_of_optio],
         0];
    }
    try{assoc3(cst_help$1, speclist); var _az_ = 0, add2 = _az_;}
    catch(_aB_){
     var _ax_ = caml_wrap_exception(_aB_);
     if(_ax_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ax_, 0);
     var
      add2 =
        [0,
         [0, cst_help$0, [0, help_action], cst_Display_this_list_of_optio$0],
         0];
    }
    var _ay_ = caml_call2(Stdlib[37], add1, add2);
    return caml_call2(Stdlib[37], speclist, _ay_);
   }
   function usage_b(buf, speclist, errmsg){
    caml_call3(Stdlib_Printf[5], buf, _d_, errmsg);
    var _as_ = add_help(speclist);
    function _at_(param){
     var
      doc = param[3],
      spec = param[2],
      key = param[1],
      _au_ = 0 < caml_ml_string_length(doc) ? 1 : 0;
     if(! _au_) return _au_;
     if(11 !== spec[0])
      return caml_call4(Stdlib_Printf[5], buf, _a_, key, doc);
     var l = spec[1], _av_ = make_symlist(cst$1, cst$0, cst, l);
     return caml_call5(Stdlib_Printf[5], buf, _b_, key, _av_, doc);
    }
    return caml_call2(Stdlib_List[18], _at_, _as_);
   }
   function usage_string(speclist, errmsg){
    var b = caml_call1(Stdlib_Buffer[1], 200);
    usage_b(b, speclist, errmsg);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function usage(speclist, errmsg){
    var _ar_ = usage_string(speclist, errmsg);
    return caml_call2(Stdlib_Printf[3], _e_, _ar_);
   }
   var current = [0, 0];
   function int_of_string_opt(x){
    try{var _ap_ = [0, runtime.caml_int_of_string(x)]; return _ap_;}
    catch(_aq_){
     var _ao_ = caml_wrap_exception(_aq_);
     if(_ao_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_ao_, 0);
    }
   }
   function float_of_string_opt(x){
    try{var _am_ = [0, runtime.caml_float_of_string(x)]; return _am_;}
    catch(_an_){
     var _al_ = caml_wrap_exception(_an_);
     if(_al_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_al_, 0);
    }
   }
   function parse_and_expand_argv_dynamic_
   (allow_expand, current, argv, speclist, anonfun, errmsg){
    var initpos = current[1];
    function convert_error(error){
     var
      b = caml_call1(Stdlib_Buffer[1], 200),
      progname =
        initpos < argv[1].length - 1
         ? caml_check_bound(argv[1], initpos)[1 + initpos]
         : cst$2;
     switch(error[0]){
       case 0:
        var s = error[1];
        if
         (caml_string_notequal(s, cst_help$4)
          && caml_string_notequal(s, cst_help$3))
         caml_call4(Stdlib_Printf[5], b, _f_, progname, s);
        break;
       case 1:
        var expected = error[3], arg = error[2], opt = error[1];
        caml_call6(Stdlib_Printf[5], b, _i_, progname, arg, opt, expected);
        break;
       case 2:
        var s$0 = error[1];
        caml_call4(Stdlib_Printf[5], b, _j_, progname, s$0);
        break;
       default:
        var s$1 = error[1];
        caml_call4(Stdlib_Printf[5], b, _k_, progname, s$1);
     }
     usage_b(b, speclist[1], errmsg);
     if(! caml_equal(error, _g_) && ! caml_equal(error, _h_))
      return [0, Bad, caml_call1(Stdlib_Buffer[2], b)];
     return [0, Help, caml_call1(Stdlib_Buffer[2], b)];
    }
    current[1]++;
    for(;;){
     if(current[1] >= argv[1].length - 1) return 0;
     try{
      var _Y_ = current[1], s = caml_check_bound(argv[1], _Y_)[1 + _Y_];
      if(caml_call2(Stdlib_String[11], cst$3, s)){
       try{
        var
         follow$1 = 0,
         _aa_ = assoc3(s, speclist[1]),
         follow$0 = follow$1,
         action = _aa_;
       }
       catch(_aj_){
        var _Z_ = caml_wrap_exception(_aj_);
        if(_Z_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_Z_, 0);
        try{
         var
          i = caml_call2(Stdlib_String[36], s, 61),
          len = caml_ml_string_length(s),
          arg =
            caml_call3(Stdlib_String[16], s, i + 1 | 0, len - (i + 1 | 0) | 0),
          keyword = caml_call3(Stdlib_String[16], s, 0, i),
          follow = [0, arg],
          _$_ = assoc3(keyword, speclist[1]),
          follow$0 = follow,
          action = _$_;
        }
        catch(_ak_){
         var ___ = caml_wrap_exception(_ak_);
         if(___ === Stdlib[8])
          throw caml_maybe_attach_backtrace([0, Stop, [0, s]], 1);
         throw caml_maybe_attach_backtrace(___, 0);
        }
       }
       var
        no_arg$0 =
          function(s, follow){
           function no_arg(param){
            if(! follow) return;
            var arg = follow[1];
            throw caml_maybe_attach_backtrace
                   ([0, Stop, [1, s, arg, cst_no_argument]], 1);
           }
           return no_arg;
          },
        no_arg = no_arg$0(s, follow$0),
        get_arg$0 =
          function(s, follow){
           function get_arg(param){
            if(follow){var arg = follow[1]; return arg;}
            if((current[1] + 1 | 0) >= argv[1].length - 1)
             throw caml_maybe_attach_backtrace([0, Stop, [2, s]], 1);
            var _ai_ = current[1] + 1 | 0;
            return caml_check_bound(argv[1], _ai_)[1 + _ai_];
           }
           return get_arg;
          },
        get_arg = get_arg$0(s, follow$0),
        consume_arg$0 =
          function(follow){
           function consume_arg(param){return follow ? 0 : (current[1]++, 0);}
           return consume_arg;
          },
        consume_arg = consume_arg$0(follow$0),
        treat_action$0 =
          function(s, no_arg, get_arg, consume_arg){
           function treat_action(param){
            switch(param[0]){
              case 0:
               var f = param[1]; no_arg(0); return caml_call1(f, 0);
              case 1:
               var f$0 = param[1], arg = get_arg(0);
               try{var _ac_ = [0, caml_call1(Stdlib[32], arg)], match = _ac_;}
               catch(_ah_){
                var _ab_ = caml_wrap_exception(_ah_);
                if(_ab_[1] !== Stdlib[6])
                 throw caml_maybe_attach_backtrace(_ab_, 0);
                var match = 0;
               }
               if(! match)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s, arg, cst_a_boolean]], 1);
               var s$0 = match[1];
               caml_call1(f$0, s$0);
               return consume_arg(0);
              case 2:
               var r = param[1]; no_arg(0); r[1] = 1; return 0;
              case 3:
               var r$0 = param[1]; no_arg(0); r$0[1] = 0; return 0;
              case 4:
               var f$1 = param[1], arg$0 = get_arg(0);
               caml_call1(f$1, arg$0);
               return consume_arg(0);
              case 5:
               var r$1 = param[1]; r$1[1] = get_arg(0); return consume_arg(0);
              case 6:
               var
                f$2 = param[1],
                arg$1 = get_arg(0),
                match$0 = int_of_string_opt(arg$1);
               if(! match$0)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s, arg$1, cst_an_integer]], 1);
               var x = match$0[1];
               caml_call1(f$2, x);
               return consume_arg(0);
              case 7:
               var
                r$2 = param[1],
                arg$2 = get_arg(0),
                match$1 = int_of_string_opt(arg$2);
               if(! match$1)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s, arg$2, cst_an_integer$0]], 1);
               var x$0 = match$1[1];
               r$2[1] = x$0;
               return consume_arg(0);
              case 8:
               var
                f$3 = param[1],
                arg$3 = get_arg(0),
                match$2 = float_of_string_opt(arg$3);
               if(! match$2)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s, arg$3, cst_a_float]], 1);
               var x$1 = match$2[1];
               caml_call1(f$3, x$1);
               return consume_arg(0);
              case 9:
               var
                r$3 = param[1],
                arg$4 = get_arg(0),
                match$3 = float_of_string_opt(arg$4);
               if(! match$3)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s, arg$4, cst_a_float$0]], 1);
               var x$2 = match$3[1];
               r$3[1] = x$2;
               return consume_arg(0);
              case 10:
               var specs = param[1];
               no_arg(0);
               return caml_call2(Stdlib_List[18], treat_action, specs);
              case 11:
               var f$4 = param[2], symb = param[1], arg$5 = get_arg(0);
               if(caml_call2(Stdlib_List[37], arg$5, symb)){
                caml_call1(f$4, arg$5);
                return consume_arg(0);
               }
               var _ad_ = make_symlist(cst$6, cst$5, cst$4, symb);
               throw caml_maybe_attach_backtrace
                      ([0,
                        Stop,
                        [1, s, arg$5, caml_call2(Stdlib[28], cst_one_of, _ad_)]],
                       1);
              case 12:
               var f$5 = param[1];
               no_arg(0);
               for(;;){
                if(current[1] >= (argv[1].length - 1 - 1 | 0)) return 0;
                var _ae_ = current[1] + 1 | 0;
                caml_call1(f$5, caml_check_bound(argv[1], _ae_)[1 + _ae_]);
                consume_arg(0);
               }
               break;
              case 13:
               var f$6 = param[1];
               no_arg(0);
               var acc = [0, 0];
               for(;;){
                if(current[1] >= (argv[1].length - 1 - 1 | 0))
                 return caml_call1(f$6, caml_call1(Stdlib_List[10], acc[1]));
                var _ag_ = current[1] + 1 | 0, _af_ = acc[1];
                acc[1] = [0, caml_check_bound(argv[1], _ag_)[1 + _ag_], _af_];
                consume_arg(0);
               }
               break;
              default:
               var f$7 = param[1];
               if(1 - allow_expand)
                throw caml_maybe_attach_backtrace
                       ([0, Stdlib[6], cst_Arg_Expand_is_is_only_allo], 1);
               var arg$6 = get_arg(0), newarg = caml_call1(f$7, arg$6);
               consume_arg(0);
               var
                before =
                  caml_call3(Stdlib_Array[5], argv[1], 0, current[1] + 1 | 0),
                after =
                  caml_call3
                   (Stdlib_Array[5],
                    argv[1],
                    current[1] + 1 | 0,
                    (argv[1].length - 1 - current[1] | 0) - 1 | 0);
               argv[1] =
                caml_call1
                 (Stdlib_Array[4], [0, before, [0, newarg, [0, after, 0]]]);
               return 0;
            }
           }
           return treat_action;
          },
        treat_action = treat_action$0(s, no_arg, get_arg, consume_arg);
       treat_action(action);
      }
      else
       caml_call1(anonfun, s);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] === Bad){
       var m = exn[2];
       throw caml_maybe_attach_backtrace(convert_error([3, m]), 1);
      }
      if(exn[1] !== Stop) throw caml_maybe_attach_backtrace(exn, 0);
      var e = exn[2];
      throw caml_maybe_attach_backtrace(convert_error(e), 1);
     }
     current[1]++;
    }
   }
   function parse_and_expand_argv_dynamic
   (current, argv, speclist, anonfun, errmsg){
    return parse_and_expand_argv_dynamic_
            (1, current, argv, speclist, anonfun, errmsg);
   }
   function parse_argv_dynamic(opt, argv, speclist, anonfun, errmsg){
    if(opt) var sth = opt[1], current$0 = sth; else var current$0 = current;
    return parse_and_expand_argv_dynamic_
            (0, current$0, [0, argv], speclist, anonfun, errmsg);
   }
   function parse_argv(opt, argv, speclist, anonfun, errmsg){
    if(opt) var sth = opt[1], current$0 = sth; else var current$0 = current;
    return parse_argv_dynamic
            ([0, current$0], argv, [0, speclist], anonfun, errmsg);
   }
   function parse(l, f, msg){
    try{var _X_ = parse_argv(0, caml_sys_argv(0), l, f, msg); return _X_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Bad){
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[3], _l_, msg$0);
      return caml_call1(Stdlib[99], 2);
     }
     if(exn[1] !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call2(Stdlib_Printf[2], _m_, msg$1);
     return caml_call1(Stdlib[99], 0);
    }
   }
   function parse_dynamic(l, f, msg){
    try{
     var _W_ = parse_argv_dynamic(0, caml_sys_argv(0), l, f, msg);
     return _W_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Bad){
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[3], _n_, msg$0);
      return caml_call1(Stdlib[99], 2);
     }
     if(exn[1] !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call2(Stdlib_Printf[2], _o_, msg$1);
     return caml_call1(Stdlib[99], 0);
    }
   }
   function parse_expand(l, f, msg){
    try{
     var
      argv = [0, caml_sys_argv(0)],
      spec = [0, l],
      current$0 = [0, current[1]],
      _V_ = parse_and_expand_argv_dynamic(current$0, argv, spec, f, msg);
     return _V_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Bad){
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[3], _p_, msg$0);
      return caml_call1(Stdlib[99], 2);
     }
     if(exn[1] !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call2(Stdlib_Printf[2], _q_, msg$1);
     return caml_call1(Stdlib[99], 0);
    }
   }
   function second_word(s){
    var len = caml_ml_string_length(s);
    function loop(n){
     var n$0 = n;
     for(;;){
      if(len <= n$0) return len;
      if(32 !== caml_string_get(s, n$0)) return n$0;
      var n$1 = n$0 + 1 | 0, n$0 = n$1;
     }
    }
    try{var n$0 = caml_call2(Stdlib_String[36], s, 9);}
    catch(_T_){
     var _R_ = caml_wrap_exception(_T_);
     if(_R_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_R_, 0);
     try{var n = caml_call2(Stdlib_String[36], s, 32);}
     catch(_U_){
      var _S_ = caml_wrap_exception(_U_);
      if(_S_ === Stdlib[8]) return len;
      throw caml_maybe_attach_backtrace(_S_, 0);
     }
     return loop(n + 1 | 0);
    }
    return loop(n$0 + 1 | 0);
   }
   function max_arg_len(cur, param){
    var doc = param[3], spec = param[2], kwd = param[1];
    if(11 === spec[0])
     return caml_call2(Stdlib_Int[11], cur, caml_ml_string_length(kwd));
    var _Q_ = caml_ml_string_length(kwd) + second_word(doc) | 0;
    return caml_call2(Stdlib_Int[11], cur, _Q_);
   }
   function replace_leading_tab(s){
    var seen = [0, 0];
    function _P_(c){
     if(9 === c && ! seen[1]){seen[1] = 1; return 32;}
     return c;
    }
    return caml_call2(Stdlib_String[18], _P_, s);
   }
   function align(opt, speclist){
    if(opt) var sth = opt[1], limit = sth; else var limit = Stdlib[19];
    var
     completed = add_help(speclist),
     len = caml_call3(Stdlib_List[26], max_arg_len, 0, completed),
     len$0 = caml_call2(Stdlib_Int[10], len, limit);
    function _J_(ksd){
     var kwd = ksd[1], spec = ksd[2];
     if(! caml_string_notequal(ksd[3], cst$8)) return ksd;
     if(11 === spec[0]){
      var
       msg$0 = ksd[3],
       cutcol$0 = second_word(msg$0),
       _M_ = caml_call2(Stdlib_Int[11], 0, len$0 - cutcol$0 | 0) + 3 | 0,
       spaces$0 = caml_call2(Stdlib_String[1], _M_, 32),
       _N_ = replace_leading_tab(msg$0),
       _O_ = caml_call2(Stdlib[28], spaces$0, _N_);
      return [0, kwd, spec, caml_call2(Stdlib[28], cst$7, _O_)];
     }
     var
      msg = ksd[3],
      spec$0 = ksd[2],
      cutcol = second_word(msg),
      kwd_len = caml_ml_string_length(kwd),
      diff = (len$0 - kwd_len | 0) - cutcol | 0;
     if(0 >= diff) return [0, kwd, spec$0, replace_leading_tab(msg)];
     var
      spaces = caml_call2(Stdlib_String[1], diff, 32),
      _K_ = replace_leading_tab(msg),
      prefix = caml_call3(Stdlib_String[16], _K_, 0, cutcol),
      suffix =
        caml_call3
         (Stdlib_String[16],
          msg,
          cutcol,
          caml_ml_string_length(msg) - cutcol | 0),
      _L_ = caml_call2(Stdlib[28], spaces, suffix);
     return [0, kwd, spec$0, caml_call2(Stdlib[28], prefix, _L_)];
    }
    return caml_call2(Stdlib_List[20], _J_, completed);
   }
   function read_aux(trim, sep, file){
    var
     ic = caml_call1(Stdlib[80], file),
     buf = caml_call1(Stdlib_Buffer[1], 200),
     words = [0, 0];
    function stash(param){
     var word = caml_call1(Stdlib_Buffer[2], buf);
     if(trim){
      var len = caml_ml_string_length(word);
      a:
      {
       if(0 < len && 13 === caml_string_get(word, len - 1 | 0)){
        var _I_ = caml_call3(Stdlib_String[16], word, 0, len - 1 | 0);
        break a;
       }
       var _I_ = word;
      }
      var word$0 = _I_;
     }
     else
      var word$0 = word;
     words[1] = [0, word$0, words[1]];
     return caml_call1(Stdlib_Buffer[8], buf);
    }
    try{
     for(;;){
      var c = caml_call1(Stdlib[82], ic);
      if(c === sep) stash(0); else caml_call2(Stdlib_Buffer[12], buf, c);
     }
    }
    catch(_H_){
     var _F_ = caml_wrap_exception(_H_);
     if(_F_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_F_, 0);
     if(0 < caml_call1(Stdlib_Buffer[7], buf)) stash(0);
     caml_call1(Stdlib[93], ic);
     var _G_ = caml_call1(Stdlib_List[10], words[1]);
     return caml_call1(Stdlib_Array[10], _G_);
    }
   }
   var _r_ = 10, _s_ = 1;
   function read_arg(_E_){return read_aux(_s_, _r_, _E_);}
   var _t_ = 0, _u_ = 0;
   function read_arg0(_D_){return read_aux(_u_, _t_, _D_);}
   function write_aux(sep, file, args){
    var oc = caml_call1(Stdlib[61], file);
    function _C_(s){return caml_call4(Stdlib_Printf[1], oc, _v_, s, sep);}
    caml_call2(Stdlib_Array[11], _C_, args);
    return caml_call1(Stdlib[76], oc);
   }
   var _w_ = 10;
   function write_arg(_A_, _B_){return write_aux(_w_, _A_, _B_);}
   var _x_ = 0;
   function write_arg0(_y_, _z_){return write_aux(_x_, _y_, _z_);}
   var
    Stdlib_Arg =
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
   runtime.caml_register_global(55, Stdlib_Arg, "Stdlib__Arg");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Printexc
//# unitInfo: Requires: Stdlib, Stdlib__Atomic, Stdlib__Buffer, Stdlib__Obj, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _o_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _p_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _n_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0,
    _j_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _k_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _a_ = [0, [3, 0, 0], "%S"],
    _m_ =
      [0,
       cst$4,
       "(Cannot print locations:\n bytecode executable program file not found)",
       "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
       "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
       "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"];
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _al_ = Stdlib_Obj[15];
    if(caml_obj_tag(f) === _al_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _am_ = Stdlib_Obj[16];
    return caml_obj_tag(f) === _am_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _aj_ = other_fields(x, i + 1 | 0), _ak_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _ak_, _aj_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[2], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     a:
     {
      try{var val = caml_call1(hd, x);}catch(_ai_){break a;}
      if(val){var s = val[1]; return [0, s];}
     }
     var param = tl;
    }
   }
   function string_of_extension_constructo(t){
    if(0 === caml_obj_tag(t)){
     var constructor = t[1][1], match = t.length - 1;
     if(2 < match >>> 0)
      var
       _ae_ = other_fields(t, 2),
       _af_ = field(t, 1),
       _ah_ = caml_call3(Stdlib_Printf[4], _d_, _af_, _ae_);
     else
      switch(match){
        case 0:
         var _ah_ = cst$1; break;
        case 1:
         var _ah_ = cst$2; break;
        default:
         var
          _ag_ = field(t, 1),
          _ah_ = caml_call2(Stdlib_Printf[4], _e_, _ag_);
      }
     var match$0 = [0, constructor, [0, _ah_]];
    }
    else
     var match$0 = [0, t[1], 0];
    var fields_opt = match$0[2], constructor$0 = match$0[1];
    if(! fields_opt) return constructor$0;
    var f = fields_opt[1];
    return caml_call2(Stdlib[28], constructor$0, f);
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var match = x[2], char$0 = match[3], line = match[2], file = match[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$0 = x[2],
      char$1 = match$0[3],
      line$0 = match$0[2],
      file$0 = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] !== Stdlib[15]) return string_of_extension_constructo(x);
    var
     match$1 = x[2],
     char$2 = match$1[3],
     line$1 = match$1[2],
     file$1 = match$1[1];
    return caml_call6
            (Stdlib_Printf[4],
             locfmt,
             file$1,
             line$1,
             char$2,
             char$2 + 6 | 0,
             cst_Undefined_recursive_module);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var _ad_ = caml_call1(fct, arg); return _ad_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), _ac_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, _ac_);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _ab_ = caml_call1(fct, arg); return _ab_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _aa_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _aa_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      _U_ = slot[5],
      _V_ = slot[4],
      _W_ = slot[3],
      _X_ = slot[6] ? cst_inlined : cst$3,
      _Y_ = slot[2],
      _Z_ = slot[7],
      ___ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _h_, ___, _Z_, _Y_, _X_, _W_, _V_, _U_)];
    }
    if(slot[1]) return 0;
    var _$_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _i_, _$_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _k_);
    var a = backtrace[1], _S_ = a.length - 1 - 1 | 0, _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _j_, str);
      }
      var _T_ = i + 1 | 0;
      if(_S_ === i) break;
      var i = _T_;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _P_ = a.length - 1 - 1 | 0,
     _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _l_, str);
      }
      var _Q_ = i + 1 | 0;
      if(_P_ === i) break;
      var i = _Q_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && runtime.caml_string_notequal(param[7], cst$4))
     return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 1 - 1 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _N_ = 0;
     else{
      var _M_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _M_){var i$0 = i - 1 | 0, i = i$0; continue;}
      var _N_ = _M_;
     }
     return _N_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[2], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers),
      _L_ = 1 - success;
     if(! _L_) return _L_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var errors = _m_.slice();
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _I_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _n_, _I_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _J_ = caml_call1(Stdlib[18], status),
      _K_ = caml_check_bound(errors, _J_)[1 + _J_];
     caml_call1(Stdlib[53], _K_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var empty_backtrace = [0];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_H_){}
      try{
       var
        _D_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _C_ = _D_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _A_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _o_, _A_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _B_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _p_, _B_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _C_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _E_ = _C_;
     }
     catch(_G_){
      var _z_ = caml_wrap_exception(_G_);
      if(_z_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_z_, 0);
      var _E_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _E_;
    }
    catch(_F_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   function _q_(_y_){return runtime.caml_raw_backtrace_next_slot(_y_);}
   function _r_(_x_){return runtime.caml_convert_raw_backtrace_slot(_x_);}
   function _s_(_w_, _v_){return runtime.caml_raw_backtrace_slot(_w_, _v_);}
   var
    _t_ =
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot],
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_u_){return caml_get_exception_raw_backtra(_u_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _t_,
       raw_backtrace_length,
       _s_,
       _r_,
       _q_,
       exn_slot_id,
       exn_slot_name,
       string_of_extension_constructo];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Fun
//# unitInfo: Requires: Stdlib, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib = global_data.Stdlib,
    cst_Fun_Finally_raised = "Fun.Finally_raised: ",
    cst_Stdlib_Fun_Finally_raised = "Stdlib.Fun.Finally_raised";
   function const$0(c, param){return c;}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function negate(p, v){return 1 - caml_call1(p, v);}
   var
    Finally_raised =
      [248, cst_Stdlib_Fun_Finally_raised, runtime.caml_fresh_oo_id(0)];
   function _a_(param){
    if(param[1] !== Finally_raised) return 0;
    var exn = param[2], _b_ = caml_call1(Stdlib_Printexc[1], exn);
    return [0, caml_call2(Stdlib[28], cst_Fun_Finally_raised, _b_)];
   }
   caml_call1(Stdlib_Printexc[9], _a_);
   function protect(finally$0, work){
    function finally_no_exn(param){
     try{caml_call1(finally$0, 0); return;}
     catch(e$0){
      var
       e = caml_wrap_exception(e$0),
       bt = caml_call1(Stdlib_Printexc[12], 0),
       exn = [0, Finally_raised, e];
      caml_restore_raw_backtrace(exn, bt);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    try{var result = caml_call1(work, 0);}
    catch(work_exn$0){
     var
      work_exn = caml_wrap_exception(work_exn$0),
      work_bt = caml_call1(Stdlib_Printexc[12], 0);
     finally_no_exn(0);
     caml_restore_raw_backtrace(work_exn, work_bt);
     throw caml_maybe_attach_backtrace(work_exn, 0);
    }
    finally_no_exn(0);
    return result;
   }
   var Stdlib_Fun = [0, const$0, flip, negate, protect, Finally_raised];
   runtime.caml_register_global(4, Stdlib_Fun, "Stdlib__Fun");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Gc
//# unitInfo: Requires: Stdlib, Stdlib__Atomic, Stdlib__Fun, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "\n",
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Atomic = global_data.Stdlib__Atomic;
   global_data.Stdlib__Fun;
   var
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ =
      [0,
       [11, "minor_collections:      ", [4, 0, 0, 0, [12, 10, 0]]],
       "minor_collections:      %d\n"],
    _b_ =
      [0,
       [11, "major_collections:      ", [4, 0, 0, 0, [12, 10, 0]]],
       "major_collections:      %d\n"],
    _c_ =
      [0,
       [11, "compactions:            ", [4, 0, 0, 0, [12, 10, 0]]],
       "compactions:            %d\n"],
    _d_ =
      [0,
       [11, "forced_major_collections: ", [4, 0, 0, 0, [12, 10, 0]]],
       "forced_major_collections: %d\n"],
    _e_ = [0, [12, 10, 0], cst],
    _f_ = [0, [8, [0, 0, 0], 0, [0, 0], 0], "%.0f"],
    _g_ =
      [0,
       [11, "minor_words:    ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "minor_words:    %*.0f\n"],
    _h_ =
      [0,
       [11, "promoted_words: ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "promoted_words: %*.0f\n"],
    _i_ =
      [0,
       [11, "major_words:    ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "major_words:    %*.0f\n"],
    _j_ = [0, [12, 10, 0], cst],
    _k_ = [0, [4, 0, 0, 0, 0], "%d"],
    _l_ =
      [0,
       [11, "top_heap_words: ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "top_heap_words: %*d\n"],
    _m_ =
      [0,
       [11, "heap_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "heap_words:     %*d\n"],
    _n_ =
      [0,
       [11, "live_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "live_words:     %*d\n"],
    _o_ =
      [0,
       [11, "free_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "free_words:     %*d\n"],
    _p_ =
      [0,
       [11, "largest_free:   ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "largest_free:   %*d\n"],
    _q_ =
      [0,
       [11, "fragments:      ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "fragments:      %*d\n"],
    _r_ = [0, [12, 10, 0], cst],
    _s_ =
      [0,
       [11, "live_blocks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "live_blocks: %d\n"],
    _t_ =
      [0,
       [11, "free_blocks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "free_blocks: %d\n"],
    _u_ =
      [0,
       [11, "heap_chunks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "heap_chunks: %d\n"];
   function eventlog_pause(param){return 0;}
   function eventlog_resume(param){return 0;}
   function print_stat(c){
    var st = runtime.caml_gc_stat(0);
    caml_call3(Stdlib_Printf[1], c, _a_, st[4]);
    caml_call3(Stdlib_Printf[1], c, _b_, st[5]);
    caml_call3(Stdlib_Printf[1], c, _c_, st[14]);
    caml_call3(Stdlib_Printf[1], c, _d_, st[17]);
    caml_call2(Stdlib_Printf[1], c, _e_);
    var l1 = caml_ml_string_length(caml_call2(Stdlib_Printf[4], _f_, st[1]));
    caml_call4(Stdlib_Printf[1], c, _g_, l1, st[1]);
    caml_call4(Stdlib_Printf[1], c, _h_, l1, st[2]);
    caml_call4(Stdlib_Printf[1], c, _i_, l1, st[3]);
    caml_call2(Stdlib_Printf[1], c, _j_);
    var l2 = caml_ml_string_length(caml_call2(Stdlib_Printf[4], _k_, st[15]));
    caml_call4(Stdlib_Printf[1], c, _l_, l2, st[15]);
    caml_call4(Stdlib_Printf[1], c, _m_, l2, st[6]);
    caml_call4(Stdlib_Printf[1], c, _n_, l2, st[8]);
    caml_call4(Stdlib_Printf[1], c, _o_, l2, st[10]);
    caml_call4(Stdlib_Printf[1], c, _p_, l2, st[12]);
    caml_call4(Stdlib_Printf[1], c, _q_, l2, st[13]);
    caml_call2(Stdlib_Printf[1], c, _r_);
    caml_call3(Stdlib_Printf[1], c, _s_, st[9]);
    caml_call3(Stdlib_Printf[1], c, _t_, st[11]);
    return caml_call3(Stdlib_Printf[1], c, _u_, st[7]);
   }
   function allocated_bytes(param){
    var
     match = runtime.caml_gc_counters(0),
     ma = match[3],
     pro = match[2],
     mi = match[1];
    return (mi + ma - pro) * (Stdlib_Sys[9] / 8 | 0);
   }
   function create_alarm(f){return caml_call1(Stdlib_Atomic[1], 1);}
   function delete_alarm(a){return caml_call2(Stdlib_Atomic[3], a, 0);}
   function _v_(param){return 0;}
   function _w_(param){return 0;}
   function _x_(param){return 0;}
   function _y_(param){return 0;}
   var null_tracker = [0, function(param){return 0;}, _y_, _x_, _w_, _v_];
   function start(sampling_rate, opt, tracker){
    if(opt)
     var sth = opt[1], callstack_size = sth;
    else
     var callstack_size = Stdlib[19];
    return runtime.caml_memprof_start(sampling_rate, callstack_size, tracker);
   }
   var _z_ = [0, null_tracker, start, runtime.caml_memprof_stop];
   function _A_(_E_){return runtime.caml_final_release(_E_);}
   var
    _B_ = runtime.caml_final_register_called_without_value,
    Stdlib_Gc =
      [0,
       print_stat,
       allocated_bytes,
       function(_D_, _C_){return runtime.caml_final_register(_D_, _C_);},
       _B_,
       _A_,
       create_alarm,
       delete_alarm,
       eventlog_pause,
       eventlog_resume,
       _z_];
   runtime.caml_register_global(26, Stdlib_Gc, "Stdlib__Gc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Digest
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[10],
    equal = Stdlib_String[9],
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1,
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_substring = "Digest.substring";
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[44], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[44], b), ofs, len);
   }
   function file(filename){
    var ic = caml_call1(Stdlib[80], filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_call1(Stdlib[93], ic);
    return d;
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function char_hex(n){var _e_ = 10 <= n ? 87 : 48; return n + _e_ | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var _d_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[44], result);
     var i = _d_;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      _a_ = digit(caml_string_get(s, i$0 + 1 | 0)),
      _b_ = (digit(caml_string_get(s, i$0)) << 4) + _a_ | 0;
     runtime.caml_bytes_set(result, i, caml_call1(Stdlib_Char[1], _b_));
     var _c_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[44], result);
     var i = _c_;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bigarray
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    float32 = 0,
    float64 = 1,
    int8_signed = 2,
    int8_unsigned = 3,
    int16_signed = 4,
    int16_unsigned = 5,
    int32 = 6,
    int64 = 7,
    int$0 = 8,
    nativeint = 9,
    complex32 = 10,
    complex64 = 11,
    char$0 = 12;
   function kind_size_in_bytes(param){
    switch(param){
      case 0:
       return 4;
      case 1:
       return 8;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 4;
      case 7:
       return 8;
      case 8:
       return Stdlib_Sys[9] / 8 | 0;
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 10:
       return 8;
      case 11:
       return 16;
      default: return 1;
    }
   }
   var c_layout = 0, fortran_layout = 1;
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1){
     caml_ba_set_generic(arr, idx, caml_call1(f, idx));
     return;
    }
    var _am_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var j = _al_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var _an_ = j + 1 | 0;
      if(_am_ === j) break;
      var j = _an_;
     }
    }
    return;
   }
   function floop(arr, idx, f, col, max){
    if(0 > col){caml_ba_set_generic(arr, idx, caml_call1(f, idx)); return;}
    var _aj_ = caml_check_bound(max, col)[1 + col], _ai_ = 1;
    if(_aj_ >= 1){
     var j = _ai_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var _ak_ = j + 1 | 0;
      if(_aj_ === j) break;
      var j = _ak_;
     }
    }
    return;
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), dlen = dims.length - 1;
    return layout
            ? (floop
               (arr, caml_make_vect(dlen, 1), f, dlen - 1 | 0, dims),
              arr)
            : (cloop(arr, caml_make_vect(dlen, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     _af_ = n - 1 | 0,
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var _ag_ = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[1 + i] = _ag_;
      var _ah_ = i + 1 | 0;
      if(_af_ === i) break;
      var i = _ah_;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var
     _ac_ = dims(arr),
     _ad_ = caml_call3(Stdlib_Array[17], caml_mul, 1, _ac_);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _ad_);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var _aa_ = [0];
    return function(_ab_){return caml_ba_set_generic(arr, _aa_, _ab_);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var _$_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _$_);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var _Z_ = 1;
     if(dim >= 1){
      var i$0 = _Z_;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var ___ = i$0 + 1 | 0;
       if(dim === i$0) break;
       var i$0 = ___;
      }
     }
     return arr;
    }
    var _X_ = dim - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      var i = _Y_;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     _U_ = data.length - 1 - 1 | 0,
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      var i = _V_;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var _R_ = caml_ba_dim_2(arr), _S_ = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _S_), _R_);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var _N_ = 1;
     if(dim2 >= 1){
      var j$0 = _N_;
      for(;;){
       var _O_ = 1;
       if(dim1 >= 1){
        var i$0 = _O_;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var _Q_ = i$0 + 1 | 0;
         if(dim1 === i$0) break;
         var i$0 = _Q_;
        }
       }
       var _P_ = j$0 + 1 | 0;
       if(dim2 === j$0) break;
       var j$0 = _P_;
      }
     }
     return arr;
    }
    var _I_ = dim1 - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _K_ = dim2 - 1 | 0, _J_ = 0;
      if(_K_ >= 0){
       var j = _J_;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var _M_ = j + 1 | 0;
        if(_K_ === j) break;
        var j = _M_;
       }
      }
      var _L_ = i + 1 | 0;
      if(_I_ === i) break;
      var i = _L_;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     _C_ = dim1 - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array2_of_array_n);
      var _E_ = dim2 - 1 | 0, _D_ = 0;
      if(_E_ >= 0){
       var j = _D_;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
        var _G_ = j + 1 | 0;
        if(_E_ === j) break;
        var j = _G_;
       }
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      var i = _F_;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     _y_ = runtime.caml_ba_dim_3(arr),
     _z_ = caml_ba_dim_2(arr),
     _A_ = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _A_), _z_),
             _y_);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var _s_ = 1;
     if(dim3 >= 1){
      var k$0 = _s_;
      for(;;){
       var _t_ = 1;
       if(dim2 >= 1){
        var j$0 = _t_;
        for(;;){
         var _v_ = 1;
         if(dim1 >= 1){
          var i$0 = _v_;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var _x_ = i$0 + 1 | 0;
           if(dim1 === i$0) break;
           var i$0 = _x_;
          }
         }
         var _w_ = j$0 + 1 | 0;
         if(dim2 === j$0) break;
         var j$0 = _w_;
        }
       }
       var _u_ = k$0 + 1 | 0;
       if(dim3 === k$0) break;
       var k$0 = _u_;
      }
     }
     return arr;
    }
    var _k_ = dim1 - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _m_ = dim2 - 1 | 0, _l_ = 0;
      if(_m_ >= 0){
       var j = _l_;
       for(;;){
        var _p_ = dim3 - 1 | 0, _o_ = 0;
        if(_p_ >= 0){
         var k = _o_;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var _r_ = k + 1 | 0;
          if(_p_ === k) break;
          var k = _r_;
         }
        }
        var _q_ = j + 1 | 0;
        if(_m_ === j) break;
        var j = _q_;
       }
      }
      var _n_ = i + 1 | 0;
      if(_k_ === i) break;
      var i = _n_;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     _b_ = dim1 - 1 | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n);
      var _d_ = dim2 - 1 | 0, _c_ = 0;
      if(_d_ >= 0){
       var j = _c_;
       for(;;){
        var col = caml_check_bound(row, j)[1 + j];
        if(col.length - 1 !== dim3)
         caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n$0);
        var _g_ = dim3 - 1 | 0, _f_ = 0;
        if(_g_ >= 0){
         var k = _f_;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[1 + k]);
          var _i_ = k + 1 | 0;
          if(_g_ === k) break;
          var k = _i_;
         }
        }
        var _h_ = j + 1 | 0;
        if(_d_ === j) break;
        var j = _h_;
       }
      }
      var _e_ = i + 1 | 0;
      if(_b_ === i) break;
      var i = _e_;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$0,
       int32,
       int64,
       nativeint,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Random
//# unitInfo: Requires: Stdlib, Stdlib__Bigarray, Stdlib__Bytes, Stdlib__Digest, Stdlib__Domain, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_blit = runtime.caml_ba_blit,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_lxm_next = runtime.caml_lxm_next,
    caml_mod = runtime.caml_mod,
    caml_notequal = runtime.caml_notequal,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    serialization_prefix = "lxm1:",
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    _j_ = runtime.caml_int64_create_lo_mi_hi(14371852, 15349651, 22696),
    _k_ = runtime.caml_int64_create_lo_mi_hi(12230193, 11438743, 35013),
    _l_ = runtime.caml_int64_create_lo_mi_hi(1424933, 15549263, 2083),
    _m_ = runtime.caml_int64_create_lo_mi_hi(9492471, 4696708, 43520),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64",
    cst_Random_int32 = "Random.int32",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int = "Random.int",
    cst_Random_State_of_binary_str =
      "Random.State.of_binary_string: expected a format compatible with OCaml ",
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function create(param){return caml_call3(Stdlib_Bigarray[19][1], 7, 0, 4);}
   function set(s, i1, i2, i3, i4){
    caml_ba_set_1(s, 0, runtime.caml_int64_or(i1, _a_));
    caml_ba_set_1(s, 1, i2);
    var i3$0 = caml_notequal(i3, _b_) ? i3 : _e_;
    caml_ba_set_1(s, 2, i3$0);
    var i4$0 = caml_notequal(i4, _c_) ? i4 : _d_;
    return caml_ba_set_1(s, 3, i4$0);
   }
   function mk(i1, i2, i3, i4){
    var s = create(0);
    set(s, i1, i2, i3, i4);
    return s;
   }
   var serialization_prefix_len = 5;
   function to_binary_string(s){
    var buf = caml_create_bytes(37);
    caml_call5
     (Stdlib_Bytes[12],
      serialization_prefix,
      0,
      buf,
      0,
      serialization_prefix_len);
    var i = 0;
    for(;;){
     var _y_ = runtime.caml_ba_get_1(s, i);
     caml_call3(Stdlib_Bytes[86], buf, 5 + (i * 8 | 0) | 0, _y_);
     var _z_ = i + 1 | 0;
     if(3 === i) return caml_call1(Stdlib_Bytes[44], buf);
     var i = _z_;
    }
   }
   function of_binary_string(buf){
    var
     _v_ = runtime.caml_ml_string_length(buf) !== 37 ? 1 : 0,
     _w_ = _v_ || 1 - caml_call2(Stdlib_String[11], serialization_prefix, buf);
    if(_w_){
     var
      _x_ =
        caml_call2(Stdlib[28], cst_Random_State_of_binary_str, Stdlib_Sys[46]);
     caml_call1(Stdlib[2], _x_);
    }
    var
     i1 = caml_call2(Stdlib_String[64], buf, 5),
     i2 = caml_call2(Stdlib_String[64], buf, 13),
     i3 = caml_call2(Stdlib_String[64], buf, 21),
     i4 = caml_call2(Stdlib_String[64], buf, 29);
    return mk(i1, i2, i3, i4);
   }
   function copy(s){var s$0 = create(0); caml_ba_blit(s, s$0); return s$0;}
   function reinit(s, seed){
    var
     n = seed.length - 1,
     b = caml_create_bytes((n * 8 | 0) + 1 | 0),
     _p_ = n - 1 | 0,
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var _t_ = caml_int64_of_int32(runtime.caml_check_bound(seed, i)[1 + i]);
      caml_call3(Stdlib_Bytes[86], b, i * 8 | 0, _t_);
      var _u_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _u_;
     }
    }
    caml_bytes_set(b, n * 8 | 0, 1);
    var d1 = caml_call1(Stdlib_Digest[4], b);
    caml_bytes_set(b, n * 8 | 0, 2);
    var
     d2 = caml_call1(Stdlib_Digest[4], b),
     _q_ = caml_call2(Stdlib_String[64], d2, 8),
     _r_ = caml_call2(Stdlib_String[64], d2, 0),
     _s_ = caml_call2(Stdlib_String[64], d1, 8);
    return set(s, caml_call2(Stdlib_String[64], d1, 0), _s_, _r_, _q_);
   }
   function make(seed){var s = create(0); reinit(s, seed); return s;}
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function bits(s){
    return caml_int64_to_int32(caml_lxm_next(s)) & 1073741823;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var
      _n_ = Stdlib[19],
      r = caml_int64_to_int32(caml_lxm_next(s)) & _n_,
      v = caml_mod(r, bound);
     if(((Stdlib[19] - bound | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function bits32(s){return caml_int64_to_int32(caml_lxm_next(s));}
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return caml_call1(Stdlib[1], cst_Random_int32);
    for(;;){
     var r = bits32(s) >>> 1 | 0, v = caml_mod(r, bound);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      return v;
    }
   }
   var bits64 = caml_lxm_next;
   function int64(s, bound){
    if(caml_lessequal(bound, _g_))
     return caml_call1(Stdlib[1], cst_Random_int64);
    for(;;){
     var
      r = caml_int64_shift_right_unsigne(caml_lxm_next(s), 1),
      v = runtime.caml_int64_mod(r, bound);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), _f_)))
      return v;
    }
   }
   var
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(caml_lxm_next(s));},
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float$0(s, bound){
    for(;;){
     var b = caml_lxm_next(s), n = caml_int64_shift_right_unsigne(b, 11);
     if(caml_notequal(n, _h_))
      return runtime.caml_int64_to_float(n) * 1.1102230246251565e-16 * bound;
    }
   }
   function bool(s){return runtime.caml_lessthan(caml_lxm_next(s), _i_);}
   function split(s){
    var
     i1 = caml_lxm_next(s),
     i2 = caml_lxm_next(s),
     i3 = caml_lxm_next(s),
     i4 = caml_lxm_next(s);
    return mk(i1, i2, i3, i4);
   }
   function mk_default(param){return mk(_m_, _l_, _k_, _j_);}
   var random_key = caml_call2(Stdlib_Domain[10][1], [0, split], mk_default);
   function bits$0(param){
    return bits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function int$1(bound){
    return int$0(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function full_int$0(bound){
    return full_int(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int32$0(bound){
    return int32(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function nativeint$0(bound){
    return nativeint(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int64$0(bound){
    return int64(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function float$1(scale){
    return float$0(caml_call1(Stdlib_Domain[10][2], random_key), scale);
   }
   function bool$0(param){
    return bool(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits32$0(param){
    return bits32(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits64$0(param){
    return caml_lxm_next(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function nativebits$0(param){
    return nativebits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function full_init(seed){
    return reinit(caml_call1(Stdlib_Domain[10][2], random_key), seed);
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(param){return full_init(caml_sys_random_seed(0));}
   function split$0(param){
    return split(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function get_state(param){
    return copy(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function set_state(s){
    return caml_ba_blit(s, caml_call1(Stdlib_Domain[10][2], random_key));
   }
   var
    Stdlib_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits,
        split,
        to_binary_string,
        of_binary_string],
       get_state,
       set_state,
       split$0];
   runtime.caml_register_global(32, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Hashtbl
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Atomic, Stdlib__Domain, Stdlib__Int, Stdlib__Random, Stdlib__Seq, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var
    Stdlib_String = global_data.Stdlib__String,
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format",
    _d_ = [0, 0];
   function ongoing_traversal(h){
    var _aB_ = h.length - 1 < 4 ? 1 : 0, _aC_ = _aB_ || (h[4] < 0 ? 1 : 0);
    return _aC_;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   try{var _f_ = caml_sys_getenv("OCAMLRUNPARAM"), params = _f_;}
   catch(_az_){
    var _a_ = caml_wrap_exception(_az_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    try{var _e_ = caml_sys_getenv("CAMLRUNPARAM"), _c_ = _e_;}
    catch(_aA_){
     var _b_ = caml_wrap_exception(_aA_);
     if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
     var _c_ = cst;
    }
    var params = _c_;
   }
   var
    randomized_default = caml_call2(Stdlib_String[15], params, 82),
    randomized = caml_call1(Stdlib_Atomic[1], randomized_default);
   function randomize(param){
    return caml_call2(Stdlib_Atomic[3], randomized, 1);
   }
   function is_randomized(param){
    return caml_call1(Stdlib_Atomic[2], randomized);
   }
   var prng_key = caml_call2(Stdlib_Domain[10][1], 0, Stdlib_Random[15][2]);
   function power_2_above(x, n){
    var x$0 = x;
    for(;;){
     if(n <= x$0) return x$0;
     if(Stdlib_Sys[13] < (x$0 * 2 | 0)) return x$0;
     var x$1 = x$0 * 2 | 0, x$0 = x$1;
    }
   }
   function create(opt, initial_size){
    if(opt)
     var sth = opt[1], random = sth;
    else
     var random = caml_call1(Stdlib_Atomic[2], randomized);
    var s = power_2_above(16, initial_size);
    if(random)
     var
      _ay_ = caml_call1(Stdlib_Domain[10][2], prng_key),
      seed = caml_call1(Stdlib_Random[15][4], _ay_);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var _ax_ = 0 < h[1] ? 1 : 0;
    return _ax_
            ? (h
               [1]
              = 0,
              caml_call4(Stdlib_Array[7], h[2], 0, h[2].length - 1, 0))
            : _ax_;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== caml_call1(Stdlib[18], h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(caml_call1(Stdlib[18], h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     var prec = prec$0, param$0 = next$0;
    }
   }
   function copy(h){
    var
     _au_ = h[4],
     _av_ = h[3],
     _aw_ = caml_call2(Stdlib_Array[13], copy_bucketlist, h[2]);
    return [0, h[1], _aw_, _av_, _au_];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     _ao_ = odata.length - 1 - 1 | 0,
     _an_ = 0;
    if(_ao_ >= 0){
     var i$0 = _an_;
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
      for(;;){
       if(! cell) break;
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
       caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
       var cell = next;
      }
      var _at_ = i$0 + 1 | 0;
      if(_ao_ === i$0) break;
      var i$0 = _at_;
     }
    }
    if(inplace){
     var _aq_ = nsize - 1 | 0, _ap_ = 0;
     if(_aq_ >= 0){
      var i = _ap_;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
       if(match$0) match$0[3] = 0;
       var _as_ = i + 1 | 0;
       if(_aq_ === i) break;
       var i = _as_;
      }
     }
     var _ar_ = 0;
    }
    else
     var _ar_ = inplace;
    return _ar_;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     _am_ = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! _am_) return _am_;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], _ai_ = d.length - 1 - 1 | 0, _ah_ = 0;
     if(_ai_ >= 0){
      var i = _ah_;
      for(;;){
       var param = caml_check_bound(d, i)[1 + i];
       for(;;){
        if(! param) break;
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        var param = next;
       }
       var _al_ = i + 1 | 0;
       if(_ai_ === i) break;
       var i = _al_;
      }
     }
     var _aj_ = 1 - old_trav, _ak_ = _aj_ ? flip_ongoing_traversal(h) : _aj_;
     return _ak_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var _ad_ = d.length - 1 - 1 | 0, _ac_ = 0;
     if(_ad_ >= 0){
      var i = _ac_;
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, slot = slot$0;
       for(;;){
        if(! slot) break;
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[1 + i] = slot;
         slot[2] = data$0;
         var prec = slot, slot = next;
        }
        else{h[1] = h[1] - 1 | 0; var slot = next;}
       }
       if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[1 + i] = 0;
       var _ag_ = i + 1 | 0;
       if(_ad_ === i) break;
       var i = _ag_;
      }
     }
     var _ae_ = 1 - old_trav, _af_ = _ae_ ? flip_ongoing_traversal(h) : _ae_;
     return _af_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], _$_ = d.length - 1 - 1 | 0, ___ = 0;
     if(_$_ >= 0){
      var i = ___;
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[1 + i],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b) break;
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu),
         b = next,
         accu = accu$0;
       }
       accu$1[1] = accu;
       var _ab_ = i + 1 | 0;
       if(_$_ === i) break;
       var i = _ab_;
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var _aa_ = accu$1[1];
     return _aa_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var
      next = param$0[3],
      accu$1 = accu$0 + 1 | 0,
      accu$0 = accu$1,
      param$0 = next;
    }
   }
   function stats(h){
    var _U_ = h[2], _V_ = 0;
    function _W_(m, b){
     var _Z_ = bucket_length(0, b);
     return caml_call2(Stdlib_Int[11], m, _Z_);
    }
    var
     mbl = caml_call3(Stdlib_Array[17], _W_, _V_, _U_),
     histo = caml_make_vect(mbl + 1 | 0, 0),
     _X_ = h[2];
    function _Y_(b){
     var l = bucket_length(0, b);
     histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
     return 0;
    }
    caml_call2(Stdlib_Array[11], _Y_, _X_);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i, buck, param){
     var i$0 = i, buck$0 = buck;
     for(;;){
      if(buck$0){
       var key = buck$0[1], data = buck$0[2], next = buck$0[3];
       return [0, [0, key, data], function(_T_){return aux(i$0, next, _T_);}];
      }
      if(i$0 === tbl_data.length - 1) return 0;
      var
       buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
       i$1 = i$0 + 1 | 0,
       i$0 = i$1,
       buck$0 = buck$1;
     }
    }
    var _Q_ = 0, _R_ = 0;
    return function(_S_){return aux(_R_, _Q_, _S_);};
   }
   function to_seq_keys(m){
    var _N_ = to_seq(m);
    function _O_(_P_){return _P_[1];}
    return caml_call2(Stdlib_Seq[29], _O_, _N_);
   }
   function to_seq_values(m){
    var _K_ = to_seq(m);
    function _L_(_M_){return _M_[2];}
    return caml_call2(Stdlib_Seq[29], _L_, _K_);
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var _J_ = h[2].length - 1 - 1 | 0;
     return caml_call2(H[2], h[3], key) & _J_;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _I_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _I_ ? resize(key_index, h) : _I_;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      c = caml_check_bound(h[2], i)[1 + i],
      prec$0 = 0,
      prec = c;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[1 + i] = next, 0);
      }
      var prec$0 = prec, prec = next;
     }
    }
    function find(h, key){
     var
      _H_ = key_index(h, key),
      match = caml_check_bound(h[2], _H_)[1 + _H_];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      var param = next;
     }
    }
    function find_opt(h, key){
     var
      _G_ = key_index(h, key),
      match = caml_check_bound(h[2], _G_)[1 + _G_];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      var param = next;
     }
    }
    function find_all(h, key){
     var
      _F_ = key_index(h, key),
      param = caml_check_bound(h[2], _F_)[1 + _F_];
     for(;;){
      if(! param) return 0;
      var k = param[1], d = param[2], next = param[3];
      if(caml_call2(H[1], k, key)) break;
      var param = next;
     }
     var block = [0, d, 24029], dst = block, offset = 1, param$0 = next;
     for(;;){
      if(! param$0){dst[1 + offset] = 0; return block;}
      var k$0 = param$0[1], d$0 = param$0[2], next$0 = param$0[3];
      if(caml_call2(H[1], k$0, key)){
       var dst$0 = [0, d$0, 24029];
       dst[1 + offset] = dst$0;
       var dst = dst$0, offset = 1, param$0 = next$0;
      }
      else
       var param$0 = next$0;
     }
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[1 + i],
      slot = l;
     for(;;){
      if(slot){
       var k = slot[1], next = slot[3];
       if(! caml_call2(H[1], k, key)){var slot = next; continue;}
       slot[1] = key;
       slot[2] = data;
       var _C_ = 0;
      }
      else
       var _C_ = 1;
      if(_C_){
       caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var _D_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(_D_) return resize(key_index, h);
       var _E_ = _D_;
      }
      else
       var _E_ = _C_;
      return _E_;
     }
    }
    function mem(h, key){
     var
      _B_ = key_index(h, key),
      param = caml_check_bound(h[2], _B_)[1 + _B_];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], _A_ = caml_call2(H[1], k, key);
      if(_A_) return _A_;
      var param = next;
     }
    }
    function add_seq(tbl, i){
     function _z_(param){
      var v = param[2], k = param[1];
      return add(tbl, k, v);
     }
     return caml_call2(Stdlib_Seq[4], _z_, i);
    }
    function replace_seq(tbl, i){
     function _y_(param){
      var v = param[2], k = param[1];
      return replace(tbl, k, v);
     }
     return caml_call2(Stdlib_Seq[4], _y_, i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, seeded_hash]),
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21],
     _x_ = include[1];
    function create(sz){return caml_call2(_x_, _d_, sz);}
    function of_seq(i){
     var tbl = create(16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 1 - 1 | 0)
            : caml_call1(Stdlib[1], cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _w_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _w_ ? resize(key_index, h) : _w_;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     c = caml_check_bound(h[2], i)[1 + i],
     prec$0 = 0,
     prec = c;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[1 + i] = next, 0);
     }
     var prec$0 = prec, prec = next;
    }
   }
   function find(h, key){
    var _v_ = key_index(h, key), match = caml_check_bound(h[2], _v_)[1 + _v_];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     var param = next;
    }
   }
   function find_opt(h, key){
    var _u_ = key_index(h, key), match = caml_check_bound(h[2], _u_)[1 + _u_];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     var param = next;
    }
   }
   function find_all(h, key){
    var _t_ = key_index(h, key), param = caml_check_bound(h[2], _t_)[1 + _t_];
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(k, key)) break;
     var param = next;
    }
    var block = [0, data, 24029], dst = block, offset = 1, param$0 = next;
    for(;;){
     if(! param$0){dst[1 + offset] = 0; return block;}
     var k$0 = param$0[1], data$0 = param$0[2], next$0 = param$0[3];
     if(0 === caml_compare(k$0, key)){
      var dst$0 = [0, data$0, 24029];
      dst[1 + offset] = dst$0;
      var dst = dst$0, offset = 1, param$0 = next$0;
     }
     else
      var param$0 = next$0;
    }
   }
   function replace(h, key, data){
    var i = key_index(h, key), l = caml_check_bound(h[2], i)[1 + i], slot = l;
    for(;;){
     if(slot){
      var k = slot[1], next = slot[3];
      if(0 !== caml_compare(k, key)){var slot = next; continue;}
      slot[1] = key;
      slot[2] = data;
      var _q_ = 0;
     }
     else
      var _q_ = 1;
     if(_q_){
      caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var _r_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(_r_) return resize(key_index, h);
      var _s_ = _r_;
     }
     else
      var _s_ = _q_;
     return _s_;
    }
   }
   function mem(h, key){
    var _p_ = key_index(h, key), param = caml_check_bound(h[2], _p_)[1 + _p_];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      _o_ = 0 === caml_compare(k, key) ? 1 : 0;
     if(_o_) return _o_;
     var param = next;
    }
   }
   function add_seq(tbl, i){
    function _n_(param){
     var v = param[2], k = param[1];
     return add(tbl, k, v);
    }
    return caml_call2(Stdlib_Seq[4], _n_, i);
   }
   function replace_seq(tbl, i){
    function _m_(param){
     var v = param[2], k = param[1];
     return replace(tbl, k, v);
    }
    return caml_call2(Stdlib_Seq[4], _m_, i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    if(opt)
     var sth = opt[1], random = sth;
    else
     var random = caml_call1(Stdlib_Atomic[2], randomized);
    var s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      _g_ = caml_call1(Stdlib_Domain[10][2], prng_key),
      seed = caml_call1(Stdlib_Random[15][4], _g_);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     _h_ = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, _h_],
     _i_ = h$0[2],
     _j_ = h[2],
     _k_ = 0;
    insert_all_buckets
     (function(_l_){return key_index(h$0, _l_);}, _k_, _j_, _i_);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(16, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Weak
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Int, Stdlib__Obj, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Obj = global_data.Stdlib__Obj,
    cst_Weak_Make_hash_bucket_cann = "Weak.Make: hash bucket cannot grow more",
    cst_Weak_fill = "Weak.fill",
    cst_Weak_blit = "Weak.blit",
    cst_Weak_check = "Weak.check",
    cst_Weak_get_copy = "Weak.get_copy",
    cst_Weak_get = "Weak.get",
    cst_Weak_set = "Weak.set",
    cst_Weak_create = "Weak.create";
   function create(l){
    var
     _Z_ = 0 <= l ? 1 : 0,
     ___ = _Z_ ? l <= Stdlib_Obj[24][15] ? 1 : 0 : _Z_;
    if(1 - ___) caml_call1(Stdlib[1], cst_Weak_create);
    return runtime.caml_weak_create(l);
   }
   function length(x){return x.length - 1 - 2 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _W_ = 0 <= o ? 1 : 0,
     _X_ = _W_ ? o < length(e) ? 1 : 0 : _W_,
     _Y_ = 1 - _X_;
    return _Y_ ? caml_call1(Stdlib[1], msg) : _Y_;
   }
   function set(e, o, x){
    raise_if_invalid_offset(e, o, cst_Weak_set);
    if(! x) return runtime.caml_ephe_unset_key(e, o);
    var x$0 = x[1];
    return runtime.caml_ephe_set_key(e, o, x$0);
   }
   function get(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function check(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_check);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _U_ = 0 !== l ? 1 : 0,
      _V_ = _U_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _U_;
     return _V_;
    }
    return caml_call1(Stdlib[1], cst_Weak_blit);
   }
   function fill(ar, ofs, len, x){
    if(0 <= ofs && 0 <= len && (length(ar) - len | 0) >= ofs){
     var _S_ = (ofs + len | 0) - 1 | 0;
     if(_S_ >= ofs){
      var i = ofs;
      for(;;){
       set(ar, i, x);
       var _T_ = i + 1 | 0;
       if(_S_ === i) break;
       var i = _T_;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Weak_fill], 1);
   }
   function Make(H){
    var emptybucket = create(0);
    function get_index(t, h){
     return caml_mod(h & Stdlib[19], t[1].length - 1);
    }
    var limit = 7;
    function create$0(sz){
     var
      sz$0 = 7 <= sz ? sz : 7,
      sz$1 = Stdlib_Sys[13] < sz$0 ? Stdlib_Sys[13] : sz$0;
     return [0,
             caml_make_vect(sz$1, emptybucket),
             caml_make_vect(sz$1, [0]),
             limit,
             0,
             0];
    }
    function clear(t){
     var _Q_ = t[1].length - 1 - 1 | 0, _P_ = 0;
     if(_Q_ >= 0){
      var i = _P_;
      for(;;){
       caml_check_bound(t[1], i)[1 + i] = emptybucket;
       caml_check_bound(t[2], i)[1 + i] = [0];
       var _R_ = i + 1 | 0;
       if(_Q_ === i) break;
       var i = _R_;
      }
     }
     t[3] = limit;
     t[4] = 0;
     return 0;
    }
    function fold(f, t, init){
     var _N_ = t[1], i = 0;
     function _O_(b, accu$1){
      var i$0 = i, accu = accu$1;
      for(;;){
       if(length(b) <= i$0) return accu;
       var match = get(b, i$0);
       if(match)
        var
         v = match[1],
         accu$0 = caml_call2(f, v, accu),
         i$1 = i$0 + 1 | 0,
         i$0 = i$1,
         accu = accu$0;
       else
        var i$2 = i$0 + 1 | 0, i$0 = i$2;
      }
     }
     return caml_call3(Stdlib_Array[19], _O_, _N_, init);
    }
    function iter(f, t){
     var _L_ = t[1], i = 0;
     function _M_(b){
      var i$0 = i;
      for(;;){
       if(length(b) <= i$0) return 0;
       var match = get(b, i$0);
       if(match){
        var v = match[1];
        caml_call1(f, v);
        var i$1 = i$0 + 1 | 0, i$0 = i$1;
       }
       else
        var i$2 = i$0 + 1 | 0, i$0 = i$2;
      }
     }
     return caml_call2(Stdlib_Array[11], _M_, _L_);
    }
    function count_bucket(i, b, accu){
     var i$0 = i, accu$0 = accu;
     for(;;){
      if(length(b) <= i$0) return accu$0;
      var
       _K_ = check(b, i$0) ? 1 : 0,
       accu$1 = accu$0 + _K_ | 0,
       i$1 = i$0 + 1 | 0,
       i$0 = i$1,
       accu$0 = accu$1;
     }
    }
    function count(t){
     var _E_ = 0, _F_ = t[1], _G_ = 0;
     function _H_(_I_, _J_){return count_bucket(_G_, _I_, _J_);}
     return caml_call3(Stdlib_Array[19], _H_, _F_, _E_);
    }
    function add_aux(t, setter, d, h, index){
     var
      bucket$0 = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket$0),
      i$3 = 0;
     for(;;){
      if(sz <= i$3) break;
      if(! check(bucket$0, i$3)){
       caml_call3(setter, bucket$0, i$3, d);
       caml_check_bound(hashes, i$3)[1 + i$3] = h;
       return 0;
      }
      var i$5 = i$3 + 1 | 0, i$3 = i$5;
     }
     var
      newsz =
        caml_call2
         (Stdlib_Int[10],
          ((3 * sz | 0) / 2 | 0) + 3 | 0,
          Stdlib_Sys[13] - 2 | 0);
     if(newsz <= sz) caml_call1(Stdlib[2], cst_Weak_Make_hash_bucket_cann);
     var newbucket$0 = create(newsz), newhashes = caml_make_vect(newsz, 0);
     blit(bucket$0, 0, newbucket$0, 0, sz);
     caml_call5(Stdlib_Array[8], hashes, 0, newhashes, 0, sz);
     caml_call3(setter, newbucket$0, sz, d);
     caml_check_bound(newhashes, sz)[1 + sz] = h;
     caml_check_bound(t[1], index)[1 + index] = newbucket$0;
     caml_check_bound(t[2], index)[1 + index] = newhashes;
     var _A_ = sz <= t[3] ? 1 : 0, _B_ = _A_ ? t[3] < newsz ? 1 : 0 : _A_;
     if(_B_){
      t[4] = t[4] + 1 | 0;
      var i$4 = 0;
      for(;;){
       var
        _q_ = t[5],
        bucket = caml_check_bound(t[1], _q_)[1 + _q_],
        _r_ = t[5],
        hbucket = caml_check_bound(t[2], _r_)[1 + _r_],
        len = length(bucket),
        prev_len = (((len - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
        live = count_bucket(0, bucket, 0);
       if(live <= prev_len){
        var j$2 = length(bucket) - 1 | 0, i$0 = 0, j = j$2;
        for(;;){
         if(prev_len > j) break;
         if(check(bucket, i$0))
          var i$1 = i$0 + 1 | 0, i$0 = i$1;
         else if(check(bucket, j)){
          blit(bucket, j, bucket, i$0, 1);
          var _s_ = caml_check_bound(hbucket, j)[1 + j];
          caml_check_bound(hbucket, i$0)[1 + i$0] = _s_;
          var j$0 = j - 1 | 0, i$2 = i$0 + 1 | 0, i$0 = i$2, j = j$0;
         }
         else
          var j$1 = j - 1 | 0, j = j$1;
        }
        if(0 === prev_len){
         var _t_ = t[5];
         caml_check_bound(t[1], _t_)[1 + _t_] = emptybucket;
         var _u_ = t[5];
         caml_check_bound(t[2], _u_)[1 + _u_] = [0];
        }
        else{
         var newbucket = create(prev_len);
         blit(bucket, 0, newbucket, 0, prev_len);
         var _x_ = t[5];
         caml_check_bound(t[1], _x_)[1 + _x_] = newbucket;
         var
          _y_ = caml_call3(Stdlib_Array[5], hbucket, 0, prev_len),
          _z_ = t[5];
         caml_check_bound(t[2], _z_)[1 + _z_] = _y_;
        }
        var
         _v_ = t[3] < len ? 1 : 0,
         _w_ = _v_ ? prev_len <= t[3] ? 1 : 0 : _v_;
        if(_w_) t[4] = t[4] - 1 | 0;
       }
       t[5] = caml_mod(t[5] + 1 | 0, t[1].length - 1);
       var _D_ = i$4 + 1 | 0;
       if(2 === i$4) break;
       var i$4 = _D_;
      }
     }
     var _C_ = ((t[1].length - 1) / 2 | 0) < t[4] ? 1 : 0;
     if(! _C_) return _C_;
     var
      oldlen = t[1].length - 1,
      newlen =
        caml_call2
         (Stdlib_Int[10], ((3 * oldlen | 0) / 2 | 0) + 3 | 0, Stdlib_Sys[13]);
     if(oldlen < newlen){
      var
       newt = create$0(newlen),
       _o_ = t[1],
       i = 0,
       _p_ =
         function(j, ob){
          var oi = i;
          for(;;){
           if(length(ob) <= oi) return 0;
           if(check(ob, oi)){
            var
             oh = caml_check_bound(t[2], j)[1 + j],
             setter$0 =
               function(oi){
                function setter(nb, ni, param){
                 return blit(ob, oi, nb, ni, 1);
                }
                return setter;
               },
             setter = setter$0(oi),
             h = caml_check_bound(oh, oi)[1 + oi];
            add_aux(newt, setter, 0, h, get_index(newt, h));
            var i$0 = oi + 1 | 0, oi = i$0;
           }
           else
            var i$1 = oi + 1 | 0, oi = i$1;
          }
         };
      caml_call2(Stdlib_Array[12], _p_, _o_);
      t[1] = newt[1];
      t[2] = newt[2];
      t[3] = newt[3];
      t[4] = newt[4];
      t[5] = caml_mod(t[5], newt[1].length - 1);
      return 0;
     }
     t[3] = Stdlib[19];
     t[4] = 0;
     return 0;
    }
    function add(t, d){
     var h = caml_call1(H[2], d);
     return add_aux(t, set, [0, d], h, get_index(t, h));
    }
    function find_aux(t, d, found, notfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return caml_call2(notfound, h, index);
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var opt = get(bucket, i);
       if(opt){
        var v = opt[1];
        if(caml_call2(H[1], v, d))
         return caml_call4(found, bucket, i, opt, v);
       }
       var i$0 = i + 1 | 0, i = i$0;
      }
      else
       var i$1 = i + 1 | 0, i = i$1;
     }
    }
    function find_opt(t, d){
     function _n_(h, i){return 0;}
     return find_aux(t, d, function(b, i, o, v){return o;}, _n_);
    }
    function merge(t, d){
     function _m_(h, i){add_aux(t, set, [0, d], h, i); return d;}
     return find_aux(t, d, function(b, i, o, v){return v;}, _m_);
    }
    function find(t, d){
     function _l_(h, i){throw caml_maybe_attach_backtrace(Stdlib[8], 1);}
     return find_aux(t, d, function(b, i, o, v){return v;}, _l_);
    }
    function remove(t, d){
     function _k_(h, i){return 0;}
     return find_aux(t, d, function(b, i, o, v){return set(b, i, 0);}, _k_);
    }
    function mem(t, d){
     function _j_(h, i){return 0;}
     return find_aux(t, d, function(b, i, o, v){return 1;}, _j_);
    }
    function find_all(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0,
      accu = 0;
     for(;;){
      if(sz <= i) return accu;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var accu$0 = [0, v, accu], i$0 = i + 1 | 0, i = i$0, accu = accu$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0, i = i$1;
      }
      else
       var i$2 = i + 1 | 0, i = i$2;
     }
    }
    function stats(t){
     var
      len = t[1].length - 1,
      lens = caml_call2(Stdlib_Array[13], length, t[1]);
     caml_call2(Stdlib_Array[34], runtime.caml_int_compare, lens);
     var _a_ = 0;
     function _b_(_i_, _h_){return _i_ + _h_ | 0;}
     var
      totlen = caml_call3(Stdlib_Array[17], _b_, _a_, lens),
      _c_ = len - 1 | 0,
      _e_ = len / 2 | 0,
      _d_ = caml_check_bound(lens, _c_)[1 + _c_],
      _f_ = caml_check_bound(lens, _e_)[1 + _e_],
      _g_ = caml_check_bound(lens, 0)[1];
     return [0, len, count(t), totlen, _g_, _f_, _d_];
    }
    return [0,
            create$0,
            clear,
            merge,
            add,
            remove,
            find,
            find_opt,
            find_all,
            mem,
            iter,
            fold,
            count,
            stats];
   }
   var
    Stdlib_Weak =
      [0, create, length, set, get, get_copy, check, fill, blit, Make];
   runtime.caml_register_global(13, Stdlib_Weak, "Stdlib__Weak");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Format
//# unitInfo: Requires: CamlinternalFormat, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Domain, Stdlib__Int, Stdlib__List, Stdlib__Queue, Stdlib__Seq, Stdlib__Stack, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$16 = "",
    cst$15 = ">",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$14 = ".",
    cst$11 = cst$15,
    cst$12 = "<\/",
    cst$13 = cst$16,
    cst$8 = cst$15,
    cst$9 = "<",
    cst$10 = cst$16,
    cst$7 = "\n",
    cst$3 = cst$16,
    cst$4 = cst$16,
    cst$5 = cst$16,
    cst$6 = cst$16,
    cst = cst$16,
    cst$0 = cst$16,
    cst$1 = cst$16,
    cst$2 = cst$16,
    Stdlib_Queue = global_data.Stdlib__Queue,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _f_ = [3, 0, 3],
    cst_Format_pp_set_geometry = "Format.pp_set_geometry: ",
    _e_ = [1, "max_indent < 2"],
    _c_ = [1, "margin <= max_indent"],
    _d_ = [0, 0],
    _b_ = [0, cst$16],
    _a_ = [0, cst$16, 0, cst$16],
    cst_Stdlib_Format_String_tag = "Stdlib.Format.String_tag";
   function id(x){return x;}
   var
    String_tag =
      [248, cst_Stdlib_Format_String_tag, runtime.caml_fresh_oo_id(0)],
    zero = 0,
    unknown = -1;
   function pp_enqueue(state, token){
    state[13] = state[13] + token[3] | 0;
    return caml_call2(Stdlib_Queue[3], token, state[28]);
   }
   var pp_infinity = 1000000010;
   function pp_output_string(state, s){
    return caml_call3(state[17], s, 0, caml_ml_string_length(s));
   }
   function pp_output_newline(state){return caml_call1(state[19], 0);}
   function format_pp_text(state, size, text){
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
    return;
   }
   function format_string(state, s){
    var _bN_ = runtime.caml_string_notequal(s, cst$16);
    return _bN_ ? format_pp_text(state, caml_ml_string_length(s), s) : _bN_;
   }
   function break_new_line(state, param, width){
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
     indent = (state[6] - width | 0) + offset | 0,
     real_indent = caml_call2(Stdlib_Int[10], state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    var n = state[10];
    caml_call1(state[21], n);
    return format_string(state, after);
   }
   function break_line(state, width){
    return break_new_line(state, _a_, width);
   }
   function break_same_line(state, param){
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after);
   }
   function format_pp_token(state, size$0, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match$3 = caml_call1(Stdlib_Stack[8], state[3]);
        if(! match$3) return;
        var
         tabs = match$3[1][1],
         add_tab =
           function(n, ls){
            if(! ls) return [0, n, 0];
            var l = ls[2], x = ls[1];
            return runtime.caml_lessthan(n, x)
                    ? [0, n, ls]
                    : [0, x, add_tab(n, l)];
           };
        tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
        return;
       case 1:
        caml_call1(Stdlib_Stack[5], state[2]); return;
       case 2:
        caml_call1(Stdlib_Stack[5], state[3]); return;
       case 3:
        var match$4 = caml_call1(Stdlib_Stack[8], state[2]);
        if(! match$4) return pp_output_newline(state);
        var width$0 = match$4[1][2];
        return break_line(state, width$0);
       case 4:
        var _bL_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
        if(! _bL_) return _bL_;
        var match$1 = caml_call1(Stdlib_Queue[6], state[28]);
        if(! match$1) return;
        var match$2 = match$1[1], size = match$2[1], length = match$2[3];
        state[12] = state[12] - length | 0;
        state[9] = state[9] + size | 0;
        return;
       default:
        var match$5 = caml_call1(Stdlib_Stack[5], state[5]);
        if(! match$5) return;
        var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
        return pp_output_string(state, marker);
     }
    switch(param[0]){
      case 0:
       var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
       var
        breaks = param[2],
        fits = param[1],
        off = breaks[2],
        before = breaks[1],
        match$6 = caml_call1(Stdlib_Stack[8], state[2]);
       if(! match$6) return;
       var
        match$7 = match$6[1],
        width$1 = match$7[2],
        box_type$0 = match$7[1];
       switch(box_type$0){
         case 0:
          return break_same_line(state, fits);
         case 1:
          return break_new_line(state, breaks, width$1);
         case 2:
          return break_new_line(state, breaks, width$1);
         case 3:
          return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
         case 4:
          return state[11]
                  ? break_same_line(state, fits)
                  : state
                     [9]
                    < (size$0 + caml_ml_string_length(before) | 0)
                    ? break_new_line(state, breaks, width$1)
                    : ((state
                       [6]
                      - width$1
                      | 0)
                      + off
                      | 0)
                      < state[10]
                      ? break_new_line(state, breaks, width$1)
                      : break_same_line(state, fits);
         default: return break_same_line(state, fits);
       }
      case 2:
       var
        off$0 = param[2],
        n = param[1],
        insertion_point = state[6] - state[9] | 0,
        match$8 = caml_call1(Stdlib_Stack[8], state[3]);
       if(! match$8) return;
       var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
       if(match$9){
        var first = match$9[1], param$0 = tabs$0[1];
        for(;;){
         if(param$0){
          var tail = param$0[2], head = param$0[1];
          if(insertion_point > head){var param$0 = tail; continue;}
          var _bM_ = head;
         }
         else
          var _bM_ = first;
         var tab = _bM_;
         break;
        }
       }
       else
        var tab = insertion_point;
       var offset = tab - insertion_point | 0;
       return 0 <= offset
               ? break_same_line(state, [0, cst$0, offset + n | 0, cst])
               : break_new_line
                 (state, [0, cst$2, tab + off$0 | 0, cst$1], state[6]);
      case 3:
       var
        ty = param[2],
        off$1 = param[1],
        insertion_point$0 = state[6] - state[9] | 0;
       if(state[8] < insertion_point$0){
        var match = caml_call1(Stdlib_Stack[8], state[2]);
        if(match){
         var match$0 = match[1], width = match$0[2], box_type = match$0[1];
         if(state[9] < width && 3 >= box_type - 1 >>> 0)
          break_line(state, width);
        }
        else
         pp_output_newline(state);
       }
       var
        width$2 = state[9] - off$1 | 0,
        box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
       return caml_call2(Stdlib_Stack[3], [0, box_type$1, width$2], state[2]);
      case 4:
       var tbox = param[1];
       return caml_call2(Stdlib_Stack[3], tbox, state[3]);
      default:
       var
        tag_name$0 = param[1],
        marker$0 = caml_call1(state[24], tag_name$0);
       pp_output_string(state, marker$0);
       return caml_call2(Stdlib_Stack[3], tag_name$0, state[5]);
    }
   }
   function advance_left(state){
    for(;;){
     var match = caml_call1(Stdlib_Queue[9], state[28]);
     if(! match) return 0;
     var
      match$0 = match[1],
      size = match$0[1],
      length = match$0[3],
      token = match$0[2],
      pending_count = state[13] - state[12] | 0,
      _bJ_ = 0 <= size ? 1 : 0,
      _bK_ = _bJ_ || (state[9] <= pending_count ? 1 : 0);
     if(! _bK_) return _bK_;
     caml_call1(Stdlib_Queue[5], state[28]);
     var size$0 = 0 <= size ? size : pp_infinity;
     format_pp_token(state, size$0, token);
     state[12] = length + state[12] | 0;
    }
   }
   function enqueue_advance(state, tok){
    pp_enqueue(state, tok);
    return advance_left(state);
   }
   function enqueue_string_as(state, size, s){
    return enqueue_advance(state, [0, size, [0, s], size]);
   }
   function initialize_scan_stack(stack){
    caml_call1(Stdlib_Stack[9], stack);
    var queue_elem = [0, unknown, _b_, 0];
    return caml_call2(Stdlib_Stack[3], [0, -1, queue_elem], stack);
   }
   function set_size(state, ty){
    var match = caml_call1(Stdlib_Stack[8], state[1]);
    if(! match) return;
    var
     match$0 = match[1],
     queue_elem = match$0[2],
     left_total = match$0[1],
     size = queue_elem[1];
    if(left_total < state[12]) return initialize_scan_stack(state[1]);
    var _bI_ = queue_elem[2];
    if(typeof _bI_ !== "number")
     switch(_bI_[0]){
       case 3:
        if(1 - ty){
         queue_elem[1] = state[13] + size | 0;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
       case 1:
       case 2:
        if(ty){
         queue_elem[1] = state[13] + size | 0;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
     }
    return;
   }
   function scan_push(state, b, token){
    pp_enqueue(state, token);
    if(b) set_size(state, 1);
    var elem = [0, state[13], token];
    return caml_call2(Stdlib_Stack[3], elem, state[1]);
   }
   function pp_open_box_gen(state, indent, br_ty){
    state[14] = state[14] + 1 | 0;
    if(state[14] < state[15]){
     var size = - state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
     return scan_push(state, 0, elem);
    }
    var _bH_ = state[14] === state[15] ? 1 : 0;
    if(! _bH_) return _bH_;
    var s = state[16];
    return enqueue_string_as(state, caml_ml_string_length(s), s);
   }
   function pp_close_box(state, param){
    var _bF_ = 1 < state[14] ? 1 : 0;
    if(_bF_){
     if(state[14] < state[15]){
      pp_enqueue(state, [0, zero, 1, 0]);
      set_size(state, 1);
      set_size(state, 0);
     }
     state[14] = state[14] - 1 | 0;
     var _bG_ = 0;
    }
    else
     var _bG_ = _bF_;
    return _bG_;
   }
   function pp_open_stag(state, tag_name){
    if(state[22]){
     caml_call2(Stdlib_Stack[3], tag_name, state[4]);
     caml_call1(state[26], tag_name);
    }
    var _bE_ = state[23];
    if(! _bE_) return _bE_;
    var token = [5, tag_name];
    return pp_enqueue(state, [0, zero, token, 0]);
   }
   function pp_close_stag(state, param){
    if(state[23]) pp_enqueue(state, [0, zero, 5, 0]);
    var _bC_ = state[22];
    if(_bC_){
     var match = caml_call1(Stdlib_Stack[5], state[4]);
     if(match){
      var tag_name = match[1];
      return caml_call1(state[27], tag_name);
     }
     var _bD_ = 0;
    }
    else
     var _bD_ = _bC_;
    return _bD_;
   }
   function pp_set_print_tags(state, b){state[22] = b; return 0;}
   function pp_set_mark_tags(state, b){state[23] = b; return 0;}
   function pp_get_print_tags(state, param){return state[22];}
   function pp_get_mark_tags(state, param){return state[23];}
   function pp_set_tags(state, b){
    pp_set_print_tags(state, b);
    return pp_set_mark_tags(state, b);
   }
   function pp_get_formatter_stag_function(state, param){
    return [0, state[24], state[25], state[26], state[27]];
   }
   function pp_set_formatter_stag_function(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    state[24] = mot;
    state[25] = mct;
    state[26] = pot;
    state[27] = pct;
    return 0;
   }
   function pp_rinit(state){
    state[12] = 1;
    state[13] = 1;
    caml_call1(Stdlib_Queue[11], state[28]);
    initialize_scan_stack(state[1]);
    caml_call1(Stdlib_Stack[9], state[2]);
    caml_call1(Stdlib_Stack[9], state[3]);
    caml_call1(Stdlib_Stack[9], state[4]);
    caml_call1(Stdlib_Stack[9], state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    return pp_open_box_gen(state, 0, 3);
   }
   function pp_flush_queue(state, end_with_newline){
    var _bA_ = state[4];
    function _bB_(param){return pp_close_stag(state, 0);}
    caml_call2(Stdlib_Stack[13], _bB_, _bA_);
    for(;;){
     if(1 >= state[14]){
      state[13] = pp_infinity;
      advance_left(state);
      if(end_with_newline) pp_output_newline(state);
      return pp_rinit(state);
     }
     pp_close_box(state, 0);
    }
   }
   function pp_print_as_size(state, size, s){
    var _bz_ = state[14] < state[15] ? 1 : 0;
    return _bz_ ? enqueue_string_as(state, size, s) : _bz_;
   }
   function pp_print_as(state, isize, s){
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_string(state, s){
    return pp_print_as(state, caml_ml_string_length(s), s);
   }
   function pp_print_bytes(state, s){
    return pp_print_as
            (state,
             runtime.caml_ml_bytes_length(s),
             caml_call1(Stdlib_Bytes[6], s));
   }
   function pp_print_int(state, i){
    return pp_print_string(state, caml_call1(Stdlib_Int[12], i));
   }
   function pp_print_float(state, f){
    return pp_print_string(state, caml_call1(Stdlib[35], f));
   }
   function pp_print_bool(state, b){
    return pp_print_string(state, caml_call1(Stdlib[30], b));
   }
   function pp_print_char(state, c){
    return pp_print_as(state, 1, caml_call2(Stdlib_String[1], 1, c));
   }
   function pp_open_hbox(state, param){return pp_open_box_gen(state, 0, 0);}
   function pp_open_vbox(state, indent){
    return pp_open_box_gen(state, indent, 1);
   }
   function pp_open_hvbox(state, indent){
    return pp_open_box_gen(state, indent, 2);
   }
   function pp_open_hovbox(state, indent){
    return pp_open_box_gen(state, indent, 3);
   }
   function pp_open_box(state, indent){
    return pp_open_box_gen(state, indent, 4);
   }
   function pp_print_newline(state, param){
    pp_flush_queue(state, 1);
    return caml_call1(state[18], 0);
   }
   function pp_print_flush(state, param){
    pp_flush_queue(state, 0);
    return caml_call1(state[18], 0);
   }
   function pp_force_newline(state, param){
    var _by_ = state[14] < state[15] ? 1 : 0;
    return _by_ ? enqueue_advance(state, [0, zero, 3, 0]) : _by_;
   }
   function pp_print_if_newline(state, param){
    var _bx_ = state[14] < state[15] ? 1 : 0;
    return _bx_ ? enqueue_advance(state, [0, zero, 4, 0]) : _bx_;
   }
   function pp_print_custom_break(state, fits, breaks){
    var
     after = fits[3],
     width = fits[2],
     before = fits[1],
     _bw_ = state[14] < state[15] ? 1 : 0;
    if(! _bw_) return _bw_;
    var
     size = - state[13] | 0,
     token = [1, fits, breaks],
     length =
       (caml_ml_string_length(before) + width | 0)
       + caml_ml_string_length(after)
       | 0,
     elem = [0, size, token, length];
    return scan_push(state, 1, elem);
   }
   function pp_print_break(state, width, offset){
    return pp_print_custom_break
            (state, [0, cst$6, width, cst$5], [0, cst$4, offset, cst$3]);
   }
   function pp_print_space(state, param){return pp_print_break(state, 1, 0);}
   function pp_print_cut(state, param){return pp_print_break(state, 0, 0);}
   function pp_open_tbox(state, param){
    state[14] = state[14] + 1 | 0;
    var _bv_ = state[14] < state[15] ? 1 : 0;
    if(! _bv_) return _bv_;
    var elem = [0, zero, [4, [0, [0, 0]]], 0];
    return enqueue_advance(state, elem);
   }
   function pp_close_tbox(state, param){
    var _bs_ = 1 < state[14] ? 1 : 0;
    if(_bs_){
     var _bt_ = state[14] < state[15] ? 1 : 0;
     if(_bt_){
      var elem = [0, zero, 2, 0];
      enqueue_advance(state, elem);
      state[14] = state[14] - 1 | 0;
      var _bu_ = 0;
     }
     else
      var _bu_ = _bt_;
    }
    else
     var _bu_ = _bs_;
    return _bu_;
   }
   function pp_print_tbreak(state, width, offset){
    var _br_ = state[14] < state[15] ? 1 : 0;
    if(! _br_) return _br_;
    var size = - state[13] | 0, elem = [0, size, [2, width, offset], width];
    return scan_push(state, 1, elem);
   }
   function pp_print_tab(state, param){return pp_print_tbreak(state, 0, 0);}
   function pp_set_tab(state, param){
    var _bq_ = state[14] < state[15] ? 1 : 0;
    if(! _bq_) return _bq_;
    var elem = [0, zero, 0, 0];
    return enqueue_advance(state, elem);
   }
   function pp_set_max_boxes(state, n){
    var _bo_ = 1 < n ? 1 : 0, _bp_ = _bo_ ? (state[15] = n, 0) : _bo_;
    return _bp_;
   }
   function pp_get_max_boxes(state, param){return state[15];}
   function pp_over_max_boxes(state, param){return state[14] === state[15] ? 1 : 0;
   }
   function pp_set_ellipsis_text(state, s){state[16] = s; return 0;}
   function pp_get_ellipsis_text(state, param){return state[16];}
   function pp_limit(n){return n < 1000000010 ? n : 1000000009;}
   function pp_set_max_indent(state, n$0){
    var _bn_ = 1 < n$0 ? 1 : 0;
    if(! _bn_) return _bn_;
    var n$1 = state[6] - n$0 | 0, _bm_ = 1 <= n$1 ? 1 : 0;
    if(! _bm_) return _bm_;
    var n = pp_limit(n$1);
    state[7] = n;
    state[8] = state[6] - state[7] | 0;
    return pp_rinit(state);
   }
   function pp_get_max_indent(state, param){return state[8];}
   function pp_set_margin(state, n){
    var _bk_ = 1 <= n ? 1 : 0;
    if(! _bk_) return _bk_;
    var n$0 = pp_limit(n);
    state[6] = n$0;
    if(state[8] <= state[6])
     var new_max_indent = state[8];
    else
     var
      _bl_ =
        caml_call2(Stdlib_Int[11], state[6] - state[7] | 0, state[6] / 2 | 0),
      new_max_indent = caml_call2(Stdlib_Int[11], _bl_, 1);
    return pp_set_max_indent(state, new_max_indent);
   }
   function validate_geometry(param){
    var margin = param[2], max_indent = param[1];
    return 2 <= max_indent ? margin <= max_indent ? _c_ : _d_ : _e_;
   }
   function check_geometry(geometry){
    return 0 === validate_geometry(geometry)[0] ? 1 : 0;
   }
   function pp_get_margin(state, param){return state[6];}
   function pp_set_full_geometry(state, param){
    var margin = param[2], max_indent = param[1];
    pp_set_margin(state, margin);
    pp_set_max_indent(state, max_indent);
    return 0;
   }
   function pp_set_geometry(state, max_indent, margin){
    var
     geometry = [0, max_indent, margin],
     match = validate_geometry(geometry);
    if(0 === match[0]) return pp_set_full_geometry(state, geometry);
    var
     msg = match[1],
     _bj_ = caml_call2(Stdlib[28], cst_Format_pp_set_geometry, msg);
    throw caml_maybe_attach_backtrace([0, Stdlib[6], _bj_], 1);
   }
   function pp_safe_set_geometry(state, max_indent, margin){
    var geometry = [0, max_indent, margin];
    return 0 === validate_geometry(geometry)[0]
            ? pp_set_full_geometry(state, geometry)
            : 0;
   }
   function pp_get_geometry(state, param){return [0, state[8], state[6]];}
   function pp_update_geometry(state, update){
    var geometry = pp_get_geometry(state, 0);
    return pp_set_full_geometry(state, caml_call1(update, geometry));
   }
   function pp_set_formatter_out_functions(state, param){
    var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
    state[17] = f;
    state[18] = g;
    state[19] = h;
    state[20] = i;
    state[21] = j;
    return 0;
   }
   function pp_get_formatter_out_functions(state, param){
    return [0, state[17], state[18], state[19], state[20], state[21]];
   }
   function pp_set_formatter_output_functi(state, f, g){state[17] = f; state[18] = g; return 0;
   }
   function pp_get_formatter_output_functi(state, param){return [0, state[17], state[18]];
   }
   function display_newline(state, param){
    return caml_call3(state[17], cst$7, 0, 1);
   }
   var blank_line = caml_call2(Stdlib_String[1], 80, 32);
   function display_blanks(state, n){
    var n$0 = n;
    for(;;){
     var _bi_ = 0 < n$0 ? 1 : 0;
     if(! _bi_) return _bi_;
     if(80 >= n$0) return caml_call3(state[17], blank_line, 0, n$0);
     caml_call3(state[17], blank_line, 0, 80);
     var n$1 = n$0 - 80 | 0, n$0 = n$1;
    }
   }
   function pp_set_formatter_out_channel(state, oc){
    state[17] = caml_call1(Stdlib[69], oc);
    state[18] = function(param){return caml_call1(Stdlib[63], oc);};
    state[19] = function(_bh_){return display_newline(state, _bh_);};
    state[20] = function(_bg_){return display_blanks(state, _bg_);};
    state[21] = function(_bf_){return display_blanks(state, _bf_);};
    return 0;
   }
   function default_pp_mark_open_tag(param){
    if(param[1] !== String_tag) return cst$10;
    var s = param[2], _be_ = caml_call2(Stdlib[28], s, cst$8);
    return caml_call2(Stdlib[28], cst$9, _be_);
   }
   function default_pp_mark_close_tag(param){
    if(param[1] !== String_tag) return cst$13;
    var s = param[2], _bd_ = caml_call2(Stdlib[28], s, cst$11);
    return caml_call2(Stdlib[28], cst$12, _bd_);
   }
   function default_pp_print_open_tag(_bc_){return 0;}
   function default_pp_print_close_tag(_bb_){return 0;}
   function pp_make_formatter(f, g, h, i, j){
    var
     pp_queue = caml_call1(Stdlib_Queue[2], 0),
     sys_tok = [0, unknown, _f_, 0];
    caml_call2(Stdlib_Queue[3], sys_tok, pp_queue);
    var scan_stack = caml_call1(Stdlib_Stack[2], 0);
    initialize_scan_stack(scan_stack);
    caml_call2(Stdlib_Stack[3], [0, 1, sys_tok], scan_stack);
    var
     _a9_ = Stdlib[19],
     _a__ = caml_call1(Stdlib_Stack[2], 0),
     _a$_ = caml_call1(Stdlib_Stack[2], 0),
     _ba_ = caml_call1(Stdlib_Stack[2], 0);
    return [0,
            scan_stack,
            caml_call1(Stdlib_Stack[2], 0),
            _ba_,
            _a$_,
            _a__,
            78,
            10,
            68,
            78,
            0,
            1,
            1,
            1,
            1,
            _a9_,
            cst$14,
            f,
            g,
            h,
            i,
            j,
            0,
            0,
            default_pp_mark_open_tag,
            default_pp_mark_close_tag,
            default_pp_print_open_tag,
            default_pp_print_close_tag,
            pp_queue];
   }
   function formatter_of_out_functions(out_funs){
    return pp_make_formatter
            (out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5]);
   }
   function make_formatter(output, flush){
    function _a1_(_a8_){return 0;}
    function _a2_(_a7_){return 0;}
    var
     ppf =
       pp_make_formatter(output, flush, function(_a6_){return 0;}, _a2_, _a1_);
    ppf[19] = function(_a5_){return display_newline(ppf, _a5_);};
    ppf[20] = function(_a4_){return display_blanks(ppf, _a4_);};
    ppf[21] = function(_a3_){return display_blanks(ppf, _a3_);};
    return ppf;
   }
   function formatter_of_out_channel(oc){
    function _a0_(param){return caml_call1(Stdlib[63], oc);}
    return make_formatter(caml_call1(Stdlib[69], oc), _a0_);
   }
   function formatter_of_buffer(b){
    function _aY_(_aZ_){return 0;}
    return make_formatter(caml_call1(Stdlib_Buffer[18], b), _aY_);
   }
   var pp_buffer_size = 512;
   function pp_make_buffer(param){
    return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
   }
   var
    stdbuf = pp_make_buffer(0),
    std_formatter = formatter_of_out_channel(Stdlib[39]),
    err_formatter = formatter_of_out_channel(Stdlib[40]),
    str_formatter = formatter_of_buffer(stdbuf),
    stdbuf_key = caml_call2(Stdlib_Domain[10][1], 0, pp_make_buffer);
   caml_call2(Stdlib_Domain[10][3], stdbuf_key, stdbuf);
   function _g_(param){
    return formatter_of_buffer(caml_call1(Stdlib_Domain[10][2], stdbuf_key));
   }
   var str_formatter_key = caml_call2(Stdlib_Domain[10][1], 0, _g_);
   caml_call2(Stdlib_Domain[10][3], str_formatter_key, str_formatter);
   function buffered_out_string(key, str, ofs, len){
    var _aX_ = caml_call1(Stdlib_Domain[10][2], key);
    return caml_call4(Stdlib_Buffer[18], _aX_, str, ofs, len);
   }
   function buffered_out_flush(oc, key, param){
    var
     buf = caml_call1(Stdlib_Domain[10][2], key),
     len = caml_call1(Stdlib_Buffer[7], buf),
     str = caml_call1(Stdlib_Buffer[2], buf);
    caml_call4(Stdlib[69], oc, str, 0, len);
    caml_call1(Stdlib[63], oc);
    return caml_call1(Stdlib_Buffer[8], buf);
   }
   function _h_(param){return caml_call1(Stdlib_Buffer[1], pp_buffer_size);}
   var std_buf_key = caml_call2(Stdlib_Domain[10][1], 0, _h_);
   function _i_(param){return caml_call1(Stdlib_Buffer[1], pp_buffer_size);}
   var err_buf_key = caml_call2(Stdlib_Domain[10][1], 0, _i_);
   function _j_(param){
    function _aG_(_aW_){return 0;}
    function _aH_(_aV_){return 0;}
    function _aI_(_aU_){return 0;}
    var _aJ_ = Stdlib[39];
    function _aK_(_aT_){return buffered_out_flush(_aJ_, std_buf_key, _aT_);}
    var
     ppf =
       pp_make_formatter
        (function(_aQ_, _aR_, _aS_){
          return buffered_out_string(std_buf_key, _aQ_, _aR_, _aS_);
         },
         _aK_,
         _aI_,
         _aH_,
         _aG_);
    ppf[19] = function(_aP_){return display_newline(ppf, _aP_);};
    ppf[20] = function(_aO_){return display_blanks(ppf, _aO_);};
    ppf[21] = function(_aN_){return display_blanks(ppf, _aN_);};
    function _aL_(_aM_){return pp_print_flush(ppf, _aM_);}
    caml_call1(Stdlib_Domain[6], _aL_);
    return ppf;
   }
   var std_formatter_key = caml_call2(Stdlib_Domain[10][1], 0, _j_);
   caml_call2(Stdlib_Domain[10][3], std_formatter_key, std_formatter);
   function _k_(param){
    function _ap_(_aF_){return 0;}
    function _aq_(_aE_){return 0;}
    function _ar_(_aD_){return 0;}
    var _as_ = Stdlib[40];
    function _at_(_aC_){return buffered_out_flush(_as_, err_buf_key, _aC_);}
    var
     ppf =
       pp_make_formatter
        (function(_az_, _aA_, _aB_){
          return buffered_out_string(err_buf_key, _az_, _aA_, _aB_);
         },
         _at_,
         _ar_,
         _aq_,
         _ap_);
    ppf[19] = function(_ay_){return display_newline(ppf, _ay_);};
    ppf[20] = function(_ax_){return display_blanks(ppf, _ax_);};
    ppf[21] = function(_aw_){return display_blanks(ppf, _aw_);};
    function _au_(_av_){return pp_print_flush(ppf, _av_);}
    caml_call1(Stdlib_Domain[6], _au_);
    return ppf;
   }
   var err_formatter_key = caml_call2(Stdlib_Domain[10][1], 0, _k_);
   caml_call2(Stdlib_Domain[10][3], err_formatter_key, err_formatter);
   function get_std_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key);
   }
   function get_err_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], err_formatter_key);
   }
   function get_str_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], str_formatter_key);
   }
   function get_stdbuf(param){
    return caml_call1(Stdlib_Domain[10][2], stdbuf_key);
   }
   function flush_buffer_formatter(buf, ppf){
    pp_flush_queue(ppf, 0);
    var s = caml_call1(Stdlib_Buffer[2], buf);
    caml_call1(Stdlib_Buffer[9], buf);
    return s;
   }
   function flush_str_formatter(param){
    var
     stdbuf = caml_call1(Stdlib_Domain[10][2], stdbuf_key),
     str_formatter = caml_call1(Stdlib_Domain[10][2], str_formatter_key);
    return flush_buffer_formatter(stdbuf, str_formatter);
   }
   function make_synchronized_formatter(output, flush){
    function _an_(param){
     var
      buf = caml_call1(Stdlib_Buffer[1], pp_buffer_size),
      output$0 = caml_call1(Stdlib_Buffer[18], buf);
     function flush$0(param){
      var _ao_ = caml_call1(Stdlib_Buffer[7], buf);
      caml_call3(output, caml_call1(Stdlib_Buffer[2], buf), 0, _ao_);
      caml_call1(Stdlib_Buffer[8], buf);
      return caml_call1(flush, 0);
     }
     return make_formatter(output$0, flush$0);
    }
    return caml_call2(Stdlib_Domain[10][1], 0, _an_);
   }
   function synchronized_formatter_of_out_(oc){
    function _am_(param){return caml_call1(Stdlib[63], oc);}
    return make_synchronized_formatter(caml_call1(Stdlib[69], oc), _am_);
   }
   function make_symbolic_output_buffer(param){return [0, 0];}
   function clear_symbolic_output_buffer(sob){sob[1] = 0; return 0;}
   function get_symbolic_output_buffer(sob){
    return caml_call1(Stdlib_List[10], sob[1]);
   }
   function flush_symbolic_output_buffer(sob){
    var items = get_symbolic_output_buffer(sob);
    clear_symbolic_output_buffer(sob);
    return items;
   }
   function add_symbolic_output_item(sob, item){sob[1] = [0, item, sob[1]]; return 0;
   }
   function formatter_of_symbolic_output_b(sob){
    function f(s, i, n){
     return add_symbolic_output_item
             (sob, [0, caml_call3(Stdlib_String[16], s, i, n)]);
    }
    function g(_al_){return add_symbolic_output_item(sob, 0);}
    function h(_ak_){return add_symbolic_output_item(sob, 1);}
    function i(n){return add_symbolic_output_item(sob, [1, n]);}
    function j(n){return add_symbolic_output_item(sob, [2, n]);}
    return pp_make_formatter(f, g, h, i, j);
   }
   function open_hbox(v){
    return pp_open_hbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_vbox(v){
    return pp_open_vbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_hvbox(v){
    return pp_open_hvbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_hovbox(v){
    return pp_open_hovbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_box(v){
    return pp_open_box(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_box(v){
    return pp_close_box
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_stag(v){
    return pp_open_stag
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_stag(v){
    return pp_close_stag
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_as(v, w){
    return pp_print_as
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function print_string(v){
    return pp_print_string
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_bytes(v){
    return pp_print_bytes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_int(v){
    return pp_print_int
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_float(v){
    return pp_print_float
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_char(v){
    return pp_print_char
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_bool(v){
    return pp_print_bool
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_break(v, w){
    return pp_print_break
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function print_cut(v){
    return pp_print_cut
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_space(v){
    return pp_print_space
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function force_newline(v){
    return pp_force_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_flush(v){
    return pp_print_flush
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_newline(v){
    return pp_print_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_if_newline(v){
    return pp_print_if_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_tbox(v){
    return pp_open_tbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_tbox(v){
    return pp_close_tbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_tbreak(v, w){
    return pp_print_tbreak
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function set_tab(v){
    return pp_set_tab(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_tab(v){
    return pp_print_tab
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_margin(v){
    return pp_set_margin
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_margin(v){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[6];
   }
   function set_max_indent(v){
    return pp_set_max_indent
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_max_indent(v){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[8];
   }
   function set_geometry(max_indent, margin){
    return pp_set_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key),
             max_indent,
             margin);
   }
   function safe_set_geometry(max_indent, margin){
    return pp_safe_set_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key),
             max_indent,
             margin);
   }
   function get_geometry(v){
    return pp_get_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function update_geometry(v){
    return pp_update_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_max_boxes(v){
    return pp_set_max_boxes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_max_boxes(v){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[15];
   }
   function over_max_boxes(v){
    return pp_over_max_boxes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_ellipsis_text(v){
    return pp_set_ellipsis_text
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_ellipsis_text(v){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[16];
   }
   function set_formatter_out_channel(v){
    return pp_set_formatter_out_channel
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_out_functions(v){
    return pp_set_formatter_out_functions
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_formatter_out_functions(v){
    return pp_get_formatter_out_functions
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_output_functions(v, w){
    return pp_set_formatter_output_functi
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function get_formatter_output_functions(v){
    return pp_get_formatter_output_functi
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_stag_functions(v){
    return pp_set_formatter_stag_function
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_formatter_stag_functions(v){
    return pp_get_formatter_stag_function
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_print_tags(v){
    return pp_set_print_tags
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_print_tags(v){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[22];
   }
   function set_mark_tags(v){
    return pp_set_mark_tags
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_mark_tags(v){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[23];
   }
   function set_tags(v){
    return pp_set_tags(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function pp_print_iter(opt, iter, pp_v, ppf, v){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    var is_first = [0, 1];
    function pp_v$0(v){
     if(is_first[1]) is_first[1] = 0; else caml_call2(pp_sep, ppf, 0);
     return caml_call2(pp_v, ppf, v);
    }
    return caml_call2(iter, pp_v$0, v);
   }
   function pp_print_list(opt, pp_v, ppf, v){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_List[18], pp_v, ppf, v);
   }
   function pp_print_array(opt, pp_v, ppf, v){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_Array[11], pp_v, ppf, v);
   }
   function pp_print_seq(opt, pp_v, ppf, seq){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_Seq[4], pp_v, ppf, seq);
   }
   function pp_print_text(ppf, s){
    var len = caml_ml_string_length(s), left = [0, 0], right = [0, 0];
    function flush(param){
     pp_print_string
      (ppf, caml_call3(Stdlib_String[16], s, left[1], right[1] - left[1] | 0));
     right[1]++;
     left[1] = right[1];
     return 0;
    }
    for(;;){
     if(right[1] === len){
      var _aj_ = left[1] !== len ? 1 : 0;
      return _aj_ ? flush(0) : _aj_;
     }
     var match = runtime.caml_string_get(s, right[1]);
     if(10 === match){
      flush(0);
      pp_force_newline(ppf, 0);
     }
     else if(32 === match){flush(0); pp_print_space(ppf, 0);} else right[1]++;
    }
   }
   function pp_print_option(opt, pp_v, ppf, param){
    if(opt)
     var sth = opt[1], none = sth;
    else
     var none = function(param, _ai_){return 0;};
    if(! param) return caml_call2(none, ppf, 0);
    var v = param[1];
    return caml_call2(pp_v, ppf, v);
   }
   function pp_print_result(ok, error, ppf, param){
    if(0 === param[0]){var v = param[1]; return caml_call2(ok, ppf, v);}
    var e = param[1];
    return caml_call2(error, ppf, e);
   }
   function pp_print_either(left, right, ppf, param){
    if(0 === param[0]){var l = param[1]; return caml_call2(left, ppf, l);}
    var r = param[1];
    return caml_call2(right, ppf, r);
   }
   function compute_tag(output, tag_acc){
    var
     buf = caml_call1(Stdlib_Buffer[1], 16),
     ppf = formatter_of_buffer(buf);
    caml_call2(output, ppf, tag_acc);
    pp_print_flush(ppf, 0);
    var len = caml_call1(Stdlib_Buffer[7], buf);
    return 2 <= len
            ? caml_call3(Stdlib_Buffer[4], buf, 1, len - 2 | 0)
            : caml_call1(Stdlib_Buffer[2], buf);
   }
   function output_formatting_lit(ppf, fmting_lit){
    if(typeof fmting_lit === "number")
     switch(fmting_lit){
       case 0:
        return pp_close_box(ppf, 0);
       case 1:
        return pp_close_stag(ppf, 0);
       case 2:
        return pp_print_flush(ppf, 0);
       case 3:
        return pp_force_newline(ppf, 0);
       case 4:
        return pp_print_newline(ppf, 0);
       case 5:
        return pp_print_char(ppf, 64);
       default: return pp_print_char(ppf, 37);
     }
    switch(fmting_lit[0]){
      case 0:
       var offset = fmting_lit[3], width = fmting_lit[2];
       return pp_print_break(ppf, width, offset);
      case 1:
       return 0;
      default:
       var c = fmting_lit[1];
       pp_print_char(ppf, 64);
       return pp_print_char(ppf, c);
    }
   }
   function output_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          output_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           output_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(output_acc, acc$0)]);
          }
          var acc$1 = match[1];
          output_acc(ppf, p$0);
          var
           _$_ = compute_tag(output_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _$_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _aa_ = acc[1];
          if(typeof _aa_ !== "number" && 0 === _aa_[0]){
           var _ab_ = _aa_[2];
           if(typeof _ab_ !== "number" && 1 === _ab_[0]){
            var s$0 = acc[2], size = _ab_[2], p$2 = _aa_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _aa_;
          break a;
         case 3:
          var _ac_ = acc[1];
          if(typeof _ac_ !== "number" && 0 === _ac_[0]){
           var _ad_ = _ac_[2];
           if(typeof _ad_ !== "number" && 1 === _ad_[0]){
            var c$0 = acc[2], size$0 = _ad_[2], p$4 = _ac_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _ac_;
          break c;
         case 4:
          var _ae_ = acc[1];
          if(typeof _ae_ !== "number" && 0 === _ae_[0]){
           var _af_ = _ae_[2];
           if(typeof _af_ !== "number" && 1 === _af_[0]){
            var s$0 = acc[2], size = _af_[2], p$2 = _ae_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _ae_;
          break a;
         case 5:
          var _ag_ = acc[1];
          if(typeof _ag_ !== "number" && 0 === _ag_[0]){
           var _ah_ = _ag_[2];
           if(typeof _ah_ !== "number" && 1 === _ah_[0]){
            var c$0 = acc[2], size$0 = _ah_[2], p$4 = _ag_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _ag_;
          break c;
         case 6:
          var f$0 = acc[2], p$5 = acc[1];
          output_acc(ppf, p$5);
          return caml_call1(f$0, ppf);
         case 7:
          var p$6 = acc[1];
          output_acc(ppf, p$6);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$7 = acc[1];
          output_acc(ppf, p$7);
          return caml_call1(Stdlib[1], msg);
       }
       output_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      output_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     output_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    output_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function strput_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          strput_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           strput_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(strput_acc, acc$0)]);
          }
          var acc$1 = match[1];
          strput_acc(ppf, p$0);
          var
           _S_ = compute_tag(strput_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _S_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _T_ = acc[1];
          if(typeof _T_ !== "number" && 0 === _T_[0]){
           var _U_ = _T_[2];
           if(typeof _U_ !== "number" && 1 === _U_[0]){
            var s$0 = acc[2], size = _U_[2], p$2 = _T_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _T_;
          break a;
         case 3:
          var _V_ = acc[1];
          if(typeof _V_ !== "number" && 0 === _V_[0]){
           var _W_ = _V_[2];
           if(typeof _W_ !== "number" && 1 === _W_[0]){
            var c$0 = acc[2], size$0 = _W_[2], p$4 = _V_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _V_;
          break c;
         case 4:
          var _X_ = acc[1];
          if(typeof _X_ !== "number" && 0 === _X_[0]){
           var _Y_ = _X_[2];
           if(typeof _Y_ !== "number" && 1 === _Y_[0]){
            var s$0 = acc[2], size = _Y_[2], p$2 = _X_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _X_;
          break a;
         case 5:
          var _Z_ = acc[1];
          if(typeof _Z_ !== "number" && 0 === _Z_[0]){
           var ___ = _Z_[2];
           if(typeof ___ !== "number" && 1 === ___[0]){
            var c$0 = acc[2], size$0 = ___[2], p$4 = _Z_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _Z_;
          break c;
         case 6:
          var p$5 = acc[1];
          if(typeof p$5 !== "number" && 0 === p$5[0]){
           var match$1 = p$5[2];
           if(typeof match$1 !== "number" && 1 === match$1[0]){
            var f$1 = acc[2], size$1 = match$1[2], p$6 = p$5[1];
            strput_acc(ppf, p$6);
            return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0));
           }
          }
          var f$0 = acc[2];
          strput_acc(ppf, p$5);
          return pp_print_string(ppf, caml_call1(f$0, 0));
         case 7:
          var p$7 = acc[1];
          strput_acc(ppf, p$7);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$8 = acc[1];
          strput_acc(ppf, p$8);
          return caml_call1(Stdlib[1], msg);
       }
       strput_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      strput_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     strput_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    strput_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function kfprintf(k, ppf, param){
    var fmt = param[1], _Q_ = 0;
    function _R_(acc){output_acc(ppf, acc); return caml_call1(k, ppf);}
    return caml_call3(CamlinternalFormat[7], _R_, _Q_, fmt);
   }
   function ikfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, ppf, fmt);
   }
   function ifprintf(ppf, param){
    var fmt = param[1], _N_ = 0;
    function _O_(_P_){return 0;}
    return caml_call3(CamlinternalFormat[8], _O_, _N_, fmt);
   }
   function fprintf(ppf){
    function _K_(_M_){return 0;}
    return function(_L_){return kfprintf(_K_, ppf, _L_);};
   }
   function printf(param){
    var fmt = param[1], _I_ = 0;
    function _J_(acc){
     return output_acc
             (caml_call1(Stdlib_Domain[10][2], std_formatter_key), acc);
    }
    return caml_call3(CamlinternalFormat[7], _J_, _I_, fmt);
   }
   function eprintf(param){
    var fmt = param[1], _G_ = 0;
    function _H_(acc){
     return output_acc
             (caml_call1(Stdlib_Domain[10][2], err_formatter_key), acc);
    }
    return caml_call3(CamlinternalFormat[7], _H_, _G_, fmt);
   }
   function kdprintf(k, param){
    var fmt = param[1], _E_ = 0;
    function _F_(acc){
     return caml_call1(k, function(ppf){return output_acc(ppf, acc);});
    }
    return caml_call3(CamlinternalFormat[7], _F_, _E_, fmt);
   }
   function dprintf(fmt){return kdprintf(function(i){return i;}, fmt);}
   function ksprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     strput_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(id, fmt);}
   function kasprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     output_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function asprintf(fmt){return kasprintf(id, fmt);}
   function flush_standard_formatters(param){
    pp_print_flush(caml_call1(Stdlib_Domain[10][2], std_formatter_key), 0);
    return pp_print_flush
            (caml_call1(Stdlib_Domain[10][2], err_formatter_key), 0);
   }
   caml_call1(Stdlib[100], flush_standard_formatters);
   function _l_(param){
    flush_standard_formatters(0);
    var
     fs = pp_get_formatter_out_functions(std_formatter, 0),
     _m_ = fs[5],
     _n_ = fs[4],
     _o_ = fs[3],
     _p_ = Stdlib[39];
    function _q_(_D_){return buffered_out_flush(_p_, std_buf_key, _D_);}
    pp_set_formatter_out_functions
     (std_formatter,
      [0,
       function(_A_, _B_, _C_){
        return buffered_out_string(std_buf_key, _A_, _B_, _C_);
       },
       _q_,
       _o_,
       _n_,
       _m_]);
    var
     fs$0 = pp_get_formatter_out_functions(err_formatter, 0),
     _r_ = fs$0[5],
     _s_ = fs$0[4],
     _t_ = fs$0[3],
     _u_ = Stdlib[40];
    function _v_(_z_){return buffered_out_flush(_u_, err_buf_key, _z_);}
    return pp_set_formatter_out_functions
            (err_formatter,
             [0,
              function(_w_, _x_, _y_){
               return buffered_out_string(err_buf_key, _w_, _x_, _y_);
              },
              _v_,
              _t_,
              _s_,
              _r_]);
   }
   caml_call1(Stdlib_Domain[5], _l_);
   var
    Stdlib_Format =
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_bytes,
       print_bytes,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       synchronized_formatter_of_out_,
       std_formatter,
       get_std_formatter,
       err_formatter,
       get_err_formatter,
       formatter_of_buffer,
       stdbuf,
       get_stdbuf,
       str_formatter,
       get_str_formatter,
       flush_str_formatter,
       make_formatter,
       make_synchronized_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_iter,
       pp_print_list,
       pp_print_array,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf,
       printf,
       eprintf,
       sprintf,
       asprintf,
       dprintf,
       ifprintf,
       kfprintf,
       kdprintf,
       ikfprintf,
       ksprintf,
       kasprintf];
   runtime.caml_register_global(37, Stdlib_Format, "Stdlib__Format");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Scanf
//# unitInfo: Requires: CamlinternalFormat, CamlinternalFormatBasics, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Int, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = '"',
    cst$6 = "-",
    cst_character = "character ",
    cst_scanf_ml = "scanf.ml",
    cst_scanf_bad_conversion$3 = 'scanf: bad conversion "%*"',
    cst_scanning_of = "scanning of ",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$5,
    cst$4 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    cst$0 = cst$5,
    cst = cst$6,
    CamlinternalFormat = global_data.CamlinternalFormat,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    _r_ = [0, 91],
    _q_ = [0, 123],
    cst_end_of_input_not_found = "end of input not found",
    cst_scanf_bad_conversion_a = 'scanf: bad conversion "%a"',
    cst_scanf_bad_conversion_t = 'scanf: bad conversion "%t"',
    cst_scanf_missing_reader = "scanf: missing reader",
    _s_ = [0, cst_scanf_ml, 1414, 13],
    cst_scanf_bad_conversion_custo =
      'scanf: bad conversion "%?" (custom converter)',
    cst_scanf_bad_conversion = cst_scanf_bad_conversion$3,
    cst_scanf_bad_conversion$0 = cst_scanf_bad_conversion$3,
    cst_scanf_bad_conversion$1 = 'scanf: bad conversion "%-"',
    cst_scanf_bad_conversion$2 = cst_scanf_bad_conversion$3,
    _t_ = [0, [3, 0, [10, 0]], "%S%!"],
    cst_in_format = ' in format "',
    _p_ = [0, 37, ""],
    _o_ =
      [0,
       [11,
        "scanf: bad input at char number ",
        [4, 3, 0, 0, [11, ": ", [2, 0, 0]]]],
       "scanf: bad input at char number %i: %s"],
    _n_ =
      [0,
       [11, "the character ", [1, [11, " cannot start a boolean", 0]]],
       "the character %C cannot start a boolean"],
    _m_ =
      [0,
       [11, "bad character hexadecimal encoding \\", [0, [0, 0]]],
       "bad character hexadecimal encoding \\%c%c"],
    _l_ =
      [0,
       [11, "bad character decimal encoding \\", [0, [0, [0, 0]]]],
       "bad character decimal encoding \\%c%c%c"],
    cst_an = "an",
    cst_x = "x",
    cst_nfinity = "nfinity",
    cst_digits = "digits",
    _k_ =
      [0,
       [11,
        cst_character,
        [1, [11, " is not a valid ", [2, 0, [11, " digit", 0]]]]],
       "character %C is not a valid %s digit"],
    cst_decimal_digits = "decimal digits",
    _j_ =
      [0,
       [11, cst_character, [1, [11, " is not a decimal digit", 0]]],
       "character %C is not a decimal digit"],
    cst_0b = "0b",
    cst_0o = "0o",
    cst_0u = "0u",
    cst_0x = "0x",
    _i_ = [0, cst_scanf_ml, 516, 9],
    _h_ =
      [0,
       [11, "invalid boolean '", [2, 0, [12, 39, 0]]],
       "invalid boolean '%s'"],
    _g_ =
      [0,
       [11, "looking for ", [1, [11, ", found ", [1, 0]]]],
       "looking for %C, found %C"],
    cst_not_a_valid_float_in_hexad =
      "not a valid float in hexadecimal notation",
    cst_no_dot_or_exponent_part_fo =
      "no dot or exponent part found in float token",
    _f_ =
      [0,
       [11,
        cst_scanning_of,
        [2,
         0,
         [11,
          " failed: premature end of file occurred before end of token",
          0]]],
       "scanning of %s failed: premature end of file occurred before end of token"],
    _e_ =
      [0,
       [11,
        cst_scanning_of,
        [2,
         0,
         [11, " failed: the specified length was too short for token", 0]]],
       "scanning of %s failed: the specified length was too short for token"],
    _d_ =
      [0,
       [11, "illegal escape character ", [1, 0]],
       "illegal escape character %C"],
    cst_unnamed_function = "unnamed function",
    cst_unnamed_character_string = "unnamed character string",
    cst_unnamed_Stdlib_input_chann = "unnamed Stdlib input channel",
    cst_Stdlib_Scanf_Scan_failure = "Stdlib.Scanf.Scan_failure",
    cst_binary = "binary",
    cst_octal = "octal",
    cst_hexadecimal = "hexadecimal",
    cst_a_Char = "a Char",
    cst_a_String = "a String",
    null_char = 0;
   function next_char(ib){
    try{
     var c = caml_call1(ib[7], 0);
     ib[2] = c;
     ib[3] = 1;
     ib[4] = ib[4] + 1 | 0;
     if(10 === c) ib[5] = ib[5] + 1 | 0;
     return c;
    }
    catch(_bb_){
     var _ba_ = caml_wrap_exception(_bb_);
     if(_ba_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_ba_, 0);
     ib[2] = null_char;
     ib[3] = 0;
     ib[1] = 1;
     return null_char;
    }
   }
   function peek_char(ib){return ib[3] ? ib[2] : next_char(ib);}
   function checked_peek_char(ib){
    var c = peek_char(ib);
    if(ib[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
    return c;
   }
   function end_of_input(ib){peek_char(ib); return ib[1];}
   function beginning_of_input(ib){return 0 === ib[4] ? 1 : 0;}
   function name_of_input(ib){
    var match = ib[9];
    if(typeof match === "number")
     return 0 === match ? cst_unnamed_function : cst_unnamed_character_string;
    if(0 === match[0]) return cst_unnamed_Stdlib_input_chann;
    var fname = match[1];
    return fname;
   }
   function char_count(ib){return ib[3] ? ib[4] - 1 | 0 : ib[4];}
   function invalidate_current_char(ib){ib[3] = 0; return 0;}
   function token_string(ib){
    var
     token_buffer = ib[8],
     tok = caml_call1(Stdlib_Buffer[2], token_buffer);
    caml_call1(Stdlib_Buffer[8], token_buffer);
    ib[6] = ib[6] + 1 | 0;
    return tok;
   }
   function skip_char(width, ib){invalidate_current_char(ib); return width;}
   function ignore_char(width, ib){return skip_char(width - 1 | 0, ib);}
   function store_char(width, ib, c){
    caml_call2(Stdlib_Buffer[12], ib[8], c);
    return ignore_char(width, ib);
   }
   var default_token_buffer_size = 1024;
   function create(iname, next){
    return [0,
            0,
            null_char,
            0,
            0,
            0,
            0,
            next,
            caml_call1(Stdlib_Buffer[1], default_token_buffer_size),
            iname];
   }
   function from_string(s){
    var i = [0, 0], len = caml_ml_string_length(s);
    function next(param){
     if(len <= i[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     var c = caml_string_get(s, i[1]);
     i[1]++;
     return c;
    }
    return create(1, next);
   }
   var _a_ = 0;
   function from_function(_a$_){return create(_a_, _a$_);}
   var len = 1024;
   function scan_close_at_end(ic){
    caml_call1(Stdlib[93], ic);
    throw caml_maybe_attach_backtrace(Stdlib[12], 1);
   }
   function scan_raise_at_end(ic){
    throw caml_maybe_attach_backtrace(Stdlib[12], 1);
   }
   function from_ic(scan_close_ic, iname, ic){
    var
     buf = runtime.caml_create_bytes(1024),
     i = [0, 0],
     lim = [0, 0],
     eof = [0, 0];
    function next(param){
     if(i[1] < lim[1]){var c = caml_bytes_get(buf, i[1]); i[1]++; return c;}
     if(eof[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     lim[1] = caml_call4(Stdlib[84], ic, buf, 0, len);
     return 0 === lim[1]
             ? (eof[1] = 1, caml_call1(scan_close_ic, ic))
             : (i[1] = 1, caml_bytes_get(buf, 0));
    }
    return create(iname, next);
   }
   var stdin = from_ic(scan_raise_at_end, [1, cst, Stdlib[38]], Stdlib[38]);
   function open_in_file(open_in, fname){
    if(! caml_string_notequal(fname, cst$6)) return stdin;
    var ic = caml_call1(open_in, fname);
    return from_ic(scan_close_at_end, [1, fname, ic], ic);
   }
   var _b_ = Stdlib[79];
   function open_in(_a__){return open_in_file(_b_, _a__);}
   var _c_ = Stdlib[80];
   function open_in_bin(_a9_){return open_in_file(_c_, _a9_);}
   function from_channel(ic){return from_ic(scan_raise_at_end, [0, ic], ic);}
   function close_in(ib){
    var match = ib[9];
    if(typeof match === "number") return 0;
    if(0 === match[0]){var ic = match[1]; return caml_call1(Stdlib[93], ic);}
    var ic$0 = match[2];
    return caml_call1(Stdlib[93], ic$0);
   }
   var
    Scan_failure =
      [248, cst_Stdlib_Scanf_Scan_failure, runtime.caml_fresh_oo_id(0)];
   function bad_input(s){
    throw caml_maybe_attach_backtrace([0, Scan_failure, s], 1);
   }
   function bad_input_escape(c){
    return bad_input(caml_call2(Stdlib_Printf[4], _d_, c));
   }
   function bad_token_length(message){
    return bad_input(caml_call2(Stdlib_Printf[4], _e_, message));
   }
   function bad_float(param){
    return bad_input(cst_no_dot_or_exponent_part_fo);
   }
   function bad_hex_float(param){
    return bad_input(cst_not_a_valid_float_in_hexad);
   }
   function character_mismatch(c, ci){
    return bad_input(caml_call3(Stdlib_Printf[4], _g_, c, ci));
   }
   function check_char(ib, c$0){
    if(10 === c$0){
     var ci = checked_peek_char(ib);
     return 10 === ci
             ? invalidate_current_char(ib)
             : 13
               === ci
               ? (invalidate_current_char(ib), check_this_char(ib, 10))
               : character_mismatch(10, ci);
    }
    if(32 !== c$0) return check_this_char(ib, c$0);
    for(;;){
     var c = peek_char(ib), _a7_ = 1 - ib[1];
     if(! _a7_) return _a7_;
     var _a8_ = c - 9 | 0;
     a:
     {
      if(4 < _a8_ >>> 0){
       if(23 === _a8_) break a;
      }
      else if(1 < _a8_ - 2 >>> 0) break a;
      return 0;
     }
     invalidate_current_char(ib);
    }
   }
   function check_this_char(ib, c){
    var ci = checked_peek_char(ib);
    return ci === c ? invalidate_current_char(ib) : character_mismatch(c, ci);
   }
   function token_char(ib){return caml_string_get(token_string(ib), 0);}
   function token_bool(ib){
    var s = token_string(ib);
    return caml_string_notequal(s, "false")
            ? caml_string_notequal
               (s, "true")
              ? bad_input(caml_call2(Stdlib_Printf[4], _h_, s))
              : 1
            : 0;
   }
   function integer_conversion_of_char(param){
    var switcher = param - 88 | 0;
    if(32 >= switcher >>> 0)
     switch(switcher){
       case 10:
        return 0;
       case 12:
        return 1;
       case 17:
        return 2;
       case 23:
        return 3;
       case 29:
        return 4;
       case 0:
       case 32:
        return 5;
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   function token_int_literal(conv, ib){
    switch(conv){
      case 0:
       var
        _a3_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0b, _a3_);
       break;
      case 3:
       var
        _a4_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0o, _a4_);
       break;
      case 4:
       var
        _a5_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0u, _a5_);
       break;
      case 5:
       var
        _a6_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0x, _a6_);
       break;
      default: var tok = token_string(ib);
    }
    var l = caml_ml_string_length(tok);
    if(0 !== l && 43 === caml_string_get(tok, 0))
     return caml_call3(Stdlib_String[16], tok, 1, l - 1 | 0);
    return tok;
   }
   function token_float(ib){
    return runtime.caml_float_of_string(token_string(ib));
   }
   function scan_decimal_digit_star(width, ib){
    var width$0 = width;
    for(;;){
     if(0 === width$0) return width$0;
     var c = peek_char(ib);
     if(ib[1]) return width$0;
     if(58 <= c){
      if(95 === c){
       var width$1 = ignore_char(width$0, ib), width$0 = width$1;
       continue;
      }
     }
     else if(48 <= c){
      var width$2 = store_char(width$0, ib, c), width$0 = width$2;
      continue;
     }
     return width$0;
    }
   }
   function scan_decimal_digit_plus(width, ib){
    if(0 === width) return bad_token_length(cst_decimal_digits);
    var c = checked_peek_char(ib);
    if(9 < c - 48 >>> 0)
     return bad_input(caml_call2(Stdlib_Printf[4], _j_, c));
    var width$0 = store_char(width, ib, c);
    return scan_decimal_digit_star(width$0, ib);
   }
   function scan_digit_plus(basis, digitp, width$2, ib){
    if(0 === width$2) return bad_token_length(cst_digits);
    var c$0 = checked_peek_char(ib);
    if(! caml_call1(digitp, c$0))
     return bad_input(caml_call3(Stdlib_Printf[4], _k_, c$0, basis));
    var width$3 = store_char(width$2, ib, c$0), width = width$3;
    for(;;){
     if(0 === width) return width;
     var c = peek_char(ib);
     if(ib[1]) return width;
     if(caml_call1(digitp, c))
      var width$0 = store_char(width, ib, c), width = width$0;
     else{
      if(95 !== c) return width;
      var width$1 = ignore_char(width, ib), width = width$1;
     }
    }
   }
   function is_binary_digit(param){return 1 < param - 48 >>> 0 ? 0 : 1;}
   function scan_binary_int(_a1_, _a2_){
    return scan_digit_plus(cst_binary, is_binary_digit, _a1_, _a2_);
   }
   function is_octal_digit(param){return 7 < param - 48 >>> 0 ? 0 : 1;}
   function scan_octal_int(_aZ_, _a0_){
    return scan_digit_plus(cst_octal, is_octal_digit, _aZ_, _a0_);
   }
   function is_hexa_digit(param){
    var _aY_ = param - 48 | 0;
    a:
    {
     if(22 < _aY_ >>> 0){
      if(5 < _aY_ - 49 >>> 0) break a;
     }
     else if(6 >= _aY_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function scan_hexadecimal_int(_aW_, _aX_){
    return scan_digit_plus(cst_hexadecimal, is_hexa_digit, _aW_, _aX_);
   }
   function scan_sign(width, ib){
    var c = checked_peek_char(ib), switcher = c - 43 | 0;
    if(2 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return store_char(width, ib, c);
       case 1: break;
       default: return store_char(width, ib, c);
     }
    return width;
   }
   function scan_optionally_signed_decimal(width, ib){
    var width$0 = scan_sign(width, ib);
    return scan_decimal_digit_plus(width$0, ib);
   }
   function scan_int_conversion(conv, width$1, ib){
    switch(conv){
      case 0:
       return scan_binary_int(width$1, ib);
      case 1:
       return scan_optionally_signed_decimal(width$1, ib);
      case 2:
       var width$0 = scan_sign(width$1, ib), c = checked_peek_char(ib);
       if(48 !== c) return scan_decimal_digit_plus(width$0, ib);
       var width = store_char(width$0, ib, c);
       if(0 === width) return width;
       var c$0 = peek_char(ib);
       if(ib[1]) return width;
       a:
       {
        if(99 <= c$0){
         if(111 === c$0)
          return scan_octal_int(store_char(width, ib, c$0), ib);
         if(120 === c$0) break a;
        }
        else{
         if(88 === c$0) break a;
         if(98 <= c$0) return scan_binary_int(store_char(width, ib, c$0), ib);
        }
        return scan_decimal_digit_star(width, ib);
       }
       return scan_hexadecimal_int(store_char(width, ib, c$0), ib);
      case 3:
       return scan_octal_int(width$1, ib);
      case 4:
       return scan_decimal_digit_plus(width$1, ib);
      default: return scan_hexadecimal_int(width$1, ib);
    }
   }
   function scan_fractional_part(width, ib){
    if(0 === width) return width;
    var c = peek_char(ib);
    return ib[1]
            ? width
            : 9
              < c - 48 >>> 0
              ? width
              : scan_decimal_digit_star(store_char(width, ib, c), ib);
   }
   function scan_exponent_part(width, ib){
    if(0 === width) return width;
    var c = peek_char(ib);
    if(ib[1]) return width;
    if(69 !== c && 101 !== c) return width;
    return scan_optionally_signed_decimal(store_char(width, ib, c), ib);
   }
   function scan_float(width$1, precision, ib){
    var
     width = scan_sign(width$1, ib),
     width$0 = scan_decimal_digit_star(width, ib);
    if(0 === width$0) return [0, width$0, precision];
    var c = peek_char(ib);
    if(ib[1]) return [0, width$0, precision];
    if(46 !== c) return [0, scan_exponent_part(width$0, ib), precision];
    var
     width$2 = store_char(width$0, ib, c),
     precision$0 = caml_call2(Stdlib_Int[10], width$2, precision),
     width$3 =
       width$2 - (precision$0 - scan_fractional_part(precision$0, ib) | 0) | 0;
    return [0, scan_exponent_part(width$3, ib), precision$0];
   }
   function check_case_insensitive_string(width, ib, error, str){
    function lowercase(c){
     return 25 < c - 65 >>> 0
             ? c
             : caml_call1(Stdlib[29], (c - 65 | 0) + 97 | 0);
    }
    var
     len = caml_ml_string_length(str),
     width$0 = [0, width],
     _aT_ = len - 1 | 0,
     _aS_ = 0;
    if(_aT_ >= 0){
     var i = _aS_;
     for(;;){
      var c = peek_char(ib), _aU_ = lowercase(caml_string_get(str, i));
      if(lowercase(c) !== _aU_) caml_call1(error, 0);
      if(0 === width$0[1]) caml_call1(error, 0);
      width$0[1] = store_char(width$0[1], ib, c);
      var _aV_ = i + 1 | 0;
      if(_aT_ === i) break;
      var i = _aV_;
     }
    }
    return width$0[1];
   }
   function scan_hex_float(width, precision, ib){
    var _aF_ = 0 === width ? 1 : 0, _aG_ = _aF_ || end_of_input(ib);
    if(_aG_) bad_hex_float(0);
    var
     width$0 = scan_sign(width, ib),
     _aH_ = 0 === width$0 ? 1 : 0,
     _aI_ = _aH_ || end_of_input(ib);
    if(_aI_) bad_hex_float(0);
    var c = peek_char(ib);
    a:
    {
     if(78 <= c){
      var switcher = c - 79 | 0;
      if(30 < switcher >>> 0){
       if(32 <= switcher) break a;
       var
        width$1 = store_char(width$0, ib, c),
        _aJ_ = 0 === width$1 ? 1 : 0,
        _aK_ = _aJ_ || end_of_input(ib);
       if(_aK_) bad_hex_float(0);
       return check_case_insensitive_string
               (width$1, ib, bad_hex_float, cst_an);
      }
      if(26 !== switcher) break a;
     }
     else{
      if(48 === c){
       var
        width$3 = store_char(width$0, ib, c),
        _aN_ = 0 === width$3 ? 1 : 0,
        _aO_ = _aN_ || end_of_input(ib);
       if(_aO_) bad_hex_float(0);
       var
        width$4 =
          check_case_insensitive_string(width$3, ib, bad_hex_float, cst_x);
       if(0 !== width$4 && ! end_of_input(ib)){
        var _aP_ = peek_char(ib) - 46 | 0;
        b:
        {
         c:
         {
          if(34 < _aP_ >>> 0){
           if(66 === _aP_) break c;
          }
          else if(32 < _aP_ - 1 >>> 0) break c;
          var width$5 = scan_hexadecimal_int(width$4, ib);
          break b;
         }
         var width$5 = width$4;
        }
        if(0 !== width$5 && ! end_of_input(ib)){
         var c$0 = peek_char(ib);
         if(46 === c$0){
          var width$6 = store_char(width$5, ib, c$0);
          b:
          {
           if(0 !== width$6 && ! end_of_input(ib)){
            var match = peek_char(ib);
            c:
            {
             if(80 !== match && 112 !== match){
              var
               precision$0 = caml_call2(Stdlib_Int[10], width$6, precision),
               width$10 =
                 width$6
                 - (precision$0 - scan_hexadecimal_int(precision$0, ib) | 0)
                 | 0;
              break c;
             }
             var width$10 = width$6;
            }
            var width$7 = width$10;
            break b;
           }
           var width$7 = width$6;
          }
          var width$8 = width$7;
         }
         else
          var width$8 = width$5;
         if(0 !== width$8 && ! end_of_input(ib)){
          var c$1 = peek_char(ib);
          if(80 !== c$1 && 112 !== c$1) return width$8;
          var
           width$9 = store_char(width$8, ib, c$1),
           _aQ_ = 0 === width$9 ? 1 : 0,
           _aR_ = _aQ_ || end_of_input(ib);
          if(_aR_) bad_hex_float(0);
          return scan_optionally_signed_decimal(width$9, ib);
         }
         return width$8;
        }
        return width$5;
       }
       return width$4;
      }
      if(73 !== c) break a;
     }
     var
      width$2 = store_char(width$0, ib, c),
      _aL_ = 0 === width$2 ? 1 : 0,
      _aM_ = _aL_ || end_of_input(ib);
     if(_aM_) bad_hex_float(0);
     return check_case_insensitive_string
             (width$2, ib, bad_hex_float, cst_nfinity);
    }
    return bad_hex_float(0);
   }
   function scan_caml_float_rest(width, precision, ib){
    var _aB_ = 0 === width ? 1 : 0, _aC_ = _aB_ || end_of_input(ib);
    if(_aC_) bad_float(0);
    var
     width$0 = scan_decimal_digit_star(width, ib),
     _aD_ = 0 === width$0 ? 1 : 0,
     _aE_ = _aD_ || end_of_input(ib);
    if(_aE_) bad_float(0);
    var c = peek_char(ib), switcher = c - 69 | 0;
    if(32 < switcher >>> 0){
     if(-23 === switcher){
      var
       width$1 = store_char(width$0, ib, c),
       precision$0 = caml_call2(Stdlib_Int[10], width$1, precision),
       width_precision = scan_fractional_part(precision$0, ib),
       frac_width = precision$0 - width_precision | 0,
       width$2 = width$1 - frac_width | 0;
      return scan_exponent_part(width$2, ib);
     }
    }
    else if(30 < switcher - 1 >>> 0) return scan_exponent_part(width$0, ib);
    return bad_float(0);
   }
   function scan_caml_float(width, precision, ib){
    var _an_ = 0 === width ? 1 : 0, _ao_ = _an_ || end_of_input(ib);
    if(_ao_) bad_float(0);
    var
     width$0 = scan_sign(width, ib),
     _ap_ = 0 === width$0 ? 1 : 0,
     _aq_ = _ap_ || end_of_input(ib);
    if(_aq_) bad_float(0);
    var c = peek_char(ib);
    if(49 <= c){
     if(58 > c){
      var
       width$1 = store_char(width$0, ib, c),
       _ar_ = 0 === width$1 ? 1 : 0,
       _as_ = _ar_ || end_of_input(ib);
      if(_as_) bad_float(0);
      return scan_caml_float_rest(width$1, precision, ib);
     }
    }
    else if(48 <= c){
     var
      width$2 = store_char(width$0, ib, c),
      _at_ = 0 === width$2 ? 1 : 0,
      _au_ = _at_ || end_of_input(ib);
     if(_au_) bad_float(0);
     var c$0 = peek_char(ib);
     if(88 !== c$0 && 120 !== c$0)
      return scan_caml_float_rest(width$2, precision, ib);
     var
      width$3 = store_char(width$2, ib, c$0),
      _av_ = 0 === width$3 ? 1 : 0,
      _aw_ = _av_ || end_of_input(ib);
     if(_aw_) bad_float(0);
     var
      width$4 = scan_hexadecimal_int(width$3, ib),
      _ax_ = 0 === width$4 ? 1 : 0,
      _ay_ = _ax_ || end_of_input(ib);
     if(_ay_) bad_float(0);
     var c$1 = peek_char(ib), switcher = c$1 - 80 | 0;
     a:
     {
      b:
      {
       if(32 < switcher >>> 0){
        if(-34 === switcher){
         var width$5 = store_char(width$4, ib, c$1);
         c:
         {
          if(0 !== width$5 && ! end_of_input(ib)){
           var match = peek_char(ib);
           d:
           {
            if(80 !== match && 112 !== match){
             var
              precision$0 = caml_call2(Stdlib_Int[10], width$5, precision),
              width$10 =
                width$5
                - (precision$0 - scan_hexadecimal_int(precision$0, ib) | 0)
                | 0;
             break d;
            }
            var width$10 = width$5;
           }
           var width$6 = width$10;
           break c;
          }
          var width$6 = width$5;
         }
         var width$7 = width$6;
         break b;
        }
       }
       else if(30 < switcher - 1 >>> 0){var width$7 = width$4; break b;}
       var width$8 = bad_float(0);
       break a;
      }
      var width$8 = width$7;
     }
     if(0 !== width$8 && ! end_of_input(ib)){
      var c$2 = peek_char(ib);
      if(80 !== c$2 && 112 !== c$2) return width$8;
      var
       width$9 = store_char(width$8, ib, c$2),
       _az_ = 0 === width$9 ? 1 : 0,
       _aA_ = _az_ || end_of_input(ib);
      if(_aA_) bad_hex_float(0);
      return scan_optionally_signed_decimal(width$9, ib);
     }
     return width$8;
    }
    return bad_float(0);
   }
   function scan_string(stp, width, ib){
    var width$0 = width;
    for(;;){
     if(0 === width$0) return width$0;
     var c = peek_char(ib);
     if(ib[1]) return width$0;
     if(! stp){
      var _am_ = c - 9 | 0;
      a:
      {
       if(4 < _am_ >>> 0){
        if(23 === _am_) break a;
       }
       else if(1 < _am_ - 2 >>> 0) break a;
       var width$2 = store_char(width$0, ib, c), width$0 = width$2;
       continue;
      }
      return width$0;
     }
     var c$0 = stp[1];
     if(c === c$0) return skip_char(width$0, ib);
     var width$1 = store_char(width$0, ib, c), width$0 = width$1;
    }
   }
   function hexadecimal_value_of_char(c){
    return 97 <= c ? c - 87 | 0 : 65 <= c ? c - 55 | 0 : c - 48 | 0;
   }
   function check_next_char(message, width, ib){
    if(0 === width) return bad_token_length(message);
    var c = peek_char(ib);
    return ib[1] ? bad_input(caml_call2(Stdlib_Printf[4], _f_, message)) : c;
   }
   function check_next_char_for_char(_ak_, _al_){
    return check_next_char(cst_a_Char, _ak_, _al_);
   }
   function check_next_char_for_string(_ai_, _aj_){
    return check_next_char(cst_a_String, _ai_, _aj_);
   }
   function scan_backslash_char(width, ib){
    var c0 = check_next_char_for_char(width, ib);
    a:
    {
     if(40 <= c0){
      if(58 > c0){
       if(48 > c0) break a;
       var
        get_digit$0 =
          function(param){
           var c = next_char(ib);
           return 9 < c - 48 >>> 0 ? bad_input_escape(c) : c;
          },
        c1$0 = get_digit$0(0),
        c2$0 = get_digit$0(0),
        c =
          ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
          + (c2$0 - 48 | 0)
          | 0;
       b:
       {
        if(0 <= c && 255 >= c){var _ag_ = caml_call1(Stdlib[29], c); break b;}
        var
         _ag_ = bad_input(caml_call4(Stdlib_Printf[4], _l_, c0, c1$0, c2$0));
       }
       return store_char(width - 2 | 0, ib, _ag_);
      }
      var switcher = c0 - 92 | 0;
      if(28 < switcher >>> 0) break a;
      switch(switcher){
        case 28:
         var
          get_digit =
            function(param){
             var c = next_char(ib), _ah_ = c - 48 | 0;
             a:
             {
              if(22 < _ah_ >>> 0){
               if(5 < _ah_ - 49 >>> 0) break a;
              }
              else if(6 >= _ah_ - 10 >>> 0) break a;
              return c;
             }
             return bad_input_escape(c);
            },
          c1 = get_digit(0),
          c2 = get_digit(0),
          _ad_ = hexadecimal_value_of_char(c2),
          c$0 = (16 * hexadecimal_value_of_char(c1) | 0) + _ad_ | 0;
         b:
         {
          if(0 <= c$0 && 255 >= c$0){
           var _af_ = caml_call1(Stdlib[29], c$0);
           break b;
          }
          var _af_ = bad_input(caml_call3(Stdlib_Printf[4], _m_, c1, c2));
         }
         return store_char(width - 2 | 0, ib, _af_);
        case 0:
        case 6:
        case 18:
        case 22:
        case 24: break;
        default: break a;
      }
     }
     else if(34 !== c0 && 39 > c0) break a;
     b:
     {
      if(110 <= c0){
       if(117 > c0)
        switch(c0 - 110 | 0){
          case 0:
           var _ae_ = 10; break b;
          case 4:
           var _ae_ = 13; break b;
          case 6:
           var _ae_ = 9; break b;
        }
      }
      else if(98 === c0){var _ae_ = 8; break b;}
      var _ae_ = c0;
     }
     return store_char(width, ib, _ae_);
    }
    return bad_input_escape(c0);
   }
   function scan_caml_string(width, ib){
    function find_stop$0(counter, width){
     var width$0 = width;
     for(;;){
      var c = check_next_char_for_string(width$0, ib);
      if(34 === c) return ignore_char(width$0, ib);
      if(92 === c){
       var
        width$1 = ignore_char(width$0, ib),
        match = check_next_char_for_string(width$1, ib);
       if(10 === match){
        var _ab_ = ignore_char(width$1, ib);
        if(counter >= 50)
         return caml_trampoline_return(skip_spaces, [0, _ab_]);
        var counter$0 = counter + 1 | 0;
        return skip_spaces(counter$0, _ab_);
       }
       if(13 === match){
        var width$3 = ignore_char(width$1, ib);
        if(10 === check_next_char_for_string(width$3, ib)){
         var _ac_ = ignore_char(width$3, ib);
         if(counter >= 50)
          return caml_trampoline_return(skip_spaces, [0, _ac_]);
         var counter$1 = counter + 1 | 0;
         return skip_spaces(counter$1, _ac_);
        }
        var width$5 = store_char(width$3, ib, 13), width$0 = width$5;
       }
       else
        var width$4 = scan_backslash_char(width$1, ib), width$0 = width$4;
      }
      else
       var width$2 = store_char(width$0, ib, c), width$0 = width$2;
     }
    }
    function skip_spaces(counter, width){
     var width$0 = width;
     for(;;){
      if(32 !== check_next_char_for_string(width$0, ib)){
       if(counter >= 50)
        return caml_trampoline_return(find_stop$0, [0, width$0]);
       var counter$0 = counter + 1 | 0;
       return find_stop$0(counter$0, width$0);
      }
      var width$1 = ignore_char(width$0, ib), width$0 = width$1;
     }
    }
    function find_stop(width){return caml_trampoline(find_stop$0(0, width));}
    var c = checked_peek_char(ib);
    return 34 === c
            ? find_stop(ignore_char(width, ib))
            : character_mismatch(34, c);
   }
   function scan_chars_in_char_set(char_set, scan_indic, width, ib){
    function scan_chars(i, stp){
     var i$0 = i;
     for(;;){
      var c = peek_char(ib), _Z_ = 0 < i$0 ? 1 : 0;
      if(_Z_){
       var ___ = 1 - ib[1];
       if(___)
        var
         _$_ = caml_call2(CamlinternalFormat[1], char_set, c),
         _aa_ = _$_ ? c !== stp ? 1 : 0 : _$_;
       else
        var _aa_ = ___;
      }
      else
       var _aa_ = _Z_;
      if(! _aa_) return _aa_;
      store_char(Stdlib[19], ib, c);
      var i$1 = i$0 - 1 | 0, i$0 = i$1;
     }
    }
    if(! scan_indic) return scan_chars(width, -1);
    var c = scan_indic[1];
    scan_chars(width, c);
    var _Y_ = 1 - ib[1];
    if(! _Y_) return _Y_;
    var ci = peek_char(ib);
    return c === ci ? invalidate_current_char(ib) : character_mismatch(c, ci);
   }
   function scanf_bad_input(ib, x){
    if(x[1] === Scan_failure)
     var s = x[2];
    else{
     if(x[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(x, 1);
     var s = x[2];
    }
    var i = char_count(ib);
    return bad_input(caml_call3(Stdlib_Printf[4], _o_, i, s));
   }
   function width_of_pad_opt(pad_opt){
    if(! pad_opt) return Stdlib[19];
    var width = pad_opt[1];
    return width;
   }
   function stopper_of_formatting_lit(fmting){
    if(6 === fmting) return _p_;
    var
     str = caml_call1(CamlinternalFormat[17], fmting),
     stp = caml_string_get(str, 1),
     sub_str =
       caml_call3
        (Stdlib_String[16], str, 2, caml_ml_string_length(str) - 2 | 0);
    return [0, stp, sub_str];
   }
   function take_format_readers$0(counter, k, fmt){
    var fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k, 0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], fmt$0 = rest; break;
       case 1:
        var rest$0 = fmt$0[1], fmt$0 = rest$0; break;
       case 2:
        var rest$1 = fmt$0[2], fmt$0 = rest$1; break;
       case 3:
        var rest$2 = fmt$0[2], fmt$0 = rest$2; break;
       case 4:
        var rest$3 = fmt$0[4], fmt$0 = rest$3; break;
       case 5:
        var rest$4 = fmt$0[4], fmt$0 = rest$4; break;
       case 6:
        var rest$5 = fmt$0[4], fmt$0 = rest$5; break;
       case 7:
        var rest$6 = fmt$0[4], fmt$0 = rest$6; break;
       case 8:
        var rest$7 = fmt$0[4], fmt$0 = rest$7; break;
       case 9:
        var rest$8 = fmt$0[2], fmt$0 = rest$8; break;
       case 10:
        var rest$9 = fmt$0[1], fmt$0 = rest$9; break;
       case 11:
        var rest$10 = fmt$0[2], fmt$0 = rest$10; break;
       case 12:
        var rest$11 = fmt$0[2], fmt$0 = rest$11; break;
       case 13:
        var rest$12 = fmt$0[3], fmt$0 = rest$12; break;
       case 14:
        var
         rest$13 = fmt$0[3],
         fmtty = fmt$0[2],
         _V_ = caml_call1(CamlinternalFormat[21], fmtty),
         _W_ = caml_call1(CamlinternalFormatBasics[2], _V_);
        if(counter >= 50)
         return caml_trampoline_return
                 (take_fmtty_format_readers$0, [0, k, _W_, rest$13]);
        var counter$0 = counter + 1 | 0;
        return take_fmtty_format_readers$0(counter$0, k, _W_, rest$13);
       case 15:
        var rest$14 = fmt$0[1], fmt$0 = rest$14; break;
       case 16:
        var rest$15 = fmt$0[1], fmt$0 = rest$15; break;
       case 17:
        var rest$16 = fmt$0[2], fmt$0 = rest$16; break;
       case 18:
        var _X_ = fmt$0[1];
        if(0 === _X_[0])
         var
          rest$17 = fmt$0[2],
          fmt$1 = _X_[1][1],
          fmt$2 = caml_call2(CamlinternalFormatBasics[3], fmt$1, rest$17),
          fmt$0 = fmt$2;
        else
         var
          rest$18 = fmt$0[2],
          fmt$3 = _X_[1][1],
          fmt$4 = caml_call2(CamlinternalFormatBasics[3], fmt$3, rest$18),
          fmt$0 = fmt$4;
        break;
       case 19:
        var fmt_rest = fmt$0[1];
        return function(reader){
         function new_k(readers_rest){
          return caml_call1(k, [0, reader, readers_rest]);
         }
         return take_format_readers(new_k, fmt_rest);};
       case 20:
        var rest$19 = fmt$0[3], fmt$0 = rest$19; break;
       case 21:
        var rest$20 = fmt$0[2], fmt$0 = rest$20; break;
       case 22:
        var rest$21 = fmt$0[1], fmt$0 = rest$21; break;
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            var fmt$0 = rest$22; break;
           case 1:
            var fmt$0 = rest$22; break;
           case 2:
            return function(reader){
             function new_k(readers_rest){
              return caml_call1(k, [0, reader, readers_rest]);
             }
             return take_format_readers(new_k, rest$22);};
           default: var fmt$0 = rest$22;
         }
        else
         switch(ign[0]){
           case 0:
            var fmt$0 = rest$22; break;
           case 1:
            var fmt$0 = rest$22; break;
           case 2:
            var fmt$0 = rest$22; break;
           case 3:
            var fmt$0 = rest$22; break;
           case 4:
            var fmt$0 = rest$22; break;
           case 5:
            var fmt$0 = rest$22; break;
           case 6:
            var fmt$0 = rest$22; break;
           case 7:
            var fmt$0 = rest$22; break;
           case 8:
            var fmt$0 = rest$22; break;
           case 9:
            var fmtty$0 = ign[2];
            if(counter >= 50)
             return caml_trampoline_return
                     (take_fmtty_format_readers$0, [0, k, fmtty$0, rest$22]);
            var counter$1 = counter + 1 | 0;
            return take_fmtty_format_readers$0(counter$1, k, fmtty$0, rest$22);
           case 10:
            var fmt$0 = rest$22; break;
           default: var fmt$0 = rest$22;
         }
        break;
       default: var rest$23 = fmt$0[3], fmt$0 = rest$23;
     }
    }
   }
   function take_fmtty_format_readers$0(counter, k, fmtty, fmt){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number"){
      if(counter >= 50)
       return caml_trampoline_return(take_format_readers$0, [0, k, fmt]);
      var counter$0 = counter + 1 | 0;
      return take_format_readers$0(counter$0, k, fmt);
     }
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1], fmtty$0 = fmtty$1; break;
       case 1:
        var fmtty$2 = fmtty$0[1], fmtty$0 = fmtty$2; break;
       case 2:
        var fmtty$3 = fmtty$0[1], fmtty$0 = fmtty$3; break;
       case 3:
        var fmtty$4 = fmtty$0[1], fmtty$0 = fmtty$4; break;
       case 4:
        var fmtty$5 = fmtty$0[1], fmtty$0 = fmtty$5; break;
       case 5:
        var fmtty$6 = fmtty$0[1], fmtty$0 = fmtty$6; break;
       case 6:
        var fmtty$7 = fmtty$0[1], fmtty$0 = fmtty$7; break;
       case 7:
        var fmtty$8 = fmtty$0[1], fmtty$0 = fmtty$8; break;
       case 8:
        var fmtty$9 = fmtty$0[2], fmtty$0 = fmtty$9; break;
       case 9:
        var
         rest = fmtty$0[3],
         ty2 = fmtty$0[2],
         ty1 = fmtty$0[1],
         _U_ = caml_call1(CamlinternalFormat[21], ty1),
         ty = caml_call2(CamlinternalFormat[22], _U_, ty2),
         fmtty$10 = caml_call2(CamlinternalFormatBasics[1], ty, rest),
         fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1], fmtty$0 = fmtty$11; break;
       case 11:
        var fmtty$12 = fmtty$0[1], fmtty$0 = fmtty$12; break;
       case 12:
        var fmtty$13 = fmtty$0[1], fmtty$0 = fmtty$13; break;
       case 13:
        var fmt_rest = fmtty$0[1];
        return function(reader){
         function new_k(readers_rest){
          return caml_call1(k, [0, reader, readers_rest]);
         }
         return take_fmtty_format_readers(new_k, fmt_rest, fmt);};
       default:
        var fmt_rest$0 = fmtty$0[1];
        return function(reader){
         function new_k(readers_rest){
          return caml_call1(k, [0, reader, readers_rest]);
         }
         return take_fmtty_format_readers(new_k, fmt_rest$0, fmt);};
     }
    }
   }
   function take_format_readers(k, fmt){
    return caml_trampoline(take_format_readers$0(0, k, fmt));
   }
   function take_fmtty_format_readers(k, fmtty, fmt){
    return caml_trampoline(take_fmtty_format_readers$0(0, k, fmtty, fmt));
   }
   function make_scanf(ib, fmt, readers){
    var fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return 0;
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        store_char(0, ib, checked_peek_char(ib));
        var c$1 = token_char(ib);
        return [0, c$1, make_scanf(ib, rest, readers)];
       case 1:
        var
         rest$0 = fmt$0[1],
         width$0 = 0,
         find_stop =
           function(width){
            var c = check_next_char_for_char(width, ib);
            return 39 === c
                    ? ignore_char(width, ib)
                    : character_mismatch(39, c);
           },
         c = checked_peek_char(ib);
        if(39 === c){
         var
          width = ignore_char(width$0, ib),
          c$0 = check_next_char_for_char(width, ib);
         if(92 === c$0)
          find_stop(scan_backslash_char(ignore_char(width, ib), ib));
         else
          find_stop(store_char(width, ib, c$0));
        }
        else
         character_mismatch(39, c);
        var c$2 = token_char(ib);
        return [0, c$2, make_scanf(ib, rest$0, readers)];
       case 2:
        var pad = fmt$0[1], match = fmt$0[2];
        if(typeof match !== "number")
         switch(match[0]){
           case 17:
            var
             rest$2 = match[2],
             fmting_lit = match[1],
             match$0 = stopper_of_formatting_lit(fmting_lit),
             str = match$0[2],
             stp = match$0[1],
             scan$0 =
               function(width, param, ib){
                return scan_string([0, stp], width, ib);
               },
             str_rest = [11, str, rest$2];
            return pad_prec_scanf
                    (ib, str_rest, readers, pad, 0, scan$0, token_string);
           case 18:
            var _G_ = match[1];
            if(0 === _G_[0]){
             var
              rest$3 = match[2],
              fmt$1 = _G_[1][1],
              scan$1 =
                function(width, param, ib){
                 return scan_string(_q_, width, ib);
                };
             return pad_prec_scanf
                     (ib,
                      caml_call2(CamlinternalFormatBasics[3], fmt$1, rest$3),
                      readers,
                      pad,
                      0,
                      scan$1,
                      token_string);
            }
            var
             rest$4 = match[2],
             fmt$2 = _G_[1][1],
             scan$2 =
               function(width, param, ib){return scan_string(_r_, width, ib);};
            return pad_prec_scanf
                    (ib,
                     caml_call2(CamlinternalFormatBasics[3], fmt$2, rest$4),
                     readers,
                     pad,
                     0,
                     scan$2,
                     token_string);
         }
        var
         rest$1 = fmt$0[2],
         scan = function(width, param, ib){return scan_string(0, width, ib);};
        return pad_prec_scanf(ib, rest$1, readers, pad, 0, scan, token_string);
       case 3:
        var
         rest$5 = fmt$0[2],
         pad$0 = fmt$0[1],
         scan$3 =
           function(width, param, ib){return scan_caml_string(width, ib);};
        return pad_prec_scanf
                (ib, rest$5, readers, pad$0, 0, scan$3, token_string);
       case 4:
        var
         rest$6 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1],
         conv =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv)),
         scan$4 =
           function(width, param, ib){
            return scan_int_conversion(conv, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$6,
                 readers,
                 pad$1,
                 prec,
                 scan$4,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv, ib));
                 });
       case 5:
        var
         rest$7 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1],
         conv$0 =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv$0)),
         scan$5 =
           function(width, param, ib){
            return scan_int_conversion(conv$0, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$7,
                 readers,
                 pad$2,
                 prec$0,
                 scan$5,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv$0, ib));
                 });
       case 6:
        var
         rest$8 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1],
         conv$1 =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv$1)),
         scan$6 =
           function(width, param, ib){
            return scan_int_conversion(conv$1, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$8,
                 readers,
                 pad$3,
                 prec$1,
                 scan$6,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv$1, ib));
                 });
       case 7:
        var
         rest$9 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1],
         conv$2 =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv$2)),
         scan$7 =
           function(width, param, ib){
            return scan_int_conversion(conv$2, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$9,
                 readers,
                 pad$4,
                 prec$2,
                 scan$7,
                 function(ib){
                  return runtime.caml_int64_of_string
                          (token_int_literal(conv$2, ib));
                 });
       case 8:
        switch(fmt$0[1][2]){
          case 5:
          case 8:
           var rest$11 = fmt$0[4], prec$4 = fmt$0[3], pad$6 = fmt$0[2];
           return pad_prec_scanf
                   (ib,
                    rest$11,
                    readers,
                    pad$6,
                    prec$4,
                    scan_caml_float,
                    token_float);
          case 6:
          case 7:
           var rest$12 = fmt$0[4], prec$5 = fmt$0[3], pad$7 = fmt$0[2];
           return pad_prec_scanf
                   (ib,
                    rest$12,
                    readers,
                    pad$7,
                    prec$5,
                    scan_hex_float,
                    token_float);
          default:
           var rest$10 = fmt$0[4], prec$3 = fmt$0[3], pad$5 = fmt$0[2];
           return pad_prec_scanf
                   (ib,
                    rest$10,
                    readers,
                    pad$5,
                    prec$3,
                    scan_float,
                    token_float);
        }
       case 9:
        var
         rest$13 = fmt$0[2],
         pad$8 = fmt$0[1],
         scan$8 =
           function(param, _T_, ib){
            var
             c = checked_peek_char(ib),
             m =
               102 === c
                ? 5
                : 116
                  === c
                  ? 4
                  : bad_input(caml_call2(Stdlib_Printf[4], _n_, c));
            return scan_string(0, m, ib);
           };
        return pad_prec_scanf
                (ib, rest$13, readers, pad$8, 0, scan$8, token_bool);
       case 10:
        var rest$14 = fmt$0[1];
        if(! end_of_input(ib)) return bad_input(cst_end_of_input_not_found);
        var fmt$0 = rest$14;
        break;
       case 11:
        var
         rest$15 = fmt$0[2],
         str$0 = fmt$0[1],
         _H_ = function(_S_){return check_char(ib, _S_);};
        caml_call2(Stdlib_String[30], _H_, str$0);
        var fmt$0 = rest$15;
        break;
       case 12:
        var rest$16 = fmt$0[2], chr = fmt$0[1];
        check_char(ib, chr);
        var fmt$0 = rest$16;
        break;
       case 13:
        var rest$17 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
        scan_caml_string(width_of_pad_opt(pad_opt), ib);
        var s = token_string(ib);
        try{
         var _I_ = caml_call2(CamlinternalFormat[14], s, fmtty), fmt$3 = _I_;
        }
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(exn, 0);
         var msg = exn[2], fmt$3 = bad_input(msg);
        }
        return [0, fmt$3, make_scanf(ib, rest$17, readers)];
       case 14:
        var rest$18 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
        scan_caml_string(width_of_pad_opt(pad_opt$0), ib);
        var s$0 = token_string(ib);
        try{
         var
          fmt$6 = caml_call2(CamlinternalFormat[13], 0, s$0)[1],
          fmt$7 = caml_call2(CamlinternalFormat[13], 0, s$0)[1],
          _K_ = caml_call1(CamlinternalFormat[21], fmtty$0),
          _L_ = caml_call1(CamlinternalFormatBasics[2], _K_),
          fmt$8 = caml_call2(CamlinternalFormat[12], fmt$7, _L_),
          _M_ = caml_call1(CamlinternalFormatBasics[2], fmtty$0),
          _N_ = caml_call2(CamlinternalFormat[12], fmt$6, _M_),
          fmt$5 = fmt$8,
          fmt$4 = _N_;
        }
        catch(exn){
         var exn$0 = caml_wrap_exception(exn);
         if(exn$0[1] !== Stdlib[7])
          throw caml_maybe_attach_backtrace(exn$0, 0);
         var
          msg$0 = exn$0[2],
          _J_ = bad_input(msg$0),
          fmt$5 = _J_[2],
          fmt$4 = _J_[1];
        }
        return [0,
                [0, fmt$4, s$0],
                make_scanf
                 (ib,
                  caml_call2(CamlinternalFormatBasics[3], fmt$5, rest$18),
                  readers)];
       case 15:
        return caml_call1(Stdlib[1], cst_scanf_bad_conversion_a);
       case 16:
        return caml_call1(Stdlib[1], cst_scanf_bad_conversion_t);
       case 17:
        var
         rest$19 = fmt$0[2],
         formatting_lit = fmt$0[1],
         _O_ = caml_call1(CamlinternalFormat[17], formatting_lit),
         _P_ = function(_R_){return check_char(ib, _R_);};
        caml_call2(Stdlib_String[30], _P_, _O_);
        var fmt$0 = rest$19;
        break;
       case 18:
        var _Q_ = fmt$0[1];
        if(0 === _Q_[0]){
         var rest$20 = fmt$0[2], fmt$9 = _Q_[1][1];
         check_char(ib, 64);
         check_char(ib, 123);
         var
          fmt$10 = caml_call2(CamlinternalFormatBasics[3], fmt$9, rest$20),
          fmt$0 = fmt$10;
        }
        else{
         var rest$21 = fmt$0[2], fmt$11 = _Q_[1][1];
         check_char(ib, 64);
         check_char(ib, 91);
         var
          fmt$12 = caml_call2(CamlinternalFormatBasics[3], fmt$11, rest$21),
          fmt$0 = fmt$12;
        }
        break;
       case 19:
        var fmt_rest = fmt$0[1];
        if(! readers) return caml_call1(Stdlib[1], cst_scanf_missing_reader);
        var
         readers_rest = readers[2],
         reader = readers[1],
         x = caml_call1(reader, ib);
        return [0, x, make_scanf(ib, fmt_rest, readers_rest)];
       case 20:
        var width_opt = fmt$0[1], match$1 = fmt$0[3];
        if(typeof match$1 !== "number" && 17 === match$1[0]){
         var
          rest$23 = match$1[2],
          fmting_lit$0 = match$1[1],
          char_set$0 = fmt$0[2],
          match$2 = stopper_of_formatting_lit(fmting_lit$0),
          str$1 = match$2[2],
          stp$0 = match$2[1],
          width$2 = width_of_pad_opt(width_opt);
         scan_chars_in_char_set(char_set$0, [0, stp$0], width$2, ib);
         var s$2 = token_string(ib), str_rest$0 = [11, str$1, rest$23];
         return [0, s$2, make_scanf(ib, str_rest$0, readers)];
        }
        var
         rest$22 = fmt$0[3],
         char_set = fmt$0[2],
         width$1 = width_of_pad_opt(width_opt);
        scan_chars_in_char_set(char_set, 0, width$1, ib);
        var s$1 = token_string(ib);
        return [0, s$1, make_scanf(ib, rest$22, readers)];
       case 21:
        var rest$24 = fmt$0[2], counter = fmt$0[1];
        switch(counter){
          case 0:
           var count = ib[5]; break;
          case 1:
           var count = char_count(ib); break;
          default: var count = ib[6];
        }
        return [0, count, make_scanf(ib, rest$24, readers)];
       case 22:
        var rest$25 = fmt$0[1], c$3 = checked_peek_char(ib);
        return [0, c$3, make_scanf(ib, rest$25, readers)];
       case 23:
        var
         rest$26 = fmt$0[2],
         ign = fmt$0[1],
         fmt$13 = caml_call2(CamlinternalFormat[6], ign, rest$26)[1],
         match$3 = make_scanf(ib, fmt$13, readers);
        if(! match$3)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
        var arg_rest = match$3[2];
        return arg_rest;
       default: return caml_call1(Stdlib[1], cst_scanf_bad_conversion_custo);
     }
    }
   }
   function pad_prec_scanf(ib, fmt, readers, pad, prec, scan, token){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var p = prec[1];
      caml_call3(scan, Stdlib[19], p, ib);
      var x$0 = caml_call1(token, ib);
      return [0, x$0, make_scanf(ib, fmt, readers)];
     }
     if(prec) return caml_call1(Stdlib[1], cst_scanf_bad_conversion);
     caml_call3(scan, Stdlib[19], Stdlib[19], ib);
     var x = caml_call1(token, ib);
     return [0, x, make_scanf(ib, fmt, readers)];
    }
    if(0 !== pad[0]) return caml_call1(Stdlib[1], cst_scanf_bad_conversion$2);
    if(! pad[1]) return caml_call1(Stdlib[1], cst_scanf_bad_conversion$1);
    var w = pad[2];
    if(typeof prec !== "number"){
     var p$0 = prec[1];
     caml_call3(scan, w, p$0, ib);
     var x$2 = caml_call1(token, ib);
     return [0, x$2, make_scanf(ib, fmt, readers)];
    }
    if(prec) return caml_call1(Stdlib[1], cst_scanf_bad_conversion$0);
    caml_call3(scan, w, Stdlib[19], ib);
    var x$1 = caml_call1(token, ib);
    return [0, x$1, make_scanf(ib, fmt, readers)];
   }
   function kscanf_gen(ib, ef, af, param){
    var str = param[2], fmt = param[1];
    function k(readers, f$1){
     caml_call1(Stdlib_Buffer[9], ib[8]);
     try{var args$1 = make_scanf(ib, fmt, readers);}
     catch(exc$0){
      var exc = caml_wrap_exception(exc$0);
      if
       (exc[1] !== Scan_failure && exc[1] !== Stdlib[7] && exc !== Stdlib[12]){
       if(exc[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exc, 0);
       var
        msg = exc[2],
        _C_ = caml_call1(Stdlib_String[25], str),
        _D_ = caml_call2(Stdlib[28], _C_, cst$0),
        _E_ = caml_call2(Stdlib[28], cst_in_format, _D_),
        _F_ = caml_call2(Stdlib[28], msg, _E_);
       return caml_call1(Stdlib[1], _F_);
      }
      return caml_call2(ef, ib, exc);
     }
     var f = f$1, args = args$1;
     for(;;){
      if(! args) return caml_call1(af, f);
      var
       args$0 = args[2],
       x = args[1],
       f$0 = caml_call1(f, x),
       f = f$0,
       args = args$0;
     }
    }
    return take_format_readers(k, fmt);
   }
   function kscanf(ib, ef, fmt){
    return kscanf_gen(ib, ef, function(x){return x;}, fmt);
   }
   function kscanf_opt(ib, fmt){
    function _A_(x){return [0, x];}
    return kscanf_gen(ib, function(param, _B_){return 0;}, _A_, fmt);
   }
   function bscanf(ib, fmt){return kscanf(ib, scanf_bad_input, fmt);}
   function bscanf_opt(ib, fmt){return kscanf_opt(ib, fmt);}
   function ksscanf(s, ef, fmt){return kscanf(from_string(s), ef, fmt);}
   function sscanf(s, fmt){
    return kscanf(from_string(s), scanf_bad_input, fmt);
   }
   function sscanf_opt(s, fmt){return kscanf_opt(from_string(s), fmt);}
   function scanf(fmt){return kscanf(stdin, scanf_bad_input, fmt);}
   function scanf_opt(fmt){return kscanf_opt(stdin, fmt);}
   function bscanf_format(ib, format, f){
    scan_caml_string(Stdlib[19], ib);
    var str = token_string(ib);
    try{var _z_ = caml_call2(CamlinternalFormat[15], str, format), fmt = _z_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2], fmt = bad_input(msg);
    }
    return caml_call1(f, fmt);
   }
   function sscanf_format(s, format, f){
    return bscanf_format(from_string(s), format, f);
   }
   function format_from_string(s, fmt){
    function _w_(x){return x;}
    var
     _x_ = caml_call1(Stdlib_String[25], s),
     _y_ = caml_call2(Stdlib[28], _x_, cst$1);
    return sscanf_format(caml_call2(Stdlib[28], cst$2, _y_), fmt, _w_);
   }
   function unescaped(s){
    function _u_(x){return x;}
    var _v_ = caml_call2(Stdlib[28], s, cst$3);
    return caml_call1(sscanf(caml_call2(Stdlib[28], cst$4, _v_), _t_), _u_);
   }
   var
    Stdlib_Scanf =
      [0,
       [0,
        stdin,
        open_in,
        open_in_bin,
        close_in,
        open_in,
        open_in_bin,
        from_string,
        from_function,
        from_channel,
        end_of_input,
        beginning_of_input,
        name_of_input],
       Scan_failure,
       bscanf,
       bscanf_opt,
       sscanf,
       sscanf_opt,
       scanf,
       scanf_opt,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped];
   runtime.caml_register_global(64, Stdlib_Scanf, "Stdlib__Scanf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Callback
//# unitInfo: Requires: Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[10],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalOO
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Obj, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalOO_ml = "camlinternalOO.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_block = runtime.caml_obj_block,
    caml_set_oo_id = runtime.caml_set_oo_id,
    caml_string_compare = runtime.caml_string_compare,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Map = global_data.Stdlib__Map,
    _g_ = [0, cst_camlinternalOO_ml, 437, 17],
    _f_ = [0, cst_camlinternalOO_ml, 419, 13],
    _e_ = [0, cst_camlinternalOO_ml, 416, 13],
    _d_ = [0, cst_camlinternalOO_ml, 413, 13],
    _c_ = [0, cst_camlinternalOO_ml, 410, 13],
    _b_ = [0, cst_camlinternalOO_ml, 407, 13],
    _a_ = [0, cst_camlinternalOO_ml, 279, 50];
   function copy(o){var o$0 = o.slice(); return caml_set_oo_id(o$0);}
   var params = [0, 1, 1, 1, 3, 16], initial_object_size = 2, dummy_item = 0;
   function public_method_label(s){
    var
     accu = [0, 0],
     _aE_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _aD_ = 0;
    if(_aE_ >= 0){
     var i = _aD_;
     for(;;){
      var _aF_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _aF_ | 0;
      var _aG_ = i + 1 | 0;
      if(_aE_ === i) break;
      var i = _aG_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
    return tag;
   }
   var
    compare = caml_string_compare,
    Vars = caml_call1(Stdlib_Map[1], [0, compare]),
    compare$0 = caml_string_compare,
    Meths = caml_call1(Stdlib_Map[1], [0, compare$0]),
    compare$1 = runtime.caml_int_compare,
    Labs = caml_call1(Stdlib_Map[1], [0, compare$1]),
    dummy_table = [0, 0, [0, dummy_item], Meths[1], Labs[1], 0, 0, Vars[1], 0],
    table_count = [0, 0],
    dummy_met = caml_obj_block(0, 0);
   function fit_size(n){
    return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n;
   }
   function new_table(pub_labels){
    table_count[1]++;
    var
     len = pub_labels.length - 1,
     methods = caml_make_vect((len * 2 | 0) + 2 | 0, dummy_met);
    caml_check_bound(methods, 0)[1] = len;
    var
     _aw_ = Stdlib_Sys[9],
     _ax_ = (runtime.caml_mul(fit_size(len), _aw_) / 8 | 0) - 1 | 0;
    caml_check_bound(methods, 1)[2] = _ax_;
    var _az_ = len - 1 | 0, _ay_ = 0;
    if(_az_ >= 0){
     var i = _ay_;
     for(;;){
      var
       _aB_ = (i * 2 | 0) + 3 | 0,
       _aA_ = caml_check_bound(pub_labels, i)[1 + i];
      caml_check_bound(methods, _aB_)[1 + _aB_] = _aA_;
      var _aC_ = i + 1 | 0;
      if(_az_ === i) break;
      var i = _aC_;
     }
    }
    return [0,
            initial_object_size,
            methods,
            Meths[1],
            Labs[1],
            0,
            0,
            Vars[1],
            0];
   }
   function resize(array, new_size){
    var old_size = array[2].length - 1, _au_ = old_size < new_size ? 1 : 0;
    if(_au_){
     var new_buck = caml_make_vect(new_size, dummy_met);
     caml_call5(Stdlib_Array[8], array[2], 0, new_buck, 0, old_size);
     array[2] = new_buck;
     var _av_ = 0;
    }
    else
     var _av_ = _au_;
    return _av_;
   }
   var method_count = [0, 0], inst_var_count = [0, 0];
   function new_method(table){
    var index = table[2].length - 1;
    resize(table, index + 1 | 0);
    return index;
   }
   function get_method_label(table, name){
    try{var _as_ = caml_call2(Meths[17], name, table[3]); return _as_;}
    catch(_at_){
     var _ar_ = caml_wrap_exception(_at_);
     if(_ar_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ar_, 0);
     var label = new_method(table);
     table[3] = caml_call3(Meths[2], name, label, table[3]);
     table[4] = caml_call3(Labs[2], label, 1, table[4]);
     return label;
    }
   }
   function get_method_labels(table, names){
    function _ap_(_aq_){return get_method_label(table, _aq_);}
    return caml_call2(Stdlib_Array[13], _ap_, names);
   }
   function set_method(table, label, element){
    method_count[1]++;
    return caml_call2(Labs[17], label, table[4])
            ? (resize
               (table, label + 1 | 0),
              caml_check_bound(table[2], label)[1 + label] = element,
              0)
            : (table[6] = [0, [0, label, element], table[6]], 0);
   }
   function get_method(table, label){
    try{var _an_ = caml_call2(Stdlib_List[49], label, table[6]); return _an_;}
    catch(_ao_){
     var _am_ = caml_wrap_exception(_ao_);
     if(_am_ === Stdlib[8])
      return caml_check_bound(table[2], label)[1 + label];
     throw caml_maybe_attach_backtrace(_am_, 0);
    }
   }
   function to_list(arr){
    return 0 === arr ? 0 : caml_call1(Stdlib_Array[9], arr);
   }
   function narrow(table, vars, virt_meths, concr_meths){
    var
     vars$0 = to_list(vars),
     virt_meths$0 = to_list(virt_meths),
     concr_meths$0 = to_list(concr_meths);
    function _X_(_al_){return get_method_label(table, _al_);}
    var virt_meth_labs = caml_call2(Stdlib_List[20], _X_, virt_meths$0);
    function _Y_(_ak_){return get_method_label(table, _ak_);}
    var concr_meth_labs = caml_call2(Stdlib_List[20], _Y_, concr_meths$0);
    table[5] =
     [0,
      [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
      table[5]];
    var _Z_ = Vars[1], ___ = table[7];
    function _$_(lab, info, tvars){
     return caml_call2(Stdlib_List[37], lab, vars$0)
             ? caml_call3(Vars[2], lab, info, tvars)
             : tvars;
    }
    table[7] = caml_call3(Vars[24], _$_, ___, _Z_);
    var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
    function _aa_(met, label){
     by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
     var _af_ = by_label[1];
     try{var _ai_ = caml_call2(Labs[17], label, table[4]), _ah_ = _ai_;}
     catch(_aj_){
      var _ag_ = caml_wrap_exception(_aj_);
      if(_ag_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ag_, 0);
      var _ah_ = 1;
     }
     by_label[1] = caml_call3(Labs[2], label, _ah_, _af_);
     return 0;
    }
    caml_call3(Stdlib_List[28], _aa_, concr_meths$0, concr_meth_labs);
    function _ab_(met, label){
     by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
     by_label[1] = caml_call3(Labs[2], label, 0, by_label[1]);
     return 0;
    }
    caml_call3(Stdlib_List[28], _ab_, virt_meths$0, virt_meth_labs);
    table[3] = by_name[1];
    table[4] = by_label[1];
    var _ac_ = 0, _ad_ = table[6];
    function _ae_(met, hm){
     var lab = met[1];
     return caml_call2(Stdlib_List[37], lab, virt_meth_labs)
             ? hm
             : [0, met, hm];
    }
    table[6] = caml_call3(Stdlib_List[27], _ae_, _ad_, _ac_);
    return 0;
   }
   function widen(table){
    var
     match = caml_call1(Stdlib_List[6], table[5]),
     vars = match[6],
     virt_meths = match[5],
     saved_vars = match[4],
     saved_hidden_meths = match[3],
     by_label = match[2],
     by_name = match[1];
    table[5] = caml_call1(Stdlib_List[7], table[5]);
    function _T_(s, v){
     var _W_ = caml_call2(Vars[17], v, table[7]);
     return caml_call3(Vars[2], v, _W_, s);
    }
    table[7] = caml_call3(Stdlib_List[26], _T_, saved_vars, vars);
    table[3] = by_name;
    table[4] = by_label;
    var _U_ = table[6];
    function _V_(met, hm){
     var lab = met[1];
     return caml_call2(Stdlib_List[37], lab, virt_meths) ? hm : [0, met, hm];
    }
    table[6] = caml_call3(Stdlib_List[27], _V_, _U_, saved_hidden_meths);
    return 0;
   }
   function new_variable(table, name){
    try{var _R_ = caml_call2(Vars[17], name, table[7]); return _R_;}
    catch(_S_){
     var _Q_ = caml_wrap_exception(_S_);
     if(_Q_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_Q_, 0);
     var index = table[1];
     table[1] = index + 1 | 0;
     if(runtime.caml_string_notequal(name, ""))
      table[7] = caml_call3(Vars[2], name, index, table[7]);
     return index;
    }
   }
   function to_array(arr){return runtime.caml_equal(arr, 0) ? [0] : arr;}
   function new_methods_variables(table, meths, vals){
    var
     meths$0 = to_array(meths),
     nmeths = meths$0.length - 1,
     nvals = vals.length - 1,
     res = caml_make_vect(nmeths + nvals | 0, 0),
     _I_ = nmeths - 1 | 0,
     _H_ = 0;
    if(_I_ >= 0){
     var i$0 = _H_;
     for(;;){
      var
       _O_ = get_method_label(table, caml_check_bound(meths$0, i$0)[1 + i$0]);
      caml_check_bound(res, i$0)[1 + i$0] = _O_;
      var _P_ = i$0 + 1 | 0;
      if(_I_ === i$0) break;
      var i$0 = _P_;
     }
    }
    var _K_ = nvals - 1 | 0, _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var
       _M_ = i + nmeths | 0,
       _L_ = new_variable(table, caml_check_bound(vals, i)[1 + i]);
      caml_check_bound(res, _M_)[1 + _M_] = _L_;
      var _N_ = i + 1 | 0;
      if(_K_ === i) break;
      var i = _N_;
     }
    }
    return res;
   }
   function get_variable(table, name){
    try{var _F_ = caml_call2(Vars[17], name, table[7]); return _F_;}
    catch(_G_){
     var _E_ = caml_wrap_exception(_G_);
     if(_E_ === Stdlib[8])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     throw caml_maybe_attach_backtrace(_E_, 0);
    }
   }
   function get_variables(table, names){
    function _C_(_D_){return get_variable(table, _D_);}
    return caml_call2(Stdlib_Array[13], _C_, names);
   }
   function add_initializer(table, f){table[8] = [0, f, table[8]]; return 0;}
   function create_table(public_methods){
    if(0 === public_methods) return new_table([0]);
    var
     tags = caml_call2(Stdlib_Array[13], public_method_label, public_methods),
     table = new_table(tags);
    function _B_(i, met){
     var lab = (i * 2 | 0) + 2 | 0;
     table[3] = caml_call3(Meths[2], met, lab, table[3]);
     table[4] = caml_call3(Labs[2], lab, 1, table[4]);
     return 0;
    }
    caml_call2(Stdlib_Array[12], _B_, public_methods);
    return table;
   }
   function init_class(table){
    inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
    table[8] = caml_call1(Stdlib_List[10], table[8]);
    var _A_ = Stdlib_Sys[9];
    return resize
            (table,
             3 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _A_) | 0);
   }
   function inherits(cla, vals, virt_meths, concr_meths, param, top){
    var env = param[4], super$0 = param[2];
    narrow(cla, vals, virt_meths, concr_meths);
    var init = top ? caml_call2(super$0, cla, env) : caml_call1(super$0, cla);
    widen(cla);
    var _s_ = 0, _t_ = to_array(concr_meths);
    function _u_(nm){return get_method(cla, get_method_label(cla, nm));}
    var
     _v_ = [0, caml_call2(Stdlib_Array[13], _u_, _t_), _s_],
     _w_ = to_array(vals);
    function _x_(_z_){return get_variable(cla, _z_);}
    var
     _y_ = [0, [0, init], [0, caml_call2(Stdlib_Array[13], _x_, _w_), _v_]];
    return caml_call1(Stdlib_Array[4], _y_);
   }
   function make_class(pub_meths, class_init){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    return [0, caml_call1(env_init, 0), class_init, env_init, 0];
   }
   function make_class_store(pub_meths, class_init, init_table){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    init_table[2] = class_init;
    init_table[1] = env_init;
    return 0;
   }
   function dummy_class(loc){
    function undef(param){
     throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
    }
    return [0, undef, undef, undef, 0];
   }
   function create_object(table){
    var obj = caml_obj_block(Stdlib_Obj[10], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function create_object_opt(obj_0, table){
    if(obj_0) return obj_0;
    var obj = caml_obj_block(Stdlib_Obj[10], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function iter_f(obj, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], f = param$0[1];
     caml_call1(f, obj);
     var param$0 = l;
    }
   }
   function run_initializers(obj, table){
    var inits = table[8], _r_ = 0 !== inits ? 1 : 0;
    return _r_ ? iter_f(obj, inits) : _r_;
   }
   function run_initializers_opt(obj_0, obj, table){
    if(obj_0) return obj;
    var inits = table[8];
    if(0 !== inits) iter_f(obj, inits);
    return obj;
   }
   function create_object_and_run_initiali(obj_0, table){
    if(obj_0) return obj_0;
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj;
   }
   function get_data(param){
    if(param) return param[2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function build_path(n, keys, tables){
    var res = [0, 0, 0, 0], r = [0, res], _o_ = 0;
    if(n >= 0){
     var i = _o_;
     for(;;){
      var _p_ = r[1];
      r[1] = [0, caml_check_bound(keys, i)[1 + i], _p_, 0];
      var _q_ = i + 1 | 0;
      if(n === i) break;
      var i = _q_;
     }
    }
    var v = r[1];
    if(! tables)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    tables[2] = v;
    return res;
   }
   function lookup_tables(root, keys){
    var root_data = get_data(root);
    if(! root_data) return build_path(keys.length - 1 - 1 | 0, keys, root);
    var i$1 = keys.length - 1 - 1 | 0, i = i$1, tables$0 = root_data;
    for(;;){
     if(0 > i) return tables$0;
     var key = caml_check_bound(keys, i)[1 + i], tables$1 = tables$0;
     for(;;){
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      if(tables$1[1] === key) break;
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      var tables = tables$1[3];
      if(! tables){
       var next = [0, key, 0, 0];
       if(! tables$1)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       tables$1[3] = next;
       return build_path(i - 1 | 0, keys, next);
      }
      var tables$1 = tables;
     }
     var tables_data = get_data(tables$1);
     if(! tables_data)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     var i$0 = i - 1 | 0, i = i$0, tables$0 = tables_data;
    }
   }
   function new_cache(table){
    var n = new_method(table);
    a:
    {
     if(0 !== (n % 2 | 0)){
      var _n_ = Stdlib_Sys[9];
      if
       ((2 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _n_) | 0)
        >= n){
       var n$0 = new_method(table);
       break a;
      }
     }
     var n$0 = n;
    }
    caml_check_bound(table[2], n$0)[1 + n$0] = 0;
    return n$0;
   }
   function set_methods(table, methods){
    var len = methods.length - 1, i = [0, 0];
    for(;;){
     if(i[1] >= len) return 0;
     var
      _h_ = i[1],
      label = caml_check_bound(methods, _h_)[1 + _h_],
      next =
        function(param){
         i[1]++;
         var _m_ = i[1];
         return caml_check_bound(methods, _m_)[1 + _m_];
        },
      clo = next(0);
     if(typeof clo === "number")
      switch(clo){
        case 0:
         var
          x = next(0),
          clo$0 = function(x){return function(obj){return x;};}(x);
         break;
        case 1:
         var
          n = next(0),
          clo$0 = function(n){return function(obj){return obj[1 + n];};}(n);
         break;
        case 2:
         var
          e = next(0),
          n$0 = next(0),
          clo$0 =
            function(e, n){return function(obj){return obj[1 + e][1 + n];};}
             (e, n$0);
         break;
        case 3:
         var
          n$1 = next(0),
          clo$0 =
            function(n){
              return function(obj){return caml_call1(obj[1][1 + n], obj);};
             }
             (n$1);
         break;
        case 4:
         var
          n$2 = next(0),
          clo$0 =
            function(n){return function(obj, x){obj[1 + n] = x; return 0;};}
             (n$2);
         break;
        case 5:
         var
          f = next(0),
          x$0 = next(0),
          clo$0 =
            function(f, x){return function(obj){return caml_call1(f, x);};}
             (f, x$0);
         break;
        case 6:
         var
          f$0 = next(0),
          n$3 = next(0),
          clo$0 =
            function(f, n){
              return function(obj){return caml_call1(f, obj[1 + n]);};
             }
             (f$0, n$3);
         break;
        case 7:
         var
          f$1 = next(0),
          e$0 = next(0),
          n$4 = next(0),
          clo$0 =
            function(f, e, n){
              return function(obj){return caml_call1(f, obj[1 + e][1 + n]);};
             }
             (f$1, e$0, n$4);
         break;
        case 8:
         var
          f$2 = next(0),
          n$5 = next(0),
          clo$0 =
            function(f, n){
              return function(obj){
               return caml_call1(f, caml_call1(obj[1][1 + n], obj));};
             }
             (f$2, n$5);
         break;
        case 9:
         var
          f$3 = next(0),
          x$1 = next(0),
          y = next(0),
          clo$0 =
            function(f, x, y){
              return function(obj){return caml_call2(f, x, y);};
             }
             (f$3, x$1, y);
         break;
        case 10:
         var
          f$4 = next(0),
          x$2 = next(0),
          n$6 = next(0),
          clo$0 =
            function(f, x, n){
              return function(obj){return caml_call2(f, x, obj[1 + n]);};
             }
             (f$4, x$2, n$6);
         break;
        case 11:
         var
          f$5 = next(0),
          x$3 = next(0),
          e$1 = next(0),
          n$7 = next(0),
          clo$0 =
            function(f, x, e, n){
              return function(obj){
               return caml_call2(f, x, obj[1 + e][1 + n]);};
             }
             (f$5, x$3, e$1, n$7);
         break;
        case 12:
         var
          f$6 = next(0),
          x$4 = next(0),
          n$8 = next(0),
          clo$0 =
            function(f, x, n){
              return function(obj){
               return caml_call2(f, x, caml_call1(obj[1][1 + n], obj));};
             }
             (f$6, x$4, n$8);
         break;
        case 13:
         var
          f$7 = next(0),
          n$9 = next(0),
          x$5 = next(0),
          clo$0 =
            function(f, n, x){
              return function(obj){return caml_call2(f, obj[1 + n], x);};
             }
             (f$7, n$9, x$5);
         break;
        case 14:
         var
          f$8 = next(0),
          e$2 = next(0),
          n$10 = next(0),
          x$6 = next(0),
          clo$0 =
            function(f, e, n, x){
              return function(obj){
               return caml_call2(f, obj[1 + e][1 + n], x);};
             }
             (f$8, e$2, n$10, x$6);
         break;
        case 15:
         var
          f$9 = next(0),
          n$11 = next(0),
          x$7 = next(0),
          clo$0 =
            function(f, n, x){
              return function(obj){
               return caml_call2(f, caml_call1(obj[1][1 + n], obj), x);};
             }
             (f$9, n$11, x$7);
         break;
        case 16:
         var
          n$12 = next(0),
          x$8 = next(0),
          clo$0 =
            function(n, x){
              return function(obj){return caml_call2(obj[1][1 + n], obj, x);};
             }
             (n$12, x$8);
         break;
        case 17:
         var
          n$13 = next(0),
          m = next(0),
          clo$0 =
            function(n, m){
              return function(obj){
               return caml_call2(obj[1][1 + n], obj, obj[1 + m]);};
             }
             (n$13, m);
         break;
        case 18:
         var
          n$14 = next(0),
          e$3 = next(0),
          m$0 = next(0),
          clo$0 =
            function(n, e, m){
              return function(obj){
               return caml_call2(obj[1][1 + n], obj, obj[1 + e][1 + m]);};
             }
             (n$14, e$3, m$0);
         break;
        case 19:
         var
          n$15 = next(0),
          m$1 = next(0),
          clo$0 =
            function(n, m){
              return function(obj){
               var _l_ = caml_call1(obj[1][1 + m], obj);
               return caml_call2(obj[1][1 + n], obj, _l_);};
             }
             (n$15, m$1);
         break;
        case 20:
         var m$2 = next(0), x$9 = next(0);
         new_cache(table);
         var
          clo$0 =
            function(m, x){
              return function(obj){
               return caml_call1(caml_get_public_method(x, m, 0), x);};
             }
             (m$2, x$9);
         break;
        case 21:
         var m$3 = next(0), n$16 = next(0);
         new_cache(table);
         var
          clo$0 =
            function(m, n){
              return function(obj){
               var _k_ = obj[1 + n];
               return caml_call1(caml_get_public_method(_k_, m, 0), _k_);};
             }
             (m$3, n$16);
         break;
        case 22:
         var m$4 = next(0), e$4 = next(0), n$17 = next(0);
         new_cache(table);
         var
          clo$0 =
            function(m, e, n){
              return function(obj){
               var _j_ = obj[1 + e][1 + n];
               return caml_call1(caml_get_public_method(_j_, m, 0), _j_);};
             }
             (m$4, e$4, n$17);
         break;
        default:
         var m$5 = next(0), n$18 = next(0);
         new_cache(table);
         var
          clo$0 =
            function(m, n){
              return function(obj){
               var _i_ = caml_call1(obj[1][1 + n], obj);
               return caml_call1(caml_get_public_method(_i_, m, 0), _i_);};
             }
             (m$5, n$18);
      }
     else
      var clo$0 = clo;
     set_method(table, label, clo$0);
     i[1]++;
    }
   }
   function stats(param){
    return [0, table_count[1], method_count[1], inst_var_count[1]];
   }
   var
    CamlinternalOO =
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params,
       stats];
   runtime.caml_register_global(17, CamlinternalOO, "CamlinternalOO");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Oo
//# unitInfo: Requires: CamlinternalOO
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalOO = global_data.CamlinternalOO,
    copy = CamlinternalOO[22],
    new_method = CamlinternalOO[1],
    public_method_label = CamlinternalOO[1],
    Stdlib_Oo = [0, copy, new_method, public_method_label];
   runtime.caml_register_global(1, Stdlib_Oo, "Stdlib__Oo");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalMod
//# unitInfo: Requires: CamlinternalLazy, CamlinternalOO, Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalMod_ml = "camlinternalMod.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    CamlinternalOO = global_data.CamlinternalOO,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_camlinternalMod_ml, 72, 5],
    _b_ = [0, cst_camlinternalMod_ml, 81, 2],
    cst_CamlinternalMod_update_mod =
      "CamlinternalMod.update_mod: not a module",
    cst_CamlinternalMod_init_mod_n = "CamlinternalMod.init_mod: not a module";
   function init_mod_block(loc, comps$0){
    var
     length = comps$0.length - 1,
     modu = runtime.caml_obj_block(0, length),
     _h_ = length - 1 | 0,
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var shape = caml_check_bound(comps$0, i)[1 + i];
      if(typeof shape === "number")
       switch(shape){
         case 0:
          var
           fn$0 =
             function(i){
              function fn(x){
               var fn$0 = modu[1 + i];
               if(fn === fn$0)
                throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
               return caml_call1(fn$0, x);
              }
              return fn;
             },
           fn = fn$0(i),
           init = fn;
          break;
         case 1:
          var l = [];
          runtime.caml_update_dummy
           (l,
            [246,
             function(l, i){
               return function(param){
                var l$0 = modu[1 + i];
                if(l === l$0)
                 throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
                var _j_ = caml_obj_tag(l$0);
                if(250 === _j_) return l$0[1];
                if(246 !== _j_ && 244 !== _j_) return l$0;
                return caml_call1(CamlinternalLazy[2], l$0);};
              }
              (l, i)]);
          var init = l;
          break;
         default: var init = caml_call1(CamlinternalOO[21], loc);
       }
      else if(0 === shape[0])
       var comps = shape[1], init = init_mod_block(loc, comps);
      else
       var v = shape[1], init = v;
      modu[1 + i] = init;
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return modu;
   }
   function init_mod(loc, shape){
    if(typeof shape !== "number" && 0 === shape[0]){
     var comps = shape[1];
     return init_mod_block(loc, comps);
    }
    return caml_call1(Stdlib[2], cst_CamlinternalMod_init_mod_n);
   }
   function update_mod_block(comps$0, modu, n){
    if(0 === caml_obj_tag(n) && comps$0.length - 1 <= n.length - 1){
     var _e_ = comps$0.length - 1 - 1 | 0, _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var n$0 = n[1 + i], shape = caml_check_bound(comps$0, i)[1 + i];
       a:
       if(typeof shape === "number"){
        if(2 === shape){
         if(0 === caml_obj_tag(n$0) && 4 === n$0.length - 1){
          var cl = modu[1 + i], j = 0;
          for(;;){
           cl[1 + j] = n$0[1 + j];
           var _c_ = j + 1 | 0;
           if(3 === j) break;
           var j = _c_;
          }
          break a;
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        modu[1 + i] = n$0;
       }
       else if(0 === shape[0]){
        var comps = shape[1];
        update_mod_block(comps, modu[1 + i], n$0);
       }
       var _f_ = i + 1 | 0;
       if(_e_ === i) break;
       var i = _f_;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function update_mod(shape, o, n){
    if(typeof shape !== "number" && 0 === shape[0]){
     var comps = shape[1];
     return update_mod_block(comps, o, n);
    }
    return caml_call1(Stdlib[2], cst_CamlinternalMod_update_mod);
   }
   var CamlinternalMod = [0, init_mod, update_mod];
   runtime.caml_register_global(8, CamlinternalMod, "CamlinternalMod");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Ephemeron
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Obj, Stdlib__Random, Stdlib__Seq, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    _c_ = [0, 0],
    _b_ = [0, 0],
    _a_ = [0, 0];
   function MakeSeeded(H){
    var
     prng = [246, function(_aM_){return caml_call1(Stdlib_Random[15][2], 0);}];
    function create(opt, initial_size){
     if(opt)
      var sth = opt[1], random = sth;
     else
      var random = caml_call1(Stdlib_Hashtbl[17], 0);
     a:
     b:
     {
      var x = 16;
      for(;;){
       if(initial_size <= x) break b;
       if(Stdlib_Sys[13] < (x * 2 | 0)) break;
       var x$0 = x * 2 | 0, x = x$0;
      }
      break a;
     }
     if(random){
      var _aK_ = runtime.caml_obj_tag(prng);
      a:
      if(250 === _aK_)
       var _aL_ = prng[1];
      else{
       if(246 !== _aK_ && 244 !== _aK_){var _aL_ = prng; break a;}
       var _aL_ = caml_call1(CamlinternalLazy[2], prng);
      }
      var seed = caml_call1(Stdlib_Random[15][4], _aL_);
     }
     else
      var seed = 0;
     return [0, 0, caml_make_vect(x, 0), seed, x];
    }
    function clear(h){
     h[1] = 0;
     var len = h[2].length - 1, _aI_ = len - 1 | 0, _aH_ = 0;
     if(_aI_ >= 0){
      var i = _aH_;
      for(;;){
       caml_check_bound(h[2], i)[1 + i] = 0;
       var _aJ_ = i + 1 | 0;
       if(_aI_ === i) break;
       var i = _aJ_;
      }
     }
     return 0;
    }
    function reset(h){
     var len = h[2].length - 1;
     return len === h[4]
             ? clear(h)
             : (h[1] = 0, h[2] = caml_make_vect(h[4], 0), 0);
    }
    function copy(h){
     var _aE_ = h[4], _aF_ = h[3], _aG_ = caml_call1(Stdlib_Array[6], h[2]);
     return [0, h[1], _aG_, _aF_, _aE_];
    }
    function key_index(h, hkey){return hkey & (h[2].length - 1 - 1 | 0);}
    function clean(h){
     function do_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var hkey = param$0[1], rest = param$0[3], c = param$0[2];
       if(caml_call1(H[6], c)){
        var rest$0 = param$0[3], c$0 = param$0[2];
        return [0, hkey, c$0, do_bucket(rest$0)];
       }
       h[1] = h[1] - 1 | 0;
       var param$0 = rest;
      }
     }
     var d = h[2], _aC_ = d.length - 1 - 1 | 0, _aB_ = 0;
     if(_aC_ >= 0){
      var i = _aB_;
      for(;;){
       d[1 + i] = do_bucket(caml_check_bound(d, i)[1 + i]);
       var _aD_ = i + 1 | 0;
       if(_aC_ === i) break;
       var i = _aD_;
      }
     }
     return 0;
    }
    function resize(h){
     var odata = h[2], osize = odata.length - 1, nsize = osize * 2 | 0;
     clean(h);
     var
      _av_ = nsize < Stdlib_Sys[13] ? 1 : 0,
      _aw_ = _av_ ? (osize >>> 1 | 0) <= h[1] ? 1 : 0 : _av_;
     if(_aw_){
      var ndata = caml_make_vect(nsize, 0);
      h[2] = ndata;
      var
       insert_bucket =
         function(param){
          if(! param) return;
          var rest = param[3], data = param[2], hkey = param[1];
          insert_bucket(rest);
          var nidx = key_index(h, hkey);
          ndata[1 + nidx] =
           [0, hkey, data, caml_check_bound(ndata, nidx)[1 + nidx]];
          return;
         },
       _ay_ = osize - 1 | 0,
       _ax_ = 0;
      if(_ay_ >= 0){
       var i = _ax_;
       for(;;){
        insert_bucket(caml_check_bound(odata, i)[1 + i]);
        var _aA_ = i + 1 | 0;
        if(_ay_ === i) break;
        var i = _aA_;
       }
      }
      var _az_ = 0;
     }
     else
      var _az_ = _aw_;
     return _az_;
    }
    function add(h, key, info){
     var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      container = caml_call2(H[1], key, info),
      bucket = [0, hkey, container, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _au_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _au_ ? resize(h) : _au_;
    }
    function remove(h, key){
     var hkey = caml_call2(H[2], h[3], key);
     function remove_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var hk = param$0[1], next = param$0[3], c = param$0[2];
       if(hkey !== hk){
        var next$0 = param$0[3], c$0 = param$0[2];
        return [0, hk, c$0, remove_bucket(next$0)];
       }
       switch(caml_call2(H[3], c, key)){
         case 0:
          h[1] = h[1] - 1 | 0; return next;
         case 1:
          return [0, hk, c, remove_bucket(next)];
         default: h[1] = h[1] - 1 | 0; var param$0 = next;
       }
      }
     }
     var
      i = key_index(h, hkey),
      _at_ = remove_bucket(caml_check_bound(h[2], i)[1 + i]);
     caml_check_bound(h[2], i)[1 + i] = _at_;
     return 0;
    }
    function find(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      _as_ = key_index(h, hkey),
      param = caml_check_bound(h[2], _as_)[1 + _as_];
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var hk = param[1], rest = param[3], c = param[2];
      if(hkey === hk)
       switch(caml_call2(H[3], c, key)){
         case 0:
          var match = caml_call1(H[4], c);
          if(match){var d = match[1]; return d;}
          var param = rest;
          break;
         case 1:
          var param = rest; break;
         default: var param = rest;
       }
      else
       var rest$0 = param[3], param = rest$0;
     }
    }
    function find_opt(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      _ar_ = key_index(h, hkey),
      param = caml_check_bound(h[2], _ar_)[1 + _ar_];
     for(;;){
      if(! param) return 0;
      var hk = param[1], rest = param[3], c = param[2];
      if(hkey === hk)
       switch(caml_call2(H[3], c, key)){
         case 0:
          var d = caml_call1(H[4], c);
          if(d) return d;
          var param = rest;
          break;
         case 1:
          var param = rest; break;
         default: var param = rest;
       }
      else
       var rest$0 = param[3], param = rest$0;
     }
    }
    function find_all(h, key){
     var hkey = caml_call2(H[2], h[3], key);
     function find_in_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var hk = param$0[1], rest = param$0[3], c = param$0[2];
       if(hkey === hk)
        switch(caml_call2(H[3], c, key)){
          case 0:
           var match = caml_call1(H[4], c);
           if(match){var d = match[1]; return [0, d, find_in_bucket(rest)];}
           var param$0 = rest;
           break;
          case 1:
           var param$0 = rest; break;
          default: var param$0 = rest;
        }
       else
        var rest$0 = param$0[3], param$0 = rest$0;
      }
     }
     var _aq_ = key_index(h, hkey);
     return find_in_bucket(caml_check_bound(h[2], _aq_)[1 + _aq_]);
    }
    function replace(h, key, info){
     var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      l = caml_check_bound(h[2], i)[1 + i];
     try{
      var param = l;
      for(;;){
       if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var hk = param[1], next = param[3], c = param[2];
       if(hkey === hk){
        if(! caml_call2(H[3], c, key)){
         var _am_ = caml_call3(H[5], c, key, info);
         return _am_;
        }
        var param = next;
       }
       else
        var next$0 = param[3], param = next$0;
      }
     }
     catch(_ap_){
      var _an_ = caml_wrap_exception(_ap_);
      if(_an_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_an_, 0);
      var container = caml_call2(H[1], key, info);
      caml_check_bound(h[2], i)[1 + i] = [0, hkey, container, l];
      h[1] = h[1] + 1 | 0;
      var _ao_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      return _ao_ ? resize(h) : _ao_;
     }
    }
    function mem(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      _al_ = key_index(h, hkey),
      param = caml_check_bound(h[2], _al_)[1 + _al_];
     for(;;){
      if(! param) return 0;
      var hk = param[1], rest = param[3], c = param[2];
      if(hk === hkey){
       if(! caml_call2(H[3], c, key)) return 1;
       var param = rest;
      }
      else
       var rest$0 = param[3], param = rest$0;
     }
    }
    function length(h){return h[1];}
    function bucket_length(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(! param$0) return accu$0;
      var
       rest = param$0[3],
       accu$1 = accu$0 + 1 | 0,
       accu$0 = accu$1,
       param$0 = rest;
     }
    }
    function stats(h){
     var _af_ = h[2], _ag_ = 0;
     function _ah_(m, b){
      var _ak_ = bucket_length(0, b);
      return caml_call2(Stdlib_Int[11], m, _ak_);
     }
     var
      mbl = caml_call3(Stdlib_Array[17], _ah_, _ag_, _af_),
      histo = caml_make_vect(mbl + 1 | 0, 0),
      _ai_ = h[2];
     function _aj_(b){
      var l = bucket_length(0, b);
      histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
      return 0;
     }
     caml_call2(Stdlib_Array[11], _aj_, _ai_);
     return [0, h[1], h[2].length - 1, mbl, histo];
    }
    function bucket_length_alive(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(! param$0) return accu$0;
      var rest = param$0[3], c = param$0[2];
      if(caml_call1(H[6], c))
       var accu$1 = accu$0 + 1 | 0, accu$0 = accu$1, param$0 = rest;
      else
       var rest$0 = param$0[3], param$0 = rest$0;
     }
    }
    function stats_alive(h){
     var size = [0, 0], _$_ = h[2], _aa_ = 0;
     function _ab_(m, b){
      var _ae_ = bucket_length_alive(0, b);
      return caml_call2(Stdlib_Int[11], m, _ae_);
     }
     var
      mbl = caml_call3(Stdlib_Array[17], _ab_, _aa_, _$_),
      histo = caml_make_vect(mbl + 1 | 0, 0),
      _ac_ = h[2];
     function _ad_(b){
      var l = bucket_length_alive(0, b);
      size[1] = size[1] + l | 0;
      histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
      return 0;
     }
     caml_call2(Stdlib_Array[11], _ad_, _ac_);
     return [0, size[1], h[2].length - 1, mbl, histo];
    }
    function add_seq(tbl, i){
     function ___(param){
      var v = param[2], k = param[1];
      return add(tbl, k, v);
     }
     return caml_call2(Stdlib_Seq[4], ___, i);
    }
    function replace_seq(tbl, i){
     function _Z_(param){
      var v = param[2], k = param[1];
      return replace(tbl, k, v);
     }
     return caml_call2(Stdlib_Seq[4], _Z_, i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function create(param){return caml_call1(Stdlib_Obj[24][1], 1);}
   function get_key(t){return caml_call2(Stdlib_Obj[24][3], t, 0);}
   function set_key(t, k){return caml_call3(Stdlib_Obj[24][5], t, 0, k);}
   function check_key(t){return caml_call2(Stdlib_Obj[24][7], t, 0);}
   function get_data(t){return caml_call1(Stdlib_Obj[24][9], t);}
   function set_data(t, d){return caml_call2(Stdlib_Obj[24][11], t, d);}
   function make(key, data){
    var eph = create(0);
    set_data(eph, data);
    set_key(eph, key);
    return eph;
   }
   function query(eph, key){
    var match = get_key(eph);
    if(! match) return 0;
    var k = match[1];
    return k === key ? get_data(eph) : 0;
   }
   function MakeSeeded$0(H){
    function create$0(k, d){
     var c = create(0);
     set_data(c, d);
     set_key(c, k);
     return c;
    }
    var seeded_hash = H[2];
    function equal(c, k){
     var match = get_key(c);
     if(! match) return 2;
     var k$0 = match[1];
     return caml_call2(H[1], k, k$0) ? 0 : 1;
    }
    function set_key_data(c, k, d){
     caml_call1(Stdlib_Obj[24][12], c);
     set_key(c, k);
     return set_data(c, d);
    }
    return MakeSeeded
            ([0,
              create$0,
              seeded_hash,
              equal,
              get_data,
              set_key_data,
              check_key]);
   }
   function Make(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded$0([0, equal, seeded_hash]),
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     length = include[12],
     stats = include[13],
     add_seq = include[14],
     replace_seq = include[15],
     clean = include[17],
     stats_alive = include[18],
     _Y_ = include[1];
    function create(sz){return caml_call2(_Y_, _a_, sz);}
    function of_seq(i){
     var tbl = create(16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$0(param){return [0, 0];}
   function add(b, k, d){
    var _X_ = b[1];
    b[1] = [0, make(k, d), _X_];
    return 0;
   }
   function test_key(k, e){
    var match = get_key(e);
    if(match){var x = match[1]; if(x === k) return 1;}
    return 0;
   }
   function remove(b, k){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_key(k, h)){b[1] = caml_call2(Stdlib_List[13], acc, t); return 0;}
     var t$0 = l[2], acc$0 = [0, h, acc], l = t$0, acc = acc$0;
    }
   }
   function find(b, k){
    var _U_ = b[1];
    function _V_(_W_){return test_key(k, _W_);}
    var match = caml_call2(Stdlib_List[40], _V_, _U_);
    if(! match) return 0;
    var e = match[1];
    return get_data(e);
   }
   function length(b){return caml_call1(Stdlib_List[1], b[1]);}
   function clear(b){b[1] = 0; return 0;}
   function create$0(param){return caml_call1(Stdlib_Obj[24][1], 2);}
   function get_key1(t){return caml_call2(Stdlib_Obj[24][3], t, 0);}
   function set_key1(t, k){return caml_call3(Stdlib_Obj[24][5], t, 0, k);}
   function get_key2(t){return caml_call2(Stdlib_Obj[24][3], t, 1);}
   function set_key2(t, k){return caml_call3(Stdlib_Obj[24][5], t, 1, k);}
   function get_data$0(t){return caml_call1(Stdlib_Obj[24][9], t);}
   function set_data$0(t, d){return caml_call2(Stdlib_Obj[24][11], t, d);}
   function make$1(key1, key2, data){
    var eph = create$0(0);
    set_data$0(eph, data);
    set_key1(eph, key1);
    set_key2(eph, key2);
    return eph;
   }
   function query$0(eph, key1, key2){
    var match = get_key1(eph);
    if(! match) return 0;
    var k = match[1];
    if(k !== key1) return 0;
    var match$0 = get_key2(eph);
    if(! match$0) return 0;
    var k$0 = match$0[1];
    return k$0 === key2 ? get_data$0(eph) : 0;
   }
   function MakeSeeded$1(H1, H2){
    function create(param, d){
     var k2 = param[2], k1 = param[1], c = create$0(0);
     set_data$0(c, d);
     set_key1(c, k1);
     set_key2(c, k2);
     return c;
    }
    function seeded_hash(seed, param){
     var
      k2 = param[2],
      k1 = param[1],
      _T_ = caml_call2(H2[2], seed, k2) * 65599 | 0;
     return caml_call2(H1[2], seed, k1) + _T_ | 0;
    }
    function equal(c, param){
     var
      k2 = param[2],
      k1 = param[1],
      match = get_key1(c),
      match$0 = get_key2(c);
     if(match && match$0){
      var k2$0 = match$0[1], k1$0 = match[1];
      if(caml_call2(H1[1], k1, k1$0) && caml_call2(H2[1], k2, k2$0)) return 0;
      return 1;
     }
     return 2;
    }
    function set_key_data(c, param, d){
     var k2 = param[2], k1 = param[1];
     caml_call1(Stdlib_Obj[24][12], c);
     set_key1(c, k1);
     set_key2(c, k2);
     return set_data$0(c, d);
    }
    function check_key(c){
     var _S_ = caml_call2(Stdlib_Obj[24][7], c, 0);
     return _S_ ? caml_call2(Stdlib_Obj[24][7], c, 1) : _S_;
    }
    return MakeSeeded
            ([0,
              create,
              seeded_hash,
              equal,
              get_data$0,
              set_key_data,
              check_key]);
   }
   function Make$0(H1, H2){
    var equal = H2[1];
    function seeded_hash(seed, x){return caml_call1(H2[2], x);}
    var equal$0 = H1[1], _Q_ = [0, equal, seeded_hash];
    function seeded_hash$0(seed, x){return caml_call1(H1[2], x);}
    var
     include = MakeSeeded$1([0, equal$0, seeded_hash$0], _Q_),
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     length = include[12],
     stats = include[13],
     add_seq = include[14],
     replace_seq = include[15],
     clean = include[17],
     stats_alive = include[18],
     _R_ = include[1];
    function create(sz){return caml_call2(_R_, _b_, sz);}
    function of_seq(i){
     var tbl = create(16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$2(param){return [0, 0];}
   function add$0(b, k1, k2, d){
    var _P_ = b[1];
    b[1] = [0, make$1(k1, k2, d), _P_];
    return 0;
   }
   function test_keys(k1, k2, e){
    var match = get_key1(e), match$0 = get_key2(e);
    if(match && match$0){
     var x2 = match$0[1], x1 = match[1];
     if(x1 === k1 && x2 === k2) return 1;
    }
    return 0;
   }
   function remove$0(b, k1, k2){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_keys(k1, k2, h)){
      b[1] = caml_call2(Stdlib_List[13], acc, t);
      return 0;
     }
     var t$0 = l[2], acc$0 = [0, h, acc], l = t$0, acc = acc$0;
    }
   }
   function find$0(b, k1, k2){
    var _M_ = b[1];
    function _N_(_O_){return test_keys(k1, k2, _O_);}
    var match = caml_call2(Stdlib_List[40], _N_, _M_);
    if(! match) return 0;
    var e = match[1];
    return get_data$0(e);
   }
   function length$0(b){return caml_call1(Stdlib_List[1], b[1]);}
   function clear$0(b){b[1] = 0; return 0;}
   function create$1(n){return caml_call1(Stdlib_Obj[24][1], n);}
   function length$1(k){return caml_call1(Stdlib_Obj[24][2], k);}
   function get_key$0(t, n){return caml_call2(Stdlib_Obj[24][3], t, n);}
   function set_key$0(t, n, k){return caml_call3(Stdlib_Obj[24][5], t, n, k);}
   function get_data$1(t){return caml_call1(Stdlib_Obj[24][9], t);}
   function set_data$1(t, d){return caml_call2(Stdlib_Obj[24][11], t, d);}
   function make$3(keys, data){
    var l = keys.length - 1, eph = create$1(l);
    set_data$1(eph, data);
    var _K_ = l - 1 | 0, _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      set_key$0(eph, i, caml_check_bound(keys, i)[1 + i]);
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      var i = _L_;
     }
    }
    return eph;
   }
   function query$1(eph, keys){
    var l = length$1(eph);
    try{
     if(l !== keys.length - 1)
      throw caml_maybe_attach_backtrace(Stdlib[3], 1);
     var _F_ = l - 1 | 0, _E_ = 0;
     if(_F_ >= 0){
      var i = _E_;
      for(;;){
       var match = get_key$0(eph, i);
       if(! match) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var k = match[1];
       if(k !== caml_check_bound(keys, i)[1 + i])
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var _H_ = i + 1 | 0;
       if(_F_ === i) break;
       var i = _H_;
      }
     }
     var _G_ = get_data$1(eph);
     return _G_;
    }
    catch(_I_){
     var _D_ = caml_wrap_exception(_I_);
     if(_D_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_D_, 0);
    }
   }
   function MakeSeeded$2(H){
    function create(k, d){
     var c = create$1(k.length - 1);
     set_data$1(c, d);
     var _B_ = k.length - 1 - 1 | 0, _A_ = 0;
     if(_B_ >= 0){
      var i = _A_;
      for(;;){
       set_key$0(c, i, caml_check_bound(k, i)[1 + i]);
       var _C_ = i + 1 | 0;
       if(_B_ === i) break;
       var i = _C_;
      }
     }
     return c;
    }
    function seeded_hash(seed, k){
     var h = [0, 0], _w_ = k.length - 1 - 1 | 0, _v_ = 0;
     if(_w_ >= 0){
      var i = _v_;
      for(;;){
       var _x_ = h[1], _y_ = caml_check_bound(k, i)[1 + i];
       h[1] = (caml_call2(H[2], seed, _y_) * 65599 | 0) + _x_ | 0;
       var _z_ = i + 1 | 0;
       if(_w_ === i) break;
       var i = _z_;
      }
     }
     return h[1];
    }
    function equal(c, k){
     var len = k.length - 1, len$0 = length$1(c);
     if(len !== len$0) return 1;
     var i$1 = len - 1 | 0, i = i$1;
     for(;;){
      if(0 > i) return 0;
      var match = get_key$0(c, i);
      if(! match) return 2;
      var ki = match[1], _u_ = caml_check_bound(k, i)[1 + i];
      if(! caml_call2(H[1], _u_, ki)) return 1;
      var i$0 = i - 1 | 0, i = i$0;
     }
    }
    function set_key_data(c, k, d){
     caml_call1(Stdlib_Obj[24][12], c);
     var _s_ = k.length - 1 - 1 | 0, _r_ = 0;
     if(_s_ >= 0){
      var i = _r_;
      for(;;){
       set_key$0(c, i, caml_check_bound(k, i)[1 + i]);
       var _t_ = i + 1 | 0;
       if(_s_ === i) break;
       var i = _t_;
      }
     }
     return set_data$1(c, d);
    }
    function check_key(c){
     var i$1 = length$1(c) - 1 | 0, i = i$1;
     for(;;){
      var _p_ = i < 0 ? 1 : 0;
      if(_p_)
       var _q_ = _p_;
      else{
       var _o_ = caml_call2(Stdlib_Obj[24][7], c, i);
       if(_o_){var i$0 = i - 1 | 0, i = i$0; continue;}
       var _q_ = _o_;
      }
      return _q_;
     }
    }
    return MakeSeeded
            ([0,
              create,
              seeded_hash,
              equal,
              get_data$1,
              set_key_data,
              check_key]);
   }
   function Make$1(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded$2([0, equal, seeded_hash]),
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     length = include[12],
     stats = include[13],
     add_seq = include[14],
     replace_seq = include[15],
     clean = include[17],
     stats_alive = include[18],
     _n_ = include[1];
    function create(sz){return caml_call2(_n_, _c_, sz);}
    function of_seq(i){
     var tbl = create(16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$4(param){return [0, 0];}
   function add$1(b, k, d){
    var _m_ = b[1];
    b[1] = [0, make$3(k, d), _m_];
    return 0;
   }
   function test_keys$0(k, e){
    try{
     if(length$1(e) !== k.length - 1)
      throw caml_maybe_attach_backtrace(Stdlib[3], 1);
     var _i_ = k.length - 1 - 1 | 0, _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       var match = get_key$0(e, i);
       if(match){
        var x = match[1];
        if(x === caml_check_bound(k, i)[1 + i]){
         var _k_ = i + 1 | 0;
         if(_i_ === i) break;
         var i = _k_;
         continue;
        }
       }
       throw caml_maybe_attach_backtrace(Stdlib[3], 1);
      }
     }
     var _j_ = 1;
     return _j_;
    }
    catch(_l_){
     var _g_ = caml_wrap_exception(_l_);
     if(_g_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_g_, 0);
    }
   }
   function remove$1(b, k){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_keys$0(k, h)){
      b[1] = caml_call2(Stdlib_List[13], acc, t);
      return 0;
     }
     var t$0 = l[2], acc$0 = [0, h, acc], l = t$0, acc = acc$0;
    }
   }
   function find$1(b, k){
    var _d_ = b[1];
    function _e_(_f_){return test_keys$0(k, _f_);}
    var match = caml_call2(Stdlib_List[40], _e_, _d_);
    if(! match) return 0;
    var e = match[1];
    return get_data$1(e);
   }
   function length$2(b){return caml_call1(Stdlib_List[1], b[1]);}
   function clear$1(b){b[1] = 0; return 0;}
   var
    Stdlib_Ephemeron =
      [0,
       [0,
        make,
        query,
        Make,
        MakeSeeded$0,
        [0, make$0, add, remove, find, length, clear]],
       [0,
        make$1,
        query$0,
        Make$0,
        MakeSeeded$1,
        [0, make$2, add$0, remove$0, find$0, length$0, clear$0]],
       [0,
        make$3,
        query$1,
        Make$1,
        MakeSeeded$2,
        [0, make$4, add$1, remove$1, find$1, length$2, clear$1]]];
   runtime.caml_register_global(13, Stdlib_Ephemeron, "Stdlib__Ephemeron");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Filename
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Domain, Stdlib__List, Stdlib__Printf, Stdlib__Random, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$19 = "",
    cst$23 = " ",
    cst_2$1 = " 2>",
    cst_2_1$1 = " 2>&1",
    cst$22 = " <",
    cst$21 = " >",
    cst$20 = '"',
    cst$24 = ".",
    cst$25 = "..",
    cst$28 = "../",
    cst$27 = "./",
    cst$26 = "/",
    cst_dev_null = "/dev/null",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$18 = cst$19,
    cst$17 = cst$19,
    cst$16 = cst$19,
    cst$8 = cst$21,
    cst$15 = cst$19,
    cst$9 = cst$22,
    cst$14 = cst$19,
    cst$10 = cst$23,
    cst$11 = cst$23,
    cst$12 = cst$20,
    cst$13 = cst$19,
    cst$6 = cst$20,
    cst$7 = cst$19,
    cst$4 = cst$19,
    cst = cst$21,
    cst$3 = cst$19,
    cst$0 = cst$22,
    cst$2 = cst$19,
    cst$1 = cst$23,
    null$0 = cst_dev_null,
    current_dir_name = cst$24,
    parent_dir_name = cst$25,
    dir_sep = cst$26,
    quotequote = "'\\''",
    null$1 = "NUL",
    current_dir_name$0 = cst$24,
    parent_dir_name$0 = cst$25,
    dir_sep$0 = "\\",
    cst$5 = cst$24,
    null$2 = cst_dev_null,
    current_dir_name$1 = cst$24,
    parent_dir_name$1 = cst$25,
    dir_sep$1 = cst$26,
    Stdlib = global_data.Stdlib,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Sys = global_data.Stdlib__Sys,
    _j_ = [0, 7, 0],
    _i_ = [0, 1, [0, 3, [0, 5, 0]]],
    _f_ = [0, [2, 0, [4, 6, [0, 2, 6], 0, [2, 0, 0]]], "%s%06x%s"],
    cst_Filename_chop_extension = "Filename.chop_extension",
    cst_Filename_chop_suffix = "Filename.chop_suffix",
    _d_ = [0, cst$20, 0],
    cst_2_1$0 = cst_2_1$1,
    cst_2$0 = cst_2$1,
    cst_Filename_quote_command_bad = "Filename.quote_command: bad file name ",
    _c_ = [0, cst$20, 0],
    cst_2_1 = cst_2_1$1,
    cst_2 = cst_2$1,
    cst_tmp = "/tmp";
   function generic_basename(is_dir_sep, current_dir_name, name){
    if(caml_string_equal(name, cst$19)) return current_dir_name;
    var n$3 = caml_ml_string_length(name) - 1 | 0, n = n$3;
    for(;;){
     if(0 > n) return caml_call3(Stdlib_String[16], name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0, n = n$0;
    }
    var p = n + 1 | 0, n$1 = n;
    for(;;){
     if(0 > n$1) return caml_call3(Stdlib_String[16], name, 0, p);
     if(caml_call2(is_dir_sep, name, n$1))
      return caml_call3
              (Stdlib_String[16], name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
     var n$2 = n$1 - 1 | 0, n$1 = n$2;
    }
   }
   function generic_dirname(is_dir_sep, current_dir_name, name){
    if(caml_string_equal(name, cst$19)) return current_dir_name;
    var n$5 = caml_ml_string_length(name) - 1 | 0, n = n$5;
    for(;;){
     if(0 > n) return caml_call3(Stdlib_String[16], name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0, n = n$0;
    }
    var n$1 = n;
    for(;;){
     if(0 > n$1) return current_dir_name;
     if(caml_call2(is_dir_sep, name, n$1)) break;
     var n$2 = n$1 - 1 | 0, n$1 = n$2;
    }
    var n$3 = n$1;
    for(;;){
     if(0 > n$3) return caml_call3(Stdlib_String[16], name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n$3))
      return caml_call3(Stdlib_String[16], name, 0, n$3 + 1 | 0);
     var n$4 = n$3 - 1 | 0, n$3 = n$4;
    }
   }
   function is_dir_sep(s, i){return 47 === caml_string_get(s, i) ? 1 : 0;}
   function is_relative(n){
    var
     _aM_ = caml_ml_string_length(n) < 1 ? 1 : 0,
     _aN_ = _aM_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    return _aN_;
   }
   function is_implicit(n){
    var _aH_ = is_relative(n);
    if(_aH_){
     var
      _aI_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _aJ_ =
        _aI_
        ||
         caml_string_notequal(caml_call3(Stdlib_String[16], n, 0, 2), cst$27);
     if(_aJ_)
      var
       _aK_ = caml_ml_string_length(n) < 3 ? 1 : 0,
       _aL_ =
         _aK_
         ||
          caml_string_notequal(caml_call3(Stdlib_String[16], n, 0, 3), cst$28);
     else
      var _aL_ = _aJ_;
    }
    else
     var _aL_ = _aH_;
    return _aL_;
   }
   function check_suffix(name, suff){
    return caml_call2(Stdlib_String[12], suff, name);
   }
   function chop_suffix_opt(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var r = caml_call3(Stdlib_String[16], filename, len_f - len_s | 0, len_s);
    return caml_string_equal(r, suffix)
            ? [0,
              caml_call3(Stdlib_String[16], filename, 0, len_f - len_s | 0)]
            : 0;
   }
   try{var _l_ = caml_sys_getenv("TMPDIR"), temp_dir_name = _l_;}
   catch(_aG_){
    var _a_ = caml_wrap_exception(_aG_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var temp_dir_name = cst_tmp;
   }
   function quote(s){
    var
     l = caml_ml_string_length(s),
     b = caml_call1(Stdlib_Buffer[1], l + 20 | 0);
    caml_call2(Stdlib_Buffer[12], b, 39);
    var _aD_ = l - 1 | 0, _aC_ = 0;
    if(_aD_ >= 0){
     var i = _aC_;
     for(;;){
      if(39 === caml_string_get(s, i))
       caml_call2(Stdlib_Buffer[16], b, quotequote);
      else{
       var _aF_ = caml_string_get(s, i);
       caml_call2(Stdlib_Buffer[12], b, _aF_);
      }
      var _aE_ = i + 1 | 0;
      if(_aD_ === i) break;
      var i = _aE_;
     }
    }
    caml_call2(Stdlib_Buffer[12], b, 39);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quote_command(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var _ar_ = cst_2_1;
     else
      var _aB_ = quote(f), _ar_ = caml_call2(Stdlib[28], cst_2, _aB_);
     var _as_ = _ar_;
    }
    else
     var _as_ = cst$4;
    if(stdout)
     var
      f$0 = stdout[1],
      _at_ = quote(f$0),
      _au_ = caml_call2(Stdlib[28], cst, _at_);
    else
     var _au_ = cst$3;
    var _av_ = caml_call2(Stdlib[28], _au_, _as_);
    if(stdin)
     var
      f$1 = stdin[1],
      _aw_ = quote(f$1),
      _ax_ = caml_call2(Stdlib[28], cst$0, _aw_);
    else
     var _ax_ = cst$2;
    var
     _ay_ = caml_call2(Stdlib[28], _ax_, _av_),
     _az_ = caml_call2(Stdlib_List[20], quote, [0, cmd, args]),
     _aA_ = caml_call2(Stdlib_String[7], cst$1, _az_);
    return caml_call2(Stdlib[28], _aA_, _ay_);
   }
   function basename(_aq_){
    return generic_basename(is_dir_sep, current_dir_name, _aq_);
   }
   function dirname(_ap_){
    return generic_dirname(is_dir_sep, current_dir_name, _ap_);
   }
   var
    Unix =
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       temp_dir_name,
       quote,
       quote_command,
       basename,
       dirname];
   function is_dir_sep$0(s, i){
    var c = caml_string_get(s, i), _am_ = 47 === c ? 1 : 0;
    if(_am_)
     var _an_ = _am_;
    else
     var _ao_ = 92 === c ? 1 : 0, _an_ = _ao_ || (58 === c ? 1 : 0);
    return _an_;
   }
   function is_relative$0(n){
    var
     _ag_ = caml_ml_string_length(n) < 1 ? 1 : 0,
     _ah_ = _ag_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    if(_ah_){
     var
      _ai_ = caml_ml_string_length(n) < 1 ? 1 : 0,
      _aj_ = _ai_ || (92 !== caml_string_get(n, 0) ? 1 : 0);
     if(_aj_)
      var
       _ak_ = caml_ml_string_length(n) < 2 ? 1 : 0,
       _al_ = _ak_ || (58 !== caml_string_get(n, 1) ? 1 : 0);
     else
      var _al_ = _aj_;
    }
    else
     var _al_ = _ah_;
    return _al_;
   }
   function is_implicit$0(n){
    var _Z_ = is_relative$0(n);
    if(_Z_){
     var
      ___ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _$_ =
        ___
        ||
         caml_string_notequal(caml_call3(Stdlib_String[16], n, 0, 2), cst$27);
     if(_$_){
      var
       _aa_ = caml_ml_string_length(n) < 2 ? 1 : 0,
       _ab_ =
         _aa_
         ||
          caml_string_notequal(caml_call3(Stdlib_String[16], n, 0, 2), ".\\");
      if(_ab_){
       var
        _ac_ = caml_ml_string_length(n) < 3 ? 1 : 0,
        _ad_ =
          _ac_
          ||
           caml_string_notequal
            (caml_call3(Stdlib_String[16], n, 0, 3), cst$28);
       if(_ad_)
        var
         _ae_ = caml_ml_string_length(n) < 3 ? 1 : 0,
         _af_ =
           _ae_
           ||
            caml_string_notequal
             (caml_call3(Stdlib_String[16], n, 0, 3), "..\\");
       else
        var _af_ = _ad_;
      }
      else
       var _af_ = _ab_;
     }
     else
      var _af_ = _$_;
    }
    else
     var _af_ = _Z_;
    return _af_;
   }
   function check_suffix$0(name, suff){
    var
     _W_ = caml_ml_string_length(suff) <= caml_ml_string_length(name) ? 1 : 0;
    if(_W_)
     var
      s =
        caml_call3
         (Stdlib_String[16],
          name,
          caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
          caml_ml_string_length(suff)),
      _X_ = caml_call1(Stdlib_String[27], suff),
      _Y_ = caml_string_equal(caml_call1(Stdlib_String[27], s), _X_);
    else
     var _Y_ = _W_;
    return _Y_;
   }
   function chop_suffix_opt$0(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var
     r = caml_call3(Stdlib_String[16], filename, len_f - len_s | 0, len_s),
     _V_ = caml_call1(Stdlib_String[27], suffix);
    return caml_string_equal(caml_call1(Stdlib_String[27], r), _V_)
            ? [0,
              caml_call3(Stdlib_String[16], filename, 0, len_f - len_s | 0)]
            : 0;
   }
   try{var _k_ = caml_sys_getenv("TEMP"), temp_dir_name$0 = _k_;}
   catch(_U_){
    var _b_ = caml_wrap_exception(_U_);
    if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
    var temp_dir_name$0 = cst$5;
   }
   function quote$0(s){
    var
     l = caml_ml_string_length(s),
     b = caml_call1(Stdlib_Buffer[1], l + 20 | 0);
    caml_call2(Stdlib_Buffer[12], b, 34);
    function loop$0(counter, i){
     var i$0 = i;
     for(;;){
      if(i$0 === l) return caml_call2(Stdlib_Buffer[12], b, 34);
      var c = caml_string_get(s, i$0);
      if(34 === c){
       var _S_ = 0;
       if(counter >= 50)
        return caml_trampoline_return(loop_bs, [0, _S_, i$0]);
       var counter$1 = counter + 1 | 0;
       return loop_bs(counter$1, _S_, i$0);
      }
      if(92 === c){
       var _T_ = 0;
       if(counter >= 50)
        return caml_trampoline_return(loop_bs, [0, _T_, i$0]);
       var counter$0 = counter + 1 | 0;
       return loop_bs(counter$0, _T_, i$0);
      }
      caml_call2(Stdlib_Buffer[12], b, c);
      var i$1 = i$0 + 1 | 0, i$0 = i$1;
     }
    }
    function loop_bs(counter, n, i){
     var n$0 = n, i$0 = i;
     for(;;){
      if(i$0 === l){caml_call2(Stdlib_Buffer[12], b, 34); return add_bs(n$0);}
      var match = caml_string_get(s, i$0);
      if(34 === match){
       add_bs((2 * n$0 | 0) + 1 | 0);
       caml_call2(Stdlib_Buffer[12], b, 34);
       var _R_ = i$0 + 1 | 0;
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, _R_]);
       var counter$1 = counter + 1 | 0;
       return loop$0(counter$1, _R_);
      }
      if(92 !== match){
       add_bs(n$0);
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, i$0]);
       var counter$0 = counter + 1 | 0;
       return loop$0(counter$0, i$0);
      }
      var i$1 = i$0 + 1 | 0, n$1 = n$0 + 1 | 0, n$0 = n$1, i$0 = i$1;
     }
    }
    function loop(i){return caml_trampoline(loop$0(0, i));}
    function add_bs(n){
     var _P_ = 1;
     if(n >= 1){
      var j = _P_;
      for(;;){
       caml_call2(Stdlib_Buffer[12], b, 92);
       var _Q_ = j + 1 | 0;
       if(n === j) break;
       var j = _Q_;
      }
     }
     return;
    }
    loop(0);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quote_cmd_filename(f){
    function _N_(param){if(34 !== param && 37 !== param) return 0; return 1;}
    if(! caml_call2(Stdlib_String[23], _N_, f))
     return caml_call2(Stdlib_String[15], f, 32)
             ? caml_call2(Stdlib_String[7], cst$7, [0, cst$6, [0, f, _c_]])
             : f;
    var _O_ = caml_call2(Stdlib[28], cst_Filename_quote_command_bad, f);
    return caml_call1(Stdlib[2], _O_);
   }
   function quote_command$0(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var _z_ = cst_2_1$0;
     else
      var
       _L_ = quote_cmd_filename(f),
       _z_ = caml_call2(Stdlib[28], cst_2$0, _L_);
     var _A_ = _z_;
    }
    else
     var _A_ = cst$16;
    var _B_ = [0, _A_, _d_];
    if(stdout)
     var
      f$0 = stdout[1],
      _C_ = quote_cmd_filename(f$0),
      _D_ = caml_call2(Stdlib[28], cst$8, _C_);
    else
     var _D_ = cst$15;
    var _E_ = [0, _D_, _B_];
    if(stdin)
     var
      f$1 = stdin[1],
      _F_ = quote_cmd_filename(f$1),
      _G_ = caml_call2(Stdlib[28], cst$9, _F_);
    else
     var _G_ = cst$14;
    var
     _I_ = caml_call2(Stdlib_List[20], quote$0, args),
     s = caml_call2(Stdlib_String[7], cst$10, _I_),
     b = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s) + 20 | 0),
     _H_ = [0, _G_, _E_];
    function _y_(c){
     a:
     {
      if(62 <= c){
       var _M_ = c - 63 | 0;
       if(60 < _M_ >>> 0){if(62 <= _M_) break a;} else if(31 !== _M_) break a;
      }
      else
       if(42 <= c){
        if(60 !== c) break a;
       }
       else{
        if(33 > c) break a;
        switch(c - 33 | 0){case 2:case 3:case 6: break a;
        }
       }
      caml_call2(Stdlib_Buffer[12], b, 94);
      return caml_call2(Stdlib_Buffer[12], b, c);
     }
     return caml_call2(Stdlib_Buffer[12], b, c);
    }
    caml_call2(Stdlib_String[30], _y_, s);
    var
     _J_ = [0, cst$11, [0, caml_call1(Stdlib_Buffer[2], b), _H_]],
     _K_ = [0, cst$12, [0, quote_cmd_filename(cmd), _J_]];
    return caml_call2(Stdlib_String[7], cst$13, _K_);
   }
   function drive_and_path(s){
    var _u_ = 2 <= caml_ml_string_length(s) ? 1 : 0;
    if(_u_){
     var param = caml_string_get(s, 0);
     a:
     {
      b:
      {
       if(91 <= param){
        if(25 < param - 97 >>> 0) break b;
       }
       else if(65 > param) break b;
       var _v_ = 1;
       break a;
      }
      var _v_ = 0;
     }
     var _w_ = _v_ ? 58 === caml_string_get(s, 1) ? 1 : 0 : _v_;
    }
    else
     var _w_ = _u_;
    if(! _w_) return [0, cst$17, s];
    var
     _x_ =
       caml_call3(Stdlib_String[16], s, 2, caml_ml_string_length(s) - 2 | 0);
    return [0, caml_call3(Stdlib_String[16], s, 0, 2), _x_];
   }
   function dirname$0(s){
    var
     match = drive_and_path(s),
     path = match[2],
     drive = match[1],
     dir = generic_dirname(is_dir_sep$0, current_dir_name$0, path);
    return caml_call2(Stdlib[28], drive, dir);
   }
   function basename$0(s){
    var path = drive_and_path(s)[2];
    return generic_basename(is_dir_sep$0, current_dir_name$0, path);
   }
   var
    Win32 =
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name$0,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
   function basename$1(_t_){
    return generic_basename(is_dir_sep$0, current_dir_name$1, _t_);
   }
   function dirname$1(_s_){
    return generic_dirname(is_dir_sep$0, current_dir_name$1, _s_);
   }
   var
    Cygwin =
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote,
       quote_command,
       basename$1,
       dirname$1],
    _e_ = Stdlib_Sys[4],
    Sysdeps =
      caml_string_notequal(_e_, "Cygwin")
       ? caml_string_notequal(_e_, "Win32") ? Unix : Win32
       : Cygwin,
    null$3 = Sysdeps[1],
    current_dir_name$2 = Sysdeps[2],
    parent_dir_name$2 = Sysdeps[3],
    dir_sep$2 = Sysdeps[4],
    is_dir_sep$1 = Sysdeps[5],
    is_relative$1 = Sysdeps[6],
    is_implicit$1 = Sysdeps[7],
    check_suffix$1 = Sysdeps[8],
    chop_suffix_opt$1 = Sysdeps[9],
    temp_dir_name$1 = Sysdeps[10],
    quote$1 = Sysdeps[11],
    quote_command$1 = Sysdeps[12],
    basename$2 = Sysdeps[13],
    dirname$2 = Sysdeps[14];
   function concat(dirname, filename){
    var l = caml_ml_string_length(dirname);
    if(0 !== l && ! is_dir_sep$1(dirname, l - 1 | 0)){
     var _r_ = caml_call2(Stdlib[28], dir_sep$2, filename);
     return caml_call2(Stdlib[28], dirname, _r_);
    }
    return caml_call2(Stdlib[28], dirname, filename);
   }
   function chop_suffix(name, suff){
    return check_suffix$1(name, suff)
            ? caml_call3
              (Stdlib_String[16],
               name,
               0,
               caml_ml_string_length(name) - caml_ml_string_length(suff) | 0)
            : caml_call1(Stdlib[1], cst_Filename_chop_suffix);
   }
   function extension_len(name){
    var i$3 = caml_ml_string_length(name) - 1 | 0, i0 = i$3;
    for(;;){
     if(0 <= i0 && ! is_dir_sep$1(name, i0)){
      if(46 === caml_string_get(name, i0)) break;
      var i$2 = i0 - 1 | 0, i0 = i$2;
      continue;
     }
     return 0;
    }
    var i$1 = i0 - 1 | 0, i = i$1;
    for(;;){
     if(0 <= i && ! is_dir_sep$1(name, i)){
      if(46 !== caml_string_get(name, i))
       return caml_ml_string_length(name) - i0 | 0;
      var i$0 = i - 1 | 0, i = i$0;
      continue;
     }
     return 0;
    }
   }
   function extension(name){
    var l = extension_len(name);
    return 0 === l
            ? cst$18
            : caml_call3
              (Stdlib_String[16],
               name,
               caml_ml_string_length(name) - l | 0,
               l);
   }
   function chop_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? caml_call1(Stdlib[1], cst_Filename_chop_extension)
            : caml_call3
              (Stdlib_String[16],
               name,
               0,
               caml_ml_string_length(name) - l | 0);
   }
   function remove_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? name
            : caml_call3
              (Stdlib_String[16],
               name,
               0,
               caml_ml_string_length(name) - l | 0);
   }
   var prng_key = caml_call2(Stdlib_Domain[10][1], 0, Stdlib_Random[15][2]);
   function temp_file_name(temp_dir, prefix, suffix){
    var
     random_state = caml_call1(Stdlib_Domain[10][2], prng_key),
     rnd = caml_call1(Stdlib_Random[15][4], random_state) & 16777215;
    return concat
            (temp_dir, caml_call4(Stdlib_Printf[4], _f_, prefix, rnd, suffix));
   }
   function _g_(param){return temp_dir_name$1;}
   var
    _h_ = [0, function(_q_){return _q_;}],
    current_temp_dir_name = caml_call2(Stdlib_Domain[10][1], _h_, _g_);
   function set_temp_dir_name(s){
    return caml_call2(Stdlib_Domain[10][3], current_temp_dir_name, s);
   }
   function get_temp_dir_name(param){
    return caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
   }
   function temp_file(opt, prefix, suffix){
    if(opt)
     var sth = opt[1], temp_dir = sth;
    else
     var temp_dir = caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      runtime.caml_sys_close(runtime.caml_sys_open(name, _i_, 384));
      return name;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(20 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0, counter = counter$0;
     }
    }
   }
   function open_temp_file(opt, _o_, _n_, prefix, suffix){
    if(opt) var sth = opt[1], mode = sth; else var mode = _j_;
    if(_o_) var sth$0 = _o_[1], perms = sth$0; else var perms = 384;
    if(_n_)
     var sth$1 = _n_[1], temp_dir = sth$1;
    else
     var temp_dir = caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      var
       _p_ =
         [0,
          name,
          caml_call3(Stdlib[62], [0, 1, [0, 3, [0, 5, mode]]], perms, name)];
      return _p_;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(20 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0, counter = counter$0;
     }
    }
   }
   function temp_dir(opt, _m_, prefix, suffix){
    if(opt)
     var sth = opt[1], temp_dir = sth;
    else
     var temp_dir = caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
    if(_m_) var sth$0 = _m_[1], perms = sth$0; else var perms = 448;
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{runtime.caml_sys_mkdir(name, perms); return name;}
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(20 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0, counter = counter$0;
     }
    }
   }
   var
    Stdlib_Filename =
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       temp_dir,
       get_temp_dir_name,
       set_temp_dir_name,
       quote$1,
       quote_command$1];
   runtime.caml_register_global(66, Stdlib_Filename, "Stdlib__Filename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Complex
//# unitInfo: Requires: Stdlib, Stdlib__Float
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    zero = [254, 0., 0.],
    one = [254, 1., 0.],
    i = [254, 0., 1.],
    _a_ = [254, 0., 0.];
   function add(x, y){return [254, x[1] + y[1], x[2] + y[2]];}
   function sub(x, y){return [254, x[1] - y[1], x[2] - y[2]];}
   function neg(x){return [254, - x[1], - x[2]];}
   function conj(x){return [254, x[1], - x[2]];}
   function mul(x, y){
    return [254, x[1] * y[1] - x[2] * y[2], x[1] * y[2] + x[2] * y[1]];
   }
   function div(x, y){
    if(Math.abs(y[2]) <= Math.abs(y[1])){
     var r = y[2] / y[1], d = y[1] + r * y[2];
     return [254, (x[1] + r * x[2]) / d, (x[2] - r * x[1]) / d];
    }
    var r$0 = y[1] / y[2], d$0 = y[2] + r$0 * y[1];
    return [254, (r$0 * x[1] + x[2]) / d$0, (r$0 * x[2] - x[1]) / d$0];
   }
   function inv(x){return div(one, x);}
   function norm2(x){return x[1] * x[1] + x[2] * x[2];}
   function norm(x){return runtime.caml_hypot_float(x[1], x[2]);}
   function arg(x){return Math.atan2(x[2], x[1]);}
   function polar(n, a){return [254, Math.cos(a) * n, Math.sin(a) * n];}
   function sqrt(x){
    if(x[1] == 0. && x[2] == 0.) return _a_;
    var r = Math.abs(x[1]), i = Math.abs(x[2]);
    if(i <= r)
     var
      q = i / r,
      w = Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
    else
     var
      q$0 = r / i,
      w = Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
    if(0. <= x[1]) return [254, w, 0.5 * x[2] / w];
    var w$0 = 0. <= x[2] ? w : - w;
    return [254, 0.5 * i / w, w$0];
   }
   function exp(x){
    var e = Math.exp(x[1]);
    return [254, e * Math.cos(x[2]), e * Math.sin(x[2])];
   }
   function log(x){
    var _b_ = Math.atan2(x[2], x[1]);
    return [254, Math.log(norm(x)), _b_];
   }
   function pow(x, y){return exp(mul(y, log(x)));}
   var
    Stdlib_Complex =
      [0,
       zero,
       one,
       i,
       neg,
       conj,
       add,
       sub,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
   runtime.caml_register_global(15, Stdlib_Complex, "Stdlib__Complex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__ArrayLabels
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array,
    init = Stdlib_Array[1],
    make_matrix = Stdlib_Array[2],
    append = Stdlib_Array[3],
    concat = Stdlib_Array[4],
    sub = Stdlib_Array[5],
    copy = Stdlib_Array[6],
    fill = Stdlib_Array[7],
    blit = Stdlib_Array[8],
    to_list = Stdlib_Array[9],
    of_list = Stdlib_Array[10],
    iter = Stdlib_Array[11],
    iteri = Stdlib_Array[12],
    map = Stdlib_Array[13],
    map_inplace = Stdlib_Array[14],
    mapi = Stdlib_Array[15],
    mapi_inplace = Stdlib_Array[16],
    fold_left = Stdlib_Array[17],
    fold_left_map = Stdlib_Array[18],
    fold_right = Stdlib_Array[19],
    iter2 = Stdlib_Array[20],
    map2 = Stdlib_Array[21],
    for_all = Stdlib_Array[22],
    exists = Stdlib_Array[23],
    for_all2 = Stdlib_Array[24],
    exists2 = Stdlib_Array[25],
    mem = Stdlib_Array[26],
    memq = Stdlib_Array[27],
    find_opt = Stdlib_Array[28],
    find_index = Stdlib_Array[29],
    find_map = Stdlib_Array[30],
    find_mapi = Stdlib_Array[31],
    split = Stdlib_Array[32],
    combine = Stdlib_Array[33],
    sort = Stdlib_Array[34],
    stable_sort = Stdlib_Array[35],
    fast_sort = Stdlib_Array[36],
    to_seq = Stdlib_Array[37],
    to_seqi = Stdlib_Array[38],
    of_seq = Stdlib_Array[39],
    Floatarray = Stdlib_Array[40],
    Stdlib_ArrayLabels =
      [0,
       init,
       make_matrix,
       append,
       concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       map_inplace,
       mapi,
       mapi_inplace,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(1, Stdlib_ArrayLabels, "Stdlib__ArrayLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__ListLabels
//# unitInfo: Requires: Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    length = Stdlib_List[1],
    compare_lengths = Stdlib_List[2],
    compare_length_with = Stdlib_List[3],
    is_empty = Stdlib_List[4],
    cons = Stdlib_List[5],
    hd = Stdlib_List[6],
    tl = Stdlib_List[7],
    nth = Stdlib_List[8],
    nth_opt = Stdlib_List[9],
    rev = Stdlib_List[10],
    init = Stdlib_List[11],
    append = Stdlib_List[12],
    rev_append = Stdlib_List[13],
    concat = Stdlib_List[14],
    flatten = Stdlib_List[15],
    equal = Stdlib_List[16],
    compare = Stdlib_List[17],
    iter = Stdlib_List[18],
    iteri = Stdlib_List[19],
    map = Stdlib_List[20],
    mapi = Stdlib_List[21],
    rev_map = Stdlib_List[22],
    filter_map = Stdlib_List[23],
    concat_map = Stdlib_List[24],
    fold_left_map = Stdlib_List[25],
    fold_left = Stdlib_List[26],
    fold_right = Stdlib_List[27],
    iter2 = Stdlib_List[28],
    map2 = Stdlib_List[29],
    rev_map2 = Stdlib_List[30],
    fold_left2 = Stdlib_List[31],
    fold_right2 = Stdlib_List[32],
    for_all = Stdlib_List[33],
    exists = Stdlib_List[34],
    for_all2 = Stdlib_List[35],
    exists2 = Stdlib_List[36],
    mem = Stdlib_List[37],
    memq = Stdlib_List[38],
    find = Stdlib_List[39],
    find_opt = Stdlib_List[40],
    find_index = Stdlib_List[41],
    find_map = Stdlib_List[42],
    find_mapi = Stdlib_List[43],
    filter = Stdlib_List[44],
    find_all = Stdlib_List[45],
    filteri = Stdlib_List[46],
    partition = Stdlib_List[47],
    partition_map = Stdlib_List[48],
    assoc = Stdlib_List[49],
    assoc_opt = Stdlib_List[50],
    assq = Stdlib_List[51],
    assq_opt = Stdlib_List[52],
    mem_assoc = Stdlib_List[53],
    mem_assq = Stdlib_List[54],
    remove_assoc = Stdlib_List[55],
    remove_assq = Stdlib_List[56],
    split = Stdlib_List[57],
    combine = Stdlib_List[58],
    sort = Stdlib_List[59],
    stable_sort = Stdlib_List[60],
    fast_sort = Stdlib_List[61],
    sort_uniq = Stdlib_List[62],
    merge = Stdlib_List[63],
    to_seq = Stdlib_List[64],
    of_seq = Stdlib_List[65],
    Stdlib_ListLabels =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       is_empty,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       concat,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       filter,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(1, Stdlib_ListLabels, "Stdlib__ListLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__BytesLabels
//# unitInfo: Requires: Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    make = Stdlib_Bytes[1],
    init = Stdlib_Bytes[2],
    empty = Stdlib_Bytes[3],
    copy = Stdlib_Bytes[4],
    of_string = Stdlib_Bytes[5],
    to_string = Stdlib_Bytes[6],
    sub = Stdlib_Bytes[7],
    sub_string = Stdlib_Bytes[8],
    extend = Stdlib_Bytes[9],
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[11],
    blit_string = Stdlib_Bytes[12],
    concat = Stdlib_Bytes[13],
    cat = Stdlib_Bytes[14],
    iter = Stdlib_Bytes[15],
    iteri = Stdlib_Bytes[16],
    map = Stdlib_Bytes[17],
    mapi = Stdlib_Bytes[18],
    fold_left = Stdlib_Bytes[19],
    fold_right = Stdlib_Bytes[20],
    for_all = Stdlib_Bytes[21],
    exists = Stdlib_Bytes[22],
    trim = Stdlib_Bytes[23],
    escaped = Stdlib_Bytes[24],
    index = Stdlib_Bytes[25],
    index_opt = Stdlib_Bytes[26],
    rindex = Stdlib_Bytes[27],
    rindex_opt = Stdlib_Bytes[28],
    index_from = Stdlib_Bytes[29],
    index_from_opt = Stdlib_Bytes[30],
    rindex_from = Stdlib_Bytes[31],
    rindex_from_opt = Stdlib_Bytes[32],
    contains = Stdlib_Bytes[33],
    contains_from = Stdlib_Bytes[34],
    rcontains_from = Stdlib_Bytes[35],
    uppercase_ascii = Stdlib_Bytes[36],
    lowercase_ascii = Stdlib_Bytes[37],
    capitalize_ascii = Stdlib_Bytes[38],
    uncapitalize_ascii = Stdlib_Bytes[39],
    compare = Stdlib_Bytes[40],
    equal = Stdlib_Bytes[41],
    starts_with = Stdlib_Bytes[42],
    ends_with = Stdlib_Bytes[43],
    unsafe_to_string = Stdlib_Bytes[44],
    unsafe_of_string = Stdlib_Bytes[45],
    split_on_char = Stdlib_Bytes[46],
    to_seq = Stdlib_Bytes[47],
    to_seqi = Stdlib_Bytes[48],
    of_seq = Stdlib_Bytes[49],
    get_utf_8_uchar = Stdlib_Bytes[50],
    set_utf_8_uchar = Stdlib_Bytes[51],
    is_valid_utf_8 = Stdlib_Bytes[52],
    get_utf_16be_uchar = Stdlib_Bytes[53],
    set_utf_16be_uchar = Stdlib_Bytes[54],
    is_valid_utf_16be = Stdlib_Bytes[55],
    get_utf_16le_uchar = Stdlib_Bytes[56],
    set_utf_16le_uchar = Stdlib_Bytes[57],
    is_valid_utf_16le = Stdlib_Bytes[58],
    get_uint8 = Stdlib_Bytes[59],
    get_int8 = Stdlib_Bytes[60],
    get_uint16_ne = Stdlib_Bytes[61],
    get_uint16_be = Stdlib_Bytes[62],
    get_uint16_le = Stdlib_Bytes[63],
    get_int16_ne = Stdlib_Bytes[64],
    get_int16_be = Stdlib_Bytes[65],
    get_int16_le = Stdlib_Bytes[66],
    get_int32_ne = Stdlib_Bytes[67],
    get_int32_be = Stdlib_Bytes[68],
    get_int32_le = Stdlib_Bytes[69],
    get_int64_ne = Stdlib_Bytes[70],
    get_int64_be = Stdlib_Bytes[71],
    get_int64_le = Stdlib_Bytes[72],
    set_uint8 = Stdlib_Bytes[73],
    set_int8 = Stdlib_Bytes[74],
    set_uint16_ne = Stdlib_Bytes[75],
    set_uint16_be = Stdlib_Bytes[76],
    set_uint16_le = Stdlib_Bytes[77],
    set_int16_ne = Stdlib_Bytes[78],
    set_int16_be = Stdlib_Bytes[79],
    set_int16_le = Stdlib_Bytes[80],
    set_int32_ne = Stdlib_Bytes[81],
    set_int32_be = Stdlib_Bytes[82],
    set_int32_le = Stdlib_Bytes[83],
    set_int64_ne = Stdlib_Bytes[84],
    set_int64_be = Stdlib_Bytes[85],
    set_int64_le = Stdlib_Bytes[86],
    unsafe_escape = Stdlib_Bytes[87],
    Stdlib_BytesLabels =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       equal,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_uint16_be,
       set_uint16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le,
       unsafe_escape];
   runtime.caml_register_global(1, Stdlib_BytesLabels, "Stdlib__BytesLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__StringLabels
//# unitInfo: Requires: Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    make = Stdlib_String[1],
    init = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    blit = Stdlib_String[6],
    concat = Stdlib_String[7],
    cat = Stdlib_String[8],
    equal = Stdlib_String[9],
    compare = Stdlib_String[10],
    starts_with = Stdlib_String[11],
    ends_with = Stdlib_String[12],
    contains_from = Stdlib_String[13],
    rcontains_from = Stdlib_String[14],
    contains = Stdlib_String[15],
    sub = Stdlib_String[16],
    split_on_char = Stdlib_String[17],
    map = Stdlib_String[18],
    mapi = Stdlib_String[19],
    fold_left = Stdlib_String[20],
    fold_right = Stdlib_String[21],
    for_all = Stdlib_String[22],
    exists = Stdlib_String[23],
    trim = Stdlib_String[24],
    escaped = Stdlib_String[25],
    uppercase_ascii = Stdlib_String[26],
    lowercase_ascii = Stdlib_String[27],
    capitalize_ascii = Stdlib_String[28],
    uncapitalize_ascii = Stdlib_String[29],
    iter = Stdlib_String[30],
    iteri = Stdlib_String[31],
    index_from = Stdlib_String[32],
    index_from_opt = Stdlib_String[33],
    rindex_from = Stdlib_String[34],
    rindex_from_opt = Stdlib_String[35],
    index = Stdlib_String[36],
    index_opt = Stdlib_String[37],
    rindex = Stdlib_String[38],
    rindex_opt = Stdlib_String[39],
    to_seq = Stdlib_String[40],
    to_seqi = Stdlib_String[41],
    of_seq = Stdlib_String[42],
    get_utf_8_uchar = Stdlib_String[43],
    is_valid_utf_8 = Stdlib_String[44],
    get_utf_16be_uchar = Stdlib_String[45],
    is_valid_utf_16be = Stdlib_String[46],
    get_utf_16le_uchar = Stdlib_String[47],
    is_valid_utf_16le = Stdlib_String[48],
    get_uint8 = Stdlib_String[49],
    get_int8 = Stdlib_String[50],
    get_uint16_ne = Stdlib_String[51],
    get_uint16_be = Stdlib_String[52],
    get_uint16_le = Stdlib_String[53],
    get_int16_ne = Stdlib_String[54],
    get_int16_be = Stdlib_String[55],
    get_int16_le = Stdlib_String[56],
    get_int32_ne = Stdlib_String[57],
    hash = Stdlib_String[58],
    seeded_hash = Stdlib_String[59],
    get_int32_be = Stdlib_String[60],
    get_int32_le = Stdlib_String[61],
    get_int64_ne = Stdlib_String[62],
    get_int64_be = Stdlib_String[63],
    get_int64_le = Stdlib_String[64],
    Stdlib_StringLabels =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       blit,
       concat,
       cat,
       equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       hash,
       seeded_hash,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global
    (1, Stdlib_StringLabels, "Stdlib__StringLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__MoreLabels
//# unitInfo: Requires: Stdlib__Hashtbl, Stdlib__Map, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Set = global_data.Stdlib__Set,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_MoreLabels = [0, Stdlib_Hashtbl, Stdlib_Map, Stdlib_Set];
   runtime.caml_register_global(3, Stdlib_MoreLabels, "Stdlib__MoreLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__StdLabels
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdlib_StdLabels = [0];
   runtime.caml_register_global(0, Stdlib_StdLabels, "Stdlib__StdLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__In_channel
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Fun, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Fun = global_data.Stdlib__Fun,
    stdin = Stdlib[38],
    open_bin = Stdlib[80],
    open_text = Stdlib[79],
    open_gen = Stdlib[81],
    cst_In_channel_input_all_chann =
      "In_channel.input_all: channel content is larger than maximum string length",
    _a_ = [0, 0];
   function with_open(openfun, s, f){
    var ic = caml_call1(openfun, s);
    function _x_(param){return caml_call1(f, ic);}
    function _y_(param){return caml_call1(Stdlib[94], ic);}
    return caml_call2(Stdlib_Fun[4], _y_, _x_);
   }
   function with_open_bin(s, f){return with_open(Stdlib[80], s, f);}
   function with_open_text(s, f){return with_open(Stdlib[79], s, f);}
   function with_open_gen(flags, perm, s, f){
    return with_open(caml_call2(Stdlib[81], flags, perm), s, f);
   }
   var
    seek = Stdlib[96][4],
    pos = Stdlib[96][5],
    length = Stdlib[96][6],
    close = Stdlib[93],
    close_noerr = Stdlib[94];
   function input_char(ic){
    try{var c = caml_call1(Stdlib[82], ic);}
    catch(_w_){
     var _v_ = caml_wrap_exception(_w_);
     if(_v_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
    return [0, c];
   }
   function input_byte(ic){
    try{var n = caml_call1(Stdlib[87], ic);}
    catch(_u_){
     var _t_ = caml_wrap_exception(_u_);
     if(_t_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_t_, 0);
    }
    return [0, n];
   }
   function input_line(ic){
    try{var s = caml_call1(Stdlib[83], ic);}
    catch(_s_){
     var _r_ = caml_wrap_exception(_s_);
     if(_r_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_r_, 0);
    }
    return [0, s];
   }
   var input = Stdlib[84];
   function really_input(ic, buf, pos, len){
    try{caml_call4(Stdlib[85], ic, buf, pos, len); return _a_;}
    catch(_q_){
     var _p_ = caml_wrap_exception(_q_);
     if(_p_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function really_input_string(ic, len){
    try{var s = caml_call2(Stdlib[86], ic, len);}
    catch(_o_){
     var _n_ = caml_wrap_exception(_o_);
     if(_n_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_n_, 0);
    }
    return [0, s];
   }
   function read_upto(ic, buf, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 !== len$0){
      var r = caml_call4(Stdlib[84], ic, buf, ofs$0, len$0);
      if(0 !== r){
       var
        len$1 = len$0 - r | 0,
        ofs$1 = ofs$0 + r | 0,
        ofs$0 = ofs$1,
        len$0 = len$1;
       continue;
      }
     }
     return ofs$0 - ofs | 0;
    }
   }
   function ensure(buf, ofs, n){
    var len = caml_ml_bytes_length(buf);
    if((ofs + n | 0) <= len) return buf;
    var new_len = [0, len];
    for(;;){
     if(new_len[1] >= (ofs + n | 0)) break;
     new_len[1] = (2 * new_len[1] | 0) + 1 | 0;
    }
    var
     new_len$0 = new_len[1],
     new_len$1 =
       new_len$0 <= Stdlib_Sys[12]
        ? new_len$0
        : ofs
          < Stdlib_Sys[12]
          ? Stdlib_Sys[12]
          : caml_call1(Stdlib[2], cst_In_channel_input_all_chann),
     new_buf = caml_create_bytes(new_len$1);
    caml_call5(Stdlib_Bytes[11], buf, 0, new_buf, 0, ofs);
    return new_buf;
   }
   function input_all(ic){
    var chunk_size = 65536;
    try{
     var
      _j_ = caml_call1(Stdlib[91], ic),
      _k_ = caml_call1(Stdlib[92], ic) - _j_ | 0,
      initial_size = _k_;
    }
    catch(_m_){
     var _h_ = caml_wrap_exception(_m_);
     if(_h_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_h_, 0);
     var initial_size = -1;
    }
    var
     initial_size$0 = 0 <= initial_size ? initial_size : chunk_size,
     initial_size$1 =
       initial_size$0 <= Stdlib_Sys[12] ? initial_size$0 : Stdlib_Sys[12],
     buf = caml_create_bytes(initial_size$1),
     nread = read_upto(ic, buf, 0, initial_size$1);
    if(nread < initial_size$1)
     return caml_call3(Stdlib_Bytes[8], buf, 0, nread);
    try{var c = caml_call1(Stdlib[82], ic);}
    catch(_l_){
     var _i_ = caml_wrap_exception(_l_);
     if(_i_ === Stdlib[12]) return caml_call1(Stdlib_Bytes[44], buf);
     throw caml_maybe_attach_backtrace(_i_, 0);
    }
    var buf$2 = ensure(buf, nread, 65537);
    runtime.caml_bytes_set(buf$2, nread, c);
    var ofs$1 = nread + 1 | 0, buf$0 = buf$2, ofs = ofs$1;
    for(;;){
     var
      buf$1 = ensure(buf$0, ofs, chunk_size),
      rem = caml_ml_bytes_length(buf$1) - ofs | 0,
      r = read_upto(ic, buf$1, ofs, rem);
     if(r < rem) return caml_call3(Stdlib_Bytes[8], buf$1, 0, ofs + r | 0);
     var ofs$0 = ofs + rem | 0, buf$0 = buf$1, ofs = ofs$0;
    }
   }
   function input_lines(ic){
    try{var line = caml_call1(Stdlib[83], ic);}
    catch(_g_){
     var _d_ = caml_wrap_exception(_g_);
     if(_d_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
    var block = [0, line, 24029], dst = block, offset = 1;
    for(;;){
     try{var line$0 = caml_call1(Stdlib[83], ic);}
     catch(_f_){
      var _e_ = caml_wrap_exception(_f_);
      if(_e_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_e_, 0);
      dst[1 + offset] = 0;
      return block;
     }
     var dst$0 = [0, line$0, 24029];
     dst[1 + offset] = dst$0;
     var dst = dst$0, offset = 1;
    }
   }
   function fold_lines(f, accu, ic){
    var accu$0 = accu;
    for(;;){
     try{var line = caml_call1(Stdlib[83], ic);}
     catch(_c_){
      var _b_ = caml_wrap_exception(_c_);
      if(_b_ === Stdlib[12]) return accu$0;
      throw caml_maybe_attach_backtrace(_b_, 0);
     }
     var accu$1 = caml_call2(f, accu$0, line), accu$0 = accu$1;
    }
   }
   var
    set_binary_mode = Stdlib[95],
    Stdlib_In_channel =
      [0,
       stdin,
       open_bin,
       open_text,
       open_gen,
       with_open_bin,
       with_open_text,
       with_open_gen,
       close,
       close_noerr,
       input_char,
       input_byte,
       input_line,
       really_input_string,
       input_all,
       input_lines,
       input,
       really_input,
       fold_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       runtime.caml_sys_isatty];
   runtime.caml_register_global(6, Stdlib_In_channel, "Stdlib__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Out_channel
//# unitInfo: Requires: Stdlib, Stdlib__Fun
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Fun = global_data.Stdlib__Fun,
    stdout = Stdlib[39],
    stderr = Stdlib[40],
    open_bin = Stdlib[61],
    open_text = Stdlib[60],
    open_gen = Stdlib[62];
   function with_open(openfun, s, f){
    var oc = caml_call1(openfun, s);
    function _a_(param){return caml_call1(f, oc);}
    function _b_(param){return caml_call1(Stdlib[77], oc);}
    return caml_call2(Stdlib_Fun[4], _b_, _a_);
   }
   function with_open_bin(s, f){return with_open(Stdlib[61], s, f);}
   function with_open_text(s, f){return with_open(Stdlib[60], s, f);}
   function with_open_gen(flags, perm, s, f){
    return with_open(caml_call2(Stdlib[62], flags, perm), s, f);
   }
   var
    seek = Stdlib[96][1],
    pos = Stdlib[96][2],
    length = Stdlib[96][3],
    close = Stdlib[76],
    close_noerr = Stdlib[77],
    flush = Stdlib[63],
    flush_all = Stdlib[64],
    output_char = Stdlib[65],
    output_byte = Stdlib[70],
    output_string = Stdlib[66],
    output_bytes = Stdlib[67],
    output = Stdlib[68],
    output_substring = Stdlib[69],
    set_binary_mode = Stdlib[78],
    Stdlib_Out_channel =
      [0,
       stdout,
       stderr,
       open_bin,
       open_text,
       open_gen,
       with_open_bin,
       with_open_text,
       with_open_gen,
       close,
       close_noerr,
       output_char,
       output_byte,
       output_string,
       output_bytes,
       output,
       output_substring,
       flush,
       flush_all,
       seek,
       pos,
       length,
       set_binary_mode,
       runtime.caml_ml_set_buffered,
       runtime.caml_ml_is_buffered,
       runtime.caml_sys_isatty];
   runtime.caml_register_global(2, Stdlib_Out_channel, "Stdlib__Out_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Effect
//# unitInfo: Requires: Stdlib, Stdlib__Callback, Stdlib__Printexc, Stdlib__Printf
//# unitInfo: Effects_without_cps: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_alloc_stack = runtime.caml_alloc_stack,
    caml_continuation_use_noexc = runtime.caml_continuation_use_noexc,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    jsoo_effect_not_supported = runtime.jsoo_effect_not_supported;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Unhandled = [248, "Stdlib.Effect.Unhandled", caml_fresh_oo_id(0)],
    Continuation_already_resumed =
      [248, "Stdlib.Effect.Continuation_already_resumed", caml_fresh_oo_id(0)],
    cst_impossible = "impossible",
    cst_Initial_setup = "Initial_setup__",
    cst_E = "E",
    _a_ =
      [0,
       [11, "Stdlib.Effect.Unhandled(", [2, 0, [12, 41, 0]]],
       "Stdlib.Effect.Unhandled(%s)"],
    cst_Stdlib_Effect_Should_not_s = "Stdlib.Effect.Should_not_see_this__",
    cst_Effect_Unhandled = "Effect.Unhandled",
    cst_Effect_Continuation_alread = "Effect.Continuation_already_resumed";
   function printer(param){
    if(param[1] !== Unhandled) return 0;
    var
     x = param[2],
     _j_ = caml_call1(Stdlib_Printexc[26], x),
     msg = caml_call2(Stdlib_Printf[4], _a_, _j_);
    return [0, msg];
   }
   caml_call1(Stdlib_Printexc[9], printer);
   var
    Should_not_see_this =
      [248, cst_Stdlib_Effect_Should_not_s, caml_fresh_oo_id(0)];
   caml_call2
    (Stdlib_Callback[2],
     cst_Effect_Unhandled,
     [0, Unhandled, Should_not_see_this]);
   caml_call2
    (Stdlib_Callback[2],
     cst_Effect_Continuation_alread,
     Continuation_already_resumed);
   function continue$0(k, v){
    function _h_(x){return x;}
    var _i_ = caml_continuation_use_noexc(k);
    return jsoo_effect_not_supported();
   }
   function discontinue(k, e){
    function _f_(e){throw caml_maybe_attach_backtrace(e, 1);}
    var _g_ = caml_continuation_use_noexc(k);
    return jsoo_effect_not_supported();
   }
   function discontinue_with_backtrace(k, e, bt){
    function _d_(e){
     caml_restore_raw_backtrace(e, bt);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var _e_ = caml_continuation_use_noexc(k);
    return jsoo_effect_not_supported();
   }
   function match_with(comp, arg, handler){
    function effc(eff, k, last_fiber){
     var match = caml_call1(handler[3], eff);
     if(! match) return jsoo_effect_not_supported();
     var f = match[1];
     return caml_call1(f, k);
    }
    var s = caml_alloc_stack(handler[1], handler[2], effc);
    return jsoo_effect_not_supported();
   }
   function try_with(comp, arg, handler){
    function effc(eff, k, last_fiber){
     var match = caml_call1(handler[1], eff);
     if(! match) return jsoo_effect_not_supported();
     var f = match[1];
     return caml_call1(f, k);
    }
    function _c_(e){throw caml_maybe_attach_backtrace(e, 1);}
    var s = caml_alloc_stack(function(x){return x;}, _c_, effc);
    return jsoo_effect_not_supported();
   }
   var
    Deep =
      [0,
       continue$0,
       discontinue,
       discontinue_with_backtrace,
       match_with,
       try_with];
   function fiber(f){
    var
     Initial_setup = [248, cst_Initial_setup, caml_fresh_oo_id(0)],
     E = [248, cst_E, caml_fresh_oo_id(0)];
    function f$0(param){return caml_call1(f, jsoo_effect_not_supported());}
    function error(param){return caml_call1(Stdlib[2], cst_impossible);}
    function effc(eff, k, last_fiber){
     if(eff === Initial_setup) throw [0, E, k];
     return error(0);
    }
    var s = caml_alloc_stack(error, error, effc);
    try{jsoo_effect_not_supported(); var _b_ = 0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== E) throw caml_maybe_attach_backtrace(exn, 0);
     var k = exn[2];
     return k;
    }
    return error(0);
   }
   function continue_gen(k, resume_fun, v, handler){
    function effc(eff, k, last_fiber){
     var match = caml_call1(handler[3], eff);
     if(! match) return jsoo_effect_not_supported();
     var f = match[1];
     return caml_call1(f, k);
    }
    var
     stack =
       runtime.caml_continuation_use_and_update_handler_noexc
        (k, handler[1], handler[2], effc);
    return jsoo_effect_not_supported();
   }
   function continue_with(k, v, handler){
    return continue_gen(k, function(x){return x;}, v, handler);
   }
   function discontinue_with(k, v, handler){
    return continue_gen
            (k,
             function(e){throw caml_maybe_attach_backtrace(e, 1);},
             v,
             handler);
   }
   function discontinue_with_backtrace$0(k, v, bt, handler){
    return continue_gen
            (k,
             function(e){
              caml_restore_raw_backtrace(e, bt);
              throw caml_maybe_attach_backtrace(e, 0);
             },
             v,
             handler);
   }
   var
    Stdlib_Effect =
      [0,
       Unhandled,
       Continuation_already_resumed,
       Deep,
       [0,
        fiber,
        continue_with,
        discontinue_with,
        discontinue_with_backtrace$0]];
   runtime.caml_register_global(13, Stdlib_Effect, "Stdlib__Effect");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsImZhaWx3aXRoIiwicyIsImludmFsaWRfYXJnIiwibWluIiwieCIsInkiLCJtYXgiLCJhYnMiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uX2Zsb2F0IiwibWF4X2ludCIsIm1pbl9pbnQiLCJzeW1ib2wiLCJzMSIsInMyIiwibDEiLCJsMiIsImNoYXJfb2ZfaW50IiwibiIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJsIiwiaSIsImkkMCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzeW1ib2wkMCIsImgxIiwiaDIiLCJ0bCIsImgzIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJvcGVuX291dF9nZW4iLCJtb2RlIiwicGVybSIsIm5hbWUiLCJjIiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJmbHVzaF9hbGwiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJ2IiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwib3Blbl9pbl9nZW4iLCJvcGVuX2luIiwib3Blbl9pbl9iaW4iLCJpbnB1dCIsImljIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsIm9mcyQwIiwibGVuJDAiLCJyIiwibGVuJDEiLCJvZnMkMSIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9saW5lIiwiYnVpbGRfcmVzdWx0IiwiYnVmIiwicG9zJDAiLCJoZCIsImFjY3UiLCJiZWciLCJhY2N1JDAiLCJyZXMiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3ltYm9sJDEiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQiLCJkb19hdF9leGl0IiwiZXhpdCIsInJldGNvZGUiLCJsZWZ0IiwicmlnaHQiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJmaW5kX2xlZnQiLCJmaW5kX3JpZ2h0IiwibWFwX2xlZnQiLCJlIiwibWFwX3JpZ2h0IiwibWFwIiwidiQwIiwiZm9sZCIsImVxdWFsIiwiZTEiLCJlMiIsInYxIiwidjIiLCJ2MSQwIiwidjIkMCIsImNvbXBhcmUiLCJvY2FtbF92ZXJzaW9uIiwib2NhbWxfcmVsZWFzZSIsImV4ZWN1dGFibGVfbmFtZSIsIm9zX3R5cGUiLCJiYWNrZW5kX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJtYXhfYXJyYXlfbGVuZ3RoIiwibWF4X2Zsb2F0YXJyYXlfbGVuZ3RoIiwibWF4X3N0cmluZ19sZW5ndGgiLCJiaWdfZW5kaWFuIiwid29yZF9zaXplIiwiaW50X3NpemUiLCJnZXRlbnZfb3B0IiwiaW50ZXJhY3RpdmUiLCJzZXRfc2lnbmFsIiwic2lnX251bSIsInNpZ19iZWgiLCJzaWdhYnJ0Iiwic2lnYWxybSIsInNpZ2ZwZSIsInNpZ2h1cCIsInNpZ2lsbCIsInNpZ2ludCIsInNpZ2tpbGwiLCJzaWdwaXBlIiwic2lncXVpdCIsInNpZ3NlZ3YiLCJzaWd0ZXJtIiwic2lndXNyMSIsInNpZ3VzcjIiLCJzaWdjaGxkIiwic2lnY29udCIsInNpZ3N0b3AiLCJzaWd0c3RwIiwic2lndHRpbiIsInNpZ3R0b3UiLCJzaWd2dGFscm0iLCJzaWdwcm9mIiwic2lnYnVzIiwic2lncG9sbCIsInNpZ3N5cyIsInNpZ3RyYXAiLCJzaWd1cmciLCJzaWd4Y3B1Iiwic2lneGZzeiIsImNhdGNoX2JyZWFrIiwib24iLCJkZXZlbG9wbWVudF92ZXJzaW9uIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwiZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfIiwiZm9yY2luZ190YWciLCJjb250X3RhZyIsImxhenlfdGFnIiwiY2xvc3VyZV90YWciLCJvYmplY3RfdGFnIiwiaW5maXhfdGFnIiwiZm9yd2FyZF90YWciLCJub19zY2FuX3RhZyIsImFic3RyYWN0X3RhZyIsInN0cmluZ190YWciLCJkb3VibGVfdGFnIiwiZG91YmxlX2FycmF5X3RhZyIsImN1c3RvbV90YWciLCJpbnRfdGFnIiwib3V0X29mX2hlYXBfdGFnIiwidW5hbGlnbmVkX3RhZyIsImluZm8iLCJvYmoiLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJtYXhfZXBoZV9sZW5ndGgiLCJjcmVhdGUiLCJsZW5ndGgiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsIm8iLCJtc2ciLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwibzEiLCJvMiIsIm1ha2UiLCJ1aWQiLCJBIiwicHJvdmFibHlfZXF1YWwiLCJCIiwic2V0IiwiaW5jciIsImRlY3IiLCJmb3JjZV9nZW5fbGF6eV9ibG9jayIsIm9ubHlfdmFsIiwiYmxrIiwiY2xvc3VyZSQwIiwicmVzdWx0JDAiLCJjbG9zdXJlIiwicmVzdWx0IiwiZSQwIiwiZm9yY2VfbGF6eV9ibG9jayIsImZvcmNlX2dlbiIsImx6diIsInQiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwibWFwX3ZhbCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCIsInNlcTEiLCJzZXEyIiwic2VxIiwiZmlsdGVyX21hcCIsInNlcSQwIiwiZmlsdGVyIiwiY29uY2F0IiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwiaXRlciIsInVuZm9sZCIsInUiLCJ1JDAiLCJpc19lbXB0eSIsInhzIiwidW5jb25zIiwieHMkMCIsInhzJDEiLCJpdGVyaSIsImZvbGRfbGVmdGkiLCJhY2N1JDEiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImZpbmQiLCJmaW5kX2luZGV4IiwiZmluZF9tYXAiLCJmaW5kX21hcGkiLCJpdGVyMiIsInlzIiwieXMkMCIsInlzJDEiLCJmb2xkX2xlZnQyIiwiZm9yX2FsbDIiLCJleGlzdHMyIiwiZXEiLCJjbXAiLCJpbml0X2F1eCIsImoiLCJpbml0IiwicmVwZWF0IiwiZm9yZXZlciIsImN5Y2xlX25vbmVtcHR5IiwiY3ljbGUiLCJpdGVyYXRlMSIsIml0ZXJhdGUiLCJtYXBpX2F1eCIsIm1hcGkiLCJ0YWlsX3NjYW4iLCJzJDAiLCJzY2FuIiwidGFrZV9hdXgiLCJ0YWtlIiwiZHJvcCIsIm4kMCIsIm4kMSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwibm9kZSIsImdyb3VwIiwidG9fbGF6eSIsImZhaWx1cmUiLCJtZW1vaXplIiwib25jZSIsImFjdGlvbiIsInppcCIsIm1hcDIiLCJpbnRlcmxlYXZlIiwic29ydGVkX21lcmdlMSIsInNvcnRlZF9tZXJnZSIsIm1hcF9mc3QiLCJ4eXMiLCJ4eXMkMCIsIm1hcF9zbmQiLCJ1bnppcCIsImZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCIsImZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAiLCJ6IiwicGFydGl0aW9uX21hcCIsInBhcnRpdGlvbiIsInBlZWwiLCJ4c3MiLCJ0cmFuc3Bvc2UiLCJ0YWlscyIsImhlYWRzIiwicmVtYWluZGVycyIsInhzcyQwIiwidGFpbHMkMCIsImhlYWRzJDAiLCJtYXBfcHJvZHVjdCIsInByb2R1Y3QiLCJvZl9kaXNwZW5zZXIiLCJpdCIsInRvX2Rpc3BlbnNlciIsImludHMiLCJub25lIiwic29tZSIsInZhbHVlIiwiZGVmYXVsdCQwIiwiZ2V0IiwiYmluZCIsImpvaW4iLCJpc19ub25lIiwiaXNfc29tZSIsIm8wIiwidjAiLCJ0b19yZXN1bHQiLCJ0b19saXN0IiwidG9fc2VxIiwib2siLCJlcnJvciIsImdldF9vayIsImdldF9lcnJvciIsIm1hcF9lcnJvciIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwicjAiLCJyMSIsImUwIiwidG9fb3B0aW9uIiwidG9fZmxvYXQiLCJ0b19zdHJpbmciLCJzZWVkZWRfaGFzaCIsInNlZWQiLCJoYXNoIiwiZXNjYXBlZCIsImxvd2VyY2FzZV9hc2NpaSIsInVwcGVyY2FzZV9hc2NpaSIsImMxIiwiYzIiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsInV0Zl9kZWNvZGVfaXNfdmFsaWQiLCJkIiwidXRmX2RlY29kZV9sZW5ndGgiLCJ1dGZfZGVjb2RlX3VjaGFyIiwidXRmX2RlY29kZSIsInV0Zl9kZWNvZGVfaW52YWxpZCIsInV0Zl84X2J5dGVfbGVuZ3RoIiwidXRmXzE2X2J5dGVfbGVuZ3RoIiwibCQwIiwibnRoIiwibCQxIiwibnRoX29wdCIsInJldl9hcHBlbmQiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwicmV2IiwibGFzdCIsImkkMSIsInIyIiwiZmxhdHRlbiIsImExIiwicjEkMCIsImEyIiwicmV2X21hcCIsImZvbGRfcmlnaHQiLCJiMiIsImIxIiwiYjEkMCIsInJldl9tYXAyIiwiZm9sZF9yaWdodDIiLCJtZW0iLCJtZW1xIiwiYXNzb2MiLCJhc3NvY19vcHQiLCJhc3NxIiwiYXNzcV9vcHQiLCJtZW1fYXNzb2MiLCJtZW1fYXNzcSIsInJlbW92ZV9hc3NvYyIsInBhaXIiLCJyZW1vdmVfYXNzcSIsImZpbmRfb3B0IiwiZmluZF9hbGwiLCJmaWx0ZXJpIiwiY29uY2F0X21hcCIsImZvbGRfbGVmdF9tYXAiLCJsX2FjY3UiLCJ4JDAiLCJ5ZXMiLCJubyIsInNwbGl0IiwicnkiLCJyeCIsImNvbWJpbmUiLCJtZXJnZSIsInQyIiwidDEiLCJzdGFibGVfc29ydCIsInNvcnQiLCJ4MiIsIngxIiwidGwkMSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwicmV2X3NvcnQiLCJ0bCQwIiwic29ydF91bmlxIiwiYyQwIiwiYyQxIiwiYyQyIiwiYyQzIiwiYyQ0IiwiYyQ1IiwiYyQ2IiwiYWNjdSQyIiwiY29tcGFyZV9sZW5ndGhzIiwiY29tcGFyZV9sZW5ndGhfd2l0aCIsImF1eCIsInRhaWwiLCJvZl9zZXEiLCJzZXEkMSIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJsb2dub3QiLCJjb3B5Iiwib2Zfc3RyaW5nIiwic3ViIiwic3ViX3N0cmluZyIsImV4dGVuZCIsImRzdG9mZiIsInNyY29mZiIsImNweWxlbiIsImZpbGwiLCJibGl0Iiwib2ZzMSIsIm9mczIiLCJibGl0X3N0cmluZyIsInNlcCIsInNlcGxlbiIsImRzdCIsInBvcyIsImhkJDAiLCJjYXQiLCJpc19zcGFjZSIsInRyaW0iLCJ1bnNhZmVfZXNjYXBlIiwiYiQwIiwiYXBwbHkxIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsInN0YXJ0c193aXRoIiwicHJlZml4IiwibGVuX3MiLCJsZW5fcHJlIiwiZW5kc193aXRoIiwic3VmZml4IiwibGVuX3N1ZiIsImRpZmYiLCJpbmRleF9yZWMiLCJsaW0iLCJpbmRleCIsImluZGV4X3JlY19vcHQiLCJpbmRleF9vcHQiLCJpbmRleF9mcm9tIiwiaW5kZXhfZnJvbV9vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4IiwicmluZGV4X2Zyb20iLCJyaW5kZXhfcmVjX29wdCIsInJpbmRleF9vcHQiLCJyaW5kZXhfZnJvbV9vcHQiLCJjb250YWluc19mcm9tIiwiY29udGFpbnMiLCJyY29udGFpbnNfZnJvbSIsInNwbGl0X29uX2NoYXIiLCJ0b19zZXFpIiwibmV3X2xlbiIsIm5ld19idWYiLCJ1bnNhZmVfZ2V0X3VpbnQxNl9sZSIsInVuc2FmZV9nZXRfdWludDE2X2JlIiwiZ2V0X2ludDgiLCJnZXRfdWludDE2X2xlIiwiZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQxNl9uZSIsImdldF9pbnQxNl9sZSIsImdldF9pbnQxNl9iZSIsImdldF9pbnQzMl9sZSIsImdldF9pbnQzMl9iZSIsImdldF9pbnQ2NF9sZSIsImdldF9pbnQ2NF9iZSIsInVuc2FmZV9zZXRfdWludDE2X2xlIiwidW5zYWZlX3NldF91aW50MTZfYmUiLCJzZXRfaW50MTZfbGUiLCJzZXRfaW50MTZfYmUiLCJzZXRfaW50MzJfbGUiLCJzZXRfaW50MzJfYmUiLCJzZXRfaW50NjRfbGUiLCJzZXRfaW50NjRfYmUiLCJzZXRfdWludDgiLCJzZXRfdWludDE2X25lIiwiZGVjX2ludmFsaWQiLCJkZWNfcmV0Iiwibm90X2luX3g4MF90b194QkYiLCJub3RfaW5feEEwX3RvX3hCRiIsIm5vdF9pbl94ODBfdG9feDlGIiwibm90X2luX3g5MF90b194QkYiLCJub3RfaW5feDgwX3RvX3g4RiIsInV0Zl84X3VjaGFyXzMiLCJiMCIsInV0Zl84X3VjaGFyXzQiLCJiMyIsImdldF91dGZfOF91Y2hhciIsImkkNCIsImIxJDEiLCJpJDUiLCJiMiQxIiwiaSQ2IiwiaSQxMCIsImIxJDMiLCJpJDExIiwiYjIkMyIsImkkMTIiLCJiMyQxIiwiaSQ3IiwiYjEkMiIsImkkOCIsImIyJDIiLCJpJDkiLCJiMyQwIiwiaSQxMyIsImIxJDQiLCJpJDE0IiwiYjIkNCIsImkkMiIsImkkMyIsImIyJDAiLCJpJDE1IiwiYjEkNSIsInNldF91dGZfOF91Y2hhciIsImxhc3QkMSIsImxhc3QkMCIsImlzX3ZhbGlkX3V0Zl84IiwibGFzdCQzIiwibGFzdCQyIiwibGFzdCQ0IiwibGFzdCQ1IiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwiaGkiLCJsbyIsInNldF91dGZfMTZiZV91Y2hhciIsInUkMSIsImlzX3ZhbGlkX3V0Zl8xNmJlIiwiZ2V0X3V0Zl8xNmxlX3VjaGFyIiwic2V0X3V0Zl8xNmxlX3VjaGFyIiwiaXNfdmFsaWRfdXRmXzE2bGUiLCJidHMiLCJib3MiLCJvZl9ieXRlcyIsInRvX2J5dGVzIiwiZyIsInRvX2J1ZmZlciIsImJ1ZmYiLCJmbGFncyIsImhlYWRlcl9zaXplIiwiZGF0YV9zaXplIiwidG90YWxfc2l6ZSIsImZyb21fYnl0ZXMiLCJmcm9tX3N0cmluZyIsIm1ha2VfbWF0cml4Iiwic3giLCJzeSIsIm1hcF9pbnBsYWNlIiwibWFwaV9pbnBsYWNlIiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJvZl9saXN0IiwiaW5wdXRfYXJyYXkiLCJlbHQiLCJvdXRwdXRfYXJyYXkiLCJlbHQkMCIsImFjYyQyIiwiYTAiLCJiaSIsImFpIiwibmEiLCJuYiIsIm1heHNvbiIsImkzMSIsImUkMSIsImokMCIsImZhdGhlciIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImkyJDAiLCJkJDAiLCJzMiQwIiwiaTEkMCIsImQkMSIsInMxJDAiLCJpc29ydHRvIiwic3Jjb2ZzIiwic29ydHRvIiwic2lnbmFsaW5nX25hbiIsImlzX2Zpbml0ZSIsImlzX2luZmluaXRlIiwiaXNfbmFuIiwiZXBzaWxvbiIsIm9mX3N0cmluZ19vcHQiLCJwaSIsImlzX2ludGVnZXIiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsInVuc2FmZV9maWxsIiwiY2hlY2siLCJobGVuIiwic3JjIiwic29mcyIsImRvZnMiLCJoIiwibWVtX2llZWUiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsIm1heF9pbnQkMCIsInVuc2lnbmVkX3RvX2ludCIsInVuc2lnbmVkX2NvbXBhcmUiLCJtIiwidW5zaWduZWRfZGl2IiwicSIsInVuc2lnbmVkX3JlbSIsInNpemUiLCJkdW1teV9wb3MiLCJ6ZXJvX3BvcyIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJyZWFkX2Z1biIsInN0aCIsIndpdGhfcG9zaXRpb25zIiwiYXV4X2J1ZmZlciIsImxleGJ1ZiIsInJlYWQiLCJuZXdsZW4iLCJuZXdidWYiLCJmcm9tX2NoYW5uZWwiLCJzZXRfcG9zaXRpb24iLCJwb3NpdGlvbiIsInNldF9maWxlbmFtZSIsImZuYW1lIiwibGV4ZW1lIiwic3ViX2xleGVtZSIsInN1Yl9sZXhlbWVfb3B0Iiwic3ViX2xleGVtZV9jaGFyIiwic3ViX2xleGVtZV9jaGFyX29wdCIsImxleGVtZV9jaGFyIiwibGV4ZW1lX3N0YXJ0IiwibGV4ZW1lX2VuZCIsImxleGVtZV9zdGFydF9wIiwibGV4ZW1lX2VuZF9wIiwibmV3X2xpbmUiLCJsY3AiLCJmbHVzaF9pbnB1dCIsImVudiIsImdyb3dfc3RhY2tzIiwib2xkc2l6ZSIsIm5ld3NpemUiLCJuZXdfcyIsIm5ld192IiwibmV3X3N0YXJ0IiwibmV3X2VuZCIsImNsZWFyX3BhcnNlciIsImN1cnJlbnRfbG9va2FoZWFkX2Z1biIsInl5cGFyc2UiLCJ0YWJsZXMiLCJzdGFydCIsImxleGVyIiwiaW5pdF9hc3AiLCJpbml0X3NwIiwiaW5pdF9zdGFja2Jhc2UiLCJpbml0X3N0YXRlIiwiaW5pdF9jdXJyX2NoYXIiLCJpbml0X2x2YWwiLCJpbml0X2VycmZsYWciLCJjbWQiLCJhcmciLCJhcmckMCIsImV4biQwIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaGwiLCJoJDAiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsInJoIiwibGgiLCJtaW5fZWx0IiwibWluX2VsdF9vcHQiLCJtYXhfZWx0IiwibWF4X2VsdF9vcHQiLCJyZW1vdmVfbWluX2VsdCIsInIkMCIsInByZXMiLCJwcmVzJDAiLCJyZW1vdmUiLCJ1bmlvbiIsInIyJDAiLCJpbnRlciIsInNwbGl0X2JpcyIsImRpc2pvaW50IiwiY29uc19lbnVtIiwiZTIkMiIsImUxJDIiLCJlMiQwIiwiZTEkMCIsImUyJDEiLCJlMSQxIiwic3Vic2V0IiwicHYiLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kX2ZpcnN0IiwidjAkMSIsInYwJDAiLCJmaW5kX2ZpcnN0X29wdCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHQiLCJ0cnlfam9pbiIsInYkMSIsIngwIiwibCQzIiwibCQ0IiwieDAkMCIsImwkNSIsIngwJDEiLCJubCIsIm1pZCIsImwkMiIsIng0IiwiYWRkX3NlcSIsInNlcV9vZl9lbnVtIiwic25vY19lbnVtIiwicmV2X3NlcV9vZl9lbnVtIiwidG9fcmV2X3NlcSIsInRvX3NlcV9mcm9tIiwibG93IiwibGQiLCJscmQiLCJyZCIsInJsZCIsImRhdGEiLCJkMCQxIiwiZDAiLCJkMCQwIiwibWluX2JpbmRpbmciLCJtaW5fYmluZGluZ19vcHQiLCJtYXhfYmluZGluZyIsIm1heF9iaW5kaW5nX29wdCIsInJlbW92ZV9taW5fYmluZGluZyIsInVwZGF0ZSIsImRhdGEkMCIsImFkZF90b19saXN0IiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJicyIsImNsZWFyIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwiY2VsbCIsIm1hdGNoIiwicGVlayIsImNvbnRlbnQiLCJwZWVrX29wdCIsInRha2Vfb3B0IiwiY2VsbCQwIiwicV9yZXMiLCJwcmV2IiwicHJldiQwIiwidHJhbnNmZXIiLCJxMSIsInEyIiwiY29udGVudHMiLCJidWZmZXIiLCJyZXNldCIsImlubmVyIiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwidWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4IiwidWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCIsImFkZF91dGZfOF91Y2hhciIsImFkZF91dGZfMTZiZV91Y2hhciIsImFkZF91dGZfMTZsZV91Y2hhciIsImFkZF9zdWJzdHJpbmciLCJvZmZzZXQiLCJuZXdfcG9zaXRpb24iLCJhZGRfc3ViYnl0ZXMiLCJhZGRfc3RyaW5nIiwiYWRkX2J5dGVzIiwiYWRkX2J1ZmZlciIsImFkZF9jaGFubmVsIiwidG9fcmVhZCQxIiwiYWxyZWFkeV9yZWFkIiwidG9fcmVhZCIsImFscmVhZHlfcmVhZCQwIiwidG9fcmVhZCQwIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsInByZXZpb3VzJDAiLCJzdGFydCQwIiwib3BlbmluZyIsImxpbSQwIiwic3RvcCQwIiwiayQyIiwiY2xvc2luZyIsInN0b3AiLCJrJDAiLCJrJDEiLCJuZXh0X2kiLCJpZGVudCIsInRydW5jYXRlIiwiYWRkX2ludDgiLCJhZGRfaW50MTZfbmUiLCJhZGRfaW50MzJfbmUiLCJhZGRfaW50NjRfbmUiLCJhZGRfaW50MTZfbGUiLCJhZGRfaW50MTZfYmUiLCJhZGRfaW50MzJfbGUiLCJhZGRfaW50MzJfYmUiLCJhZGRfaW50NjRfbGUiLCJhZGRfaW50NjRfYmUiLCJwcm90ZWN0IiwicmVsZWFzZSIsImFjcXVpcmUiLCJ0cnlfYWNxdWlyZSIsInJldCIsImdldF92YWx1ZSIsIm1ha2UkMCIsInJlbGVhc2UkMCIsImFjcXVpcmUkMCIsInRyeV9hY3F1aXJlJDAiLCJjcHVfcmVsYXgiLCJ1bmlxdWVfdmFsdWUiLCJjcmVhdGVfZGxzIiwia2V5X2NvdW50ZXIiLCJwYXJlbnRfa2V5cyIsIm5ld19rZXkiLCJzcGxpdF9mcm9tX3BhcmVudCIsImluaXRfb3JwaGFuIiwiaWR4Iiwia2kiLCJtYXliZV9ncm93Iiwic3oiLCJuZXdfc3oiLCJuZXdfc3QiLCJnZXRfaWQiLCJkb21haW4iLCJzZWxmIiwiaXNfbWFpbl9kb21haW4iLCJmaXJzdF9kb21haW5fc3Bhd25lZCIsImZpcnN0X3NwYXduX2Z1bmN0aW9uIiwiYmVmb3JlX2ZpcnN0X3NwYXduIiwib2xkX2YiLCJuZXdfZiIsImF0X2V4aXRfa2V5Iiwic3Bhd24iLCJwayIsInRlcm1fbXV0ZXgiLCJ0ZXJtX2NvbmRpdGlvbiIsInRlcm1fc3RhdGUiLCJib2R5IiwiZXgkMCIsImV4IiwicmVjb21tZW5kZWRfZG9tYWluX2NvdW50Iiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiY0YiLCJicHJpbnRfcGFkdHkiLCJwYWR0eSIsImJwcmludF9pZ25vcmVkX2ZsYWciLCJpZ25fZmxhZyIsImJwcmludF9wYWRfb3B0IiwiYnByaW50X3BhZGRpbmciLCJwYWR0eSQwIiwiYnByaW50X3ByZWNpc2lvbiIsImJwcmludF9pY29udl9mbGFnIiwiYnByaW50X2FsdGludF9mbXQiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciQwIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsImZtdHR5JDQiLCJmbXR0eSQ1IiwiZm10dHkkNiIsImZtdHR5JDciLCJmbXR0eSQ4IiwiZm10dHkkOSIsInN1Yl9mbXR0eSIsImZtdHR5JDEwIiwic3ViX2ZtdHR5JDAiLCJmbXR0eSQxMSIsImZtdHR5JDEyIiwiZm10dHkkMTMiLCJmbXR0eSQxNCIsImZtdHR5JDE1IiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXRpdGVyIiwiZm10JDAiLCJpZ25fZmxhZyQwIiwic3RyJDEiLCJpc19hbG9uZSQwIiwiaXNfYWxvbmUiLCJhZnRlciIsImJlZm9yZSIsImokMSIsImZtdCQxIiwic3ltbSIsImZtdHR5X3JlbF9kZXQiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsInRyYW5zIiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJyZXN0MSIsInJlc3QyIiwicmVzdDEkMCIsInJlc3QyJDAiLCJyZXN0MSQxIiwicmVzdDIkMSIsInJlc3QxJDIiLCJyZXN0MiQyIiwicmVzdDEkMyIsInJlc3QyJDMiLCJyZXN0MSQ0IiwicmVzdDIkNCIsInJlc3QxJDUiLCJyZXN0MiQ1IiwicmVzdDEkNiIsInJlc3QyJDYiLCJyZXN0MSQ3IiwidHkxJDAiLCJyZXN0MiQ3IiwidHkyJDAiLCJyZXN0MSQ4IiwidHkxMiIsInR5MTEiLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmNCIsImYyIiwicmVzdDEkOSIsInJlc3QyJDkiLCJyZXN0MSQxMCIsInJlc3QyJDEwIiwicmVzdDEkMTEiLCJyZXN0MiQxMSIsInJlc3QxJDEyIiwicmVzdDIkMTIiLCJyZXN0MSQxMyIsInJlc3QyJDEzIiwiZm10dHlfb2ZfZm10IiwiZm10dHlfb2ZfcGFkZGluZ19mbXR0eSIsInR5X3Jlc3QiLCJwcmVjX3R5IiwiZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IiwidHlfcmVzdCQwIiwicHJlY190eSQwIiwidHlfcmVzdCQxIiwicHJlY190eSQxIiwidHlfcmVzdCQyIiwicHJlY190eSQyIiwidHlfcmVzdCQzIiwicHJlY190eSQzIiwidHkkMCIsImZvcm1hdHRpbmdfZ2VuIiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJ0eXBlX2Zvcm1hdCIsInR5cGVfZm9ybWF0X2dlbiIsImZtdHR5MCIsImZtdHR5X3Jlc3QiLCJmbXRfcmVzdCIsImZtdHR5X3Jlc3QkMCIsImZtdF9yZXN0JDAiLCJmbXRfcmVzdCQxIiwiZm10dHlfcmVzdCQxIiwiZm10JDIiLCJmbXRfcmVzdCQyIiwiZm10dHlfcmVzdCQyIiwiZm10JDMiLCJmbXRfcmVzdCQzIiwiZm10dHlfcmVzdCQzIiwiZm10JDQiLCJmbXRfcmVzdCQ0IiwiZm10dHlfcmVzdCQ0IiwiZm10JDUiLCJmbXRfcmVzdCQ1IiwiZm10dHlfcmVzdCQ1IiwicHJlYyQ0IiwiZm10JDYiLCJmbXRfcmVzdCQ2IiwicHJlYyQ1IiwicGFkJDkiLCJwYWQkMTAiLCJmbXR0eV9yZXN0JDYiLCJwcmVjJDYiLCJmbXQkNyIsImZtdF9yZXN0JDciLCJwcmVjJDciLCJwYWQkMTEiLCJwYWQkMTIiLCJmbXR0eV9yZXN0JDciLCJwcmVjJDgiLCJmbXQkOCIsImZtdF9yZXN0JDgiLCJwYWQkMTMiLCJwYWQkMTQiLCJmbXR0eV9yZXN0JDgiLCJmbXQkOSIsImZtdF9yZXN0JDkiLCJmbXQkMTAiLCJmbXRfcmVzdCQxMCIsImZtdCQxMSIsImZtdF9yZXN0JDExIiwiZm10JDEyIiwiZm10dHlfcmVzdCQ5IiwiZm10X3Jlc3QkMTIiLCJmbXQkMTMiLCJmbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXQkMTQiLCJmbXR0eV9yZXN0JDExIiwiZm10X3Jlc3QkMTQiLCJmbXQkMTUiLCJmbXR0eV9yZXN0JDEyIiwiZm10X3Jlc3QkMTUiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE2IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJmbXR0eTMiLCJmbXQzIiwiZm10MSQwIiwiZm10dHkyJDAiLCJmbXQyJDAiLCJmbXR0eTMkMCIsImZtdDMkMCIsImZtdHR5X3Jlc3QkMTMiLCJmbXRfcmVzdCQxOCIsImZtdHR5JDE3IiwiZm10JDE4IiwiZm10dHlfcmVzdCQxNCIsImZtdF9yZXN0JDE5IiwiZm10dHkkMTgiLCJmbXQkMTkiLCJmbXR0eV9yZXN0JDE1IiwiZm10X3Jlc3QkMjAiLCJmbXR0eSQxOSIsImZtdCQyMCIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwidHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpIiwiZm10dHkkMjEiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsImZtdHR5X3Jlc3QkMTYiLCJmbXR0eSQyMCIsImZtdCQyMSIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QkMCIsInN1Yl9mbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDciLCJzdWJfZm10dHlfcmVzdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkOSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJzdWJfZm10dHlfcmVzdCQxMiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwic3ViX2ZtdHR5X3Jlc3QkMTQiLCJzdWIyX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTUiLCJzdWIyX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxNiIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE4Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJzdWJfZm10dHlfcmVzdCQyMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJzdWJfZm10dHlfcmVzdCQyMyIsInN1Yl9mbXR0eV9yZXN0JDI0Iiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJzdWJfZm10dHlfcmVzdCQyNiIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwid2lkdGgkMCIsImZpeF9pbnRfcHJlY2lzaW9uIiwicmVzJDEiLCJzdHJpbmdfdG9fY2FtbF9zdHJpbmciLCJmb3JtYXRfb2ZfZmNvbnYiLCJzeW1iIiwidHJhbnNmb3JtX2ludF9hbHQiLCJkaWdpdHMiLCJwdXQiLCJjb252ZXJ0X2ludCIsImNvbnZlcnRfaW50MzIiLCJjb252ZXJ0X25hdGl2ZWludCIsImNvbnZlcnRfaW50NjQiLCJjb252ZXJ0X2Zsb2F0IiwiaGV4Iiwic2lnbiIsImNhbWxfc3BlY2lhbF92YWwiLCJzdHJpbmdfb2ZfZm10dHkiLCJtYWtlX3ByaW50ZiQwIiwibmV3X2FjYyIsIm1ha2VfcHJpbnRmIiwibWFrZV9wYWRkaW5nIiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJwJDAiLCJwJDEiLCJhY2MkMyIsImFjYyQ0IiwiayQzIiwia2FjYyIsImskNCIsIm1ha2VfaWdub3JlZF9wYXJhbSQwIiwibWFrZV9jdXN0b20kMCIsIm1ha2VfaW52YWxpZF9hcmciLCJtYWtlX2Zyb21fZm10dHkkMCIsIm1ha2VfZnJvbV9mbXR0eSIsIm1ha2VfY3VzdG9tIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwibWFrZV9pcHJpbnRmJDAiLCJtYWtlX2lwcmludGYiLCJmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiIsImtvYyIsInJlc3QkMjQiLCJyZXN0JDI1IiwicmVzdCQyNiIsInJlc3QkMjciLCJyZXN0JDI4IiwicmVzdCQyOSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMyIsInAkNCIsInAkNSIsInAkMiIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wYWRwcmVjX2ZtdF9lYmIiLCJmbXRfZWJiX29mX3N0cmluZyIsImxlZ2FjeV9iZWhhdmlvciIsImZsYWciLCJsZWdhY3lfYmVoYXZpb3IkMCIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJ1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQiLCJlbmRfaW5kIiwiaW52YWxpZF9mb3JtYXRfd2l0aG91dCIsImV4cGVjdGVkX2NoYXJhY3RlciIsImV4cGVjdGVkIiwicGFyc2UiLCJsaXRfc3RhcnQiLCJhZGRfbGl0ZXJhbCIsInN0cl9pbmQkMSIsInN0cl9pbmQkMiIsInBhcnNlX2ZsYWdzIiwic3RyX2luZCQwIiwicGFyc2VfdGFnIiwic3RyX2luZCQzIiwic3RyX2luZF8xIiwicGFyc2VfaW50ZWdlciIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsImZvcm1hdHRpbmdfbGl0JDAiLCJuZXh0X2luZCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInN0cl9pbmQkNCIsInN0cl9pbmRfMSQwIiwic3RyX2luZF8yJDAiLCJzdHJfaW5kXzMkMCIsInMkMSIsImZvcm1hdHRpbmdfbGl0JDEiLCJuZXh0X2luZCQwIiwicGN0X2luZCIsIm1pbnVzIiwicGx1cyIsInNwYWNlIiwic2V0X2ZsYWciLCJzdHJfaW5kJDUiLCJzcGFjZSQwIiwiaGFzaCQwIiwicGx1cyQwIiwibWludXMkMCIsInplcm8kMCIsImluY29tcGF0aWJsZV9mbGFnIiwicGFyc2VfcG9zaXRpdmUiLCJuZXdfaW5kIiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2NvbnZlcnNpb24iLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwic3ltYiQwIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsInN1Yl9lbmQiLCJzZWFyY2hfc3ViZm9ybWF0X2VuZCIsInN1Yl9mbXQiLCJpZ25vcmVkJDIiLCJjb3VudGVyJDAiLCJpZ25vcmVkJDYiLCJpZ25vcmVkJDciLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIiLCJyZXZlcnNlIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsImZtdF9yZXN0JDIzIiwiaWdub3JlZCQxMCIsImZtdF9yZXN0JDI0IiwiZm10X3Jlc3QkMjUiLCJzdWJfZW5kJDAiLCJzdWJfZm10JDAiLCJmbXRfcmVzdCQyNiIsImlnbm9yZWQkMTEiLCJpZ25vcmVkJDMiLCJpZ25vcmVkJDUiLCJjb21wdXRlX2ludF9jb252IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwic3ViX2VuZCQxIiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3Iiwib3B0aW9uIiwic3ViZm10IiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0Iiwia2ZwcmludGYiLCJrYnByaW50ZiIsImlrZnByaW50ZiIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJpYnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwibWFrZV9zeW1saXN0IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMSIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiY3VycmVudCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXyIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJwcm9nbmFtZSIsImZvbGxvdyQwIiwia2V5d29yZCIsIm5vX2FyZyQwIiwiZm9sbG93Iiwibm9fYXJnIiwiZ2V0X2FyZyQwIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnJDAiLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiQwIiwidHJlYXRfYWN0aW9uIiwiZiQwIiwiZiQxIiwiciQxIiwiZiQyIiwiYXJnJDEiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiZiQ3IiwiYXJnJDYiLCJuZXdhcmciLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsInNwZWMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsIndvcmQkMCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJsb2NmbXQiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwidXNlX3ByaW50ZXJzIiwic3RyaW5nX29mX2V4dGVuc2lvbl9jb25zdHJ1Y3RvIiwiY29uc3RydWN0b3IiLCJmaWVsZHNfb3B0IiwiY29uc3RydWN0b3IkMCIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsInByaW50IiwiZmN0IiwiY2F0Y2gkMCIsInJhd19iYWNrdHJhY2VfZW50cmllcyIsImJ0IiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwicGFyYW0iLCJiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUiLCJiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiIsImJhY2t0cmFjZV9zbG90X2RlZm5hbWUiLCJiYWNrdHJhY2Vfc2xvdHMiLCJiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IiwiZW50cnkiLCJyYXdfYmFja3RyYWNlX2xlbmd0aCIsImdldF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJvbGRfcHJpbnRlcnMiLCJuZXdfcHJpbnRlcnMiLCJleG5fc2xvdCIsImV4bl9zbG90X2lkIiwiZXhuX3Nsb3RfbmFtZSIsImVycm9ycyIsImRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbiIsInN0YXR1cyIsInVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwic2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwiZW1wdHlfYmFja3RyYWNlIiwiaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImRlYnVnZ2VyX2luX3VzZSIsImV4biQxIiwicmF3X2JhY2t0cmFjZSQwIiwiY29uc3QkMCIsImZsaXAiLCJuZWdhdGUiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biQwIiwid29ya19leG4iLCJ3b3JrX2J0IiwiZXZlbnRsb2dfcGF1c2UiLCJldmVudGxvZ19yZXN1bWUiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsIm51bGxfdHJhY2tlciIsInNhbXBsaW5nX3JhdGUiLCJ0cmFja2VyIiwiY2FsbHN0YWNrX3NpemUiLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJkaWdlc3QiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJmbG9hdDMyIiwiZmxvYXQ2NCIsImludDhfc2lnbmVkIiwiaW50OF91bnNpZ25lZCIsImludDE2X3NpZ25lZCIsImludDE2X3Vuc2lnbmVkIiwiaW50MzIiLCJpbnQ2NCIsImludCQwIiwibmF0aXZlaW50IiwiY29tcGxleDMyIiwiY29tcGxleDY0Iiwia2luZF9zaXplX2luX2J5dGVzIiwiY19sYXlvdXQiLCJmb3J0cmFuX2xheW91dCIsImNsb29wIiwiYXJyIiwiY29sIiwiZmxvb3AiLCJsYXlvdXQiLCJkaW1zIiwiZGxlbiIsInNpemVfaW5fYnl0ZXMiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImNyZWF0ZSQwIiwiZGltIiwic2l6ZV9pbl9ieXRlcyQxIiwic2xpY2UiLCJpbml0JDAiLCJvZl9hcnJheSIsImJhIiwiY3JlYXRlJDEiLCJkaW0xIiwiZGltMiIsInNpemVfaW5fYnl0ZXMkMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsImluaXQkMSIsIm9mX2FycmF5JDAiLCJyb3ciLCJjcmVhdGUkMiIsImRpbTMiLCJzaXplX2luX2J5dGVzJDMiLCJzbGljZV9sZWZ0XzEiLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsImluaXQkMiIsIm9mX2FycmF5JDEiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJzZXJpYWxpemF0aW9uX3ByZWZpeCIsImkzIiwiaTQiLCJpMyQwIiwiaTQkMCIsIm1rIiwic2VyaWFsaXphdGlvbl9wcmVmaXhfbGVuIiwidG9fYmluYXJ5X3N0cmluZyIsIm9mX2JpbmFyeV9zdHJpbmciLCJyZWluaXQiLCJtYWtlX3NlbGZfaW5pdCIsImJpdHMiLCJpbnRhdXgiLCJib3VuZCIsImZ1bGxfaW50IiwiYml0czMyIiwiYml0czY0IiwibmF0aXZlYml0cyIsImZsb2F0JDAiLCJib29sIiwibWtfZGVmYXVsdCIsInJhbmRvbV9rZXkiLCJiaXRzJDAiLCJpbnQkMSIsImZ1bGxfaW50JDAiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiYml0czMyJDAiLCJiaXRzNjQkMCIsIm5hdGl2ZWJpdHMkMCIsImZ1bGxfaW5pdCIsInNlbGZfaW5pdCIsInNwbGl0JDAiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmdfa2V5IiwicG93ZXJfMl9hYm92ZSIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiaW5zZXJ0X2FsbF9idWNrZXRzIiwiaW5kZXhmdW4iLCJpbnBsYWNlIiwib2RhdGEiLCJuZGF0YSIsIm5zaXplIiwibmRhdGFfdGFpbCIsIm5pZHgiLCJtYXRjaCQwIiwib3NpemUiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidGJsX2RhdGEiLCJidWNrIiwiYnVjayQwIiwiYnVjayQxIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwia2V5X2luZGV4IiwiYnVja2V0IiwiazEiLCJuZXh0MSIsImsyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJoYXNoX3BhcmFtIiwicmVidWlsZCIsImdldF9jb3B5IiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiY291bnQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCQwIiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld2J1Y2tldCIsIm9sZGxlbiIsIm5ld3QiLCJvYiIsIm9pIiwib2giLCJzZXR0ZXIkMCIsIm5pIiwiZmluZF9hdXgiLCJmb3VuZCIsIm5vdGZvdW5kIiwibGVucyIsInRvdGxlbiIsInVua25vd24iLCJwcF9lbnF1ZXVlIiwidG9rZW4iLCJwcF9pbmZpbml0eSIsInBwX291dHB1dF9zdHJpbmciLCJwcF9vdXRwdXRfbmV3bGluZSIsImZvcm1hdF9wcF90ZXh0IiwidGV4dCIsImZvcm1hdF9zdHJpbmciLCJicmVha19uZXdfbGluZSIsInJlYWxfaW5kZW50IiwiYnJlYWtfbGluZSIsImJyZWFrX3NhbWVfbGluZSIsImZvcm1hdF9wcF90b2tlbiIsInNpemUkMCIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiYWR2YW5jZV9sZWZ0IiwicGVuZGluZ19jb3VudCIsImVucXVldWVfYWR2YW5jZSIsImVucXVldWVfc3RyaW5nX2FzIiwiaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIiwic3RhY2siLCJxdWV1ZV9lbGVtIiwic2V0X3NpemUiLCJsZWZ0X3RvdGFsIiwic2Nhbl9wdXNoIiwiZWxlbSIsInBwX29wZW5fYm94X2dlbiIsImJyX3R5IiwicHBfY2xvc2VfYm94IiwicHBfb3Blbl9zdGFnIiwicHBfY2xvc2Vfc3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsImVuZF93aXRoX25ld2xpbmUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2J5dGVzIiwicHBfcHJpbnRfaW50IiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9jdXN0b21fYnJlYWsiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInZhbGlkYXRlX2dlb21ldHJ5IiwibWFyZ2luIiwibWF4X2luZGVudCIsImNoZWNrX2dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2Z1bGxfZ2VvbWV0cnkiLCJwcF9zZXRfZ2VvbWV0cnkiLCJwcF9zYWZlX3NldF9nZW9tZXRyeSIsInBwX2dldF9nZW9tZXRyeSIsInBwX3VwZGF0ZV9nZW9tZXRyeSIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2JsYW5rcyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwiZmx1c2giLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsInN0ZGJ1Zl9rZXkiLCJzdHJfZm9ybWF0dGVyX2tleSIsImJ1ZmZlcmVkX291dF9zdHJpbmciLCJidWZmZXJlZF9vdXRfZmx1c2giLCJzdGRfYnVmX2tleSIsImVycl9idWZfa2V5Iiwic3RkX2Zvcm1hdHRlcl9rZXkiLCJlcnJfZm9ybWF0dGVyX2tleSIsImdldF9zdGRfZm9ybWF0dGVyIiwiZ2V0X2Vycl9mb3JtYXR0ZXIiLCJnZXRfc3RyX2Zvcm1hdHRlciIsImdldF9zdGRidWYiLCJmbHVzaF9idWZmZXJfZm9ybWF0dGVyIiwiZmx1c2hfc3RyX2Zvcm1hdHRlciIsIm1ha2Vfc3luY2hyb25pemVkX2Zvcm1hdHRlciIsIm91dHB1dCQwIiwiZmx1c2gkMCIsInN5bmNocm9uaXplZF9mb3JtYXR0ZXJfb2Zfb3V0XyIsIm1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJzb2IiLCJnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJpdGVtcyIsImFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSIsIml0ZW0iLCJmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2IiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fc3RhZyIsImNsb3NlX3N0YWciLCJwcmludF9hcyIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfaWZfbmV3bGluZSIsIm9wZW5fdGJveCIsImNsb3NlX3Rib3giLCJwcmludF90YnJlYWsiLCJzZXRfdGFiIiwicHJpbnRfdGFiIiwic2V0X21hcmdpbiIsImdldF9tYXJnaW4iLCJzZXRfbWF4X2luZGVudCIsImdldF9tYXhfaW5kZW50Iiwic2V0X2dlb21ldHJ5Iiwic2FmZV9zZXRfZ2VvbWV0cnkiLCJnZXRfZ2VvbWV0cnkiLCJ1cGRhdGVfZ2VvbWV0cnkiLCJzZXRfbWF4X2JveGVzIiwiZ2V0X21heF9ib3hlcyIsIm92ZXJfbWF4X2JveGVzIiwic2V0X2VsbGlwc2lzX3RleHQiLCJnZXRfZWxsaXBzaXNfdGV4dCIsInNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsInNldF9wcmludF90YWdzIiwiZ2V0X3ByaW50X3RhZ3MiLCJzZXRfbWFya190YWdzIiwiZ2V0X21hcmtfdGFncyIsInNldF90YWdzIiwicHBfcHJpbnRfaXRlciIsInBwX3YiLCJwcF9zZXAiLCJpc19maXJzdCIsInBwX3YkMCIsInBwX3ByaW50X2xpc3QiLCJwcF9wcmludF9hcnJheSIsInBwX3ByaW50X3NlcSIsInBwX3ByaW50X3RleHQiLCJwcF9wcmludF9vcHRpb24iLCJwcF9wcmludF9yZXN1bHQiLCJwcF9wcmludF9laXRoZXIiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJidHkiLCJwJDYiLCJwJDciLCJzaXplJDEiLCJwJDgiLCJrZHByaW50ZiIsImRwcmludGYiLCJrYXNwcmludGYiLCJhc3ByaW50ZiIsImZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMiLCJmcyIsImZzJDAiLCJudWxsX2NoYXIiLCJuZXh0X2NoYXIiLCJpYiIsInBlZWtfY2hhciIsImNoZWNrZWRfcGVla19jaGFyIiwiZW5kX29mX2lucHV0IiwiYmVnaW5uaW5nX29mX2lucHV0IiwibmFtZV9vZl9pbnB1dCIsImNoYXJfY291bnQiLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJpbmFtZSIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsIm9wZW5faW5fZmlsZSIsImNsb3NlX2luIiwiaWMkMCIsImJhZF9pbnB1dCIsImJhZF9pbnB1dF9lc2NhcGUiLCJiYWRfdG9rZW5fbGVuZ3RoIiwibWVzc2FnZSIsImJhZF9mbG9hdCIsImJhZF9oZXhfZmxvYXQiLCJjaGFyYWN0ZXJfbWlzbWF0Y2giLCJjaSIsImNoZWNrX2NoYXIiLCJjaGVja190aGlzX2NoYXIiLCJ0b2tlbl9jaGFyIiwidG9rZW5fYm9vbCIsImludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIiwidG9rZW5faW50X2xpdGVyYWwiLCJjb252IiwidG9rZW5fZmxvYXQiLCJzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciIsInNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwibG93ZXJjYXNlIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsImdldF9kaWdpdCIsInNjYW5fY2FtbF9zdHJpbmciLCJmaW5kX3N0b3AkMCIsInNraXBfc3BhY2VzIiwiZmluZF9zdG9wIiwic2Nhbl9jaGFyc19pbl9jaGFyX3NldCIsInNjYW5faW5kaWMiLCJzY2FuX2NoYXJzIiwic2NhbmZfYmFkX2lucHV0Iiwid2lkdGhfb2ZfcGFkX29wdCIsInN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQiLCJmbXRpbmciLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzJDAiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzJDAiLCJyZWFkZXIiLCJuZXdfayIsInJlYWRlcnNfcmVzdCIsInRha2VfZm9ybWF0X3JlYWRlcnMiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIiwibWFrZV9zY2FuZiIsInJlYWRlcnMiLCJzY2FuJDAiLCJzdHJfcmVzdCIsInBhZF9wcmVjX3NjYW5mIiwic2NhbiQxIiwic2NhbiQyIiwic2NhbiQzIiwic2NhbiQ0IiwiY29udiQwIiwic2NhbiQ1IiwiY29udiQxIiwic2NhbiQ2IiwiY29udiQyIiwic2NhbiQ3Iiwic2NhbiQ4IiwiZm10aW5nX2xpdCQwIiwic3RwJDAiLCJzJDIiLCJzdHJfcmVzdCQwIiwiYXJnX3Jlc3QiLCJrc2NhbmZfZ2VuIiwiZWYiLCJhcmdzJDEiLCJleGMkMCIsImV4YyIsImFyZ3MkMCIsImtzY2FuZiIsImtzY2FuZl9vcHQiLCJic2NhbmYiLCJic2NhbmZfb3B0Iiwia3NzY2FuZiIsInNzY2FuZiIsInNzY2FuZl9vcHQiLCJzY2FuZiIsInNjYW5mX29wdCIsImJzY2FuZl9mb3JtYXQiLCJmb3JtYXQiLCJzc2NhbmZfZm9ybWF0IiwiZm9ybWF0X2Zyb21fc3RyaW5nIiwidW5lc2NhcGVkIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZHVtbXlfaXRlbSIsInB1YmxpY19tZXRob2RfbGFiZWwiLCJ0YWciLCJjb21wYXJlJDAiLCJjb21wYXJlJDEiLCJkdW1teV90YWJsZSIsInRhYmxlX2NvdW50IiwiZHVtbXlfbWV0IiwiZml0X3NpemUiLCJuZXdfdGFibGUiLCJwdWJfbGFiZWxzIiwibWV0aG9kcyIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm1ldGhzJDAiLCJubWV0aHMiLCJudmFscyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsInRhZ3MiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJzdXBlciQwIiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaSIsImdldF9kYXRhIiwiYnVpbGRfcGF0aCIsImtleXMiLCJsb29rdXBfdGFibGVzIiwicm9vdCIsInJvb3RfZGF0YSIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJ0YWJsZXNfZGF0YSIsIm5ld19jYWNoZSIsInNldF9tZXRob2RzIiwiY2xvIiwiY2xvJDAiLCJuJDIiLCJuJDMiLCJuJDQiLCJuJDUiLCJuJDYiLCJ4JDMiLCJuJDciLCJ4JDQiLCJuJDgiLCJuJDkiLCJ4JDUiLCJmJDgiLCJlJDIiLCJuJDEwIiwieCQ2IiwiZiQ5IiwibiQxMSIsIngkNyIsIm4kMTIiLCJ4JDgiLCJuJDEzIiwibiQxNCIsImUkMyIsIm4kMTUiLCJtJDEiLCJtJDIiLCJ4JDkiLCJtJDMiLCJuJDE2IiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNSIsIm4kMTgiLCJpbml0X21vZF9ibG9jayIsImNvbXBzJDAiLCJtb2R1Iiwic2hhcGUiLCJmbiQwIiwiY29tcHMiLCJpbml0X21vZCIsInVwZGF0ZV9tb2RfYmxvY2siLCJjbCIsInVwZGF0ZV9tb2QiLCJwcm5nIiwiaGtleSIsImNsZWFuIiwiZG9fYnVja2V0IiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsImZpbmRfaW5fYnVja2V0IiwiYnVja2V0X2xlbmd0aF9hbGl2ZSIsInN0YXRzX2FsaXZlIiwic2V0X2RhdGEiLCJlcGgiLCJxdWVyeSIsInNldF9rZXlfZGF0YSIsInRlc3Rfa2V5IiwidCQwIiwiZ2V0X2tleTEiLCJzZXRfa2V5MSIsImdldF9rZXkyIiwic2V0X2tleTIiLCJnZXRfZGF0YSQwIiwic2V0X2RhdGEkMCIsIm1ha2UkMSIsImtleTEiLCJrZXkyIiwicXVlcnkkMCIsImsyJDAiLCJrMSQwIiwiZXF1YWwkMCIsInNlZWRlZF9oYXNoJDAiLCJtYWtlJDIiLCJhZGQkMCIsInRlc3Rfa2V5cyIsInJlbW92ZSQwIiwiZmluZCQwIiwibGVuZ3RoJDAiLCJjbGVhciQwIiwibGVuZ3RoJDEiLCJnZXRfa2V5JDAiLCJzZXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwic2V0X2RhdGEkMSIsIm1ha2UkMyIsInF1ZXJ5JDEiLCJtYWtlJDQiLCJhZGQkMSIsInRlc3Rfa2V5cyQwIiwicmVtb3ZlJDEiLCJmaW5kJDEiLCJsZW5ndGgkMiIsImNsZWFyJDEiLCJudWxsJDAiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJudWxsJDEiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsIm51bGwkMiIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiZ2VuZXJpY19iYXNlbmFtZSIsImlzX2Rpcl9zZXAiLCJnZW5lcmljX2Rpcm5hbWUiLCJpc19yZWxhdGl2ZSIsImlzX2ltcGxpY2l0IiwiY2hlY2tfc3VmZml4Iiwic3VmZiIsImNob3Bfc3VmZml4X29wdCIsImxlbl9mIiwidGVtcF9kaXJfbmFtZSIsInF1b3RlIiwicXVvdGVfY29tbWFuZCIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJjaG9wX3N1ZmZpeF9vcHQkMCIsInRlbXBfZGlyX25hbWUkMCIsInF1b3RlJDAiLCJsb29wJDAiLCJsb29wX2JzIiwiYWRkX2JzIiwicXVvdGVfY21kX2ZpbGVuYW1lIiwicXVvdGVfY29tbWFuZCQwIiwiZHJpdmVfYW5kX3BhdGgiLCJkaXJuYW1lJDAiLCJwYXRoIiwiZHJpdmUiLCJkaXIiLCJiYXNlbmFtZSQwIiwiYmFzZW5hbWUkMSIsImRpcm5hbWUkMSIsIm51bGwkMyIsImN1cnJlbnRfZGlyX25hbWUkMiIsInBhcmVudF9kaXJfbmFtZSQyIiwiZGlyX3NlcCQyIiwiaXNfZGlyX3NlcCQxIiwiaXNfcmVsYXRpdmUkMSIsImlzX2ltcGxpY2l0JDEiLCJjaGVja19zdWZmaXgkMSIsImNob3Bfc3VmZml4X29wdCQxIiwidGVtcF9kaXJfbmFtZSQxIiwicXVvdGUkMSIsInF1b3RlX2NvbW1hbmQkMSIsImJhc2VuYW1lJDIiLCJkaXJuYW1lJDIiLCJjaG9wX3N1ZmZpeCIsImV4dGVuc2lvbl9sZW4iLCJpMCIsImV4dGVuc2lvbiIsImNob3BfZXh0ZW5zaW9uIiwicmVtb3ZlX2V4dGVuc2lvbiIsInRlbXBfZmlsZV9uYW1lIiwidGVtcF9kaXIiLCJyYW5kb21fc3RhdGUiLCJybmQiLCJjdXJyZW50X3RlbXBfZGlyX25hbWUiLCJzZXRfdGVtcF9kaXJfbmFtZSIsImdldF90ZW1wX2Rpcl9uYW1lIiwidGVtcF9maWxlIiwib3Blbl90ZW1wX2ZpbGUiLCJzdGgkMCIsInBlcm1zIiwic3RoJDEiLCJuZWciLCJjb25qIiwibXVsIiwiZGl2IiwiaW52Iiwibm9ybTIiLCJub3JtIiwicG9sYXIiLCJzcXJ0IiwicSQwIiwidyQwIiwiZXhwIiwibG9nIiwicG93Iiwib3Blbl9iaW4iLCJvcGVuX3RleHQiLCJvcGVuX2dlbiIsIndpdGhfb3BlbiIsIm9wZW5mdW4iLCJ3aXRoX29wZW5fYmluIiwid2l0aF9vcGVuX3RleHQiLCJ3aXRoX29wZW5fZ2VuIiwic2VlayIsImNsb3NlIiwiY2xvc2Vfbm9lcnIiLCJpbnB1dF9jaGFyIiwiaW5wdXRfYnl0ZSIsInJlYWRfdXB0byIsImVuc3VyZSIsIm5ld19sZW4kMCIsIm5ld19sZW4kMSIsImlucHV0X2FsbCIsImNodW5rX3NpemUiLCJpbml0aWFsX3NpemUkMCIsImluaXRpYWxfc2l6ZSQxIiwibnJlYWQiLCJidWYkMiIsImJ1ZiQwIiwiYnVmJDEiLCJyZW0iLCJpbnB1dF9saW5lcyIsImZvbGRfbGluZXMiLCJzZXRfYmluYXJ5X21vZGUiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwicHJpbnRlciIsImNvbnRpbnVlJDAiLCJkaXNjb250aW51ZSIsImRpc2NvbnRpbnVlX3dpdGhfYmFja3RyYWNlIiwibWF0Y2hfd2l0aCIsImNvbXAiLCJoYW5kbGVyIiwiZWZmYyIsImVmZiIsImxhc3RfZmliZXIiLCJ0cnlfd2l0aCIsImZpYmVyIiwiY29udGludWVfZ2VuIiwicmVzdW1lX2Z1biIsImNvbnRpbnVlX3dpdGgiLCJkaXNjb250aW51ZV93aXRoIiwiZGlzY29udGludWVfd2l0aF9iYWNrdHJhY2UkMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvc3RkbGliLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2VpdGhlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9zeXMubWwuaW4iLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvb2JqLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3R5cGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvYXRvbWljLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvbGF6eS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9zZXEubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3Jlc3VsdC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9ib29sLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2NoYXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvdWNoYXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvbGlzdC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9pbnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvYnl0ZXMubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3VuaXQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3BhcnNpbmcubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvc2V0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL21hcC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9idWZmZXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvbXV0ZXgubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvc2VtYXBob3JlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2RvbWFpbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2FyZy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9wcmludGV4Yy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9mdW4ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvZ2MubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvZGlnZXN0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3JhbmRvbS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3dlYWsubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL3NjYW5mLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2NhbWxpbnRlcm5hbE1vZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvZmlsZW5hbWUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9pbl9jaGFubmVsLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL291dF9jaGFubmVsLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sL2VmZmVjdC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7WUErZ0JRQTtJLDhCQWtDWTs7O1dBOUJSQyxpQkFDUixXQUxJRCxVQUlJQzs7V0FFRUMsbUJBQ1YsV0FQSUYsVUFNTUU7O1dBRUhDLG1CQUNQLFdBVElILFVBUUdHOztXQUVFQyxtQkFDVCxXQVhJSixVQVVLSTs7V0FJSUMsbUJBQ2IsV0FmSUwsVUFjU0s7O1dBRkpDLG1CQUNULFdBYklOLFVBWUtNOztXQUlBQyxtQkFDVCxXQWpCSVAsVUFnQktPOztXQUVEQyxtQkFDUixXQW5CSVIsVUFrQklROztXQUVXQyxtQkFBSkM7T0FDZixXQURlQSxJQXBCWFYsVUFvQmVTOztXQUVTRSxtQkFBWEM7T0FDakIsV0FEaUJBLEtBQUFBLEtBdEJiWixVQXNCd0JXOztXQUVuQkUsbUJBQ1QsWUF6QkliLFVBd0JLYTs7V0FFQUMsb0JBQ1QsWUEzQklkLFVBMEJLYzs7V0FFRkMsb0JBQ1AsWUE3QklmLFVBNEJHZTs7V0FFR0Msb0JBQ1YsWUEvQkloQixVQThCTWdCO21CQUVRQyxvQkFDbEIsWUFqQ0lqQixVQWdDY2lCOzs7WUFtQmRDLGFBV0pDLFFBQU9DO0lBQVUsVUFBakJELHFCQStCZ0IsT0EvQlRDO1dBQVBEOztXQUNRbEIsT0FE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LEdBQUU4aEY7SUFDdkIsT0FiRU07YUFZaUJ0dUQ7c0JBQ0MzdkIsR0FBSyxNQUFBLDRCQUFMQSxNQUFZO2FBRFhuRTthQUFFOGhGO0dBQ29CO1lBRXpDVSw2QkFBMkIxdUQsR0FBRTl6QixHQUFFNmxELElBQUdpOEI7SUFDcEMsT0FoQkVNO2FBZTJCdHVEO3NCQUNUM3ZCO2NBQUssMkJBQUxBLEdBRGEwaEQ7Y0FDUixNQUFBLDRCQUFMMWhEO2FBQXVDO2FBRDVCbkU7YUFBSzhoRjtHQUNrQzs7Ozs7Ozs7UUE5Q3BFSztRQXVDQUc7UUFHQUM7UUFHQUM7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgX19GVU5DVElPTl9fIDogc3RyaW5nID0gXCIlbG9jX0ZVTkNUSU9OXCJcblxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcblxuKCogQ29tcGFyaXNvbnMgKilcblxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5cbmxldCBtaW4geCB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5cbigqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5cbigqIEludGVnZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcblxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5cbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5cbmxldCBsbm90IHggPSB4IGx4b3IgKC0xKVxuXG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5cbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuXG4oKiBGbG9hdGluZy1wb2ludCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbmhfZmxvYXRcIiBcImNhbWxfYXRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmxldCBpbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuZWdfaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4RkZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmFuID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0Y4XzAwXzAwXzAwXzAwXzAwXzAxTFxubGV0IG1heF9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9FRl9GRl9GRl9GRl9GRl9GRl9GRkxcbmxldCBtaW5fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4MDBfMTBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgZXBzaWxvbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgzQ19CMF8wMF8wMF8wMF8wMF8wMF8wMExcblxudHlwZSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5cbigqIFN0cmluZyBhbmQgYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlcyBTdHJpbmcgYW5kIEJ5dGVzICopXG5cbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19sZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBzdHJpbmdfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc19ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc191bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0ICggXiApIHMxIHMyID1cbiAgbGV0IGwxID0gc3RyaW5nX2xlbmd0aCBzMSBhbmQgbDIgPSBzdHJpbmdfbGVuZ3RoIHMyIGluXG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIChsMSArIGwyKSBpblxuICBzdHJpbmdfYmxpdCBzMSAwIHMgMCBsMTtcbiAgc3RyaW5nX2JsaXQgczIgMCBzIGwxIGwyO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgQ2hhciAqKVxuXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NoYXJfb2ZfaW50IDogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcImNoYXJfb2ZfaW50XCIgZWxzZSB1bnNhZmVfY2hhcl9vZl9pbnQgblxuXG4oKiBVbml0IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxuXG4oKiBSZWZlcmVuY2VzICopXG5cbnR5cGUgJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxuXG4oKiBSZXN1bHQgdHlwZSAqKVxuXG50eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxuXG4oKiBTdHJpbmcgY29udmVyc2lvbiBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG5sZXQgc3RyaW5nX29mX2Jvb2wgYiA9XG4gIGlmIGIgdGhlbiBcInRydWVcIiBlbHNlIFwiZmFsc2VcIlxubGV0IGJvb2xfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgXyAtPiBpbnZhbGlkX2FyZyBcImJvb2xfb2Zfc3RyaW5nXCJcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbiAgfCBfIC0+IE5vbmVcblxubGV0IHN0cmluZ19vZl9pbnQgbiA9XG4gIGZvcm1hdF9pbnQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmV4dGVybmFsIHN0cmluZ19nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gc3RyaW5nX2xlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IGwgdGhlbiBzIF4gXCIuXCIgZWxzZVxuICAgIG1hdGNoIHN0cmluZ19nZXQgcyBpIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgfCBfIC0+IHNcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzdHJpbmdfb2ZfZmxvYXQgZiA9IHZhbGlkX2Zsb2F0X2xleGVtIChmb3JtYXRfZmxvYXQgXCIlLjEyZ1wiIGYpXG5cbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuKCogTGlzdCBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIExpc3QgKilcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gIHwgW10gLT4gbDJcbiAgfCBoMSA6OiBbXSAtPiBoMSA6OiBsMlxuICB8IGgxIDo6IGgyIDo6IFtdIC0+IGgxIDo6IGgyIDo6IGwyXG4gIHwgaDEgOjogaDIgOjogaDMgOjogdGwgLT4gaDEgOjogaDIgOjogaDMgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG4oKiBmb3IgYXRfZXhpdCAqKVxudHlwZSAnYSBhdG9taWNfdFxuZXh0ZXJuYWwgYXRvbWljX21ha2UgOiAnYSAtPiAnYSBhdG9taWNfdCA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsIGF0b21pY19nZXQgOiAnYSBhdG9taWNfdCAtPiAnYSA9IFwiJWF0b21pY19sb2FkXCJcbmV4dGVybmFsIGF0b21pY19jb21wYXJlX2FuZF9zZXQgOiAnYSBhdG9taWNfdCAtPiAnYSAtPiAnYSAtPiBib29sXG4gID0gXCIlYXRvbWljX2Nhc1wiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gYXRvbWljX21ha2UgZmx1c2hfYWxsXG5cbmxldCByZWMgYXRfZXhpdCBmID1cbiAgKCogTVBSIzcyNTMsIE1QUiM3Nzk2OiBtYWtlIHN1cmUgXCJmXCIgaXMgZXhlY3V0ZWQgb25seSBvbmNlICopXG4gIGxldCBmX3lldF90b19ydW4gPSBhdG9taWNfbWFrZSB0cnVlIGluXG4gIGxldCBvbGRfZXhpdCA9IGF0b21pY19nZXQgZXhpdF9mdW5jdGlvbiBpblxuICBsZXQgbmV3X2V4aXQgKCkgPVxuICAgIGlmIGF0b21pY19jb21wYXJlX2FuZF9zZXQgZl95ZXRfdG9fcnVuIHRydWUgZmFsc2UgdGhlbiBmICgpIDtcbiAgICBvbGRfZXhpdCAoKVxuICBpblxuICBsZXQgc3VjY2VzcyA9IGF0b21pY19jb21wYXJlX2FuZF9zZXQgZXhpdF9mdW5jdGlvbiBvbGRfZXhpdCBuZXdfZXhpdCBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIGF0X2V4aXQgZlxuXG5sZXQgZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQgPSByZWYgKGZ1biAoKSAtPiAoKSlcblxubGV0IGRvX2F0X2V4aXQgKCkgPVxuICAoIWRvX2RvbWFpbl9sb2NhbF9hdF9leGl0KSAoKTtcbiAgKGF0b21pY19nZXQgZXhpdF9mdW5jdGlvbikgKClcblxubGV0IGV4aXQgcmV0Y29kZSA9XG4gIGRvX2F0X2V4aXQgKCk7XG4gIHN5c19leGl0IHJldGNvZGVcblxubGV0IF8gPSByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiIGRvX2F0X2V4aXRcblxuKCpNT0RVTEVfQUxJQVNFUyopXG5tb2R1bGUgQXJnICAgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgICAgPSBBcnJheUxhYmVsc1xubW9kdWxlIEF0b21pYyAgICAgICAgID0gQXRvbWljXG5tb2R1bGUgQmlnYXJyYXkgICAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICAgID0gQm9vbFxubW9kdWxlIEJ1ZmZlciAgICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICAgID0gQnl0ZXNMYWJlbHNcbm1vZHVsZSBDYWxsYmFjayAgICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgICAgPSBDb21wbGV4XG5tb2R1bGUgQ29uZGl0aW9uICAgICAgPSBDb25kaXRpb25cbm1vZHVsZSBEaWdlc3QgICAgICAgICA9IERpZ2VzdFxubW9kdWxlIERvbWFpbiAgICAgICAgID0gRG9tYWluXG5tb2R1bGUgRWZmZWN0ICAgICAgICAgPSBFZmZlY3Rcbm1vZHVsZSBFaXRoZXIgICAgICAgICA9IEVpdGhlclxubW9kdWxlIEVwaGVtZXJvbiAgICAgID0gRXBoZW1lcm9uXG5tb2R1bGUgRmlsZW5hbWUgICAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgICA9IEZvcm1hdFxubW9kdWxlIEZ1biAgICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgICAgPSBHY1xubW9kdWxlIEhhc2h0YmwgICAgICAgID0gSGFzaHRibFxubW9kdWxlIEluX2NoYW5uZWwgICAgID0gSW5fY2hhbm5lbFxubW9kdWxlIEludCAgICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgICAgPSBJbnQzMlxubW9kdWxlIEludDY0ICAgICAgICAgID0gSW50NjRcbm1vZHVsZSBMYXp5ICAgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgICA9IExleGluZ1xubW9kdWxlIExpc3QgICAgICAgICAgID0gTGlzdFxubW9kdWxlIExpc3RMYWJlbHMgICAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICAgID0gTWFwXG5tb2R1bGUgTWFyc2hhbCAgICAgICAgPSBNYXJzaGFsXG5tb2R1bGUgTW9yZUxhYmVscyAgICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTXV0ZXggICAgICAgICAgPSBNdXRleFxubW9kdWxlIE5hdGl2ZWludCAgICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgICAgPSBPYmpcbm1vZHVsZSBPbyAgICAgICAgICAgICA9IE9vXG5tb2R1bGUgT3B0aW9uICAgICAgICAgPSBPcHRpb25cbm1vZHVsZSBPdXRfY2hhbm5lbCAgICA9IE91dF9jaGFubmVsXG5tb2R1bGUgUGFyc2luZyAgICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUHJpbnRleGMgICAgICAgPSBQcmludGV4Y1xubW9kdWxlIFByaW50ZiAgICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICAgID0gUmFuZG9tXG5tb2R1bGUgUmVzdWx0ICAgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VtYXBob3JlICAgICAgPSBTZW1hcGhvcmVcbm1vZHVsZSBTZXEgICAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3RhY2sgICAgICAgICAgPSBTdGFja1xubW9kdWxlIFN0ZExhYmVscyAgICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyaW5nICAgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgICA9IFN0cmluZ0xhYmVsc1xubW9kdWxlIFN5cyAgICAgICAgICAgID0gU3lzXG5tb2R1bGUgVHlwZSAgICAgICAgICAgPSBUeXBlXG5tb2R1bGUgVWNoYXIgICAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICAgID0gVW5pdFxubW9kdWxlIFdlYWsgICAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJzaWZhbCwgSU5SSUEgU2FjbGF5ICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2IpIHQgPSBMZWZ0IG9mICdhIHwgUmlnaHQgb2YgJ2JcblxubGV0IGxlZnQgdiA9IExlZnQgdlxubGV0IHJpZ2h0IHYgPSBSaWdodCB2XG5cbmxldCBpc19sZWZ0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IHRydWVcbnwgUmlnaHQgXyAtPiBmYWxzZVxuXG5sZXQgaXNfcmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gZmFsc2VcbnwgUmlnaHQgXyAtPiB0cnVlXG5cbmxldCBmaW5kX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gU29tZSB2XG58IFJpZ2h0IF8gLT4gTm9uZVxuXG5sZXQgZmluZF9yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBOb25lXG58IFJpZ2h0IHYgLT4gU29tZSB2XG5cbmxldCBtYXBfbGVmdCBmID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IExlZnQgKGYgdilcbnwgUmlnaHQgXyBhcyBlIC0+IGVcblxubGV0IG1hcF9yaWdodCBmID0gZnVuY3Rpb25cbnwgTGVmdCBfIGFzIGUgLT4gZVxufCBSaWdodCB2IC0+IFJpZ2h0IChmIHYpXG5cbmxldCBtYXAgfmxlZnQgfnJpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IExlZnQgKGxlZnQgdilcbnwgUmlnaHQgdiAtPiBSaWdodCAocmlnaHQgdilcblxubGV0IGZvbGQgfmxlZnQgfnJpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IGxlZnQgdlxufCBSaWdodCB2IC0+IHJpZ2h0IHZcblxubGV0IGl0ZXIgPSBmb2xkXG5cbmxldCBmb3JfYWxsID0gZm9sZFxuXG5sZXQgZXF1YWwgfmxlZnQgfnJpZ2h0IGUxIGUyID0gbWF0Y2ggZTEsIGUyIHdpdGhcbnwgTGVmdCB2MSwgTGVmdCB2MiAtPiBsZWZ0IHYxIHYyXG58IFJpZ2h0IHYxLCBSaWdodCB2MiAtPiByaWdodCB2MSB2MlxufCBMZWZ0IF8sIFJpZ2h0IF8gfCBSaWdodCBfLCBMZWZ0IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfmxlZnQgfnJpZ2h0IGUxIGUyID0gbWF0Y2ggZTEsIGUyIHdpdGhcbnwgTGVmdCB2MSwgTGVmdCB2MiAtPiBsZWZ0IHYxIHYyXG58IFJpZ2h0IHYxLCBSaWdodCB2MiAtPiByaWdodCB2MSB2MlxufCBMZWZ0IF8sIFJpZ2h0IF8gLT4gKC0xKVxufCBSaWdodCBfLCBMZWZ0IF8gLT4gMVxuIiwiKCogQGNvbmZpZ3VyZV9pbnB1dEAgKilcbiMzIFwic3lzLm1sLmluXCJcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBiYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG4oKiBTeXN0ZW0gaW50ZXJmYWNlICopXG5cbmV4dGVybmFsIGdldF9jb25maWc6IHVuaXQgLT4gc3RyaW5nICogaW50ICogYm9vbCA9IFwiY2FtbF9zeXNfZ2V0X2NvbmZpZ1wiXG5leHRlcm5hbCBnZXRfZXhlY3V0YWJsZV9uYW1lIDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZVwiXG5leHRlcm5hbCBhcmd2IDogc3RyaW5nIGFycmF5ID0gXCIlc3lzX2FyZ3ZcIlxuZXh0ZXJuYWwgYmlnX2VuZGlhbiA6IHVuaXQgLT4gYm9vbCA9IFwiJWJpZ19lbmRpYW5cIlxuZXh0ZXJuYWwgd29yZF9zaXplIDogdW5pdCAtPiBpbnQgPSBcIiV3b3JkX3NpemVcIlxuZXh0ZXJuYWwgaW50X3NpemUgOiB1bml0IC0+IGludCA9IFwiJWludF9zaXplXCJcbmV4dGVybmFsIG1heF93b3NpemUgOiB1bml0IC0+IGludCA9IFwiJW1heF93b3NpemVcIlxuZXh0ZXJuYWwgdW5peCA6IHVuaXQgLT4gYm9vbCA9IFwiJW9zdHlwZV91bml4XCJcbmV4dGVybmFsIHdpbjMyIDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX3dpbjMyXCJcbmV4dGVybmFsIGN5Z3dpbiA6IHVuaXQgLT4gYm9vbCA9IFwiJW9zdHlwZV9jeWd3aW5cIlxuZXh0ZXJuYWwgZ2V0X2JhY2tlbmRfdHlwZSA6IHVuaXQgLT4gYmFja2VuZF90eXBlID0gXCIlYmFja2VuZF90eXBlXCJcblxubGV0IGV4ZWN1dGFibGVfbmFtZSA9IGdldF9leGVjdXRhYmxlX25hbWUoKVxubGV0IChvc190eXBlLCBfLCBfKSA9IGdldF9jb25maWcoKVxubGV0IGJhY2tlbmRfdHlwZSA9IGdldF9iYWNrZW5kX3R5cGUgKClcbmxldCBiaWdfZW5kaWFuID0gYmlnX2VuZGlhbiAoKVxubGV0IHdvcmRfc2l6ZSA9IHdvcmRfc2l6ZSAoKVxubGV0IGludF9zaXplID0gaW50X3NpemUgKClcbmxldCB1bml4ID0gdW5peCAoKVxubGV0IHdpbjMyID0gd2luMzIgKClcbmxldCBjeWd3aW4gPSBjeWd3aW4gKClcbmxldCBtYXhfYXJyYXlfbGVuZ3RoID0gbWF4X3dvc2l6ZSAoKVxubGV0IG1heF9mbG9hdGFycmF5X2xlbmd0aCA9IG1heF9hcnJheV9sZW5ndGggLyAoNjQgLyB3b3JkX3NpemUpXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDFcbmV4dGVybmFsIHJ1bnRpbWVfdmFyaWFudCA6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3J1bnRpbWVfdmFyaWFudFwiXG5leHRlcm5hbCBydW50aW1lX3BhcmFtZXRlcnMgOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcIlxuXG5leHRlcm5hbCBmaWxlX2V4aXN0czogc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3lzX2ZpbGVfZXhpc3RzXCJcbmV4dGVybmFsIGlzX2RpcmVjdG9yeSA6IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N5c19pc19kaXJlY3RvcnlcIlxuZXh0ZXJuYWwgaXNfcmVndWxhcl9maWxlIDogc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZVwiXG5leHRlcm5hbCByZW1vdmU6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19yZW1vdmVcIlxuZXh0ZXJuYWwgcmVuYW1lIDogc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19yZW5hbWVcIlxuZXh0ZXJuYWwgZ2V0ZW52OiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjYW1sX3N5c19nZXRlbnZcIlxuXG5sZXQgZ2V0ZW52X29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAoZ2V0ZW52IHMpXG4gIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuZXh0ZXJuYWwgY29tbWFuZDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcIlxuZXh0ZXJuYWwgdGltZTogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfc3lzX3RpbWVcIiBcImNhbWxfc3lzX3RpbWVfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjaGRpcjogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX2NoZGlyXCJcbmV4dGVybmFsIG1rZGlyOiBzdHJpbmcgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX21rZGlyXCJcbmV4dGVybmFsIHJtZGlyOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfcm1kaXJcIlxuZXh0ZXJuYWwgZ2V0Y3dkOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZ2V0Y3dkXCJcbmV4dGVybmFsIHJlYWRkaXIgOiBzdHJpbmcgLT4gc3RyaW5nIGFycmF5ID0gXCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVwiXG5cbmxldCBpbnRlcmFjdGl2ZSA9IHJlZiBmYWxzZVxuXG50eXBlIHNpZ25hbF9iZWhhdmlvciA9XG4gICAgU2lnbmFsX2RlZmF1bHRcbiAgfCBTaWduYWxfaWdub3JlXG4gIHwgU2lnbmFsX2hhbmRsZSBvZiAoaW50IC0+IHVuaXQpXG5cbmV4dGVybmFsIHNpZ25hbCA6IGludCAtPiBzaWduYWxfYmVoYXZpb3IgLT4gc2lnbmFsX2JlaGF2aW9yXG4gICAgICAgICAgICAgICAgPSBcImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlclwiXG5cbmxldCBzZXRfc2lnbmFsIHNpZ19udW0gc2lnX2JlaCA9IGlnbm9yZShzaWduYWwgc2lnX251bSBzaWdfYmVoKVxuXG5sZXQgc2lnYWJydCA9IC0xXG5sZXQgc2lnYWxybSA9IC0yXG5sZXQgc2lnZnBlID0gLTNcbmxldCBzaWdodXAgPSAtNFxubGV0IHNpZ2lsbCA9IC01XG5sZXQgc2lnaW50ID0gLTZcbmxldCBzaWdraWxsID0gLTdcbmxldCBzaWdwaXBlID0gLThcbmxldCBzaWdxdWl0ID0gLTlcbmxldCBzaWdzZWd2ID0gLTEwXG5sZXQgc2lndGVybSA9IC0xMVxubGV0IHNpZ3VzcjEgPSAtMTJcbmxldCBzaWd1c3IyID0gLTEzXG5sZXQgc2lnY2hsZCA9IC0xNFxubGV0IHNpZ2NvbnQgPSAtMTVcbmxldCBzaWdzdG9wID0gLTE2XG5sZXQgc2lndHN0cCA9IC0xN1xubGV0IHNpZ3R0aW4gPSAtMThcbmxldCBzaWd0dG91ID0gLTE5XG5sZXQgc2lndnRhbHJtID0gLTIwXG5sZXQgc2lncHJvZiA9IC0yMVxubGV0IHNpZ2J1cyA9IC0yMlxubGV0IHNpZ3BvbGwgPSAtMjNcbmxldCBzaWdzeXMgPSAtMjRcbmxldCBzaWd0cmFwID0gLTI1XG5sZXQgc2lndXJnID0gLTI2XG5sZXQgc2lneGNwdSA9IC0yN1xubGV0IHNpZ3hmc3ogPSAtMjhcblxuZXhjZXB0aW9uIEJyZWFrXG5cbmxldCBjYXRjaF9icmVhayBvbiA9XG4gIGlmIG9uIHRoZW5cbiAgICBzZXRfc2lnbmFsIHNpZ2ludCAoU2lnbmFsX2hhbmRsZShmdW4gXyAtPiByYWlzZSBCcmVhaykpXG4gIGVsc2VcbiAgICBzZXRfc2lnbmFsIHNpZ2ludCBTaWduYWxfZGVmYXVsdFxuXG5cbmV4dGVybmFsIGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzOiBib29sIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcIlxuZXh0ZXJuYWwgcnVudGltZV93YXJuaW5nc19lbmFibGVkOiB1bml0IC0+IGJvb2wgPVxuICBcImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXCJcblxuKCogVGhlIHZlcnNpb24gc3RyaW5nIGlzIGZvdW5kIGluIGZpbGUgLi4vVkVSU0lPTiAqKVxuXG5sZXQgb2NhbWxfdmVyc2lvbiA9IFwiQFZFUlNJT05AXCJcblxubGV0IGRldmVsb3BtZW50X3ZlcnNpb24gPSBAT0NBTUxfREVWRUxPUE1FTlRfVkVSU0lPTkBcblxudHlwZSBleHRyYV9wcmVmaXggPSBQbHVzIHwgVGlsZGVcblxudHlwZSBleHRyYV9pbmZvID0gZXh0cmFfcHJlZml4ICogc3RyaW5nXG5cbnR5cGUgb2NhbWxfcmVsZWFzZV9pbmZvID0ge1xuICBtYWpvciA6IGludDtcbiAgbWlub3IgOiBpbnQ7XG4gIHBhdGNobGV2ZWwgOiBpbnQ7XG4gIGV4dHJhIDogZXh0cmFfaW5mbyBvcHRpb25cbn1cblxubGV0IG9jYW1sX3JlbGVhc2UgPSB7XG4gIG1ham9yID0gQE9DQU1MX1ZFUlNJT05fTUFKT1JAO1xuICBtaW5vciA9IEBPQ0FNTF9WRVJTSU9OX01JTk9SQDtcbiAgcGF0Y2hsZXZlbCA9IEBPQ0FNTF9WRVJTSU9OX1BBVENITEVWRUxAO1xuICBleHRyYSA9IEBPQ0FNTF9SRUxFQVNFX0VYVFJBQFxufVxuXG4oKiBPcHRpbWl6YXRpb24gKilcblxuZXh0ZXJuYWwgb3BhcXVlX2lkZW50aXR5IDogJ2EgLT4gJ2EgPSBcIiVvcGFxdWVcIlxuXG5tb2R1bGUgSW1tZWRpYXRlNjQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgTm9uX2ltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UoSW1tZWRpYXRlIDogSW1tZWRpYXRlKShOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG4gICAgdHlwZSAnYSByZXByID1cbiAgICAgIHwgSW1tZWRpYXRlIDogSW1tZWRpYXRlLnQgcmVwclxuICAgICAgfCBOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZS50IHJlcHJcbiAgICBleHRlcm5hbCBtYWdpYyA6IF8gcmVwciAtPiB0IHJlcHIgPSBcIiVpZGVudGl0eVwiXG4gICAgbGV0IHJlcHIgPVxuICAgICAgaWYgd29yZF9zaXplID0gNjQgdGhlblxuICAgICAgICBtYWdpYyBJbW1lZGlhdGVcbiAgICAgIGVsc2VcbiAgICAgICAgbWFnaWMgTm9uX2ltbWVkaWF0ZVxuICBlbmRcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBPcGVyYXRpb25zIG9uIGludGVybmFsIHJlcHJlc2VudGF0aW9ucyBvZiB2YWx1ZXMgKilcblxudHlwZSB0XG5cbnR5cGUgcmF3X2RhdGEgPSBuYXRpdmVpbnRcblxuZXh0ZXJuYWwgcmVwciA6ICdhIC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiB0IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbWFnaWMgOiAnYSAtPiAnYiA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGlzX2ludCA6IHQgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfYmxvY2sgYSA9IG5vdCAoaXNfaW50IGEpXG5leHRlcm5hbCB0YWcgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpemUgOiB0IC0+IGludCA9IFwiJW9ial9zaXplXCJcbmV4dGVybmFsIHJlYWNoYWJsZV93b3JkcyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial9yZWFjaGFibGVfd29yZHNcIlxuZXh0ZXJuYWwgZmllbGQgOiB0IC0+IGludCAtPiB0ID0gXCIlb2JqX2ZpZWxkXCJcbmV4dGVybmFsIHNldF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdW5pdCA9IFwiJW9ial9zZXRfZmllbGRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdGFycmF5X2dldFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X3NldCA6XG4gICAgZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiY2FtbF9mbG9hdGFycmF5X3NldFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBkb3VibGVfZmllbGQgeCBpID0gZmxvYXRhcnJheV9nZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaVxubGV0IFtAaW5saW5lIGFsd2F5c10gc2V0X2RvdWJsZV9maWVsZCB4IGkgdiA9XG4gIGZsb2F0YXJyYXlfc2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGkgdlxuZXh0ZXJuYWwgcmF3X2ZpZWxkIDogdCAtPiBpbnQgLT4gcmF3X2RhdGEgPSBcImNhbWxfb2JqX3Jhd19maWVsZFwiXG5leHRlcm5hbCBzZXRfcmF3X2ZpZWxkIDogdCAtPiBpbnQgLT4gcmF3X2RhdGEgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfb2JqX3NldF9yYXdfZmllbGRcIlxuXG5leHRlcm5hbCBuZXdfYmxvY2sgOiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfb2JqX2Jsb2NrXCJcbmV4dGVybmFsIGR1cCA6IHQgLT4gdCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5leHRlcm5hbCB3aXRoX3RhZyA6IGludCAtPiB0IC0+IHQgPSBcImNhbWxfb2JqX3dpdGhfdGFnXCJcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQzXG5cbmxldCBmb3JjaW5nX3RhZyA9IDI0NFxubGV0IGNvbnRfdGFnID0gMjQ1XG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubW9kdWxlIENsb3N1cmUgPSBzdHJ1Y3RcbiAgdHlwZSBpbmZvID0ge1xuICAgIGFyaXR5OiBpbnQ7XG4gICAgc3RhcnRfZW52OiBpbnQ7XG4gIH1cblxuICBsZXQgaW5mb19vZl9yYXcgKGluZm8gOiBuYXRpdmVpbnQpID1cbiAgICBsZXQgb3BlbiBOYXRpdmVpbnQgaW5cbiAgICBsZXQgYXJpdHkgPVxuICAgICAgKCogc2lnbmVkOiBuZWdhdGl2ZSBmb3IgdHVwbGVkIGZ1bmN0aW9ucyAqKVxuICAgICAgaWYgU3lzLndvcmRfc2l6ZSA9IDY0IHRoZW5cbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDU2KVxuICAgICAgZWxzZVxuICAgICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0IGluZm8gMjQpXG4gICAgaW5cbiAgICBsZXQgc3RhcnRfZW52ID1cbiAgICAgICgqIHN0YXJ0X2VudiBpcyB1bnNpZ25lZCwgYnV0IHdlIGtub3cgaXQgY2FuIGFsd2F5cyBmaXQgYW4gT0NhbWxcbiAgICAgICAgIGludGVnZXIgc28gd2UgdXNlIFt0b19pbnRdIGluc3RlYWQgb2YgW3Vuc2lnbmVkX3RvX2ludF0uICopXG4gICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKHNoaWZ0X2xlZnQgaW5mbyA4KSA5KSBpblxuICAgIHsgYXJpdHk7IHN0YXJ0X2VudiB9XG5cbiAgKCogbm90ZTogd2UgZXhwZWN0IGEgY2xvc3VyZSwgbm90IGFuIGluZml4IHBvaW50ZXIgKilcbiAgbGV0IGluZm8gKG9iaiA6IHQpID1cbiAgICBhc3NlcnQgKHRhZyBvYmogPSBjbG9zdXJlX3RhZyk7XG4gICAgaW5mb19vZl9yYXcgKHJhd19maWVsZCBvYmogMSlcbmVuZFxuXG5tb2R1bGUgRXh0ZW5zaW9uX2NvbnN0cnVjdG9yID1cbnN0cnVjdFxuICB0eXBlIHQgPSBleHRlbnNpb25fY29uc3RydWN0b3JcbiAgbGV0IG9mX3ZhbCB4ID1cbiAgICBsZXQgeCA9IHJlcHIgeCBpblxuICAgIGxldCBzbG90ID1cbiAgICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgICAgZWxzZSB4XG4gICAgaW5cbiAgICBsZXQgbmFtZSA9XG4gICAgICBpZiAoaXNfYmxvY2sgc2xvdCkgJiYgKHRhZyBzbG90KSA9IG9iamVjdF90YWcgdGhlbiBmaWVsZCBzbG90IDBcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcbiAgICBpblxuICAgICAgaWYgKHRhZyBuYW1lKSA9IHN0cmluZ190YWcgdGhlbiAob2JqIHNsb3QgOiB0KVxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIG5hbWUgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gaWQgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMSkgOiBpbnQpXG5lbmRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIlxuICBsZXQgY3JlYXRlIGwgPVxuICAgIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gbWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uY3JlYXRlXCI7XG4gICAgY3JlYXRlIGxcblxuICBsZXQgbGVuZ3RoIHggPSBzaXplKHJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBsZXQgZ2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleVwiO1xuICAgIGdldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleV9jb3B5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcIlxuICBsZXQgZ2V0X2tleV9jb3B5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5X2NvcHlcIjtcbiAgICBnZXRfa2V5X2NvcHkgZSBvXG5cbiAgZXh0ZXJuYWwgc2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuICBsZXQgc2V0X2tleSBlIG8geCA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5zZXRfa2V5XCI7XG4gICAgc2V0X2tleSBlIG8geFxuXG4gIGV4dGVybmFsIHVuc2V0X2tleTogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG4gIGxldCB1bnNldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnVuc2V0X2tleVwiO1xuICAgIHVuc2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBjaGVja19rZXk6IHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19rZXlcIlxuICBsZXQgY2hlY2tfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5jaGVja19rZXlcIjtcbiAgICBjaGVja19rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGxldCBibGl0X2tleSBlMSBvMSBlMiBvMiBsID1cbiAgICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmJsaXRfa2V5XCJcbiAgICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXRfa2V5IGUxIG8xIGUyIG8yIGxcblxuICBleHRlcm5hbCBnZXRfZGF0YTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YVwiXG4gIGV4dGVybmFsIGdldF9kYXRhX2NvcHk6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVwiXG4gIGV4dGVybmFsIHNldF9kYXRhOiB0IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfZGF0YVwiXG4gIGV4dGVybmFsIHVuc2V0X2RhdGE6IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2RhdGFcIlxuICBleHRlcm5hbCBjaGVja19kYXRhOiB0IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19kYXRhXCJcbiAgZXh0ZXJuYWwgYmxpdF9kYXRhIDogdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9ibGl0X2RhdGFcIlxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVHlwZSBlcXVhbGl0eSB3aXRuZXNzICopXG5cbnR5cGUgKF8sIF8pIGVxID0gRXF1YWw6ICgnYSwgJ2EpIGVxXG5cbigqIFR5cGUgaWRlbnRpZmllcnMgKilcblxubW9kdWxlIElkID0gc3RydWN0XG4gIHR5cGUgXyBpZCA9IC4uXG4gIG1vZHVsZSB0eXBlIElEID0gc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBfIGlkICs9IElkIDogdCBpZFxuICBlbmRcblxuICB0eXBlICEnYSB0ID0gKG1vZHVsZSBJRCB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gIGxldCBtYWtlICh0eXBlIGEpICgpIDogYSB0ID1cbiAgICAobW9kdWxlIHN0cnVjdCB0eXBlIHQgPSBhIHR5cGUgXyBpZCArPSBJZCA6IHQgaWQgZW5kKVxuXG4gIGxldFtAaW5saW5lXSB1aWQgKHR5cGUgYSkgKChtb2R1bGUgQSkgOiBhIHQpID1cbiAgICBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkIChPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBBLklkKVxuXG4gIGxldCBwcm92YWJseV9lcXVhbFxuICAgICAgKHR5cGUgYSBiKSAoKG1vZHVsZSBBKSA6IGEgdCkgKChtb2R1bGUgQikgOiBiIHQpIDogKGEsIGIpIGVxIG9wdGlvblxuICAgID1cbiAgICBtYXRjaCBBLklkIHdpdGggQi5JZCAtPiBTb21lIEVxdWFsIHwgXyAtPiBOb25lXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTdGVwaGVuIERvbGFuLCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTctMjAxOCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZS4gICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBtYWtlIDogJ2EgLT4gJ2EgdCA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gJ2EgPSBcIiVhdG9taWNfbG9hZFwiXG5leHRlcm5hbCBleGNoYW5nZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgPSBcIiVhdG9taWNfZXhjaGFuZ2VcIlxuZXh0ZXJuYWwgY29tcGFyZV9hbmRfc2V0IDogJ2EgdCAtPiAnYSAtPiAnYSAtPiBib29sID0gXCIlYXRvbWljX2Nhc1wiXG5leHRlcm5hbCBmZXRjaF9hbmRfYWRkIDogaW50IHQgLT4gaW50IC0+IGludCA9IFwiJWF0b21pY19mZXRjaF9hZGRcIlxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbmxldCBzZXQgciB4ID0gaWdub3JlIChleGNoYW5nZSByIHgpXG5sZXQgaW5jciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgMSlcbmxldCBkZWNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAoLTEpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBJbnRlcm5hbHMgb2YgZm9yY2luZyBsYXp5IHZhbHVlcy4gKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxuKCogW3VwZGF0ZV90b19mb3JjaW5nIGJsa10gdHJpZXMgdG8gdXBkYXRlIGEgW2Jsa10gd2l0aCBbbGF6eV90YWddIHRvXG4gICBbZm9yY2luZ190YWddIHVzaW5nIGNvbXBhcmUtYW5kLXN3YXAgKENBUyksIHRha2luZyBjYXJlIHRvIGhhbmRsZSBjb25jdXJyZW50XG4gICBtYXJraW5nIG9mIHRoZSBoZWFkZXIgd29yZCBieSBhIGNvbmN1cnJlbnQgR0MgdGhyZWFkLiBSZXR1cm5zIFswXSBpZiB0aGVcbiAgIENBUyBpcyBzdWNjZXNzZnVsLiBJZiB0aGUgQ0FTIGZhaWxzLCB0aGVuIHRoZSB0YWcgd2FzIG9ic2VydmVkIHRvIGJlXG4gICBzb21ldGhpbmcgb3RoZXIgdGhhbiBbbGF6eV90YWddIGR1ZSB0byBhIGNvbmN1cnJlbnQgbXV0YXRvci4gSW4gdGhpcyBjYXNlLFxuICAgdGhlIGZ1bmN0aW9uIHJldHVybnMgWzFdLiAqKVxuZXh0ZXJuYWwgdXBkYXRlX3RvX2ZvcmNpbmcgOiBPYmoudCAtPiBpbnQgPVxuICBcImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZ1wiIFtAQG5vYWxsb2NdXG5cbigqIFtyZXNldF90b19sYXp5IGJsa10gZXhwZWN0cyBbYmxrXSB0byBiZSBhIGxhenkgb2JqZWN0IHdpdGggW09iai5mb3JjaW5nX3RhZ11cbiAgIGFuZCB1cGRhdGVzIHRoZSB0YWcgdG8gW09iai5sYXp5X3RhZ10sIHRha2luZyBjYXJlIHRvIGhhbmRsZSBjb25jdXJyZW50XG4gICBtYXJraW5nIG9mIHRoaXMgb2JqZWN0J3MgaGVhZGVyIGJ5IGEgY29uY3VycmVudCBHQyB0aHJlYWQuICopXG5leHRlcm5hbCByZXNldF90b19sYXp5IDogT2JqLnQgLT4gdW5pdCA9IFwiY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenlcIiBbQEBub2FsbG9jXVxuXG4oKiBbdXBkYXRlX3RvX2ZvcndhcmQgYmxrXSBleHBlY3RzIFtibGtdIHRvIGJlIGEgbGF6eSBvYmplY3Qgd2l0aFxuICAgW09iai5mb3JjaW5nX3RhZ10gYW5kIHVwZGF0ZXMgdGhlIHRhZyB0byBbT2JqLmZvcndhcmRfdGFnXSwgdGFraW5nIGNhcmUgdG9cbiAgIGhhbmRsZSBjb25jdXJyZW50IG1hcmtpbmcgb2YgdGhpcyBvYmplY3QncyBoZWFkZXIgYnkgYSBjb25jdXJyZW50IEdDIHRocmVhZC5cbiAqKVxuZXh0ZXJuYWwgdXBkYXRlX3RvX2ZvcndhcmQgOiBPYmoudCAtPiB1bml0ID1cbiAgXCJjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmRcIiBbQEBub2FsbG9jXVxuXG4oKiBBc3N1bWVzIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgZm9yY2luZyAqKVxubGV0IGRvX2ZvcmNlX2Jsb2NrIGJsayA9XG4gIGxldCBiID0gT2JqLnJlcHIgYmxrIGluXG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCBiIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgKCkpOyAoKiBSZWxlYXNlIHRoZSBjbG9zdXJlICopXG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgdXBkYXRlX3RvX2ZvcndhcmQgYjtcbiAgICByZXN1bHRcbiAgd2l0aCBlIC0+XG4gICAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJlc2V0X3RvX2xhenkgYjtcbiAgICByYWlzZSBlXG5cbigqIEFzc3VtZXMgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBmb3JjaW5nICopXG5sZXQgZG9fZm9yY2VfdmFsX2Jsb2NrIGJsayA9XG4gIGxldCBiID0gT2JqLnJlcHIgYmxrIGluXG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCBiIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgKCkpOyAoKiBSZWxlYXNlIHRoZSBjbG9zdXJlICopXG4gIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gIE9iai5zZXRfZmllbGQgYiAwIChPYmoucmVwciByZXN1bHQpO1xuICB1cGRhdGVfdG9fZm9yd2FyZCBiO1xuICByZXN1bHRcblxuKCogQ2FsbGVkIGJ5IFtmb3JjZV9nZW5dICopXG5sZXQgZm9yY2VfZ2VuX2xhenlfYmxvY2sgfm9ubHlfdmFsIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICAoKiBXZSBleHBlY3QgdGhlIHRhZyB0byBiZSBbbGF6eV90YWddLCBidXQgbWF5IGJlIG90aGVyIHRhZ3MgZHVlIHRvXG4gICAgIGNvbmN1cnJlbnQgZm9yY2luZyBvZiBsYXp5IHZhbHVlcy4gKilcbiAgbWF0Y2ggdXBkYXRlX3RvX2ZvcmNpbmcgKE9iai5yZXByIGJsaykgd2l0aFxuICB8IDAgd2hlbiBvbmx5X3ZhbCAtPiBkb19mb3JjZV92YWxfYmxvY2sgYmxrXG4gIHwgMCAtPiBkb19mb3JjZV9ibG9jayBibGtcbiAgfCBfIC0+IHJhaXNlIFVuZGVmaW5lZFxuXG4oKiB1c2VkIGluIHRoZSAlbGF6eV9mb3JjZSBwcmltaXRpdmUgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIGJsayA9IGZvcmNlX2dlbl9sYXp5X2Jsb2NrIH5vbmx5X3ZhbDpmYWxzZSBibGtcblxuKCogW2ZvcmNlX2dlbiB+b25seV92YWw6ZmFsc2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXNcbiAgIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0c1xuICAgYXJndW1lbnQsIGV4Y2VwdCB3aGVuIGFmbCBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxubGV0IGZvcmNlX2dlbiB+b25seV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0IGNvdWxkIGhhdmUgYmVlblxuICAgICAgIHNob3J0Y3V0IGR1cmluZyBHQywgc28gdGhhdCBpbmZvcm1hdGlvbiBtdXN0IGJlIGZvcmdvdHRlbiAoc2VlIEdQUiM3MTNcbiAgICAgICBhbmQgaXNzdWUgIzczMDEpLiBUaGlzIGlzIG5vdCBhbiBpc3N1ZSBoZXJlIGF0IHRoZSBtb21lbnQgc2luY2VcbiAgICAgICBbT2JqLnRhZ10gaXMgbm90IHNpbXBsaWZpZWQgYnkgdGhlIGNvbXBpbGVyLCBhbmQgR1BSIzcxMyBhbHNvXG4gICAgICAgZW5zdXJlcyB0aGF0IG5vIHZhbHVlIHdpbGwgYmUga25vd24gdG8gaGF2ZSBGb3J3YXJkX3RhZy5cbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gICgqIFNUQVJUIG5vIHNhZmUgcG9pbnRzLiBJZiBhIEdDIG9jY3VycyBoZXJlLCB0aGVuIHRoZSBvYmplY3QgW3hdIG1heSBiZVxuICAgICBzaG9ydC1jaXJjdWl0ZWQsIGFuZCBnZXR0aW5nIHRoZSBmaXJzdCBmaWVsZCBvZiBbeF0gd291bGQgZ2V0IHVzIHRoZSB3cm9uZ1xuICAgICB2YWx1ZS4gTHVja2lseSwgdGhlIGNvbXBpbGVyIGRvZXMgbm90IGluc2VydCBHQyBzYWZlIHBvaW50cyBhdCB0aGlzIHBsYWNlLFxuICAgICBzbyBpdCBpcyBvay4gKilcbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuXG4gICAgKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZylcbiAgKCogRU5EIG5vIHNhZmUgcG9pbnRzICopXG4gIGVsc2UgaWYgdCA9IE9iai5mb3JjaW5nX3RhZyB0aGVuIHJhaXNlIFVuZGVmaW5lZFxuICBlbHNlIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfZ2VuX2xhenlfYmxvY2sgfm9ubHlfdmFsIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWxpbnRlcm5hbExhenkudFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5leHRlcm5hbCBmb3JjZSA6ICdhIHQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxubGV0IGZvcmNlX3ZhbCBsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV9nZW4gfm9ubHlfdmFsOnRydWUgbFxuXG5sZXQgZnJvbV9mdW4gKGYgOiB1bml0IC0+ICdhcmcpID1cbiAgbGV0IHggPSBPYmoubmV3X2Jsb2NrIE9iai5sYXp5X3RhZyAxIGluXG4gIE9iai5zZXRfZmllbGQgeCAwIChPYmoucmVwciBmKTtcbiAgKE9iai5vYmogeCA6ICdhcmcgdClcblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fFxuICAgICB0ID0gT2JqLmZvcmNpbmdfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbWFwIGYgeCA9XG4gIGxhenkgKGYgKGZvcmNlIHgpKVxuXG5sZXQgbWFwX3ZhbCBmIHggPVxuICBpZiBpc192YWwgeFxuICB0aGVuIGZyb21fdmFsIChmIChmb3JjZSB4KSlcbiAgZWxzZSBsYXp5IChmIChmb3JjZSB4KSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggbmV4dCAoKSA9IENvbnMgKHgsIG5leHQpXG5cbmxldCByZWMgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIG1hdGNoIHNlcTEoKSB3aXRoXG4gIHwgTmlsIC0+IHNlcTIoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKHgsIGFwcGVuZCBuZXh0IHNlcTIpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGNvbmNhdCBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICBhcHBlbmQgeCAoY29uY2F0IG5leHQpICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGFwcGVuZCAoZiB4KSAoZmxhdF9tYXAgZiBuZXh0KSAoKVxuXG5sZXQgY29uY2F0X21hcCA9IGZsYXRfbWFwXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBmb2xkX2xlZnQgZiBhY2MgbmV4dFxuXG5sZXQgcmVjIGl0ZXIgZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBmIHg7XG4gICAgICAgIGl0ZXIgZiBuZXh0XG5cbmxldCByZWMgdW5mb2xkIGYgdSAoKSA9XG4gIG1hdGNoIGYgdSB3aXRoXG4gIHwgTm9uZSAtPiBOaWxcbiAgfCBTb21lICh4LCB1JykgLT4gQ29ucyAoeCwgdW5mb2xkIGYgdScpXG5cbmxldCBpc19lbXB0eSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKF8sIF8pIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgdW5jb25zIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBTb21lICh4LCB4cylcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcblxuXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBhY2N1IHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBhY2N1XG4gIHwgQ29ucyAoXywgeHMpIC0+XG4gICAgICBsZW5ndGhfYXV4IChhY2N1ICsgMSkgeHNcblxubGV0W0BpbmxpbmVdIGxlbmd0aCB4cyA9XG4gIGxlbmd0aF9hdXggMCB4c1xuXG5sZXQgcmVjIGl0ZXJpX2F1eCBmIGkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgICgpXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBmIGkgeDtcbiAgICAgIGl0ZXJpX2F1eCBmIChpKzEpIHhzXG5cbmxldFtAaW5saW5lXSBpdGVyaSBmIHhzID1cbiAgaXRlcmlfYXV4IGYgMCB4c1xuXG5sZXQgcmVjIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSBpIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBhY2N1XG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBsZXQgYWNjdSA9IGYgYWNjdSBpIHggaW5cbiAgICAgIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSAoaSsxKSB4c1xuXG5sZXRbQGlubGluZV0gZm9sZF9sZWZ0aSBmIGFjY3UgeHMgPVxuICBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgMCB4c1xuXG5sZXQgcmVjIGZvcl9hbGwgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgcCB4ICYmIGZvcl9hbGwgcCB4c1xuXG5sZXQgcmVjIGV4aXN0cyBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBmYWxzZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgcCB4IHx8IGV4aXN0cyBwIHhzXG5cbmxldCByZWMgZmluZCBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOb25lXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kIHAgeHNcblxubGV0IGZpbmRfaW5kZXggcCB4cyA9XG4gIGxldCByZWMgYXV4IGkgeHMgPSBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgaWYgcCB4IHRoZW4gU29tZSBpIGVsc2UgYXV4IChpKzEpIHhzIGluXG4gIGF1eCAwIHhzXG5cbmxldCByZWMgZmluZF9tYXAgZiB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGZpbmRfbWFwIGYgeHNcbiAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc3VsdFxuXG5sZXQgZmluZF9tYXBpIGYgeHMgPVxuICBsZXQgcmVjIGF1eCBpIHhzID0gbWF0Y2ggeHMoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBhdXggKGkrMSkgeHNcbiAgICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgICByZXN1bHQgaW5cbiAgYXV4IDAgeHNcblxuKCogW2l0ZXIyXSwgW2ZvbGRfbGVmdDJdLCBbZm9yX2FsbDJdLCBbZXhpc3RzMl0sIFttYXAyXSwgW3ppcF0gd29yayBhbHNvIGluXG4gICB0aGUgY2FzZSB3aGVyZSB0aGUgdHdvIHNlcXVlbmNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzLiBUaGV5IHN0b3AgYXMgc29vblxuICAgYXMgb25lIHNlcXVlbmNlIGlzIGV4aGF1c3RlZC4gVGhlaXIgYmVoYXZpb3IgaXMgc2xpZ2h0bHkgYXN5bW1ldHJpYzogd2hlblxuICAgW3hzXSBpcyBlbXB0eSwgdGhleSBkbyBub3QgZm9yY2UgW3lzXTsgaG93ZXZlciwgd2hlbiBbeXNdIGlzIGVtcHR5LCBbeHNdIGlzXG4gICBmb3JjZWQsIGV2ZW4gdGhvdWdoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIFt4cygpXSB0dXJucyBvdXRcbiAgIHRvIGJlIHVzZWxlc3MuICopXG5cbmxldCByZWMgaXRlcjIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeTtcbiAgICAgICAgICBpdGVyMiBmIHhzIHlzXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBhY2N1XG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGxldCBhY2N1ID0gZiBhY2N1IHggeSBpblxuICAgICAgICAgIGZvbGRfbGVmdDIgZiBhY2N1IHhzIHlzXG5cbmxldCByZWMgZm9yX2FsbDIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgZiB4IHkgJiYgZm9yX2FsbDIgZiB4cyB5c1xuXG5sZXQgcmVjIGV4aXN0czIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSB8fCBleGlzdHMyIGYgeHMgeXNcblxubGV0IHJlYyBlcXVhbCBlcSB4cyB5cyA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICB8IE5pbCwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpLCBDb25zICh5LCB5cykgLT5cbiAgICAgIGVxIHggeSAmJiBlcXVhbCBlcSB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXylcbiAgfCBDb25zIChfLCBfKSwgTmlsIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIDBcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgbGV0IGMgPSBjbXAgeCB5IGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSBjbXAgeHMgeXNcbiAgfCBOaWwsIENvbnMgKF8sIF8pIC0+XG4gICAgICAtMVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgICsxXG5cblxuXG4oKiBbaW5pdF9hdXggZiBpIGpdIGlzIHRoZSBzZXF1ZW5jZSBbZiBpLCAuLi4sIGYgKGotMSldLiAqKVxuXG5sZXQgcmVjIGluaXRfYXV4IGYgaSBqICgpID1cbiAgaWYgaSA8IGogdGhlbiBiZWdpblxuICAgIENvbnMgKGYgaSwgaW5pdF9hdXggZiAoaSArIDEpIGopXG4gIGVuZFxuICBlbHNlXG4gICAgTmlsXG5cbmxldCBpbml0IG4gZiA9XG4gIGlmIG4gPCAwIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlNlcS5pbml0XCJcbiAgZWxzZVxuICAgIGluaXRfYXV4IGYgMCBuXG5cbmxldCByZWMgcmVwZWF0IHggKCkgPVxuICBDb25zICh4LCByZXBlYXQgeClcblxubGV0IHJlYyBmb3JldmVyIGYgKCkgPVxuICBDb25zIChmKCksIGZvcmV2ZXIgZilcblxuKCogVGhpcyBwcmVsaW1pbmFyeSBkZWZpbml0aW9uIG9mIFtjeWNsZV0gcmVxdWlyZXMgdGhlIHNlcXVlbmNlIFt4c11cbiAgIHRvIGJlIG5vbmVtcHR5LiBBcHBseWluZyBpdCB0byBhbiBlbXB0eSBzZXF1ZW5jZSB3b3VsZCBwcm9kdWNlIGFcbiAgIHNlcXVlbmNlIHRoYXQgZGl2ZXJnZXMgd2hlbiBpdCBpcyBmb3JjZWQuICopXG5cbmxldCByZWMgY3ljbGVfbm9uZW1wdHkgeHMgKCkgPVxuICBhcHBlbmQgeHMgKGN5Y2xlX25vbmVtcHR5IHhzKSAoKVxuXG4oKiBbY3ljbGUgeHNdIGNoZWNrcyB3aGV0aGVyIFt4c10gaXMgZW1wdHkgYW5kLCBpZiBzbywgcmV0dXJucyBhbiBlbXB0eVxuICAgc2VxdWVuY2UuIE90aGVyd2lzZSwgW2N5Y2xlIHhzXSBwcm9kdWNlcyBvbmUgY29weSBvZiBbeHNdIGZvbGxvd2VkXG4gICB3aXRoIHRoZSBpbmZpbml0ZSBzZXF1ZW5jZSBbY3ljbGVfbm9uZW1wdHkgeHNdLiBUaHVzLCB0aGUgbm9uZW1wdGluZXNzXG4gICBjaGVjayBpcyBwZXJmb3JtZWQganVzdCBvbmNlLiAqKVxuXG5sZXQgY3ljbGUgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzJykgLT5cbiAgICAgIENvbnMgKHgsIGFwcGVuZCB4cycgKGN5Y2xlX25vbmVtcHR5IHhzKSlcblxuKCogW2l0ZXJhdGUxIGYgeF0gaXMgdGhlIHNlcXVlbmNlIFtmIHgsIGYgKGYgeCksIC4uLl0uXG4gICBJdCBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChpdGVyYXRlIGYgeCldLlxuICAgW2l0ZXJhdGUxXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIGl0ZXJhdGUxIGYgeCAoKSA9XG4gIGxldCB5ID0gZiB4IGluXG4gIENvbnMgKHksIGl0ZXJhdGUxIGYgeSlcblxuKCogW2l0ZXJhdGUgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW3gsIGYgeCwgLi4uXS4gKilcblxuKCogVGhlIHJlYXNvbiB3aHkgd2UgZ2l2ZSB0aGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLFxuICAgYXMgb3Bwb3NlZCB0byB0aGUgbW9yZSBuYWl2ZSBkZWZpbml0aW9uIHRoYXQgbWF5IGNvbWUgdG8gbWluZCwgaXMgdGhhdFxuICAgd2UgYXJlIGNhcmVmdWwgdG8gYXZvaWQgZXZhbHVhdGluZyBbZiB4XSB1bnRpbCB0aGlzIGZ1bmN0aW9uIGNhbGwgaXNcbiAgIGFjdHVhbGx5IG5lY2Vzc2FyeS4gVGhlIG5haXZlIGRlZmluaXRpb24gKG5vdCBzaG93biBoZXJlKSBjb21wdXRlcyB0aGVcbiAgIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgc2VxdWVuY2UsIFtmIHhdLCB3aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuICAgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLiAqKVxuXG5sZXQgaXRlcmF0ZSBmIHggPVxuICBjb25zIHggKGl0ZXJhdGUxIGYgeClcblxuXG5cbmxldCByZWMgbWFwaV9hdXggZiBpIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKGYgaSB4LCBtYXBpX2F1eCBmIChpKzEpIHhzKVxuXG5sZXRbQGlubGluZV0gbWFwaSBmIHhzID1cbiAgbWFwaV9hdXggZiAwIHhzXG5cbigqIFt0YWlsX3NjYW4gZiBzIHhzXSBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChzY2FuIGYgcyB4cyldLlxuICAgW3RhaWxfc2Nhbl0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtzY2FuXS4gKilcblxuKCogVGhpcyBzbGlnaHRseSBpbmRpcmVjdCBkZWZpbml0aW9uIG9mIFtzY2FuXSBpcyBtZWFudCB0byBhdm9pZCBjb21wdXRpbmdcbiAgIGVsZW1lbnRzIHRvbyBlYXJseTsgc2VlIHRoZSBhYm92ZSBjb21tZW50IGFib3V0IFtpdGVyYXRlMV0gYW5kIFtpdGVyYXRlXS4gKilcblxubGV0IHJlYyB0YWlsX3NjYW4gZiBzIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBzID0gZiBzIHggaW5cbiAgICAgIENvbnMgKHMsIHRhaWxfc2NhbiBmIHMgeHMpXG5cbmxldCBzY2FuIGYgcyB4cyA9XG4gIGNvbnMgcyAodGFpbF9zY2FuIGYgcyB4cylcblxuKCogW3Rha2VdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFt0YWtlIDAgeHNdIHJldHVybnMgW2VtcHR5XVxuICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgcmVjIHRha2VfYXV4IG4geHMgPVxuICBpZiBuID0gMCB0aGVuXG4gICAgZW1wdHlcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgICBDb25zICh4LCB0YWtlX2F1eCAobi0xKSB4cylcblxubGV0IHRha2UgbiB4cyA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTZXEudGFrZVwiO1xuICB0YWtlX2F1eCBuIHhzXG5cbigqIFtmb3JjZV9kcm9wIG4geHNdIGlzIGVxdWl2YWxlbnQgdG8gW2Ryb3AgbiB4cyAoKV0uXG4gICBbZm9yY2VfZHJvcCBuIHhzXSByZXF1aXJlcyBbbiA+IDBdLlxuICAgW2ZvcmNlX2Ryb3BdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbZHJvcF0uICopXG5cbmxldCByZWMgZm9yY2VfZHJvcCBuIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxldCBuID0gbiAtIDEgaW5cbiAgICAgIGlmIG4gPSAwIHRoZW5cbiAgICAgICAgeHMoKVxuICAgICAgZWxzZVxuICAgICAgICBmb3JjZV9kcm9wIG4geHNcblxuKCogW2Ryb3BdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFtkcm9wIDAgeHNdIHJldHVybnMgW3hzXSBpbW1lZGlhdGVseSxcbiAgIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgZHJvcCBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS5kcm9wXCJcbiAgZWxzZSBpZiBuID0gMCB0aGVuXG4gICAgeHNcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgZm9yY2VfZHJvcCBuIHhzXG5cbmxldCByZWMgdGFrZV93aGlsZSBwIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIENvbnMgKHgsIHRha2Vfd2hpbGUgcCB4cykgZWxzZSBOaWxcblxubGV0IHJlYyBkcm9wX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSBhcyBub2RlIC0+XG4gICAgICBpZiBwIHggdGhlbiBkcm9wX3doaWxlIHAgeHMgKCkgZWxzZSBub2RlXG5cbmxldCByZWMgZ3JvdXAgZXEgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoY29ucyB4ICh0YWtlX3doaWxlIChlcSB4KSB4cyksIGdyb3VwIGVxIChkcm9wX3doaWxlIChlcSB4KSB4cykpXG5cbmV4Y2VwdGlvbiBGb3JjZWRfdHdpY2VcblxubW9kdWxlIFN1c3BlbnNpb24gPSBzdHJ1Y3RcblxuICB0eXBlICdhIHN1c3BlbnNpb24gPVxuICAgIHVuaXQgLT4gJ2FcblxuICAoKiBDb252ZXJzaW9ucy4gKilcblxuICBsZXQgdG9fbGF6eSA6ICdhIHN1c3BlbnNpb24gLT4gJ2EgTGF6eS50ID1cbiAgICBMYXp5LmZyb21fZnVuXG4gICAgKCogZnVuIHMgLT4gbGF6eSAocygpKSAqKVxuXG4gIGxldCBmcm9tX2xhenkgKHMgOiAnYSBMYXp5LnQpIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+IExhenkuZm9yY2Ugc1xuXG4gICgqIFttZW1vaXplXSB0dXJucyBhbiBhcmJpdHJhcnkgc3VzcGVuc2lvbiBpbnRvIGEgcGVyc2lzdGVudCBzdXNwZW5zaW9uLiAqKVxuXG4gIGxldCBtZW1vaXplIChzIDogJ2Egc3VzcGVuc2lvbikgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmcm9tX2xhenkgKHRvX2xhenkgcylcblxuICAoKiBbZmFpbHVyZV0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgZmFpbHMgd2hlbiBmb3JjZWQuICopXG5cbiAgbGV0IGZhaWx1cmUgOiBfIHN1c3BlbnNpb24gPVxuICAgIGZ1biAoKSAtPlxuICAgICAgKCogQSBzdXNwZW5zaW9uIGNyZWF0ZWQgYnkgW29uY2VdIGhhcyBiZWVuIGZvcmNlZCB0d2ljZS4gKilcbiAgICAgIHJhaXNlIEZvcmNlZF90d2ljZVxuXG4gICgqIElmIFtmXSBpcyBhIHN1c3BlbnNpb24sIHRoZW4gW29uY2UgZl0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgY2FuIGJlIGZvcmNlZFxuICAgICBhdCBtb3N0IG9uY2UuIElmIGl0IGlzIGZvcmNlZCBtb3JlIHRoYW4gb25jZSwgdGhlbiBbRm9yY2VkX3R3aWNlXSBpc1xuICAgICByYWlzZWQuICopXG5cbiAgbGV0IG9uY2UgKGYgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGxldCBhY3Rpb24gPSBBdG9taWMubWFrZSBmIGluXG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBHZXQgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBzdG9yZWQgaW4gW2FjdGlvbl0sIGFuZCB3cml0ZSB0aGVcbiAgICAgICAgIGZ1bmN0aW9uIFtmYWlsdXJlXSBpbiBpdHMgcGxhY2UsIHNvIHRoZSBuZXh0IGFjY2VzcyB3aWxsIHJlc3VsdFxuICAgICAgICAgaW4gYSBjYWxsIHRvIFtmYWlsdXJlKCldLiAqKVxuICAgICAgbGV0IGYgPSBBdG9taWMuZXhjaGFuZ2UgYWN0aW9uIGZhaWx1cmUgaW5cbiAgICAgIGYoKVxuXG5lbmQgKCogU3VzcGVuc2lvbiAqKVxuXG5sZXQgcmVjIG1lbW9pemUgeHMgPVxuICBTdXNwZW5zaW9uLm1lbW9pemUgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG1lbW9pemUgeHMpXG4gIClcblxubGV0IHJlYyBvbmNlIHhzID1cbiAgU3VzcGVuc2lvbi5vbmNlIChmdW4gKCkgLT5cbiAgICBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICBDb25zICh4LCBvbmNlIHhzKVxuICApXG5cblxubGV0IHJlYyB6aXAgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zICgoeCwgeSksIHppcCB4cyB5cylcblxubGV0IHJlYyBtYXAyIGYgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zIChmIHggeSwgbWFwMiBmIHhzIHlzKVxuXG5sZXQgcmVjIGludGVybGVhdmUgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHlzKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKHgsIGludGVybGVhdmUgeXMgeHMpXG5cbigqIFtzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSB5c10uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCB4cyAoY29ucyB5IHlzKV0uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgW3NvcnRlZF9tZXJnZSBjbXAgKGNvbnMgeCB4cykgKGNvbnMgeSB5cyldLlxuXG4gICBUaGVzZSB0aHJlZSBmdW5jdGlvbnMgYXJlIHVzZWQgYXMgYnVpbGRpbmcgYmxvY2tzIGluIHRoZSBkZWZpbml0aW9uXG4gICBvZiBbc29ydGVkX21lcmdlXS4gKilcblxubGV0IHJlYyBzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5cyAoKSA9XG4gIG1hdGNoIHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgQ29ucyAoeCwgeHMpXG4gIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuYW5kIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh5LCB5cylcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzID1cbiAgaWYgY21wIHggeSA8PSAwIHRoZW5cbiAgICBDb25zICh4LCBzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5cylcbiAgZWxzZVxuICAgIENvbnMgKHksIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzKVxuXG5sZXQgc29ydGVkX21lcmdlIGNtcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICAgIHwgTmlsLCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBOaWwsIGNcbiAgICB8IGMsIE5pbCAtPlxuICAgICAgICBjXG4gICAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuXG5sZXQgcmVjIG1hcF9mc3QgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKHgsIF8pLCB4eXMpIC0+XG4gICAgICBDb25zICh4LCBtYXBfZnN0IHh5cylcblxubGV0IHJlYyBtYXBfc25kIHh5cyAoKSA9XG4gIG1hdGNoIHh5cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKChfLCB5KSwgeHlzKSAtPlxuICAgICAgQ29ucyAoeSwgbWFwX3NuZCB4eXMpXG5cbmxldCB1bnppcCB4eXMgPVxuICBtYXBfZnN0IHh5cywgbWFwX3NuZCB4eXNcblxubGV0IHNwbGl0ID1cbiAgdW56aXBcblxuKCogW2ZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzXSBpcyBlcXVpdmFsZW50IHRvXG4gICBbZmlsdGVyX21hcCBFaXRoZXIuZmluZF9sZWZ0IChtYXAgZiB4cyldLiAqKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IHkgLT5cbiAgICAgICAgICBDb25zICh5LCBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cylcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyAoKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBFaXRoZXIuTGVmdCBfIC0+XG4gICAgICAgICAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpXG4gICAgICB8IEVpdGhlci5SaWdodCB6IC0+XG4gICAgICAgICAgQ29ucyAoeiwgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzKVxuXG5sZXQgcGFydGl0aW9uX21hcCBmIHhzID1cbiAgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMsXG4gIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4c1xuXG5sZXQgcGFydGl0aW9uIHAgeHMgPVxuICBmaWx0ZXIgcCB4cywgZmlsdGVyIChmdW4geCAtPiBub3QgKHAgeCkpIHhzXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtwZWVsIHhzc10gaXMgYSBwYWlyIG9mXG4gICB0aGUgZmlyc3QgY29sdW1uIChhIHNlcXVlbmNlIG9mIGVsZW1lbnRzKSBhbmQgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIG1hdHJpeCAoYSBzZXF1ZW5jZSBvZiBzaG9ydGVyIHJvd3MpLiBUaGVzZSB0d28gc2VxdWVuY2VzIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gQW4gZW1wdHkgcm93IGlzIGlnbm9yZWQuICopXG5cbigqIEJlY2F1c2UgW3BlZWxdIHVzZXMgW3VuemlwXSwgaXRzIGFyZ3VtZW50IG11c3QgYmUgcGVyc2lzdGVudC4gVGhlIHNhbWVcbiAgIHJlbWFyayBhcHBsaWVzIHRvIFt0cmFuc3Bvc2VdLCBbZGlhZ29uYWxzXSwgW3Byb2R1Y3RdLCBldGMuICopXG5cbmxldCBwZWVsIHhzcyA9XG4gIHVuemlwIChmaWx0ZXJfbWFwIHVuY29ucyB4c3MpXG5cbmxldCByZWMgdHJhbnNwb3NlIHhzcyAoKSA9XG4gIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHhzcyBpblxuICBpZiBpc19lbXB0eSBoZWFkcyB0aGVuIGJlZ2luXG4gICAgYXNzZXJ0IChpc19lbXB0eSB0YWlscyk7XG4gICAgTmlsXG4gIGVuZFxuICBlbHNlXG4gICAgQ29ucyAoaGVhZHMsIHRyYW5zcG9zZSB0YWlscylcblxuKCogVGhlIGludGVybmFsIGZ1bmN0aW9uIFtkaWFnb25hbHNdIHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50LCBbcmVtYWluZGVyc10sXG4gICB3aGljaCBjb250YWlucyB0aGUgcmVtYWluZGVycyBvZiB0aGUgcm93cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuXG4gICBkaXNjb3ZlcmVkLiAqKVxuXG5sZXQgcmVjIGRpYWdvbmFscyByZW1haW5kZXJzIHhzcyAoKSA9XG4gIG1hdGNoIHhzcygpIHdpdGhcbiAgfCBDb25zICh4cywgeHNzKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IG5vbmVtcHR5IHJvdyBbeCA6OiB4c10uIFRodXMsIHRoZSBuZXh0IGRpYWdvbmFsXG4gICAgICAgICAgICAgaXMgW3ggOjogaGVhZHNdOiB0aGlzIGRpYWdvbmFsIGJlZ2lucyB3aXRoIFt4XSBhbmQgY29udGludWVzIHdpdGhcbiAgICAgICAgICAgICB0aGUgZmlyc3QgZWxlbWVudCBvZiBldmVyeSByb3cgaW4gW3JlbWFpbmRlcnNdLiBJbiB0aGUgcmVjdXJzaXZlXG4gICAgICAgICAgICAgY2FsbCwgdGhlIGFyZ3VtZW50IFtyZW1haW5kZXJzXSBpcyBpbnN0YW50aWF0ZWQgd2l0aCBbeHMgOjpcbiAgICAgICAgICAgICB0YWlsc10sIHdoaWNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LCBbeHNdLFxuICAgICAgICAgICAgIGFuZCB0aGF0IHdlIGtlZXAgdGhlIHRhaWxzIG9mIHRoZSBwcmUtZXhpc3RpbmcgcmVtYWluaW5nIHJvd3MuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGNvbnMgeCBoZWFkcywgZGlhZ29uYWxzIChjb25zIHhzIHRhaWxzKSB4c3MpXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IGVtcHR5IHJvdy4gSW4gdGhpcyBjYXNlLCB0aGUgbmV3IGRpYWdvbmFsIGlzXG4gICAgICAgICAgICAganVzdCBbaGVhZHNdLCBhbmQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIGp1c3QgW3RhaWxzXSxcbiAgICAgICAgICAgICBhcyB3ZSBkbyBub3QgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LiAqKVxuICAgICAgICAgIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHJlbWFpbmRlcnMgaW5cbiAgICAgICAgICBDb25zIChoZWFkcywgZGlhZ29uYWxzIHRhaWxzIHhzcylcbiAgICAgIGVuZFxuICB8IE5pbCAtPlxuICAgICAgKCogVGhlcmUgYXJlIG5vIG1vcmUgcm93cyB0byBiZSBkaXNjb3ZlcmVkLiBUaGVyZSByZW1haW5zIHRvIGV4aGF1c3RcbiAgICAgICAgIHRoZSByZW1haW5pbmcgcm93cy4gKilcbiAgICAgIHRyYW5zcG9zZSByZW1haW5kZXJzICgpXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtkaWFnb25hbHMgeHNzXSBpc1xuICAgdGhlIHNlcXVlbmNlIG9mIGl0cyBkaWFnb25hbHMuXG5cbiAgIFRoZSBmaXJzdCBkaWFnb25hbCBjb250YWlucyBqdXN0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgZmlyc3Qgcm93LiBUaGUgc2Vjb25kIGRpYWdvbmFsIGNvbnRhaW5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgc2Vjb25kIHJvdyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBmaXJzdCByb3c7IGFuZCBzbyBvbi5cbiAgIFRoaXMga2luZCBvZiBkaWFnb25hbCBpcyBpbiBmYWN0IHNvbWV0aW1lcyBrbm93biBhcyBhbiBhbnRpZGlhZ29uYWwuXG5cbiAgIC0gRXZlcnkgZGlhZ29uYWwgaXMgYSBmaW5pdGUgc2VxdWVuY2UuXG4gICAtIFRoZSByb3dzIG9mIHRoZSBtYXRyaXggW3hzc10gYXJlIG5vdCByZXF1aXJlZCB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBpcyBub3QgcmVxdWlyZWQgdG8gYmUgZmluaXRlIChpbiBlaXRoZXIgZGlyZWN0aW9uKS5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBtdXN0IGJlIHBlcnNpc3RlbnQuICopXG5cbmxldCBkaWFnb25hbHMgeHNzID1cbiAgZGlhZ29uYWxzIGVtcHR5IHhzc1xuXG5sZXQgbWFwX3Byb2R1Y3QgZiB4cyB5cyA9XG4gIGNvbmNhdCAoZGlhZ29uYWxzIChcbiAgICBtYXAgKGZ1biB4IC0+XG4gICAgICBtYXAgKGZ1biB5IC0+XG4gICAgICAgIGYgeCB5XG4gICAgICApIHlzXG4gICAgKSB4c1xuICApKVxuXG5sZXQgcHJvZHVjdCB4cyB5cyA9XG4gIG1hcF9wcm9kdWN0IChmdW4geCB5IC0+ICh4LCB5KSkgeHMgeXNcblxubGV0IG9mX2Rpc3BlbnNlciBpdCA9XG4gIGxldCByZWMgYyAoKSA9XG4gICAgbWF0Y2ggaXQoKSB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5pbFxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIENvbnMgKHgsIGMpXG4gIGluXG4gIGNcblxubGV0IHRvX2Rpc3BlbnNlciB4cyA9XG4gIGxldCBzID0gcmVmIHhzIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICghcykoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIHMgOj0geHM7XG4gICAgICAgIFNvbWUgeFxuXG5cblxubGV0IHJlYyBpbnRzIGkgKCkgPVxuICBDb25zIChpLCBpbnRzIChpICsgMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhXG5cbmxldCBub25lID0gTm9uZVxubGV0IHNvbWUgdiA9IFNvbWUgdlxubGV0IHZhbHVlIG8gfmRlZmF1bHQgPSBtYXRjaCBvIHdpdGggU29tZSB2IC0+IHYgfCBOb25lIC0+IGRlZmF1bHRcbmxldCBnZXQgPSBmdW5jdGlvbiBTb21lIHYgLT4gdiB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJvcHRpb24gaXMgTm9uZVwiXG5sZXQgYmluZCBvIGYgPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IGYgdlxubGV0IGpvaW4gPSBmdW5jdGlvbiBTb21lIG8gLT4gbyB8IE5vbmUgLT4gTm9uZVxubGV0IG1hcCBmIG8gPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IFNvbWUgKGYgdilcbmxldCBmb2xkIH5ub25lIH5zb21lID0gZnVuY3Rpb24gU29tZSB2IC0+IHNvbWUgdiB8IE5vbmUgLT4gbm9uZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBmIHYgfCBOb25lIC0+ICgpXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gdHJ1ZSB8IFNvbWUgXyAtPiBmYWxzZVxubGV0IGlzX3NvbWUgPSBmdW5jdGlvbiBOb25lIC0+IGZhbHNlIHwgU29tZSBfIC0+IHRydWVcblxubGV0IGVxdWFsIGVxIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBlcSB2MCB2MVxufCBOb25lLCBOb25lIC0+IHRydWVcbnwgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSBjbXAgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGNtcCB2MCB2MVxufCBOb25lLCBOb25lIC0+IDBcbnwgTm9uZSwgU29tZSBfIC0+IC0xXG58IFNvbWUgXywgTm9uZSAtPiAxXG5cbmxldCB0b19yZXN1bHQgfm5vbmUgPSBmdW5jdGlvbiBOb25lIC0+IEVycm9yIG5vbmUgfCBTb21lIHYgLT4gT2sgdlxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE5vbmUgLT4gU2VxLmVtcHR5IHwgU29tZSB2IC0+IFNlcS5yZXR1cm4gdlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gYm9vbCA9IGZhbHNlIHwgdHJ1ZVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5sZXQgZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9faW50IDogYm9vbCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuXG4oKiBVVEYgY29kZWNzIHRvb2xzICopXG5cbnR5cGUgdXRmX2RlY29kZSA9IGludFxuKCogVGhpcyBpcyBhbiBpbnQgWzB4RFVVVVVVVV0gZGVjb21wb3NlZCBhcyBmb2xsb3dzOlxuICAgLSBbRF0gaXMgZm91ciBiaXRzIGZvciBkZWNvZGUgaW5mb3JtYXRpb24sIHRoZSBoaWdoZXN0IGJpdCBpcyBzZXQgaWYgdGhlXG4gICAgIGRlY29kZSBpcyB2YWxpZC4gVGhlIHRocmVlIGxvd2VyIGJpdHMgaW5kaWNhdGUgdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgICBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlIGNvbnN1bWVkIGJ5IHRoZSBkZWNvZGUuXG4gICAtIFtVVVVVVVVdIGlzIHRoZSBkZWNvZGVkIFVuaWNvZGUgY2hhcmFjdGVyIG9yIHRoZSBVbmljb2RlIHJlcGxhY2VtZW50XG4gICAgIGNoYXJhY3RlciBVK0ZGRkQgaWYgZm9yIGludmFsaWQgZGVjb2Rlcy4gKilcblxubGV0IHZhbGlkX2JpdCA9IDI3XG5sZXQgZGVjb2RlX2JpdHMgPSAyNFxuXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pc192YWxpZCBkID0gKGQgbHNyIHZhbGlkX2JpdCkgPSAxXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9sZW5ndGggZCA9IChkIGxzciBkZWNvZGVfYml0cykgbGFuZCAwYjExMVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfdWNoYXIgZCA9IHVuc2FmZV9vZl9pbnQgKGQgbGFuZCAweEZGRkZGRilcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlIG4gdSA9ICgoOCBsb3IgbikgbHNsIGRlY29kZV9iaXRzKSBsb3IgKHRvX2ludCB1KVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfaW52YWxpZCBuID0gKG4gbHNsIGRlY29kZV9iaXRzKSBsb3IgcmVwXG5cbmxldCB1dGZfOF9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4MDA3RiAtPiAxXG58IHUgd2hlbiB1IDw9IDB4MDdGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAzXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHV0Zl8xNl9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGluaXQgaSBsYXN0IGYgPVxuICBpZiBpID4gbGFzdCB0aGVuIFtdXG4gIGVsc2UgaWYgaSA9IGxhc3QgdGhlbiBbZiBpXVxuICBlbHNlXG4gICAgbGV0IHIxID0gZiBpIGluXG4gICAgbGV0IHIyID0gZiAoaSsxKSBpblxuICAgIHIxIDo6IHIyIDo6IGluaXQgKGkrMikgbGFzdCBmXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpbml0IDAgKGxlbiAtIDEpIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBbYTFdIC0+XG4gICAgICBsZXQgcjEgPSBmIGExIGluXG4gICAgICBbcjFdXG4gIHwgYTE6OmEyOjpsIC0+XG4gICAgICBsZXQgcjEgPSBmIGExIGluXG4gICAgICBsZXQgcjIgPSBmIGEyIGluXG4gICAgICByMTo6cjI6Om1hcCBmIGxcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgW2ExXSAtPlxuICAgICAgbGV0IHIxID0gZiBpIGExIGluXG4gICAgICBbcjFdXG4gIHwgYTE6OmEyOjpsIC0+XG4gICAgICBsZXQgcjEgPSBmIGkgYTEgaW5cbiAgICAgIGxldCByMiA9IGYgKGkrMSkgYTIgaW5cbiAgICAgIHIxOjpyMjo6bWFwaSAoaSsyKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoW2ExXSwgW2IxXSkgLT5cbiAgICAgIGxldCByMSA9IGYgYTEgYjEgaW5cbiAgICAgIFtyMV1cbiAgfCAoYTE6OmEyOjpsMSwgYjE6OmIyOjpsMikgLT5cbiAgICAgIGxldCByMSA9IGYgYTEgYjEgaW5cbiAgICAgIGxldCByMiA9IGYgYTIgYjIgaW5cbiAgICAgIHIxOjpyMjo6bWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCBmaW5kX2luZGV4IHAgPVxuICBsZXQgcmVjIGF1eCBpID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIHAgYSB0aGVuIFNvbWUgaSBlbHNlIGF1eCAoaSsxKSBsIGluXG4gIGF1eCAwXG5cbmxldCByZWMgZmluZF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgZiBsXG4gICAgIGVuZFxuXG5sZXQgZmluZF9tYXBpIGYgPVxuICBsZXQgcmVjIGF1eCBpID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGF1eCAoaSsxKSBsXG4gICAgIGVuZCBpblxuICBhdXggMFxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaW5kX2FsbCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IDo6IGZpbmRfYWxsIHAgbCBlbHNlIGZpbmRfYWxsIHAgbFxuXG5sZXQgZmlsdGVyID0gZmluZF9hbGxcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgZmlsdGVyaSBwIGkgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgeDo6bCAtPlxuICAgICAgbGV0IGknID0gaSArIDEgaW5cbiAgICAgIGlmIHAgaSB4IHRoZW4geCA6OiBmaWx0ZXJpIHAgaScgbCBlbHNlIGZpbHRlcmkgcCBpJyBsXG5cbmxldCBmaWx0ZXJpIHAgbCA9IGZpbHRlcmkgcCAwIGxcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IHggOjogbCAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbFxuICAgICAgfCBTb21lIHYgLT4gdiA6OiBmaWx0ZXJfbWFwIGYgbFxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBjb25jYXRfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgeDo6eHMgLT4gcHJlcGVuZF9jb25jYXRfbWFwIChmIHgpIGYgeHNcbmFuZFtAdGFpbF9tb2RfY29uc10gcHJlcGVuZF9jb25jYXRfbWFwIHlzIGYgeHMgPVxuICBtYXRjaCB5cyB3aXRoXG4gIHwgW10gLT4gY29uY2F0X21hcCBmIHhzXG4gIHwgeSA6OiB5cyAtPiB5IDo6IHByZXBlbmRfY29uY2F0X21hcCB5cyBmIHhzXG5cbmxldCBmb2xkX2xlZnRfbWFwIGYgYWNjdSBsID1cbiAgbGV0IHJlYyBhdXggYWNjdSBsX2FjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdSwgcmV2IGxfYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIGxldCBhY2N1LCB4ID0gZiBhY2N1IHggaW5cbiAgICAgICAgYXV4IGFjY3UgKHggOjogbF9hY2N1KSBsIGluXG4gIGF1eCBhY2N1IFtdIGxcblxubGV0IHBhcnRpdGlvbiBwIGwgPVxuICBsZXQgcmVjIHBhcnQgeWVzIG5vID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IHllcywgcmV2IG5vKVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBwYXJ0ICh4IDo6IHllcykgbm8gbCBlbHNlIHBhcnQgeWVzICh4IDo6IG5vKSBsIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcGFydGl0aW9uX21hcCBwIGwgPVxuICBsZXQgcmVjIHBhcnQgbGVmdCByaWdodCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiBsZWZ0LCByZXYgcmlnaHQpXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIHAgeCB3aXRoXG4gICAgICAgfCBFaXRoZXIuTGVmdCB2IC0+IHBhcnQgKHYgOjogbGVmdCkgcmlnaHQgbFxuICAgICAgIHwgRWl0aGVyLlJpZ2h0IHYgLT4gcGFydCBsZWZ0ICh2IDo6IHJpZ2h0KSBsXG4gICAgIGVuZFxuICBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHJlYyBzcGxpdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKFtdLCBbXSlcbiAgfCAoeCx5KTo6bCAtPlxuICAgICAgbGV0IChyeCwgcnkpID0gc3BsaXQgbCBpbiAoeDo6cngsIHk6OnJ5KVxuXG5sZXQgcmVjIGNvbWJpbmUgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IChhMSwgYTIpIDo6IGNvbWJpbmUgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmNvbWJpbmVcIlxuXG4oKiogc29ydGluZyAqKVxuXG5sZXQgcmVjIG1lcmdlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwyIC0+IGwyXG4gIHwgbDEsIFtdIC0+IGwxXG4gIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgdGhlbiBoMSA6OiBtZXJnZSBjbXAgdDEgbDJcbiAgICAgIGVsc2UgaDIgOjogbWVyZ2UgY21wIGwxIHQyXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXSBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXSBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgaWYgY21wIHgxIHgyID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHNvcnQgPSBzdGFibGVfc29ydFxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqIE5vdGU6IG9uIGEgdmVyeSBsb25nIGxpc3QgKGxlbmd0aCBvdmVyIGFib3V0IDEwMDAwMCksIGl0IHVzZWQgdG8gYmVcbiAgIGZhc3RlciB0byBjb252ZXJ0IHRoZSBsaXN0IHRvIGFuIGFycmF5LCBzb3J0IHRoZSBhcnJheSwgYW5kIGNvbnZlcnRcbiAgIGJhY2ssIHRydW5jYXRpbmcgdGhlIGFycmF5IG9iamVjdCBhZnRlciBwcmVwZW5kaW5nIGVhY2ggdGhvdXNhbmRcbiAgIGVudHJpZXMgdG8gdGhlIHJlc3VsdGluZyBsaXN0LiBJbXBvc3NpYmxlIG5vdyB0aGF0IE9iai50cnVuY2F0ZSBoYXNcbiAgIGJlZW4gcmVtb3ZlZC4gKilcblxuKCoqIHNvcnRpbmcgKyByZW1vdmluZyBkdXBsaWNhdGVzICopXG5cbmxldCBzb3J0X3VuaXEgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2UgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlX3JldiB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MV0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MV0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhzIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IF8gOjogbDEsIF8gOjogbDIgLT4gY29tcGFyZV9sZW5ndGhzIGwxIGwyXG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gOjogXyAtPiBmYWxzZVxuXG4oKiogezEgQ29tcGFyaXNvbn0gKilcblxuKCogTm90ZTogd2UgYXJlICpub3QqIHNob3J0Y3V0dGluZyB0aGUgbGlzdCBieSB1c2luZ1xuICAgW0xpc3QuY29tcGFyZV9sZW5ndGhzXSBmaXJzdDsgdGhpcyBtYXkgYmUgc2xvd2VyIG9uIGxvbmcgbGlzdHNcbiAgIGltbWVkaWF0ZWx5IHN0YXJ0IHdpdGggZGlzdGluY3QgZWxlbWVudHMuIEl0IGlzIGFsc28gaW5jb3JyZWN0IGZvclxuICAgW2NvbXBhcmVdIGJlbG93LCBhbmQgaXQgaXMgYmV0dGVyIChwcmluY2lwbGUgb2YgbGVhc3Qgc3VycHJpc2UpIHRvXG4gICB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggZm9yIGJvdGggZnVuY3Rpb25zLiAqKVxubGV0IHJlYyBlcXVhbCBlcSBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBbXSwgXzo6XyB8IF86Ol8sIFtdIC0+IGZhbHNlXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT4gZXEgYTEgYTIgJiYgZXF1YWwgZXEgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXzo6XyAtPiAtMVxuICB8IF86Ol8sIFtdIC0+IDFcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPlxuICAgIGxldCBjID0gY21wIGExIGEyIGluXG4gICAgaWYgYyA8PiAwIHRoZW4gY1xuICAgIGVsc2UgY29tcGFyZSBjbXAgbDEgbDJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBsID1cbiAgbGV0IHJlYyBhdXggbCAoKSA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gU2VxLk5pbFxuICAgIHwgeCA6OiB0YWlsIC0+IFNlcS5Db25zICh4LCBhdXggdGFpbClcbiAgaW5cbiAgYXV4IGxcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgb2Zfc2VxIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiBbXVxuICB8IFNlcS5Db25zICh4MSwgc2VxKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggc2VxICgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbeDFdXG4gICAgICB8IFNlcS5Db25zICh4Miwgc2VxKSAtPiB4MSA6OiB4MiA6OiBvZl9zZXEgc2VxXG4gICAgICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gaW50XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuZXh0ZXJuYWwgbmVnIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCBhZGQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCBzdWIgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCBtdWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCBkaXYgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCByZW0gOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCBsb2dvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxvZ25vdCB4ID0gbG9neG9yIHggKC0xKVxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5cbigqXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmcgcyA9IHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcbiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmxldCB0b19zdHJpbmcgeCA9IGZvcm1hdF9pbnQgXCIlZFwiIHhcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IEludC5taW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgdW5zYWZlX2VzY2FwZSBzID1cbiAgKCogV2UgcGVyZm9ybSB0d28gcGFzc2VzIG9uIHRoZSBpbnB1dCBzZXF1ZW5jZSwgb25lIHRvIGNvbXB1dGUgdGhlXG4gICAgIHJlc3VsdCBzaXplIGFuZCBvbmUgdG8gd3JpdGUgdGhlIHJlc3VsdC5cblxuICAgICAjMTE1MDgsICMxMTUwOTogVGhpcyBsb2dpYyB3b3VsZCBiZSBpbmNvcnJlY3QgaW4gcHJlc2VuY2Ugb2ZcbiAgICAgY29uY3VycmVudCBtb2RpZmljYXRpb24gdG8gdGhlIGlucHV0LCBtYWtpbmcgdGhlIHVzZSBvZlxuICAgICBbdW5zYWZlX3NldF0gYmVsb3cgbWVtb3J5LXVuc2FmZS5cblxuICAgICBQcmVjb25kaXRpb246IFRoaXMgZnVuY3Rpb24gbWF5IGJlIHNhZmVseSBjYWxsZWQgb246XG4gICAgIC0gYW4gaW1tdXRhYmxlIGJ5dGUgc2VxdWVuY2VcbiAgICAgLSBhIHVuaXF1ZWx5LW93bmVkIGJ5dGUgc2VxdWVuY2UgKHRoZSBmdW5jdGlvbiB0YWtlcyBvd25lcnNoaXApXG5cbiAgICAgSW4gZWl0aGVyIGNhc2Ugd2UgcmV0dXJuIGEgdW5pcXVlbHktb3duZWQgYnl0ZSBzZXF1ZW5jZS5cbiAgKilcbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBzXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgZXNjYXBlZCBiID1cbiAgbGV0IGIgPSBjb3B5IGIgaW5cbiAgKCogV2UgY29weSBvdXIgaW5wdXQgdG8gb2J0YWluIGEgdW5pcXVlbHktb3duZWQgYnl0ZSBzZXF1ZW5jZSBbYl1cbiAgICAgdG8gc2F0aXNmeSBbdW5zYWZlX2VzY2FwZV0ncyBwcmVjb25kaXRpb24gKilcbiAgdW5zYWZlX2VzY2FwZSBiXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxudHlwZSB0ID0gYnl0ZXNcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBidWYgPSByZWYgKG1ha2UgMjU2ICdcXDAwMCcpIGluXG4gIGxldCByZXNpemUgKCkgPVxuICAgICgqIHJlc2l6ZSAqKVxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1pbiAoMiAqIGxlbmd0aCAhYnVmKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICBpZiBsZW5ndGggIWJ1ZiA9IG5ld19sZW4gdGhlbiBmYWlsd2l0aCBcIkJ5dGVzLm9mX3NlcTogY2Fubm90IGdyb3cgYnl0ZXNcIjtcbiAgICBsZXQgbmV3X2J1ZiA9IG1ha2UgbmV3X2xlbiAnXFwwMDAnIGluXG4gICAgYmxpdCAhYnVmIDAgbmV3X2J1ZiAwICFuO1xuICAgIGJ1ZiA6PSBuZXdfYnVmXG4gIGluXG4gIFNlcS5pdGVyXG4gICAgKGZ1biBjIC0+XG4gICAgICAgaWYgIW4gPSBsZW5ndGggIWJ1ZiB0aGVuIHJlc2l6ZSgpO1xuICAgICAgIHNldCAhYnVmICFuIGM7XG4gICAgICAgaW5jciBuKVxuICAgIGk7XG4gIHN1YiAhYnVmIDAgIW5cblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuKCogVGhlIGdldF8gZnVuY3Rpb25zIGFyZSBhbGwgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcblxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZ1XCJcbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9nZXRfdWludDE2X25lIGIgaVxuICBlbHNlIHN3YXAxNiAodW5zYWZlX2dldF91aW50MTZfbmUgYiBpKVxuXG5sZXQgZ2V0X2ludDggYiBpID1cbiAgKChnZXRfdWludDggYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDgpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDgpXG5cbmxldCBnZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfaW50MTZfbmUgYiBpID1cbiAgKChnZXRfdWludDE2X25lIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfbGUgYiBpID1cbiAgKChnZXRfdWludDE2X2xlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfYmUgYiBpID1cbiAgKChnZXRfdWludDE2X2JlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MzJfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDMyX2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgeFxuXG5sZXQgdW5zYWZlX3NldF91aW50MTZfYmUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4IGVsc2VcbiAgdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIChzd2FwMTYgeClcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG5cbigqIFVURiBjb2RlY3MgYW5kIHZhbGlkYXRpb25zICopXG5cbmxldCBkZWNfaW52YWxpZCA9IFVjaGFyLnV0Zl9kZWNvZGVfaW52YWxpZFxubGV0W0BpbmxpbmVdIGRlY19yZXQgbiB1ID0gVWNoYXIudXRmX2RlY29kZSBuIChVY2hhci51bnNhZmVfb2ZfaW50IHUpXG5cbigqIEluIGNhc2Ugb2YgZGVjb2RpbmcgZXJyb3IsIGlmIHdlIGVycm9yIG9uIHRoZSBmaXJzdCBieXRlLCB3ZVxuICAgY29uc3VtZSB0aGUgYnl0ZSwgb3RoZXJ3aXNlIHdlIGNvbnN1bWUgdGhlIFtuXSBieXRlcyBwcmVjZWRpbmdcbiAgIHRoZSBlcnJvcmluZyBieXRlLlxuXG4gICBUaGlzIG1lYW5zIHRoYXQgaWYgYSBjbGllbnQgdXNlcyBkZWNvZGVzIHdpdGhvdXQgY2FyaW5nIGFib3V0XG4gICB2YWxpZGl0eSBpdCBuYXR1cmFsbHkgcmVwbGFjZSBib2d1cyBkYXRhIHdpdGggVWNoYXIucmVwIGFjY29yZGluZ1xuICAgdG8gdGhlIFdIQVRXRyBFbmNvZGluZyBzdGFuZGFyZC4gT3RoZXIgc2NoZW1lcyBhcmUgcG9zc2libGUgYnlcbiAgIGNvbnN1bHRpbmcgdGhlIG51bWJlciBvZiB1c2VkIGJ5dGVzIG9uIGludmFsaWQgZGVjb2Rlcy4gRm9yIG1vcmVcbiAgIGRldGFpbHMgc2VlIGh0dHBzOi8vaHNpdm9uZW4uZmkvYnJva2VuLXV0Zi04L1xuXG4gICBGb3IgdGhpcyByZWFzb24gaW4gW2dldF91dGZfOF91Y2hhcl0gd2UgZ3JhZHVhbGx5IGNoZWNrIHRoZSBuZXh0XG4gICBieXRlIGlzIGF2YWlsYWJsZSByYXRoZXIgdGhhbiBkb2luZyBpdCBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAgIGZpcnN0IGJ5dGUuIENvbnRyYXN0IHdpdGggW2lzX3ZhbGlkX3V0Zl84XS4gKilcblxuKCogVVRGLTggKilcblxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feEJGIGIgPSBiIGxzciA2IDw+IDBiMTBcbmxldFtAaW5saW5lXSBub3RfaW5feEEwX3RvX3hCRiBiID0gYiBsc3IgNSA8PiAwYjEwMVxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feDlGIGIgPSBiIGxzciA1IDw+IDBiMTAwXG5sZXRbQGlubGluZV0gbm90X2luX3g5MF90b194QkYgYiA9IGIgPCAweDkwIHx8IDB4QkYgPCBiXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194OEYgYiA9IGIgbHNyIDQgPD4gMHg4XG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl8yIGIwIGIxID1cbiAgKChiMCBsYW5kIDB4MUYpIGxzbCA2KSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpKVxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfMyBiMCBiMSBiMiA9XG4gICgoYjAgbGFuZCAweDBGKSBsc2wgMTIpIGxvclxuICAoKGIxIGxhbmQgMHgzRikgbHNsIDYpIGxvclxuICAoKGIyIGxhbmQgMHgzRikpXG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzID1cbiAgKChiMCBsYW5kIDB4MDcpIGxzbCAxOCkgbG9yXG4gICgoYjEgbGFuZCAweDNGKSBsc2wgMTIpIGxvclxuICAoKGIyIGxhbmQgMHgzRikgbHNsIDYpIGxvclxuICAoKGIzIGxhbmQgMHgzRikpXG5cbmxldCBnZXRfdXRmXzhfdWNoYXIgYiBpID1cbiAgbGV0IGIwID0gZ2V0X3VpbnQ4IGIgaSBpbiAoKiByYWlzZXMgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIGluZGV4LiAqKVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50OCBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIG1hdGNoIENoYXIudW5zYWZlX2NociBiMCB3aXRoICgqIFNlZSBUaGUgVW5pY29kZSBTdGFuZGFyZCwgVGFibGUgMy43ICopXG4gIHwgJ1xceDAwJyAuLiAnXFx4N0YnIC0+IGRlY19yZXQgMSBiMFxuICB8ICdcXHhDMicgLi4gJ1xceERGJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBkZWNfcmV0IDIgKHV0Zl84X3VjaGFyXzIgYjAgYjEpXG4gIHwgJ1xceEUwJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94QTBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RTEnIC4uICdcXHhFQycgfCAnXFx4RUUnIC4uICdcXHhFRicgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEVEJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feDlGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RjAnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g5MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgJ1xceEYxJyAuLiAnXFx4RjMnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgJ1xceEY0JyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feDhGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8IF8gLT4gZGVjX2ludmFsaWQgMVxuXG5sZXQgc2V0X3V0Zl84X3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDggaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICAgc2V0X3VpbnQ4IGIgaSB1O1xuICAgICAgMVxuICB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4QzAgbG9yICh1IGxzciA2KSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgMilcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEUwIGxvciAodSBsc3IgMTIpKTtcbiAgICAgICBzZXQgYiAoaSArIDEpICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDMpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEYwIGxvciAodSBsc3IgMTgpKTtcbiAgICAgICBzZXQgYiAoaSArIDEpICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiAoaSArIDIpICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDQpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl84IGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQ4IGluXG4gICAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIChnZXQgYiBpKSB3aXRoXG4gICAgfCAnXFx4MDAnIC4uICdcXHg3RicgLT4gbG9vcCBtYXggYiAoaSArIDEpXG4gICAgfCAnXFx4QzInIC4uICdcXHhERicgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RTAnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feEEwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFMScgLi4gJ1xceEVDJyB8ICdcXHhFRScgLi4gJ1xceEVGJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RUQnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3g5RiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGMCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94OTBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGMScgLi4gJ1xceEYzJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEY0JyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194OEYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuXG4oKiBVVEYtMTZCRSAqKVxuXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIGIgaSA9XG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIGlmIGkgPSBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfcmV0IDIgdVxuICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGRlY19pbnZhbGlkIDJcbiAgfCBoaSAtPiAoKiBjb21iaW5lIFtoaV0gd2l0aCBhIGxvdyBzdXJyb2dhdGUgKilcbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAobWF4IC0gaSArIDEpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19pbnZhbGlkIDIgKCogcmV0cnkgaGVyZSAqKVxuICAgICAgfCBsbyAtPlxuICAgICAgICAgIGxldCB1ID0gKCgoaGkgbGFuZCAweDNGRikgbHNsIDEwKSBsb3IgKGxvIGxhbmQgMHgzRkYpKSArIDB4MTAwMDAgaW5cbiAgICAgICAgICBkZWNfcmV0IDQgdVxuXG5sZXQgc2V0X3V0Zl8xNmJlX3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDE2X2JlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2UgKHNldCBiIGkgdTsgMilcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgIGxldCBoaSA9ICgweEQ4MDAgbG9yICh1JyBsc3IgMTApKSBpblxuICAgICAgbGV0IGxvID0gKDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpKSBpblxuICAgICAgc2V0IGIgaSBoaTsgc2V0IGIgKGkgKyAyKSBsbzsgNFxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfMTZiZSBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBpblxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBpZiBpID0gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBsb29wIG1heCBiIChpICsgMilcbiAgICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGZhbHNlXG4gICAgfCBfaGkgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGZhbHNlXG4gICAgICAgIHwgX2xvIC0+IGxvb3AgbWF4IGIgKGkgKyA0KVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuXG4oKiBVVEYtMTZMRSAqKVxuXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIGIgaSA9XG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIGlmIGkgPSBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfcmV0IDIgdVxuICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGRlY19pbnZhbGlkIDJcbiAgfCBoaSAtPiAoKiBjb21iaW5lIFtoaV0gd2l0aCBhIGxvdyBzdXJyb2dhdGUgKilcbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAobWF4IC0gaSArIDEpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19pbnZhbGlkIDIgKCogcmV0cnkgaGVyZSAqKVxuICAgICAgfCBsbyAtPlxuICAgICAgICAgIGxldCB1ID0gKCgoaGkgbGFuZCAweDNGRikgbHNsIDEwKSBsb3IgKGxvIGxhbmQgMHgzRkYpKSArIDB4MTAwMDAgaW5cbiAgICAgICAgICBkZWNfcmV0IDQgdVxuXG5sZXQgc2V0X3V0Zl8xNmxlX3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDE2X2xlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2UgKHNldCBiIGkgdTsgMilcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgIGxldCBoaSA9ICgweEQ4MDAgbG9yICh1JyBsc3IgMTApKSBpblxuICAgICAgbGV0IGxvID0gKDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpKSBpblxuICAgICAgc2V0IGIgaSBoaTsgc2V0IGIgKGkgKyAyKSBsbzsgNFxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfMTZsZSBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBpblxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBpZiBpID0gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBsb29wIG1heCBiIChpICsgMilcbiAgICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGZhbHNlXG4gICAgfCBfaGkgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGZhbHNlXG4gICAgICAgIHwgX2xvIC0+IGxvb3AgbWF4IGIgKGkgKyA0KVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTdHJpbmcgb3BlcmF0aW9ucywgYmFzZWQgb24gYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBieXRlcy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBieXRlcy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgZW1wdHkgPSBcIlwiXG5sZXQgb2ZfYnl0ZXMgPSBCLnRvX3N0cmluZ1xubGV0IHRvX2J5dGVzID0gQi5vZl9zdHJpbmdcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGJsaXQgPVxuICBCLmJsaXRfc3RyaW5nXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gXCJcIlxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW4gYnRzIEBAXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoQi5jcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCA9ICggXiApXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5sZXQgZm9sZF9yaWdodCBmIHggYSA9XG4gIEIuZm9sZF9yaWdodCBmIChib3MgeCkgYVxubGV0IGZvbGRfbGVmdCBmIGEgeCA9XG4gIEIuZm9sZF9sZWZ0IGYgYSAoYm9zIHgpXG5sZXQgZXhpc3RzIGYgcyA9XG4gIEIuZXhpc3RzIGYgKGJvcyBzKVxubGV0IGZvcl9hbGwgZiBzID1cbiAgQi5mb3JfYWxsIGYgKGJvcyBzKVxuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBiID0gYm9zIHMgaW5cbiAgKCogV2Ugc2F0aXNmeSBbdW5zYWZlX2VzY2FwZV0ncyBwcmVjb25kaXRpb24gYnkgcGFzc2luZyBhblxuICAgICBpbW11dGFibGUgYnl0ZSBzZXF1ZW5jZSBbYl0uICopXG4gIGJ0cyAoQi51bnNhZmVfZXNjYXBlIGIpXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2ggOiBpbnQgLT4gc3RyaW5nIC0+IGludCA9IFwiY2FtbF9zdHJpbmdfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2ggMCB4XG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuXG4oKiBVVEYgZGVjb2RlcnMgYW5kIHZhbGlkYXRvcnMgKilcblxubGV0IGdldF91dGZfOF91Y2hhciBzIGkgPSBCLmdldF91dGZfOF91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfOCBzID0gQi5pc192YWxpZF91dGZfOCAoYm9zIHMpXG5cbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzE2YmVfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgcyA9IEIuaXNfdmFsaWRfdXRmXzE2YmUgKGJvcyBzKVxuXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl8xNmxlX3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlIHMgPSBCLmlzX3ZhbGlkX3V0Zl8xNmxlIChib3MgcylcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9zdHJpbmdfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfc3RyaW5nX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX3N0cmluZ19nZXQ2NFwiXG5cbmxldCBnZXRfaW50OCBzIGkgPSBCLmdldF9pbnQ4IChib3MgcykgaVxubGV0IGdldF91aW50MTZfbGUgcyBpID0gQi5nZXRfdWludDE2X2xlIChib3MgcykgaVxubGV0IGdldF91aW50MTZfYmUgcyBpID0gQi5nZXRfdWludDE2X2JlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9uZSBzIGkgPSBCLmdldF9pbnQxNl9uZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbGUgcyBpID0gQi5nZXRfaW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2JlIHMgaSA9IEIuZ2V0X2ludDE2X2JlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9sZSBzIGkgPSBCLmdldF9pbnQzMl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfYmUgcyBpID0gQi5nZXRfaW50MzJfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2xlIHMgaSA9IEIuZ2V0X2ludDY0X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9iZSBzIGkgPSBCLmdldF9pbnQ2NF9iZSAoYm9zIHMpIGlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gdW5pdCA9ICgpXG5cbmxldCBlcXVhbCAoKSAoKSA9IHRydWVcbmxldCBjb21wYXJlICgpICgpID0gMFxubGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGV4dGVybl9mbGFncyA9XG4gICAgTm9fc2hhcmluZ1xuICB8IENsb3N1cmVzXG4gIHwgQ29tcGF0XzMyXG5cbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ3J1bnRpbWUvZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXNcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAxNlxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBhcnJheXMuICopXG50eXBlICdhIHQgPSAnYSBhcnJheVxuXG4oKiBBcnJheSBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG5leHRlcm5hbCBnZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV9zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV91bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfdW5zYWZlX3NldFwiXG5leHRlcm5hbCBtYWtlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIGNyZWF0ZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCB1bnNhZmVfc3ViIDogJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9zdWJcIlxuZXh0ZXJuYWwgYXBwZW5kX3ByaW0gOiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9hcHBlbmRcIlxuZXh0ZXJuYWwgY29uY2F0IDogJ2EgYXJyYXkgbGlzdCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9jb25jYXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfZmlsbFwiXG5leHRlcm5hbCBjcmVhdGVfZmxvYXQ6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjb3B5IGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIHVuc2FmZV9zdWIgYSAwIGxcblxubGV0IGFwcGVuZCBhMSBhMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICBpZiBsMSA9IDAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbGVuZ3RoIGEyID0gMCB0aGVuIHVuc2FmZV9zdWIgYTEgMCBsMVxuICBlbHNlIGFwcGVuZF9wcmltIGExIGEyXG5cbmxldCBzdWIgYSBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5zdWJcIlxuICBlbHNlIHVuc2FmZV9zdWIgYSBvZnMgbGVuXG5cbmxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdlxuXG5sZXQgYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIGExIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBhMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlblxuXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGl0ZXIyIGYgYSBiID1cbiAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG5sZXQgbWFwIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBfaW5wbGFjZSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgdW5zYWZlX3NldCBhIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgZG9uZVxuXG5sZXQgbWFwaV9pbnBsYWNlIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IGEgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gIGRvbmVcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2MgaW5wdXRfYXJyYXkgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGlucHV0X2FycmF5IGluXG4gIGlmIGxlbiA9IDAgdGhlbiAoYWNjLCBbfHxdKSBlbHNlIGJlZ2luXG4gICAgbGV0IGFjYywgZWx0ID0gZiBhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgMCkgaW5cbiAgICBsZXQgb3V0cHV0X2FycmF5ID0gY3JlYXRlIGxlbiBlbHQgaW5cbiAgICBsZXQgYWNjID0gcmVmIGFjYyBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgYWNjJywgZWx0ID0gZiAhYWNjICh1bnNhZmVfZ2V0IGlucHV0X2FycmF5IGkpIGluXG4gICAgICBhY2MgOj0gYWNjJztcbiAgICAgIHVuc2FmZV9zZXQgb3V0cHV0X2FycmF5IGkgZWx0O1xuICAgIGRvbmU7XG4gICAgIWFjYywgb3V0cHV0X2FycmF5XG4gIGVuZFxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZm9yX2FsbDJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBleGlzdHMyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5leGlzdHMyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX29wdCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBpZiBwIHggdGhlbiBTb21lIHhcbiAgICAgIGVsc2UgbG9vcCAoc3VjYyBpKVxuICBpblxuICBsb29wIDBcblxubGV0IGZpbmRfaW5kZXggcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBTb21lIGlcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX21hcCBmIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBtYXRjaCBmICh1bnNhZmVfZ2V0IGEgaSkgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKHN1Y2MgaSlcbiAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICBpblxuICBsb29wIDBcblxubGV0IGZpbmRfbWFwaSBmIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBtYXRjaCBmIGkgKHVuc2FmZV9nZXQgYSBpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoc3VjYyBpKVxuICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3BsaXQgeCA9XG4gIGlmIHggPSBbfHxdIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGEwLCBiMCA9IHVuc2FmZV9nZXQgeCAwIGluXG4gICAgbGV0IG4gPSBsZW5ndGggeCBpblxuICAgIGxldCBhID0gY3JlYXRlIG4gYTAgaW5cbiAgICBsZXQgYiA9IGNyZWF0ZSBuIGIwIGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgYWksIGJpID0gdW5zYWZlX2dldCB4IGkgaW5cbiAgICAgIHVuc2FmZV9zZXQgYSBpIGFpO1xuICAgICAgdW5zYWZlX3NldCBiIGkgYmlcbiAgICBkb25lO1xuICAgIGEsIGJcbiAgZW5kXG5cbmxldCBjb21iaW5lIGEgYiA9XG4gIGxldCBuYSA9IGxlbmd0aCBhIGluXG4gIGxldCBuYiA9IGxlbmd0aCBiIGluXG4gIGlmIG5hIDw+IG5iIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5jb21iaW5lXCI7XG4gIGlmIG5hID0gMCB0aGVuIFt8fF1cbiAgZWxzZSBiZWdpblxuICAgIGxldCB4ID0gY3JlYXRlIG5hICh1bnNhZmVfZ2V0IGEgMCwgdW5zYWZlX2dldCBiIDApIGluXG4gICAgZm9yIGkgPSAxIHRvIG5hIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCB4IGkgKHVuc2FmZV9nZXQgYSBpLCB1bnNhZmVfZ2V0IGIgaSlcbiAgICBkb25lO1xuICAgIHhcbiAgZW5kXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgcXVpZXRfbmFuID0gbmFuXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IHNpZ25hbGluZ19uYW4gPSBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2JydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NicnRfZmxvYXRcIiBcImNhbWxfY2JydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwMl9mbG9hdFwiIFwiY2FtbF9leHAyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZl9mbG9hdFwiIFwiY2FtbF9lcmZcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZmNfZmxvYXRcIiBcImNhbWxfZXJmY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1hcF9pbnBsYWNlIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBhIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lXG5cbiAgbGV0IG1hcDIgZiBhIGIgPVxuICAgIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcmkgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICBsZXQgbWFwaSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBtYXBpX2lucGxhY2UgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IGEgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgICBsZXQgciA9IHJlZiB4IGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgICBsZXQgciA9IHJlZiB4IGluXG4gICAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZXhpc3RzIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSkgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvcl9hbGwgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKGkgKyAxKVxuICAgICAgZWxzZSBmYWxzZSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgbWVtIHggYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIG1vc3RseSBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGJ1dCBzbGlnaHRseSBkaWZmZXJlbnQgKilcbiAgbGV0IG1lbV9pZWVlIHggYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgeCA9ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmaW5kX29wdCBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBpZiBwIHggdGhlbiBTb21lIHhcbiAgICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZmluZF9pbmRleCBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gU29tZSBpXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZmluZF9tYXAgZiBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIG1hdGNoIGYgKHVuc2FmZV9nZXQgYSBpKSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZpbmRfbWFwaSBmIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgbWF0Y2ggZiBpICh1bnNhZmVfZ2V0IGEgaSkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG4gIGxldCBzb3J0IGNtcCBhID1cbiAgICBsZXQgbWF4c29uIGwgaSA9XG4gICAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgICAheFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICAgIHRoZW4gaTMxKzFcbiAgICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICAgIGluXG4gICAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgYSBpIGU7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICAgIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIGJ1YmJsZWRvd24gbCBqXG4gICAgaW5cbiAgICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgYSBpIGU7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICAgIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgICBkb25lO1xuICAgIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBleGNlcHQgZm9yIHRoZSBjYWxsIHRvIFtjcmVhdGVdICopXG4gIGxldCBjdXRvZmYgPSA1XG4gIGxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gICAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgICAgZW5kXG4gICAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgICBpblxuICAgIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICAgIGRlY3IgajtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgICAgZG9uZTtcbiAgICBpblxuICAgIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICAgIGxldCB0ID0gY3JlYXRlIGwyIGluXG4gICAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gICAgZW5kXG5cbiAgbGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXEgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgICAgZWxzZSBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxaSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgICAgZWxzZSBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggMFxuXG4gICgqIG1vc3RseSBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG9mX3Jldl9saXN0IGwgPVxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICBbXSAtPiBhXG4gICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgIGluXG4gICAgZmlsbCAobGVuLTEpIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG9mX3NlcSBpID1cbiAgICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgICBvZl9yZXZfbGlzdCBsXG5cblxuICBsZXQgbWFwX3RvX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGlmIGwgPSAwIHRoZW4gW3wgfF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBBcnJheS5tYWtlIGwgKGYgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcblxuICBsZXQgbWFwX2Zyb21fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKEFycmF5LnVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuZW5kXG5cbm1vZHVsZSBBcnJheUxhYmVscyA9IEFycmF5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPlxuICAgICAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgICAgIGZ1biBuIC0+XG4gICAgICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbWFzayA9IDB4RkZGRiBsc2wgMTYgbG9yIDB4RkZGRiBpblxuICAgICAgZnVuIG4gLT4gU29tZSAodG9faW50IG4gbGFuZCBtYXNrKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIEludC5taW4gKDIgKiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuID4gbmV3bGVuXG4gICAgICB0aGVuIGZhaWx3aXRoIFwiTGV4aW5nLmxleF9yZWZpbGw6IGNhbm5vdCBncm93IGJ1ZmZlclwiO1xuICAgICAgbGV0IG5ld2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgICgqIENvcHkgdGhlIHZhbGlkIGRhdGEgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbmV3YnVmIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3Bvcyk7XG4gICAgICBsZXhidWYubGV4X2J1ZmZlciA8LSBuZXdidWZcbiAgICBlbmQ7XG4gICAgKCogUmVhbGxvY2F0aW9uIG9yIG5vdCwgd2UgaGF2ZSBzaGlmdGVkIHRoZSBkYXRhIGxlZnQgYnlcbiAgICAgICBzdGFydF9wb3MgY2hhcmFjdGVyczsgdXBkYXRlIHRoZSBwb3NpdGlvbnMgKilcbiAgICBsZXQgcyA9IGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gICAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIGxleGJ1Zi5sZXhfYWJzX3BvcyArIHM7XG4gICAgbGV4YnVmLmxleF9jdXJyX3BvcyA8LSBsZXhidWYubGV4X2N1cnJfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X3N0YXJ0X3BvcyA8LSAwO1xuICAgIGxleGJ1Zi5sZXhfbGFzdF9wb3MgPC0gbGV4YnVmLmxleF9sYXN0X3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIHMgO1xuICAgIGxldCB0ID0gbGV4YnVmLmxleF9tZW0gaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQtMSBkb1xuICAgICAgbGV0IHYgPSB0LihpKSBpblxuICAgICAgaWYgdiA+PSAwIHRoZW5cbiAgICAgICAgdC4oaSkgPC0gdi1zXG4gICAgZG9uZVxuICBlbmQ7XG4gICgqIFRoZXJlIGlzIG5vdyBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gIEJ5dGVzLmJsaXQgYXV4X2J1ZmZlciAwIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiBuO1xuICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuICsgblxuXG5sZXQgemVyb19wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMTtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gMDtcbn1cblxubGV0IGZyb21fZnVuY3Rpb24gPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIGYgPVxuICB7IHJlZmlsbF9idWZmID0gbGV4X3JlZmlsbCBmIChCeXRlcy5jcmVhdGUgNTEyKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDEwMjQ7XG4gICAgbGV4X2J1ZmZlcl9sZW4gPSAwO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSBmYWxzZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCA/d2l0aF9wb3NpdGlvbnMgaWMgPVxuICBmcm9tX2Z1bmN0aW9uID93aXRoX3Bvc2l0aW9ucyAoZnVuIGJ1ZiBuIC0+IGlucHV0IGljIGJ1ZiAwIG4pXG5cbmxldCBmcm9tX3N0cmluZyA/KHdpdGhfcG9zaXRpb25zID0gdHJ1ZSkgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IHNldF9wb3NpdGlvbiBsZXhidWYgcG9zaXRpb24gPVxuICBsZXhidWYubGV4X2N1cnJfcCAgPC0ge3Bvc2l0aW9uIHdpdGggcG9zX2ZuYW1lID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2ZuYW1lfTtcbiAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIHBvc2l0aW9uLnBvc19jbnVtXG5cbmxldCBzZXRfZmlsZW5hbWUgbGV4YnVmIGZuYW1lID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0ge2xleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZm5hbWV9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcGFyc2luZyBlbmdpbmUgKilcblxub3BlbiBMZXhpbmdcblxuKCogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG50eXBlIHBhcnNlcl9lbnYgPVxuICB7IG11dGFibGUgc19zdGFjayA6IGludCBhcnJheTsgICAgICAgICgqIFN0YXRlcyAqKVxuICAgIG11dGFibGUgdl9zdGFjayA6IE9iai50IGFycmF5OyAgICAgICgqIFNlbWFudGljIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgKCogU3RhcnQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzeW1iX2VuZF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAgICgqIEVuZCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN0YWNrc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBTaXplIG9mIHRoZSBzdGFja3MgKilcbiAgICBtdXRhYmxlIHN0YWNrYmFzZSA6IGludDsgICAgICAgICAgICAoKiBCYXNlIHNwIGZvciBjdXJyZW50IHBhcnNlICopXG4gICAgbXV0YWJsZSBjdXJyX2NoYXIgOiBpbnQ7ICAgICAgICAgICAgKCogTGFzdCB0b2tlbiByZWFkICopXG4gICAgbXV0YWJsZSBsdmFsIDogT2JqLnQ7ICAgICAgICAgICAgICAgKCogSXRzIHNlbWFudGljIGF0dHJpYnV0ZSAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydCA6IHBvc2l0aW9uOyAgICAgICgqIFN0YXJ0IHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kIDogcG9zaXRpb247ICAgICAgICAoKiBFbmQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wgKilcbiAgICBtdXRhYmxlIGFzcCA6IGludDsgICAgICAgICAgICAgICAgICAoKiBUaGUgc3RhY2sgcG9pbnRlciBmb3IgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgcnVsZV9sZW4gOiBpbnQ7ICAgICAgICAgICAgICgqIE51bWJlciBvZiByaHMgaXRlbXMgaW4gdGhlIHJ1bGUgKilcbiAgICBtdXRhYmxlIHJ1bGVfbnVtYmVyIDogaW50OyAgICAgICAgICAoKiBSdWxlIG51bWJlciB0byByZWR1Y2UgYnkgKilcbiAgICBtdXRhYmxlIHNwIDogaW50OyAgICAgICAgICAgICAgICAgICAoKiBTYXZlZCBzcCBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBzdGF0ZSA6IGludDsgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3RhdGUgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgZXJyZmxhZyA6IGludCB9ICAgICAgICAgICAgICgqIFNhdmVkIGVycm9yIGZsYWcgZm9yIHBhcnNlX2VuZ2luZSAqKVxuW0BAd2FybmluZyBcIi11bnVzZWQtZmllbGRcIl1cblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpc2pvaW50OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBkaWZmOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBjYXJkaW5hbDogdCAtPiBpbnRcbiAgICB2YWwgZWxlbWVudHM6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgbWluX2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWluX2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBtYXhfZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtYXhfZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGNob29zZTogdCAtPiBlbHRcbiAgICB2YWwgY2hvb3NlX29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoZWx0IC0+IGVsdCBvcHRpb24pIC0+IHQgLT4gdFxuICAgIHZhbCBwYXJ0aXRpb246IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0ICogdFxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCB0b19saXN0IDogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBvZl9saXN0OiBlbHQgbGlzdCAtPiB0XG4gICAgdmFsIHRvX3NlcV9mcm9tIDogZWx0IC0+IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogZWx0IFNlcS50IC0+IHQgLT4gdFxuICAgIHZhbCBvZl9zZXEgOiBlbHQgU2VxLnQgLT4gdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGVsdCA9IE9yZC50XG4gICAgdHlwZSB0ID0gRW1wdHkgfCBOb2RlIG9mIHtsOnQ7IHY6ZWx0OyByOnQ7IGg6aW50fVxuXG4gICAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGVcbiAgICAgICBjaGlsZHJlbiBkaWZmZXIgYnkgYXQgbW9zdCAyICopXG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICAgIGxldCBiYWwgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICAgIGxldCByZWMgYWRkIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdCBlbHNlXG4gICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHQgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHQgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgc2luZ2xldG9uIHggPSBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCB2IGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGVsZW1lbnRzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGVsZW1lbnQuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9lbGVtZW50IHggbCkgdiByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiAoYWRkX21heF9lbGVtZW50IHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2VsZW1lbnQgdiByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9lbGVtZW50IHYgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IHJcblxuICAgICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG5cbiAgICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdCBsXG5cbiAgICBsZXQgcmVjIG1pbl9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHRfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0IHJcblxuICAgIGxldCByZWMgbWF4X2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdF9vcHQgclxuXG4gICAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBiYWwgdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogU3BsaXR0aW5nLiAgc3BsaXQgeCBzIHJldHVybnMgYSB0cmlwbGUgKGwsIHByZXNlbnQsIHIpIHdoZXJlXG4gICAgICAgIC0gbCBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPCB4XG4gICAgICAgIC0gciBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPiB4XG4gICAgICAgIC0gcHJlc2VudCBpcyBmYWxzZSBpZiBzIGNvbnRhaW5zIG5vIGVsZW1lbnQgZXF1YWwgdG8geCxcbiAgICAgICAgICBvciB0cnVlIGlmIHMgY29udGFpbnMgYW4gZWxlbWVudCBlcXVhbCB0byB4LiAqKVxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIGZhbHNlLCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgdHJ1ZSwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgbHIsIHByZXMsIHJyKVxuXG4gICAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSBhcyB0KSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW5cbiAgICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0MikgLT4gdDJcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMTsgaD1oMX0sIE5vZGV7bD1sMjsgdj12Mjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxIHRoZW4gYWRkIHYyIHMxIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMiwgXywgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGgxID0gMSB0aGVuIGFkZCB2MSBzMiBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDEsIF8sIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8IChfLCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKVxuXG4gICAgKCogU2FtZSBhcyBzcGxpdCwgYnV0IGNvbXB1dGUgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzXG4gICAgICAgb25seSBpZiB0aGUgcGl2b3QgZWxlbWVudCBpcyBub3QgaW4gdGhlIHNldC4gIFRoZSByaWdodCBzdWJ0cmVlXG4gICAgICAgaXMgY29tcHV0ZWQgb24gZGVtYW5kLiAqKVxuXG4gICAgdHlwZSBzcGxpdF9iaXMgPVxuICAgICAgfCBGb3VuZFxuICAgICAgfCBOb3RGb3VuZCBvZiB0ICogKHVuaXQgLT4gdClcblxuICAgIGxldCByZWMgc3BsaXRfYmlzIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vdEZvdW5kIChFbXB0eSwgKGZ1biAoKSAtPiBFbXB0eSkpXG4gICAgICB8IE5vZGV7bDsgdjsgcjsgX30gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gRm91bmRcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IGwgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobGwsIHJsKSAtPiBOb3RGb3VuZCAobGwsIChmdW4gKCkgLT4gam9pbiAocmwgKCkpIHYgcikpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggciB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsciwgcnIpIC0+IE5vdEZvdW5kIChqb2luIGwgdiBsciwgcnIpXG5cbiAgICBsZXQgcmVjIGRpc2pvaW50IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSB8IChfLCBFbXB0eSkgLT4gdHJ1ZVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgaWYgczEgPT0gczIgdGhlbiBmYWxzZVxuICAgICAgICAgIGVsc2UgbWF0Y2ggc3BsaXRfYmlzIHYxIHQyIHdpdGhcbiAgICAgICAgICAgICAgTm90Rm91bmQobDIsIHIyKSAtPiBkaXNqb2ludCBsMSBsMiAmJiBkaXNqb2ludCByMSAocjIgKCkpXG4gICAgICAgICAgICB8IEZvdW5kIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKVxuXG4gICAgdHlwZSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2YgZWx0ICogdCAqIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCByLCBlKSlcblxuICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgfCAoTW9yZSh2MSwgcjEsIGUxKSwgTW9yZSh2MiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuXG4gICAgbGV0IGNvbXBhcmUgczEgczIgPVxuICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSBzMSBFbmQpIChjb25zX2VudW0gczIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIHMxIHMyID1cbiAgICAgIGNvbXBhcmUgczEgczIgPSAwXG5cbiAgICBsZXQgcmVjIHN1YnNldCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIEVtcHR5LCBfIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w9bDE7IHY9djE7IHI9cjF9LCAoTm9kZSB7bD1sMjsgdj12Mjsgcj1yMn0gYXMgdDIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCBsMSBsMiAmJiBzdWJzZXQgcjEgcjJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1sMTsgdj12MTsgcj1FbXB0eTsgaD0wfSkgbDIgJiYgc3Vic2V0IHIxIHQyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPUVtcHR5OyB2PXYxOyByPXIxOyBoPTB9KSByMiAmJiBzdWJzZXQgbDEgdDJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBpdGVyIGYgbDsgZiB2OyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBmb2xkIGYgcyBhY2N1ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZm9sZCBmIHIgKGYgdiAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSkgYXMgdCAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdiB0aGVuXG4gICAgICAgICAgICBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIHQgZWxzZSBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiByZilcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGV7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgZWxlbWVudHMgcyA9XG4gICAgICBlbGVtZW50c19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9lbHRcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2VsdF9vcHRcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdlxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgdlxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCB0cnlfam9pbiBsIHYgciA9XG4gICAgICAoKiBbam9pbiBsIHYgcl0gY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gKGVsZW1lbnRzIG9mIGwgPCB2IDxcbiAgICAgICAgIGVsZW1lbnRzIG9mIHIpOyB1c2UgW3RyeV9qb2luIGwgdiByXSB3aGVuIHRoaXMgcHJvcGVydHkgbWF5XG4gICAgICAgICBub3QgaG9sZCwgYnV0IHlvdSBob3BlIGl0IGRvZXMgaG9sZCBpbiB0aGUgY29tbW9uIGNhc2UgKilcbiAgICAgIGlmIChsID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgKG1heF9lbHQgbCkgdiA8IDApXG4gICAgICAmJiAociA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIHYgKG1pbl9lbHQgcikgPCAwKVxuICAgICAgdGhlbiBqb2luIGwgdiByXG4gICAgICBlbHNlIHVuaW9uIGwgKGFkZCB2IHIpXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcblxuICAgIGxldCB0cnlfY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gdHJ5X2pvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgIGxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gZmlsdGVyX21hcCBmIHIgaW5cbiAgICAgICAgIGJlZ2luIG1hdGNoIHYnIHdpdGhcbiAgICAgICAgICAgfCBTb21lIHYnIC0+XG4gICAgICAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG4gICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICB0cnlfY29uY2F0IGwnIHInXG4gICAgICAgICBlbmRcblxuICAgIGxldCBvZl9zb3J0ZWRfbGlzdCBsID1cbiAgICAgIGxldCByZWMgc3ViIG4gbCA9XG4gICAgICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgICAgICB8IDAsIGwgLT4gRW1wdHksIGxcbiAgICAgICAgfCAxLCB4MCA6OiBsIC0+IE5vZGUge2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX0sIGxcbiAgICAgICAgfCAyLCB4MCA6OiB4MSA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxOyByPUVtcHR5OyBoPTJ9LCBsXG4gICAgICAgIHwgMywgeDAgOjogeDEgOjogeDIgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTtcbiAgICAgICAgICAgICAgICAgcj1Ob2Rle2w9RW1wdHk7IHY9eDI7IHI9RW1wdHk7IGg9MX07IGg9Mn0sIGxcbiAgICAgICAgfCBuLCBsIC0+XG4gICAgICAgICAgbGV0IG5sID0gbiAvIDIgaW5cbiAgICAgICAgICBsZXQgbGVmdCwgbCA9IHN1YiBubCBsIGluXG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IG1pZCA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgcmlnaHQsIGwgPSBzdWIgKG4gLSBubCAtIDEpIGwgaW5cbiAgICAgICAgICAgIGNyZWF0ZSBsZWZ0IG1pZCByaWdodCwgbFxuICAgICAgaW5cbiAgICAgIGZzdCAoc3ViIChMaXN0Lmxlbmd0aCBsKSBsKVxuXG4gICAgbGV0IHRvX2xpc3QgPSBlbGVtZW50c1xuXG4gICAgbGV0IG9mX2xpc3QgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZW1wdHlcbiAgICAgIHwgW3gwXSAtPiBzaW5nbGV0b24geDBcbiAgICAgIHwgW3gwOyB4MV0gLT4gYWRkIHgxIChzaW5nbGV0b24geDApXG4gICAgICB8IFt4MDsgeDE7IHgyXSAtPiBhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzXSAtPiBhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzOyB4NF0gLT4gYWRkIHg0IChhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSkpXG4gICAgICB8IF8gLT4gb2Zfc29ydGVkX2xpc3QgKExpc3Quc29ydF91bmlxIE9yZC5jb21wYXJlIGwpXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIHMgeCAtPiBhZGQgeCBzKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgYyA9IHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHJlYyBzbm9jX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gc25vY19lbnVtIHIgKE1vcmUodiwgbCwgZSkpXG5cbiAgICBsZXQgcmVjIHJldl9zZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fcmV2X3NlcSBjID0gcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBzID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBzIGMgPSBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgcjsgdjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBzIEVuZClcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISsnYSB0XG4gICAgdmFsIGVtcHR5OiAnYSB0XG4gICAgdmFsIGFkZDoga2V5IC0+ICdhIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGRfdG9fbGlzdDoga2V5IC0+ICdhIC0+ICdhIGxpc3QgdCAtPiAnYSBsaXN0IHRcbiAgICB2YWwgdXBkYXRlOiBrZXkgLT4gKCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBzaW5nbGV0b246IGtleSAtPiAnYSAtPiAnYSB0XG4gICAgdmFsIHJlbW92ZToga2V5IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBtZXJnZTpcbiAgICAgIChrZXkgLT4gJ2Egb3B0aW9uIC0+ICdiIG9wdGlvbiAtPiAnYyBvcHRpb24pIC0+XG4gICAgICAnYSB0IC0+ICdiIHQgLT4gJ2MgdFxuICAgIHZhbCB1bmlvbjogKGtleSAtPiAnYSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgaXNfZW1wdHk6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBtZW06IGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZXF1YWw6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGZvcl9hbGw6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgdG9fbGlzdCA6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG9mX2xpc3QgOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgdFxuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fcmV2X3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGtleSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPSBzdHJ1Y3RcblxuICAgIHR5cGUga2V5ID0gT3JkLnRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUgb2Yge2w6J2EgdDsgdjprZXk7IGQ6J2E7IHI6J2EgdDsgaDppbnR9XG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gaGVpZ2h0IGwgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgc2luZ2xldG9uIHggZCA9IE5vZGV7bD1FbXB0eTsgdj14OyBkOyByPUVtcHR5OyBoPTF9XG5cbiAgICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyBkPWxyZDsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IGQ9cmxkOyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBhZGQgeCBkYXRhID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggZGF0YSBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IGRhdGEgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gZFxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZFxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge2x9IC0+IG1pbl9iaW5kaW5nIGxcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfS0+IG1pbl9iaW5kaW5nX29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZyByXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmdfb3B0IHJcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9iaW5kaW5nIGwpIHYgZCByXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IChOb2RlIHtsOyB2OyBkOyByfSBhcyBtKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW4gaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIHVwZGF0ZSB4IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5XG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgICAgIGVuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBtZXJnZSBsIHJcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gdXBkYXRlIHggZiBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHVwZGF0ZSB4IGYgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCBhZGRfdG9fbGlzdCB4IGRhdGEgbSA9XG4gICAgICBsZXQgYWRkID0gZnVuY3Rpb24gTm9uZSAtPiBTb21lIFtkYXRhXSB8IFNvbWUgbCAtPiBTb21lIChkYXRhIDo6IGwpIGluXG4gICAgICB1cGRhdGUgeCBhZGQgbVxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgdG9fbGlzdCA9IGJpbmRpbmdzXG4gICAgbGV0IG9mX2xpc3QgYnMgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIG0gKGssIHYpIC0+IGFkZCBrIHYgbSkgZW1wdHkgYnNcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gbSAoayx2KSAtPiBhZGQgayB2IG0pIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+IFNlcS5Db25zICgoayx2KSwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgbSA9XG4gICAgICBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBtIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IGQ7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGQsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT5cbiAgICAgICAgICBTZXEuQ29ucyAoKGssdiksIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9XG4gICAgICByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IG0gPVxuICAgICAgbGV0IHJlYyBhdXggbG93IG0gYyA9IG1hdGNoIG0gd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgZCwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIGQsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IG0gRW5kKVxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjIDogJ2EgbGlzdDsgbXV0YWJsZSBsZW4gOiBpbnQ7IH1cblxuZXhjZXB0aW9uIEVtcHR5XG5cbmxldCBjcmVhdGUgKCkgPSB7IGMgPSBbXTsgbGVuID0gMDsgfVxuXG5sZXQgY2xlYXIgcyA9IHMuYyA8LSBbXTsgcy5sZW4gPC0gMFxuXG5sZXQgY29weSBzID0geyBjID0gcy5jOyBsZW4gPSBzLmxlbjsgfVxuXG5sZXQgcHVzaCB4IHMgPSBzLmMgPC0geCA6OiBzLmM7IHMubGVuIDwtIHMubGVuICsgMVxuXG5sZXQgcG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHBvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBTb21lIGhkXG4gIHwgW10gICAgIC0+IE5vbmVcblxubGV0IGRyb3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgX2hkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMVxuICB8IFtdIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG4oKiBUaGUgW2lubmVyX2J1ZmZlcl0gdHlwZSBlbnN1cmVzIHRoYXQgdGhlIFtsZW5ndGhdIGFuZCBbYnVmZmVyXSBmaWVsZHMgYXJlXG4gICBhbHdheXMgc3luY2hyb25pemVkLCBbbGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGJ1ZmZlcl0sIGV2ZW4gaW4gcHJlc2VuY2VcbiAgIG9mIGRhdGEgcmFjZXMuXG4qKVxudHlwZSBpbm5lcl9idWZmZXIgPSB7XG4gIGJ1ZmZlcjogYnl0ZXM7XG4gIGxlbmd0aDogaW50O1xufVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGlubmVyIDogaW5uZXJfYnVmZmVyO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFtpbm5lci5sZW5ndGggPSBCeXRlcy5sZW5ndGggaW5uZXIuYnVmZmVyXVxuICAgSW4gYWJzZW5jZSBvZiBkYXRhIHJhY2VzLCB3ZSBhbHNvIGhhdmVcbiAgIC0gWzAgPD0gYi5wb3NpdGlvbiA8PSBiLmlubmVyLmxlbmd0aF1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmlubmVyLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7IGlubmVyID0geyBidWZmZXIgPSBzOyBsZW5ndGggPSBufTsgcG9zaXRpb24gPSAwOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmlubmVyLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuaW5uZXIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuaW5uZXIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy5ibGl0IHNyYy5pbm5lci5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7bGVuZ3RofSA9IGIuaW5uZXIgaW5cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBsZW5ndGggdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBsZXQgaW5uZXIgPVxuICAgIHsgYnVmZmVyID0gYi5pbml0aWFsX2J1ZmZlcjsgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGIuaW5pdGlhbF9idWZmZXIgfVxuICBpblxuICBiLmlubmVyIDwtIGlubmVyXG5cbigqIFtyZXNpemUgYiBtb3JlXSBlbnN1cmVzIHRoYXQgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIuaW5uZXIubGVuZ3RoXSBob2xkc1xuICAgYnkgZHluYW1pY2FsbHkgZXh0ZW5kaW5nIFtiLmlubmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IuaW5uZXIubGVuZ3RoXS5cbiopXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBvbGRfcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQgb2xkX2xlbiA9IGIuaW5uZXIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgd2hpbGUgb2xkX3BvcyArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgb2xkX3BvcyArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmlubmVyLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmlubmVyIDwtIHsgYnVmZmVyID0gbmV3X2J1ZmZlcjsgbGVuZ3RoID0gIW5ld19sZW4gfVxuXG4oKiBOb3RlOlxuICAgIFNvbWUgb2YgdGhlIGZ1bmN0aW9ucyBiZWxvdyBoYXZlIGEgZmFzdCBwYXRoIHdoZW4gdGhlIGlubmVyXG4gIGJ1ZmZlciBkb2Vzbid0IG5lZWQgdG8gYmUgZXh0ZW5kZWQuXG4gICAgSW4gdGhpcyBjYXNlLCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgdW5zYWZlIGFjY2Vzc2VzIG9uIHRoZVxuICBjb250ZW50cyBvZiB0aGUgW2lubmVyXSBmaWVsZCBzaW5jZSBpdHMgZmllbGRzIGFyZSBpbW11dGFibGUuXG4gIEluIHByZXNlbmNlIG9mIGRhdGEgcmFjZXMsIHdlIG1heSBhY2Nlc3MgdGhlIHdyb25nIGlubmVyIGJ1ZmZlciwgYnV0IHdlXG4gIHdpbGwgdXNlIHRoaXMgYnVmZmVyIHNhZmVseS5cbiAgQXMgc29vbiBhcyB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgYnVmZmVyLCB3ZSBmYWxsIGJhY2sgdG8gc2FmZSBhY2Nlc3Nlcy5cbiopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQge2J1ZmZlcjtsZW5ndGh9ID0gYi5pbm5lciBpblxuICBpZiBwb3MgPj0gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDE7XG4gICAgQnl0ZXMuc2V0IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gY1xuICApIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfc2V0IGJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbmxldCB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXggPSA0XG5sZXQgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCA9IDRcblxubGV0IHJlYyBhZGRfdXRmXzhfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfOF91Y2hhciBiLmlubmVyLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfOF91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2YmVfdWNoYXIgYi5pbm5lci5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgcmVjIGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5pbm5lci5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfMTZsZV91Y2hhciBiLmlubmVyLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7bGVuZ3RofSA9IGIuaW5uZXIgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiBsZW47XG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiBsZW5cbiAgKSBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgb2Zmc2V0IGJ1ZmZlciBwb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7IGxlbmd0aH0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgbGVuO1xuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIHMgMCBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgKSBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgMCBidWZmZXIgcG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuaW5uZXIuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogdGhpcyAocHJpdmF0ZSkgZnVuY3Rpb24gY291bGQgbW92ZSBpbnRvIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG5sZXQgcmVhbGx5X2lucHV0X3VwX3RvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWQgPVxuICAgIGlmIHRvX3JlYWQgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBpbnB1dCBpYyBidWYgb2ZzIHRvX3JlYWQgaW5cbiAgICAgIGlmIHIgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBhbHJlYWR5X3JlYWQgPSBhbHJlYWR5X3JlYWQgKyByIGluXG4gICAgICAgIGxldCBvZnMgPSBvZnMgKyByIGluXG4gICAgICAgIGxldCB0b19yZWFkID0gdG9fcmVhZCAtIHIgaW5cbiAgICAgICAgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW4gbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZDowIH5vZnMgfnRvX3JlYWQ6bGVuXG5cblxubGV0IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiA9XG4gIGlmIGIucG9zaXRpb24gKyBsZW4gPiBiLmlubmVyLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgbGV0IG4gPSByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgblxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGxldCBuID0gdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuIGluXG4gICgqIEl0IGlzIGludGVudGlvbmFsIHRoYXQgYSBjb25zdW1lciBjYXRjaGluZyBFbmRfb2ZfZmlsZVxuICAgICB3aWxsIHNlZSB0aGUgZGF0YSB3cml0dGVuIChzZWUgIzY3MTksICM3MTM2KS4gKilcbiAgaWYgbiA8IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAoKVxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuaW5uZXIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLmdldCBiLmlubmVyLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLmdldCBiLmlubmVyLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IGFkZF9zZXEgYiBzZXEgPSBTZXEuaXRlciAoYWRkX2NoYXIgYikgc2VxXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBiID0gY3JlYXRlIDMyIGluXG4gIGFkZF9zZXEgYiBpO1xuICBiXG5cbigqKiB7NiBCaW5hcnkgZW5jb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzIgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzIgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcblxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxuXG5sZXQgYWRkX2ludDggYiB4ID1cbiAgbGV0IHBvc2l0aW9uID0gYi5wb3NpdGlvbiBpblxuICBsZXQge2xlbmd0aDsgYnVmZmVyfSA9IGIuaW5uZXIgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uICsgMSBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgMTtcbiAgICBzZXRfaW50OCBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQ4IGJ1ZmZlciBwb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X25lIGIgeCA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtsZW5ndGg7IGJ1ZmZlcn0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIDIgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDI7XG4gICAgc2V0X2ludDE2IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24geFxuICApIGVsc2VcbiAgICB1bnNhZmVfc2V0X2ludDE2IGJ1ZmZlciBwb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDMyX25lIGIgeCA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtsZW5ndGg7IGJ1ZmZlcn0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIDQgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDQ7XG4gICAgc2V0X2ludDMyIGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24geFxuICApIGVsc2VcbiAgICB1bnNhZmVfc2V0X2ludDMyIGJ1ZmZlciBwb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDY0X25lIGIgeCA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtsZW5ndGg7IGJ1ZmZlcn0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIDggaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDg7XG4gICAgc2V0X2ludDY0IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24geFxuICApIGVsc2VcbiAgICB1bnNhZmVfc2V0X2ludDY0IGJ1ZmZlciBwb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X2xlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQxNl9iZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDE2IHgpXG5cbmxldCBhZGRfaW50MzJfbGUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDMyX2JlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMzIgeClcblxubGV0IGFkZF9pbnQ2NF9sZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50NjRfYmUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXA2NCB4KVxuXG5sZXQgYWRkX3VpbnQ4ID0gYWRkX2ludDhcbmxldCBhZGRfdWludDE2X25lID0gYWRkX2ludDE2X25lXG5sZXQgYWRkX3VpbnQxNl9sZSA9IGFkZF9pbnQxNl9sZVxubGV0IGFkZF91aW50MTZfYmUgPSBhZGRfaW50MTZfYmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIFBhc2NhbCBDdW9xLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTUgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0XG5leHRlcm5hbCBjcmVhdGU6IHVuaXQgLT4gdCA9IFwiY2FtbF9tbF9tdXRleF9uZXdcIlxuZXh0ZXJuYWwgbG9jazogdCAtPiB1bml0ID0gXCJjYW1sX21sX211dGV4X2xvY2tcIlxuZXh0ZXJuYWwgdHJ5X2xvY2s6IHQgLT4gYm9vbCA9IFwiY2FtbF9tbF9tdXRleF90cnlfbG9ja1wiXG5leHRlcm5hbCB1bmxvY2s6IHQgLT4gdW5pdCA9IFwiY2FtbF9tbF9tdXRleF91bmxvY2tcIlxuXG4oKiBwcml2YXRlIHJlLWV4cG9ydCAqKVxuZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4oKiBjYW5ub3QgaW5saW5lLCBvdGhlcndpc2UgZmxhbWJkYSBtaWdodCBtb3ZlIGNvZGUgYXJvdW5kLiAqKVxubGV0W0BpbmxpbmUgbmV2ZXJdIHByb3RlY3QgbSBmID1cbiAgbG9jayBtO1xuICBtYXRjaCBmKCkgd2l0aFxuICB8IHggLT5cbiAgICB1bmxvY2sgbTsgeFxuICB8IGV4Y2VwdGlvbiBlIC0+XG4gICAgKCogTk9URTogW3VubG9ja10gZG9lcyBub3QgcG9sbCBmb3IgYXN5bmNocm9ub3VzIGV4Y2VwdGlvbnMgKilcbiAgICB1bmxvY2sgbTtcbiAgICByZXJhaXNlIGVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIFhhdmllciBMZXJveSwgQ29sbMOoZ2UgZGUgRnJhbmNlIGFuZCBJTlJJQSBQYXJpcyAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBTZW1hcGhvcmVzICopXG5cbnR5cGUgc2VtID0ge1xuICBtdXQ6IE11dGV4LnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICgqIHByb3RlY3RzIFt2XSAqKVxuICBtdXRhYmxlIHY6IGludDsgICAgICAgICAgICAgICAgICAgICAgICgqIHRoZSBjdXJyZW50IHZhbHVlICopXG4gIG5vbnplcm86IENvbmRpdGlvbi50ICAgICAgICAgICAgICAgICAgKCogc2lnbmFsZWQgd2hlbiBbdiA+IDBdICopXG59XG5cbm1vZHVsZSBDb3VudGluZyA9IHN0cnVjdFxuXG50eXBlIHQgPSBzZW1cblxubGV0IG1ha2UgdiA9XG4gIGlmIHYgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTZW1hcGhvcmUuQ291bnRpbmcuaW5pdDogd3JvbmcgaW5pdGlhbCB2YWx1ZVwiO1xuICB7IG11dCA9IE11dGV4LmNyZWF0ZSgpOyB2OyBub256ZXJvID0gQ29uZGl0aW9uLmNyZWF0ZSgpIH1cblxubGV0IHJlbGVhc2UgcyA9XG4gIE11dGV4LmxvY2sgcy5tdXQ7XG4gIGlmIHMudiA8IG1heF9pbnQgdGhlbiBiZWdpblxuICAgIHMudiA8LSBzLnYgKyAxO1xuICAgIENvbmRpdGlvbi5zaWduYWwgcy5ub256ZXJvO1xuICAgIE11dGV4LnVubG9jayBzLm11dFxuICBlbmQgZWxzZSBiZWdpblxuICAgIE11dGV4LnVubG9jayBzLm11dDtcbiAgICByYWlzZSAoU3lzX2Vycm9yIFwiU2VtYXBob3JlLkNvdW50aW5nLnJlbGVhc2U6IG92ZXJmbG93XCIpXG4gIGVuZFxuXG5sZXQgYWNxdWlyZSBzID1cbiAgTXV0ZXgubG9jayBzLm11dDtcbiAgd2hpbGUgcy52ID0gMCBkbyBDb25kaXRpb24ud2FpdCBzLm5vbnplcm8gcy5tdXQgZG9uZTtcbiAgcy52IDwtIHMudiAtIDE7XG4gIE11dGV4LnVubG9jayBzLm11dFxuXG5sZXQgdHJ5X2FjcXVpcmUgcyA9XG4gIE11dGV4LmxvY2sgcy5tdXQ7XG4gIGxldCByZXQgPSBpZiBzLnYgPSAwIHRoZW4gZmFsc2UgZWxzZSAocy52IDwtIHMudiAtIDE7IHRydWUpIGluXG4gIE11dGV4LnVubG9jayBzLm11dDtcbiAgcmV0XG5cbmxldCBnZXRfdmFsdWUgcyA9IHMudlxuXG5lbmRcblxubW9kdWxlIEJpbmFyeSA9IHN0cnVjdFxuXG50eXBlIHQgPSBzZW1cblxubGV0IG1ha2UgYiA9XG4gIHsgbXV0ID0gTXV0ZXguY3JlYXRlKCk7XG4gICAgdiA9IGlmIGIgdGhlbiAxIGVsc2UgMDtcbiAgICBub256ZXJvID0gQ29uZGl0aW9uLmNyZWF0ZSgpIH1cblxubGV0IHJlbGVhc2UgcyA9XG4gIE11dGV4LmxvY2sgcy5tdXQ7XG4gIHMudiA8LSAxO1xuICBDb25kaXRpb24uc2lnbmFsIHMubm9uemVybztcbiAgTXV0ZXgudW5sb2NrIHMubXV0XG5cbmxldCBhY3F1aXJlIHMgPVxuICBNdXRleC5sb2NrIHMubXV0O1xuICB3aGlsZSBzLnYgPSAwIGRvIENvbmRpdGlvbi53YWl0IHMubm9uemVybyBzLm11dCBkb25lO1xuICBzLnYgPC0gMDtcbiAgTXV0ZXgudW5sb2NrIHMubXV0XG5cbmxldCB0cnlfYWNxdWlyZSBzID1cbiAgTXV0ZXgubG9jayBzLm11dDtcbiAgbGV0IHJldCA9IGlmIHMudiA9IDAgdGhlbiBmYWxzZSBlbHNlIChzLnYgPC0gMDsgdHJ1ZSkgaW5cbiAgTXV0ZXgudW5sb2NrIHMubXV0O1xuICByZXRcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgIEtDIFNpdmFyYW1ha3Jpc2huYW4sIEluZGlhbiBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgTWFkcmFzICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU3RlcGhlbiBEb2xhbiwgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICBUb20gS2VsbHksIE9DYW1sIExhYnMgQ29uc3VsdGFuY3kgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluZGlhbiBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgTWFkcmFzICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IFVuaXZlcnNpdHkgb2YgQ2FtYnJpZGdlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIE9DYW1sIExhYnMgQ29uc3VsdGFuY3kgTHRkICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSBSYXcgPSBzdHJ1Y3RcbiAgKCogTG93LWxldmVsIHByaW1pdGl2ZXMgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWUgKilcbiAgdHlwZSB0ID0gcHJpdmF0ZSBpbnRcbiAgZXh0ZXJuYWwgc3Bhd24gOiAodW5pdCAtPiB1bml0KSAtPiBNdXRleC50IC0+IHRcbiAgICA9IFwiY2FtbF9kb21haW5fc3Bhd25cIlxuICBleHRlcm5hbCBzZWxmIDogdW5pdCAtPiB0XG4gICAgPSBcImNhbWxfbWxfZG9tYWluX2lkXCJcbiAgZXh0ZXJuYWwgY3B1X3JlbGF4IDogdW5pdCAtPiB1bml0XG4gICAgPSBcImNhbWxfbWxfZG9tYWluX2NwdV9yZWxheFwiXG4gIGV4dGVybmFsIGdldF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQ6IHVuaXQgLT4gaW50XG4gICAgPSBcImNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50XCIgW0BAbm9hbGxvY11cbmVuZFxuXG5sZXQgY3B1X3JlbGF4ICgpID0gUmF3LmNwdV9yZWxheCAoKVxuXG50eXBlIGlkID0gUmF3LnRcblxudHlwZSAnYSBzdGF0ZSA9XG58IFJ1bm5pbmdcbnwgRmluaXNoZWQgb2YgKCdhLCBleG4pIHJlc3VsdFxuXG50eXBlICdhIHQgPSB7XG4gIGRvbWFpbiA6IFJhdy50O1xuICB0ZXJtX211dGV4OiBNdXRleC50O1xuICB0ZXJtX2NvbmRpdGlvbjogQ29uZGl0aW9uLnQ7XG4gIHRlcm1fc3RhdGU6ICdhIHN0YXRlIHJlZiAoKiBwcm90ZWN0ZWQgYnkgW3Rlcm1fbXV0ZXhdICopXG59XG5cbm1vZHVsZSBETFMgPSBzdHJ1Y3RcblxuICB0eXBlIGRsc19zdGF0ZSA9IE9iai50IGFycmF5XG5cbiAgbGV0IHVuaXF1ZV92YWx1ZSA9IE9iai5yZXByIChyZWYgMClcblxuICBleHRlcm5hbCBnZXRfZGxzX3N0YXRlIDogdW5pdCAtPiBkbHNfc3RhdGUgPSBcIiVkbHNfZ2V0XCJcblxuICBleHRlcm5hbCBzZXRfZGxzX3N0YXRlIDogZGxzX3N0YXRlIC0+IHVuaXQgPVxuICAgIFwiY2FtbF9kb21haW5fZGxzX3NldFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNyZWF0ZV9kbHMgKCkgPVxuICAgIGxldCBzdCA9IEFycmF5Lm1ha2UgOCB1bmlxdWVfdmFsdWUgaW5cbiAgICBzZXRfZGxzX3N0YXRlIHN0XG5cbiAgbGV0IF8gPSBjcmVhdGVfZGxzICgpXG5cbiAgdHlwZSAnYSBrZXkgPSBpbnQgKiAodW5pdCAtPiAnYSlcblxuICBsZXQga2V5X2NvdW50ZXIgPSBBdG9taWMubWFrZSAwXG5cbiAgdHlwZSBrZXlfaW5pdGlhbGl6ZXIgPVxuICAgIEtJOiAnYSBrZXkgKiAoJ2EgLT4gJ2EpIC0+IGtleV9pbml0aWFsaXplclxuXG4gIGxldCBwYXJlbnRfa2V5cyA9IEF0b21pYy5tYWtlIChbXSA6IGtleV9pbml0aWFsaXplciBsaXN0KVxuXG4gIGxldCByZWMgYWRkX3BhcmVudF9rZXkga2kgPVxuICAgIGxldCBsID0gQXRvbWljLmdldCBwYXJlbnRfa2V5cyBpblxuICAgIGlmIG5vdCAoQXRvbWljLmNvbXBhcmVfYW5kX3NldCBwYXJlbnRfa2V5cyBsIChraSA6OiBsKSlcbiAgICB0aGVuIGFkZF9wYXJlbnRfa2V5IGtpXG5cbiAgbGV0IG5ld19rZXkgP3NwbGl0X2Zyb21fcGFyZW50IGluaXRfb3JwaGFuID1cbiAgICBsZXQgaWR4ID0gQXRvbWljLmZldGNoX2FuZF9hZGQga2V5X2NvdW50ZXIgMSBpblxuICAgIGxldCBrID0gKGlkeCwgaW5pdF9vcnBoYW4pIGluXG4gICAgYmVnaW4gbWF0Y2ggc3BsaXRfZnJvbV9wYXJlbnQgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBzcGxpdCAtPiBhZGRfcGFyZW50X2tleSAoS0koaywgc3BsaXQpKVxuICAgIGVuZDtcbiAgICBrXG5cbiAgKCogSWYgbmVjZXNzYXJ5LCBncm93IHRoZSBjdXJyZW50IGRvbWFpbidzIGxvY2FsIHN0YXRlIGFycmF5IHN1Y2ggdGhhdCBbaWR4XVxuICAgKiBpcyBhIHZhbGlkIGluZGV4IGluIHRoZSBhcnJheS4gKilcbiAgbGV0IG1heWJlX2dyb3cgaWR4ID1cbiAgICBsZXQgc3QgPSBnZXRfZGxzX3N0YXRlICgpIGluXG4gICAgbGV0IHN6ID0gQXJyYXkubGVuZ3RoIHN0IGluXG4gICAgaWYgaWR4IDwgc3ogdGhlbiBzdFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByZWMgY29tcHV0ZV9uZXdfc2l6ZSBzID1cbiAgICAgICAgaWYgaWR4IDwgcyB0aGVuIHMgZWxzZSBjb21wdXRlX25ld19zaXplICgyICogcylcbiAgICAgIGluXG4gICAgICBsZXQgbmV3X3N6ID0gY29tcHV0ZV9uZXdfc2l6ZSBzeiBpblxuICAgICAgbGV0IG5ld19zdCA9IEFycmF5Lm1ha2UgbmV3X3N6IHVuaXF1ZV92YWx1ZSBpblxuICAgICAgQXJyYXkuYmxpdCBzdCAwIG5ld19zdCAwIHN6O1xuICAgICAgc2V0X2Rsc19zdGF0ZSBuZXdfc3Q7XG4gICAgICBuZXdfc3RcbiAgICBlbmRcblxuICBsZXQgc2V0IChpZHgsIF9pbml0KSB4ID1cbiAgICBsZXQgc3QgPSBtYXliZV9ncm93IGlkeCBpblxuICAgICgqIFtTeXMub3BhcXVlX2lkZW50aXR5XSBlbnN1cmVzIHRoYXQgZmxhbWJkYSBkb2VzIG5vdCBsb29rIGF0IHRoZSB0eXBlIG9mXG4gICAgICogW3hdLCB3aGljaCBtYXkgYmUgYSBbZmxvYXRdIGFuZCBjb25jbHVkZSB0aGF0IHRoZSBbc3RdIGlzIGEgZmxvYXQgYXJyYXkuXG4gICAgICogV2UgZG8gbm90IHdhbnQgT0NhbWwncyBmbG9hdCBhcnJheSBvcHRpbWlzYXRpb24ga2lja2luZyBpbiBoZXJlLiAqKVxuICAgIHN0LihpZHgpIDwtIE9iai5yZXByIChTeXMub3BhcXVlX2lkZW50aXR5IHgpXG5cbiAgbGV0IGdldCAoaWR4LCBpbml0KSA9XG4gICAgbGV0IHN0ID0gbWF5YmVfZ3JvdyBpZHggaW5cbiAgICBsZXQgdiA9IHN0LihpZHgpIGluXG4gICAgaWYgdiA9PSB1bmlxdWVfdmFsdWUgdGhlblxuICAgICAgbGV0IHYnID0gT2JqLnJlcHIgKGluaXQgKCkpIGluXG4gICAgICBzdC4oaWR4KSA8LSAoU3lzLm9wYXF1ZV9pZGVudGl0eSB2Jyk7XG4gICAgICBPYmoubWFnaWMgdidcbiAgICBlbHNlIE9iai5tYWdpYyB2XG5cbiAgbGV0IGdldF9pbml0aWFsX2tleXMgKCkgOiAoaW50ICogT2JqLnQpIGxpc3QgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuIChLSSAoKGlkeCwgXykgYXMgaywgc3BsaXQpKSAtPlxuICAgICAgICAgICAoaWR4LCBPYmoucmVwciAoc3BsaXQgKGdldCBrKSkpKVxuICAgICAgKEF0b21pYy5nZXQgcGFyZW50X2tleXMpXG5cbiAgbGV0IHNldF9pbml0aWFsX2tleXMgKGw6IChpbnQgKiBPYmoudCkgbGlzdCkgPVxuICAgIExpc3QuaXRlclxuICAgICAgKGZ1biAoaWR4LCB2KSAtPlxuICAgICAgICBsZXQgc3QgPSBtYXliZV9ncm93IGlkeCBpbiBzdC4oaWR4KSA8LSB2KVxuICAgICAgbFxuXG5lbmRcblxuKCoqKioqKioqIElkZW50aXR5ICoqKioqKioqKiopXG5cbmxldCBnZXRfaWQgeyBkb21haW47IF8gfSA9IGRvbWFpblxuXG5sZXQgc2VsZiAoKSA9IFJhdy5zZWxmICgpXG5cbmxldCBpc19tYWluX2RvbWFpbiAoKSA9IChzZWxmICgpIDo+IGludCkgPSAwXG5cbigqKioqKioqKiBDYWxsYmFja3MgKioqKioqKioqKilcblxuKCogZmlyc3Qgc3Bhd24sIGRvbWFpbiBzdGFydHVwIGFuZCBhdCBleGl0IGZ1bmN0aW9uYWxpdHkgKilcbmxldCBmaXJzdF9kb21haW5fc3Bhd25lZCA9IEF0b21pYy5tYWtlIGZhbHNlXG5cbmxldCBmaXJzdF9zcGF3bl9mdW5jdGlvbiA9IHJlZiAoZnVuICgpIC0+ICgpKVxuXG5sZXQgYmVmb3JlX2ZpcnN0X3NwYXduIGYgPVxuICBpZiBBdG9taWMuZ2V0IGZpcnN0X2RvbWFpbl9zcGF3bmVkIHRoZW5cbiAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcImZpcnN0IGRvbWFpbiBhbHJlYWR5IHNwYXduZWRcIilcbiAgZWxzZSBiZWdpblxuICAgIGxldCBvbGRfZiA9ICFmaXJzdF9zcGF3bl9mdW5jdGlvbiBpblxuICAgIGxldCBuZXdfZiAoKSA9IG9sZF9mICgpOyBmICgpIGluXG4gICAgZmlyc3Rfc3Bhd25fZnVuY3Rpb24gOj0gbmV3X2ZcbiAgZW5kXG5cbmxldCBkb19iZWZvcmVfZmlyc3Rfc3Bhd24gKCkgPVxuICBpZiBub3QgKEF0b21pYy5nZXQgZmlyc3RfZG9tYWluX3NwYXduZWQpIHRoZW4gYmVnaW5cbiAgICBBdG9taWMuc2V0IGZpcnN0X2RvbWFpbl9zcGF3bmVkIHRydWU7XG4gICAgIWZpcnN0X3NwYXduX2Z1bmN0aW9uKCk7XG4gICAgKCogUmVsZWFzZSB0aGUgb2xkIGZ1bmN0aW9uICopXG4gICAgZmlyc3Rfc3Bhd25fZnVuY3Rpb24gOj0gKGZ1biAoKSAtPiAoKSlcbiAgZW5kXG5cbmxldCBhdF9leGl0X2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT4gKGZ1biAoKSAtPiAoKSkpXG5cbmxldCBhdF9leGl0IGYgPVxuICBsZXQgb2xkX2V4aXQgOiB1bml0IC0+IHVuaXQgPSBETFMuZ2V0IGF0X2V4aXRfa2V5IGluXG4gIGxldCBuZXdfZXhpdCAoKSA9XG4gICAgKCogVGhlIGRvbWFpbiB0ZXJtaW5hdGlvbiBjYWxsYmFja3MgKFthdF9leGl0XSkgYXJlIHJ1biBpblxuICAgICAgIGxhc3QtaW4tZmlyc3Qtb3V0IChMSUZPKSBvcmRlciBpbiBvcmRlciB0byBiZSBzeW1tZXRyaWMgd2l0aCB0aGUgZG9tYWluXG4gICAgICAgY3JlYXRpb24gY2FsbGJhY2tzIChbYXRfZWFjaF9zcGF3bl0pIHdoaWNoIHJ1biBpbiBmaXJzdC1pbi1maXNydC1vdXRcbiAgICAgICAoRklGTykgb3JkZXIuICopXG4gICAgZiAoKTsgb2xkX2V4aXQgKClcbiAgaW5cbiAgRExTLnNldCBhdF9leGl0X2tleSBuZXdfZXhpdFxuXG5sZXQgZG9fYXRfZXhpdCAoKSA9XG4gIGxldCBmIDogdW5pdCAtPiB1bml0ID0gRExTLmdldCBhdF9leGl0X2tleSBpblxuICBmICgpXG5cbmxldCBfID0gU3RkbGliLmRvX2RvbWFpbl9sb2NhbF9hdF9leGl0IDo9IGRvX2F0X2V4aXRcblxuKCoqKioqKiogQ3JlYXRpb24gYW5kIFRlcm1pbmF0aW9uICoqKioqKioqKVxuXG5sZXQgc3Bhd24gZiA9XG4gIGRvX2JlZm9yZV9maXJzdF9zcGF3biAoKTtcbiAgbGV0IHBrID0gRExTLmdldF9pbml0aWFsX2tleXMgKCkgaW5cblxuICAoKiBUaGUgW3Rlcm1fbXV0ZXhdIGFuZCBbdGVybV9jb25kaXRpb25dIGFyZSB1c2VkIHRvXG4gICAgIHN5bmNocm9uaXplIHdpdGggdGhlIGpvaW5pbmcgZG9tYWlucyAqKVxuICBsZXQgdGVybV9tdXRleCA9IE11dGV4LmNyZWF0ZSAoKSBpblxuICBsZXQgdGVybV9jb25kaXRpb24gPSBDb25kaXRpb24uY3JlYXRlICgpIGluXG4gIGxldCB0ZXJtX3N0YXRlID0gcmVmIFJ1bm5pbmcgaW5cblxuICBsZXQgYm9keSAoKSA9XG4gICAgbGV0IHJlc3VsdCA9XG4gICAgICBtYXRjaFxuICAgICAgICBETFMuY3JlYXRlX2RscyAoKTtcbiAgICAgICAgRExTLnNldF9pbml0aWFsX2tleXMgcGs7XG4gICAgICAgIGxldCByZXMgPSBmICgpIGluXG4gICAgICAgIHJlc1xuICAgICAgd2l0aFxuICAgICAgfCB4IC0+IE9rIHhcbiAgICAgIHwgZXhjZXB0aW9uIGV4IC0+IEVycm9yIGV4XG4gICAgaW5cblxuICAgIGxldCByZXN1bHQnID1cbiAgICAgICgqIFJ1biB0aGUgW2F0X2V4aXRdIGNhbGxiYWNrcyB3aGVuIHRoZSBkb21haW4gY29tcHV0YXRpb24gZWl0aGVyXG4gICAgICAgICB0ZXJtaW5hdGVzIG5vcm1hbGx5IG9yIGV4Y2VwdGlvbmFsbHkuICopXG4gICAgICBtYXRjaCBkb19hdF9leGl0ICgpIHdpdGhcbiAgICAgIHwgKCkgLT4gcmVzdWx0XG4gICAgICB8IGV4Y2VwdGlvbiBleCAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgICAgfCBPayBfIC0+XG4gICAgICAgICAgICAgICgqIElmIHRoZSBkb21haW4gY29tcHV0YXRpb24gdGVybWluYXRlZCBub3JtYWxseSwgYnV0IHRoZVxuICAgICAgICAgICAgICAgICBbYXRfZXhpdF0gY2FsbGJhY2tzIHJhaXNlZCBhbiBleGNlcHRpb24sIHRoZW4gcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgICBleGNlcHRpb24uICopXG4gICAgICAgICAgICAgIEVycm9yIGV4XG4gICAgICAgICAgfCBFcnJvciBfIC0+XG4gICAgICAgICAgICAgICgqIElmIGJvdGggdGhlIGRvbWFpbiBjb21wdXRhdGlvbiBhbmQgdGhlIFthdF9leGl0XSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgcmFpc2VkIGV4Y2VwdGlvbnMsIHRoZW4gaWdub3JlIHRoZSBleGNlcHRpb24gZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAgW2F0X2V4aXRdIGNhbGxiYWNrcyBhbmQgcmV0dXJuIHRoZSBvcmlnaW5hbCBleGNlcHRpb24uICopXG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIGVuZFxuICAgIGluXG5cbiAgICAoKiBTeW5jaHJvbml6ZSB3aXRoIGpvaW5pbmcgZG9tYWlucyAqKVxuICAgIE11dGV4LmxvY2sgdGVybV9tdXRleDtcbiAgICBtYXRjaCAhdGVybV9zdGF0ZSB3aXRoXG4gICAgfCBSdW5uaW5nIC0+XG4gICAgICAgIHRlcm1fc3RhdGUgOj0gRmluaXNoZWQgcmVzdWx0JztcbiAgICAgICAgQ29uZGl0aW9uLmJyb2FkY2FzdCB0ZXJtX2NvbmRpdGlvbjtcbiAgICB8IEZpbmlzaGVkIF8gLT5cbiAgICAgICAgZmFpbHdpdGggXCJpbnRlcm5hbCBlcnJvcjogQW0gSSBhbHJlYWR5IGZpbmlzaGVkP1wiXG4gICAgKCogW3Rlcm1fbXV0ZXhdIGlzIHVubG9ja2VkIGluIHRoZSBydW50aW1lIGFmdGVyIHRoZSBjbGVhbnVwIGZ1bmN0aW9ucyBvblxuICAgICAgIHRoZSBDIHNpZGUgYXJlIGZpbmlzaGVkLiAqKVxuICBpblxuICB7IGRvbWFpbiA9IFJhdy5zcGF3biBib2R5IHRlcm1fbXV0ZXg7XG4gICAgdGVybV9tdXRleDtcbiAgICB0ZXJtX2NvbmRpdGlvbjtcbiAgICB0ZXJtX3N0YXRlIH1cblxubGV0IGpvaW4geyB0ZXJtX211dGV4OyB0ZXJtX2NvbmRpdGlvbjsgdGVybV9zdGF0ZTsgXyB9ID1cbiAgTXV0ZXgubG9jayB0ZXJtX211dGV4O1xuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIG1hdGNoICF0ZXJtX3N0YXRlIHdpdGhcbiAgICB8IFJ1bm5pbmcgLT5cbiAgICAgICAgQ29uZGl0aW9uLndhaXQgdGVybV9jb25kaXRpb24gdGVybV9tdXRleDtcbiAgICAgICAgbG9vcCAoKVxuICAgIHwgRmluaXNoZWQgcmVzIC0+XG4gICAgICAgIE11dGV4LnVubG9jayB0ZXJtX211dGV4O1xuICAgICAgICByZXNcbiAgaW5cbiAgbWF0Y2ggbG9vcCAoKSB3aXRoXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXggLT4gcmFpc2UgZXhcblxubGV0IHJlY29tbWVuZGVkX2RvbWFpbl9jb3VudCA9IFJhdy5nZXRfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0ICgoRmxvYXRfZmxhZ18sIEZsb2F0X2YpLFxuICAgICAgICAgICAgICBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYgPVxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfaCB8IEZsb2F0X0hcbiAgfCBGbG9hdF9DRiAtPiAtNlxuICAoKiBGb3IgJWggJUggYW5kICUjRiBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuICB8IEZsb2F0X0YgLT4gMTJcbiAgKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIE9DYW1sIGZsb2F0IHByaW50aW5nICglRikuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuICB8IEZsb2F0X0NGIC0+ICdGJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIGFuZC9vciAnIycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID1cbiAgYmVnaW4gbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgfCBGbG9hdF9mbGFnX3AgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9mbGFnX3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mbGFnXyAtPiAoKSBlbmQ7XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfQ0YgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfR1xuICB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPiAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRm9ybWF0dGluZ19saXQuICopXG4oKiBVc2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBmbXRpbmdfZ2VuIHdpdGhcbiAgICAgIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQHtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAW1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICBlbmQ7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPlxuICAgICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmcm9tIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiB+Y0Y6J2cnIGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbGV0IGhleCAoKSA9XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfZmxhZ19wIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9mbGFnX3MgLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gIGxldCBhZGRfZG90X2lmX25lZWRlZCBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKSBpblxuICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIiBpblxuICBsZXQgY2FtbF9zcGVjaWFsX3ZhbCBzdHIgPSBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT4gc3RyXG4gICAgfCBGUF9pbmZpbml0ZSAtPiBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgIHwgRlBfbmFuIC0+IFwibmFuXCIgaW5cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIC0+IGhleCAoKVxuICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSAoaGV4ICgpKVxuICB8IEZsb2F0X0NGIC0+IGNhbWxfc3BlY2lhbF92YWwgKGhleCAoKSlcbiAgfCBGbG9hdF9GIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBjYW1sX3NwZWNpYWxfdmFsIChhZGRfZG90X2lmX25lZWRlZCBzdHIpXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgLT5cbiAgICBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4XG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biBfIC0+IGsgbykgKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPlxuICBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpIDogKHgseSkgcGFkZGluZyA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpIDogKGEsYikgcGFkZGluZyA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kXG4gICAgICAgICAgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdkJyAtPiBJbnRfQ2RcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdpJyAtPiBJbnRfQ2lcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd1JyAtPiBJbnRfQ3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3BhY2UsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggaGFzaCwgc3ltYiB3aXRoXG4gICAgfCBfLCAnZicgLT4gRmxvYXRfZlxuICAgIHwgXywgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IF8sICdFJyAtPiBGbG9hdF9FXG4gICAgfCBfLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgXywgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IF8sICdoJyAtPiBGbG9hdF9oXG4gICAgfCBfLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCB0cnVlLCAnRicgLT4gRmxvYXRfQ0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBSZXN0X2FsbCBvZiAoc3RyaW5nIGxpc3QgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGFsbCByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLnN0YXJ0c193aXRoIH5wcmVmaXg6XCItXCIgcyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBub19hcmcgKCk7IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgUmVzdF9hbGwgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgbGV0IGFjYyA9IHJlZiBbXSBpblxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCBBcnJheS5sZW5ndGggIWFyZ3YgLSAxIGRvXG4gICAgICAgICAgICAgIGFjYyA6PSAhYXJndi4oIWN1cnJlbnQgKyAxKSA6OiAhYWNjO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICBmIChMaXN0LnJldiAhYWNjKVxuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID1cbiAgICAgICAgICAgICAgQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW5cbiAgICBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gSW50Lm1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkKVxuICB8IF8gLT4gSW50Lm1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKEludC5tYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gSW50Lm1pbiBsZW4gbGltaXQgaW5cbiAgTGlzdC5tYXAgKGFkZF9wYWRkaW5nIGxlbikgY29tcGxldGVkXG5cbmxldCB0cmltX2NyIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIGxlbiA+IDAgJiYgU3RyaW5nLmdldCBzIChsZW4gLSAxKSA9ICdcXHInIHRoZW5cbiAgICBTdHJpbmcuc3ViIHMgMCAobGVuIC0gMSlcbiAgZWxzZVxuICAgIHNcblxubGV0IHJlYWRfYXV4IHRyaW0gc2VwIGZpbGUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICBsZXQgd29yZHMgPSByZWYgW10gaW5cbiAgbGV0IHN0YXNoICgpID1cbiAgICBsZXQgd29yZCA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgICBsZXQgd29yZCA9IGlmIHRyaW0gdGhlbiB0cmltX2NyIHdvcmQgZWxzZSB3b3JkIGluXG4gICAgd29yZHMgOj0gd29yZCA6OiAhd29yZHM7XG4gICAgQnVmZmVyLmNsZWFyIGJ1ZlxuICBpblxuICBiZWdpblxuICAgIHRyeSB3aGlsZSB0cnVlIGRvXG4gICAgICAgIGxldCBjID0gaW5wdXRfY2hhciBpYyBpblxuICAgICAgICBpZiBjID0gc2VwIHRoZW4gc3Rhc2ggKCkgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgICAgIGRvbmVcbiAgICB3aXRoIEVuZF9vZl9maWxlIC0+ICgpXG4gIGVuZDtcbiAgaWYgQnVmZmVyLmxlbmd0aCBidWYgPiAwIHRoZW4gc3Rhc2ggKCk7XG4gIGNsb3NlX2luIGljO1xuICBBcnJheS5vZl9saXN0IChMaXN0LnJldiAhd29yZHMpXG5cbmxldCByZWFkX2FyZyA9IHJlYWRfYXV4IHRydWUgJ1xcbidcblxubGV0IHJlYWRfYXJnMCA9IHJlYWRfYXV4IGZhbHNlICdcXHgwMCdcblxubGV0IHdyaXRlX2F1eCBzZXAgZmlsZSBhcmdzID1cbiAgbGV0IG9jID0gb3Blbl9vdXRfYmluIGZpbGUgaW5cbiAgQXJyYXkuaXRlciAoZnVuIHMgLT4gZnByaW50ZiBvYyBcIiVzJWNcIiBzIHNlcCkgYXJncztcbiAgY2xvc2Vfb3V0IG9jXG5cbmxldCB3cml0ZV9hcmcgPSB3cml0ZV9hdXggJ1xcbidcblxubGV0IHdyaXRlX2FyZzAgPSB3cml0ZV9hdXggJ1xceDAwJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSBBdG9taWMubWFrZSBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgKEF0b21pYy5nZXQgcHJpbnRlcnMpXG5cbmxldCBkZXN0cnVjdF9leHRfY29uc3RydWN0b3IgeCA9XG4gIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAoKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpLCBOb25lKVxuICBlbHNlXG4gICAgbGV0IGNvbnN0cnVjdG9yID1cbiAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgKGNvbnN0cnVjdG9yLCBTb21lIChmaWVsZHMgeCkpXG5cbmxldCBzdHJpbmdfb2ZfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHQgPVxuICBsZXQgY29uc3RydWN0b3IsIGZpZWxkc19vcHQgPSBkZXN0cnVjdF9leHRfY29uc3RydWN0b3IgdCBpblxuICBtYXRjaCBmaWVsZHNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IGNvbnN0cnVjdG9yXG4gIHwgU29tZSBmIC0+IGNvbnN0cnVjdG9yIF4gZlxuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgc3RyaW5nX29mX2V4dGVuc2lvbl9jb25zdHJ1Y3RvciAoT2JqLnJlcHIgeClcblxubGV0IHRvX3N0cmluZyBlID1cbiAgbWF0Y2ggdXNlX3ByaW50ZXJzIGUgd2l0aFxuICB8IFNvbWUgcyAtPiBzXG4gIHwgTm9uZSAtPiB0b19zdHJpbmdfZGVmYXVsdCBlXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VfZW50cnkgPSBwcml2YXRlIGludFxudHlwZSByYXdfYmFja3RyYWNlID0gcmF3X2JhY2t0cmFjZV9lbnRyeSBhcnJheVxuXG5sZXQgcmF3X2JhY2t0cmFjZV9lbnRyaWVzIGJ0ID0gYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgICAgZGVmbmFtZSAgICAgOiBzdHJpbmc7XG4gICAgfVxuICB8IFVua25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgOiBib29sXG4gICAgfVxuXG4oKiB0byBhdm9pZCB3YXJuaW5nICopXG5sZXQgXyA9IFtLbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2U7IGZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZV9udW1iZXIgPSAwOyBzdGFydF9jaGFyID0gMDsgZW5kX2NoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc19pbmxpbmUgPSBmYWxzZTsgZGVmbmFtZSA9IFwiXCIgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzICVzIGluIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5kZWZuYW1lIGwuZmlsZW5hbWVcbiAgICAgICAgICAgICAgKGlmIGwuaXNfaW5saW5lIHRoZW4gXCIgKGlubGluZWQpXCIgZWxzZSBcIlwiKVxuICAgICAgICAgICAgICBsLmxpbmVfbnVtYmVyIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xufVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24gPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgIFNvbWUge1xuICAgICAgZmlsZW5hbWUgICAgPSBsLmZpbGVuYW1lO1xuICAgICAgbGluZV9udW1iZXIgPSBsLmxpbmVfbnVtYmVyO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX2NoYXI7XG4gICAgfVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfXG4gIHwgS25vd25fbG9jYXRpb24geyBkZWZuYW1lID0gXCJcIiB9IC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IFNvbWUgbC5kZWZuYW1lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IGVudHJ5ID1cbiAgYmFja3RyYWNlX3Nsb3RzIFt8IGVudHJ5IHxdXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuICBsZXQgbmFtZSA9IGJhY2t0cmFjZV9zbG90X2RlZm5hbWVcbmVuZFxuXG5sZXQgcmF3X2JhY2t0cmFjZV9sZW5ndGggYnQgPSBBcnJheS5sZW5ndGggYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QgOlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gcmF3X2JhY2t0cmFjZV9zbG90IG9wdGlvblxuICA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFwiXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOlxuICAgcmV0dXJucyB0aGUgKnN0cmluZyogY29ycmVzcG9uZGluZyB0byB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgZ2V0X2JhY2t0cmFjZSAoKSA9IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxuZXh0ZXJuYWwgcmVjb3JkX2JhY2t0cmFjZTogYm9vbCAtPiB1bml0ID0gXCJjYW1sX3JlY29yZF9iYWNrdHJhY2VcIlxuZXh0ZXJuYWwgYmFja3RyYWNlX3N0YXR1czogdW5pdCAtPiBib29sID0gXCJjYW1sX2JhY2t0cmFjZV9zdGF0dXNcIlxuXG5sZXQgcmVjIHJlZ2lzdGVyX3ByaW50ZXIgZm4gPVxuICBsZXQgb2xkX3ByaW50ZXJzID0gQXRvbWljLmdldCBwcmludGVycyBpblxuICBsZXQgbmV3X3ByaW50ZXJzID0gZm4gOjogb2xkX3ByaW50ZXJzIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBwcmludGVycyBvbGRfcHJpbnRlcnMgbmV3X3ByaW50ZXJzIGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gcmVnaXN0ZXJfcHJpbnRlciBmblxuXG5leHRlcm5hbCBnZXRfY2FsbHN0YWNrOiBpbnQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2tcIlxuXG5sZXQgZXhuX3Nsb3QgeCA9XG4gIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICBpZiBPYmoudGFnIHggPSAwIHRoZW4gT2JqLmZpZWxkIHggMCBlbHNlIHhcblxubGV0IGV4bl9zbG90X2lkIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDEpIDogaW50KVxuXG5sZXQgZXhuX3Nsb3RfbmFtZSB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAwKSA6IHN0cmluZylcblxuZXh0ZXJuYWwgZ2V0X2RlYnVnX2luZm9fc3RhdHVzIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXNcIlxuXG4oKiBEZXNjcmlwdGlvbnMgZm9yIGVycm9ycyBpbiBzdGFydHVwLmguIFNlZSBhbHNvIGJhY2t0cmFjZS5jICopXG5sZXQgZXJyb3JzID0gW3wgXCJcIjtcbiAgKCogRklMRV9OT1RfRk9VTkQgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIG5vdCBmb3VuZClcIjtcbiAgKCogQkFEX0JZVEVDT0RFICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBhcHBlYXJzIHRvIGJlIGNvcnJ1cHQpXCI7XG4gICgqIFdST05HX01BR0lDICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyKVwiO1xuICAoKiBOT19GRFMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGNhbm5vdCBiZSBvcGVuZWQ7XFxuIFxcXG4gICAgICAtLSB0b28gbWFueSBvcGVuIGZpbGVzLiBUcnkgcnVubmluZyB3aXRoIE9DQU1MUlVOUEFSQU09Yj0yKVwiXG58XVxuXG5sZXQgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZSA9XG4gIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICBsZXQgc3RhdHVzID0gZ2V0X2RlYnVnX2luZm9fc3RhdHVzICgpIGluXG4gIGlmIHN0YXR1cyA8IDAgdGhlblxuICAgIHByZXJyX2VuZGxpbmUgZXJyb3JzLihhYnMgc3RhdHVzKTtcbiAgZmx1c2ggc3RkZXJyXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBmblxuXG5sZXQgZW1wdHlfYmFja3RyYWNlIDogcmF3X2JhY2t0cmFjZSA9IFt8IHxdXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtydW50aW1lL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIHRyeVxuICAgICAgIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgd2l0aCBleG4nIC0+XG4gICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbcnVudGltZS9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmxldCBjb25zdCBjIF8gPSBjXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgbmVnYXRlIHAgdiA9IG5vdCAocCB2KVxuXG5leGNlcHRpb24gRmluYWxseV9yYWlzZWQgb2YgZXhuXG5cbmxldCAoKSA9IFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgQEAgZnVuY3Rpb25cbnwgRmluYWxseV9yYWlzZWQgZXhuIC0+IFNvbWUgKFwiRnVuLkZpbmFsbHlfcmFpc2VkOiBcIiBeIFByaW50ZXhjLnRvX3N0cmluZyBleG4pXG58IF8gLT4gTm9uZVxuXG5sZXQgcHJvdGVjdCB+KGZpbmFsbHkgOiB1bml0IC0+IHVuaXQpIHdvcmsgPVxuICBsZXQgZmluYWxseV9ub19leG4gKCkgPVxuICAgIHRyeSBmaW5hbGx5ICgpIHdpdGggZSAtPlxuICAgICAgbGV0IGJ0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIChGaW5hbGx5X3JhaXNlZCBlKSBidFxuICBpblxuICBtYXRjaCB3b3JrICgpIHdpdGhcbiAgfCByZXN1bHQgLT4gZmluYWxseV9ub19leG4gKCkgOyByZXN1bHRcbiAgfCBleGNlcHRpb24gd29ya19leG4gLT5cbiAgICAgIGxldCB3b3JrX2J0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGZpbmFsbHlfbm9fZXhuICgpIDtcbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIHdvcmtfZXhuIHdvcmtfYnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgSmFjcXVlcy1IZW5yaSBKb3VyZGFuLCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUGFyaXMgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYtMjAxNiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlICAgKilcbigqICAgICBldCBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG4gIGZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogaW50O1xufVxuXG50eXBlIGNvbnRyb2wgPSB7XG4gIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIHNwYWNlX292ZXJoZWFkIDogaW50O1xuICB2ZXJib3NlIDogaW50O1xuICBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIHN0YWNrX2xpbWl0IDogaW50O1xuICBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5cbmxldCBldmVudGxvZ19wYXVzZSAoKSA9ICgpXG5sZXQgZXZlbnRsb2dfcmVzdW1lICgpID0gKClcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0LmZvcmNlZF9tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIEF0b21pYy50XG50eXBlIGFsYXJtX3JlYyA9IHthY3RpdmUgOiBhbGFybTsgZiA6IHVuaXQgLT4gdW5pdH1cblxubGV0IHJlYyBjYWxsX2FsYXJtIGFyZWMgPVxuICBpZiBBdG9taWMuZ2V0IGFyZWMuYWN0aXZlIHRoZW4gYmVnaW5cbiAgICBsZXQgZmluYWxseSAoKSA9IGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYyBpblxuICAgIEZ1bi5wcm90ZWN0IH5maW5hbGx5IGFyZWMuZlxuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gQXRvbWljLm1ha2UgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gQXRvbWljLnNldCBhIGZhbHNlXG5cbm1vZHVsZSBNZW1wcm9mID1cbiAgc3RydWN0XG4gICAgdHlwZSBhbGxvY2F0aW9uX3NvdXJjZSA9IE5vcm1hbCB8IE1hcnNoYWwgfCBDdXN0b21cbiAgICB0eXBlIGFsbG9jYXRpb24gPVxuICAgICAgeyBuX3NhbXBsZXMgOiBpbnQ7XG4gICAgICAgIHNpemUgOiBpbnQ7XG4gICAgICAgIHNvdXJjZSA6IGFsbG9jYXRpb25fc291cmNlO1xuICAgICAgICBjYWxsc3RhY2sgOiBQcmludGV4Yy5yYXdfYmFja3RyYWNlIH1cblxuICAgIHR5cGUgKCdtaW5vciwgJ21ham9yKSB0cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3I6IGFsbG9jYXRpb24gLT4gJ21pbm9yIG9wdGlvbjtcbiAgICAgIGFsbG9jX21ham9yOiBhbGxvY2F0aW9uIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBwcm9tb3RlOiAnbWlub3IgLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIGRlYWxsb2NfbWlub3I6ICdtaW5vciAtPiB1bml0O1xuICAgICAgZGVhbGxvY19tYWpvcjogJ21ham9yIC0+IHVuaXQ7XG4gICAgfVxuXG4gICAgbGV0IG51bGxfdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBwcm9tb3RlID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgZGVhbGxvY19taW5vciA9IChmdW4gXyAtPiAoKSk7XG4gICAgICBkZWFsbG9jX21ham9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICB9XG5cbiAgICBleHRlcm5hbCBjX3N0YXJ0IDpcbiAgICAgIGZsb2F0IC0+IGludCAtPiAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgLT4gdW5pdFxuICAgICAgPSBcImNhbWxfbWVtcHJvZl9zdGFydFwiXG5cbiAgICBsZXQgc3RhcnRcbiAgICAgIH5zYW1wbGluZ19yYXRlXG4gICAgICA/KGNhbGxzdGFja19zaXplID0gbWF4X2ludClcbiAgICAgIHRyYWNrZXIgPVxuICAgICAgY19zdGFydCBzYW1wbGluZ19yYXRlIGNhbGxzdGFja19zaXplIHRyYWNrZXJcblxuICAgIGV4dGVybmFsIHN0b3AgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfbWVtcHJvZl9zdG9wXCJcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIGxldCBkbGVuID0gQXJyYXkubGVuZ3RoIGRpbXMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY2xvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMCkgZiAwIGRpbXM7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZmxvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMSkgZiAocHJlZCBkbGVuKSBkaW1zOyBhcnJcblxuICBleHRlcm5hbCBudW1fZGltczogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCJjYW1sX2JhX251bV9kaW1zXCJcbiAgZXh0ZXJuYWwgbnRoX2RpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9iYV9kaW1cIlxuICBsZXQgZGltcyBhID1cbiAgICBsZXQgbiA9IG51bV9kaW1zIGEgaW5cbiAgICBsZXQgZCA9IEFycmF5Lm1ha2UgbiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkbyBkLihpKSA8LSBudGhfZGltIGEgaSBkb25lO1xuICAgIGRcblxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKEFycmF5LmZvbGRfbGVmdCAoICogKSAxIChkaW1zIGFycikpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHNsaWNlX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIHNsaWNlX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuZW5kXG5cbm1vZHVsZSBBcnJheTAgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfHxdXG4gIGxldCBnZXQgYXJyID0gR2VuYXJyYXkuZ2V0IGFyciBbfHxdXG4gIGxldCBzZXQgYXJyID0gR2VuYXJyYXkuc2V0IGFyciBbfHxdXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID0ga2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycilcblxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuXG4gIGxldCBvZl92YWx1ZSBraW5kIGxheW91dCB2ID1cbiAgICBsZXQgYSA9IGNyZWF0ZSBraW5kIGxheW91dCBpblxuICAgIHNldCBhIHY7XG4gICAgYVxuICBsZXQgaW5pdCA9IG9mX3ZhbHVlXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMSB0byBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0gZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0gZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgZm9yIGsgPSAwIHRvIHByZWQgZGltMyBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgayA9IDEgdG8gZGltMyBkb1xuICAgICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDYW1iaXVtLCBDb2xsZWdlIGRlIEZyYW5jZSBhbmQgSW5yaWEgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciAqKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgb3BlbiBCaWdhcnJheVxuXG4gIHR5cGUgdCA9IChpbnQ2NCwgaW50NjRfZWx0LCBjX2xheW91dCkgQXJyYXkxLnRcblxuICBleHRlcm5hbCBuZXh0OiB0IC0+IChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgICA9IFwiY2FtbF9seG1fbmV4dFwiIFwiY2FtbF9seG1fbmV4dF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuICBsZXQgY3JlYXRlICgpIDogdCA9XG4gICAgQXJyYXkxLmNyZWF0ZSBJbnQ2NCBDX2xheW91dCA0XG5cbiAgbGV0IHNldCBzIGkxIGkyIGkzIGk0ID1cbiAgICBBcnJheTEudW5zYWZlX3NldCBzIDAgKEludDY0LmxvZ29yIGkxIDFMKTsgKCogbXVzdCBiZSBvZGQgKilcbiAgICBBcnJheTEudW5zYWZlX3NldCBzIDEgaTI7XG4gICAgQXJyYXkxLnVuc2FmZV9zZXQgcyAyIChpZiBpMyA8PiAwTCB0aGVuIGkzIGVsc2UgMUwpOyAoKiBtdXN0IG5vdCBiZSAwICopXG4gICAgQXJyYXkxLnVuc2FmZV9zZXQgcyAzIChpZiBpNCA8PiAwTCB0aGVuIGk0IGVsc2UgMkwpICgqIG11c3Qgbm90IGJlIDAgKilcblxuICBsZXQgbWsgaTEgaTIgaTMgaTQgPVxuICAgIGxldCBzID0gY3JlYXRlICgpIGluXG4gICAgc2V0IHMgaTEgaTIgaTMgaTQ7IHNcblxuICBsZXQgc2VyaWFsaXphdGlvbl9wcmVmaXggPVxuICAgIFwibHhtMTpcIlxuICAgICgqIFwibHhtXCIgZGVub3RlcyB0aGUgYWxnb3JpdGhtIGN1cnJlbnRseSBpbiB1c2UsIGFuZCAnMScgaXNcbiAgICAgICBhIHZlcnNpb24gbnVtYmVyLiBXZSBzaG91bGQgdXBkYXRlIHRoaXMgcHJlZml4IGlmIHdlIGNoYW5nZVxuICAgICAgIHRoZSBSYW5kb20gYWxnb3JpdGhtIG9yIHRoZSBzZXJpYWxpemF0aW9uIGZvcm1hdCwgc28gdGhhdCB1c2Vyc1xuICAgICAgIGdldCBhIGNsZWFuIGVycm9yIGluc3RlYWQgb2YgYmVsaWV2aW5nIHRoYXQgdGhleSBmYWl0aGZ1bGx5XG4gICAgICAgcmVwcm9kdWNlIHRoZWlyIHByZXZpb3VzIHN0YXRlIGFuZCBpbiBmYWN0IGdldCBhIGRpZmZlcnJlbnRcbiAgICAgICBzdHJlYW0uXG5cbiAgICAgICBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gY29uc3RyYWludCB0byBrZWVwIHRoZSBzYW1lXG4gICAgICAgXCI8bmFtZT48dmVyPjo8ZGF0YT5cIiBmb3JtYXQgb3IgbWVzc2FnZSBzaXplIGluIGZ1dHVyZSB2ZXJzaW9ucyxcbiAgICAgICB3ZSBjb3VsZCBjaGFuZ2UgdGhlIGZvcm1hdCBjb21wbGV0ZWx5IGlmIHdlIHdhbnRlZCBhcyBsb25nXG4gICAgICAgYXMgdGhlcmUgaXMgbm8gY29uZnVzaW9uIHBvc3NpYmxlIHdpdGggdGhlIHByZXZpb3VzIGZvcm1hdHMuICopXG5cbiAgbGV0IHNlcmlhbGl6YXRpb25fcHJlZml4X2xlbiA9XG4gICAgU3RyaW5nLmxlbmd0aCBzZXJpYWxpemF0aW9uX3ByZWZpeFxuXG4gIGxldCB0b19iaW5hcnlfc3RyaW5nIHMgPVxuICAgIGxldCBwcmVmaXggPSBzZXJpYWxpemF0aW9uX3ByZWZpeCBpblxuICAgIGxldCBwcmVmbGVuID0gc2VyaWFsaXphdGlvbl9wcmVmaXhfbGVuIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAocHJlZmxlbiArIDQgKiA4KSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIHByZWZpeCAwIGJ1ZiAwIHByZWZsZW47XG4gICAgZm9yIGkgPSAwIHRvIDMgZG9cbiAgICAgIEJ5dGVzLnNldF9pbnQ2NF9sZSBidWYgKHByZWZsZW4gKyBpICogOCkgKEFycmF5MS5nZXQgcyBpKVxuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcblxuICBsZXQgb2ZfYmluYXJ5X3N0cmluZyBidWYgPVxuICAgIGxldCBwcmVmaXggPSBzZXJpYWxpemF0aW9uX3ByZWZpeCBpblxuICAgIGxldCBwcmVmbGVuID0gc2VyaWFsaXphdGlvbl9wcmVmaXhfbGVuIGluXG4gICAgaWYgU3RyaW5nLmxlbmd0aCBidWYgPD4gcHJlZmxlbiArIDQgKiA4XG4gICAgICAgfHwgbm90IChTdHJpbmcuc3RhcnRzX3dpdGggfnByZWZpeCBidWYpXG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhcbiAgICAgICAgKFwiUmFuZG9tLlN0YXRlLm9mX2JpbmFyeV9zdHJpbmc6IGV4cGVjdGVkIGEgZm9ybWF0IFxcXG4gICAgICAgICAgY29tcGF0aWJsZSB3aXRoIE9DYW1sIFwiIF4gU3lzLm9jYW1sX3ZlcnNpb24pO1xuICAgIGxldCBpMSA9IFN0cmluZy5nZXRfaW50NjRfbGUgYnVmIChwcmVmbGVuICsgMCAqIDgpIGluXG4gICAgbGV0IGkyID0gU3RyaW5nLmdldF9pbnQ2NF9sZSBidWYgKHByZWZsZW4gKyAxICogOCkgaW5cbiAgICBsZXQgaTMgPSBTdHJpbmcuZ2V0X2ludDY0X2xlIGJ1ZiAocHJlZmxlbiArIDIgKiA4KSBpblxuICAgIGxldCBpNCA9IFN0cmluZy5nZXRfaW50NjRfbGUgYnVmIChwcmVmbGVuICsgMyAqIDgpIGluXG4gICAgbWsgaTEgaTIgaTMgaTRcblxuICBsZXQgYXNzaWduIChkc3Q6IHQpIChzcmM6IHQpID1cbiAgICBBcnJheTEuYmxpdCBzcmMgZHN0XG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHMnID0gY3JlYXRlKCkgaW4gYXNzaWduIHMnIHM7IHMnXG5cbiAgKCogVGhlIHNlZWQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMuICBJdCBjYW4gYmUganVzdCBvbmUgaW50ZWdlcixcbiAgICAgYnV0IGl0IGNhbiBhbHNvIGJlIDEyIG9yIG1vcmUgYnl0ZXMuICBUbyBoaWRlIHRoZSBkaWZmZXJlbmNlLFxuICAgICB3ZSBzZXJpYWxpemUgdGhlIGFycmF5IGFzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIHRoZW4gaGFzaCB0aGVcbiAgICAgc2VxdWVuY2Ugd2l0aCBNRDUgKERpZ2VzdC5ieXRlcykuICBNRDUgZ2l2ZXMgb25seSAxMjggYml0cyB3aGlsZVxuICAgICB3ZSBuZWVkIDI1NiBiaXRzLCBzbyB3ZSBoYXNoIHR3aWNlIHdpdGggZGlmZmVyZW50IHN1ZmZpeGVzLiAqKVxuICBsZXQgcmVpbml0IHMgc2VlZCA9XG4gICAgbGV0IG4gPSBBcnJheS5sZW5ndGggc2VlZCBpblxuICAgIGxldCBiID0gQnl0ZXMuY3JlYXRlIChuICogOCArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkb1xuICAgICAgQnl0ZXMuc2V0X2ludDY0X2xlIGIgKGkgKiA4KSAoSW50NjQub2ZfaW50IHNlZWQuKGkpKVxuICAgIGRvbmU7XG4gICAgQnl0ZXMuc2V0IGIgKG4gKiA4KSAnXFx4MDEnO1xuICAgIGxldCBkMSA9IERpZ2VzdC5ieXRlcyBiIGluXG4gICAgQnl0ZXMuc2V0IGIgKG4gKiA4KSAnXFx4MDInO1xuICAgIGxldCBkMiA9IERpZ2VzdC5ieXRlcyBiIGluXG4gICAgc2V0IHMgKFN0cmluZy5nZXRfaW50NjRfbGUgZDEgMClcbiAgICAgICAgICAoU3RyaW5nLmdldF9pbnQ2NF9sZSBkMSA4KVxuICAgICAgICAgIChTdHJpbmcuZ2V0X2ludDY0X2xlIGQyIDApXG4gICAgICAgICAgKFN0cmluZy5nZXRfaW50NjRfbGUgZDIgOClcblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcyA9IGNyZWF0ZSgpIGluIHJlaW5pdCBzIHNlZWQ7IHNcblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPVxuICAgIG1ha2UgKHJhbmRvbV9zZWVkICgpKVxuXG4gICgqIFJldHVybiAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgSW50NjQudG9faW50IChuZXh0IHMpIGxhbmQgMHgzRkZGX0ZGRkZcblxuICAoKiBSZXR1cm4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgKGluY2x1ZGVkKSBhbmQgW2JvdW5kXSAoZXhjbHVkZWQpICopXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cbiAgKCogUmV0dXJuIGFuIGludGVnZXIgYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS5cbiAgICAgW2JvdW5kXSBtYXkgYmUgYW55IHBvc2l0aXZlIFtpbnRdLiAqKVxuICBsZXQgcmVjIGludDYzYXV4IHMgbiA9XG4gICAgbGV0IHIgPSBJbnQ2NC50b19pbnQgKG5leHQgcykgbGFuZCBtYXhfaW50IGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiBtYXhfaW50IC0gbiArIDEgdGhlbiBpbnQ2M2F1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGZ1bGxfaW50IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDAgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJSYW5kb20uZnVsbF9pbnRcIlxuICAgIGVsc2UgaWYgYm91bmQgPiAweDNGRkZGRkZGIHRoZW5cbiAgICAgIGludDYzYXV4IHMgYm91bmRcbiAgICBlbHNlXG4gICAgICBpbnRhdXggcyBib3VuZFxuXG4gICgqIFJldHVybiAzMiByYW5kb20gYml0cyBhcyBhbiBbaW50MzJdICopXG4gIGxldCBiaXRzMzIgcyA9XG4gICAgSW50NjQudG9faW50MzIgKG5leHQgcylcblxuICAoKiBSZXR1cm4gYW4gW2ludDMyXSBiZXR3ZWVuIDAgKGluY2x1ZGVkKSBhbmQgW2JvdW5kXSAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IHIgPSBJbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIChiaXRzMzIgcykgMSBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLihzdWIgciB2ID4gYWRkIChzdWIgbWF4X2ludCBuKSAxbClcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG4gICgqIFJldHVybiA2NCByYW5kb20gYml0cyBhcyBhbiBbaW50NjRdICopXG4gIGxldCBiaXRzNjQgcyA9XG4gICAgbmV4dCBzXG5cbiAgKCogUmV0dXJuIGFuIFtpbnQ2NF0gYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCByID0gSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYml0czY0IHMpIDEgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC4oc3ViIHIgdiA+IGFkZCAoc3ViIG1heF9pbnQgbikgMUwpXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuICAoKiBSZXR1cm4gMzIgb3IgNjQgcmFuZG9tIGJpdHMgYXMgYSBbbmF0aXZlaW50XSAqKVxuICBsZXQgbmF0aXZlYml0cyA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChiaXRzMzIgcylcbiAgICBlbHNlIGZ1biBzIC0+IEludDY0LnRvX25hdGl2ZWludCAoYml0czY0IHMpXG5cbiAgKCogUmV0dXJuIGEgW25hdGl2ZWludF0gYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IG5hdGl2ZWludCA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgYm91bmQgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMiBzIChOYXRpdmVpbnQudG9faW50MzIgYm91bmQpKVxuICAgIGVsc2UgZnVuIHMgYm91bmQgLT4gSW50NjQudG9fbmF0aXZlaW50IChpbnQ2NCBzIChJbnQ2NC5vZl9uYXRpdmVpbnQgYm91bmQpKVxuXG4gICgqIFJldHVybiBhIGZsb2F0IDAgPCB4IDwgMSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgYW1vbmcgdGhlXG4gICAgIG11bHRpcGxlcyBvZiAyXi01MyAqKVxuICBsZXQgcmVjIHJhd2Zsb2F0IHMgPVxuICAgIGxldCBiID0gbmV4dCBzIGluXG4gICAgbGV0IG4gPSBJbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIGIgMTEgaW5cbiAgICBpZiBuIDw+IDBMIHRoZW4gSW50NjQudG9fZmxvYXQgbiAqLiAweDEucC01MyBlbHNlIHJhd2Zsb2F0IHNcblxuICAoKiBSZXR1cm4gYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIFtib3VuZF0gKilcbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgKCogUmV0dXJuIGEgcmFuZG9tIEJvb2xlYW4gKilcbiAgbGV0IGJvb2wgcyA9IG5leHQgcyA8IDBMXG5cbiAgKCogU3BsaXQgYSBuZXcgUFJORyBvZmYgdGhlIGdpdmVuIFBSTkcgKilcbiAgbGV0IHNwbGl0IHMgPVxuICAgIGxldCBpMSA9IGJpdHM2NCBzIGluIGxldCBpMiA9IGJpdHM2NCBzIGluXG4gICAgbGV0IGkzID0gYml0czY0IHMgaW4gbGV0IGk0ID0gYml0czY0IHMgaW5cbiAgICBtayBpMSBpMiBpMyBpNFxuZW5kXG5cbmxldCBta19kZWZhdWx0ICgpID1cbiAgKCogVGhpcyBpcyB0aGUgc3RhdGUgb2J0YWluZWQgd2l0aCBbU3RhdGUubWFrZSBbfCAzMTQxNTkyNjUgfF1dLiAqKVxuICBTdGF0ZS5tayAoLTYxOTY4NzQyODk1Njc3MDUwOTdMKVxuICAgICAgICAgICA1ODY1NzMyNDk4MzM3MTMxODlMXG4gICAgICAgICAgICgtODU5MTI2ODgwMzg2NTA0MzQwN0wpXG4gICAgICAgICAgIDYzODg2MTM1OTU4NDk3NzIwNDRMXG5cbmxldCByYW5kb21fa2V5ID1cbiAgRG9tYWluLkRMUy5uZXdfa2V5IH5zcGxpdF9mcm9tX3BhcmVudDpTdGF0ZS5zcGxpdCBta19kZWZhdWx0XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIGJvdW5kXG5sZXQgZnVsbF9pbnQgYm91bmQgPSBTdGF0ZS5mdWxsX2ludCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBpbnQzMiBib3VuZCA9IFN0YXRlLmludDMyIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IGZsb2F0IHNjYWxlID0gU3RhdGUuZmxvYXQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgYml0czMyICgpID0gU3RhdGUuYml0czMyIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KVxubGV0IGJpdHM2NCAoKSA9IFN0YXRlLmJpdHM2NCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBuYXRpdmViaXRzICgpID0gU3RhdGUubmF0aXZlYml0cyAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUucmVpbml0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIFNwbGl0dGluZyAqKVxuXG5sZXQgc3BsaXQgKCkgPSBTdGF0ZS5zcGxpdCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIHRoZSBsb2FkIGZhY3RvciBiZWNvbWVzIHRvbyBoaWdoLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSBBdG9taWMubWFrZSByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IEF0b21pYy5zZXQgcmFuZG9taXplZCB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9IEF0b21pYy5nZXQgcmFuZG9taXplZFxuXG5sZXQgcHJuZ19rZXkgPSBEb21haW4uRExTLm5ld19rZXkgUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0XG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSBBdG9taWMuZ2V0IHJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPVxuICAgIGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChEb21haW4uRExTLmdldCBwcm5nX2tleSkgZWxzZSAwXG4gIGluXG4gIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxubGV0IGNsZWFyIGggPVxuICBpZiBoLnNpemUgPiAwIHRoZW4gYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBBcnJheS5maWxsIGguZGF0YSAwIChBcnJheS5sZW5ndGggaC5kYXRhKSBFbXB0eVxuICBlbmRcblxubGV0IHJlc2V0IGggPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgICB8fCBsZW4gPSBhYnMgaC5pbml0aWFsX3NpemUgdGhlblxuICAgIGNsZWFyIGhcbiAgZWxzZSBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIChhYnMgaC5pbml0aWFsX3NpemUpIEVtcHR5XG4gIGVuZFxuXG5sZXQgY29weV9idWNrZXRsaXN0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBFbXB0eVxuICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGxldCByZWMgbG9vcCBwcmVjID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBDb25zIHByZWMgLT4gIHByZWMubmV4dCA8LSByXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBsb29wIHIgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgbG9vcCByIG5leHQ7XG4gICAgICByXG5cbmxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkubWFwIGNvcHlfYnVja2V0bGlzdCBoLmRhdGEgfVxuXG5sZXQgbGVuZ3RoIGggPSBoLnNpemVcblxubGV0IGluc2VydF9hbGxfYnVja2V0cyBpbmRleGZ1biBpbnBsYWNlIG9kYXRhIG5kYXRhID1cbiAgbGV0IG5zaXplID0gQXJyYXkubGVuZ3RoIG5kYXRhIGluXG4gIGxldCBuZGF0YV90YWlsID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgaWYgaW5wbGFjZSB0aGVuIGNlbGxcbiAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICBpblxuICAgICAgICBsZXQgbmlkeCA9IGluZGV4ZnVuIGtleSBpblxuICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gbmRhdGEuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICBlbmQ7XG4gICAgICAgIG5kYXRhX3RhaWwuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9kYXRhIC0gMSBkb1xuICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gIGRvbmU7XG4gIGlmIGlucGxhY2UgdGhlblxuICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgIG1hdGNoIG5kYXRhX3RhaWwuKGkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgIGRvbmVcblxubGV0IHJlc2l6ZSBpbmRleGZ1biBoID1cbiAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBpbnBsYWNlID0gbm90IChvbmdvaW5nX3RyYXZlcnNhbCBoKSBpblxuICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgICAgKCogc28gdGhhdCBpbmRleGZ1biBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgaW5zZXJ0X2FsbF9idWNrZXRzIChpbmRleGZ1biBoKSBpbnBsYWNlIG9kYXRhIG5kYXRhXG4gIGVuZFxuXG5sZXQgaXRlciBmIGggPVxuICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICAoKVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGYga2V5IGRhdGE7IGRvX2J1Y2tldCBuZXh0IGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IHJlYyBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIEVtcHR5XG4gICAgICBlbmRcbiAgfCAoQ29ucyAoe2tleTsgZGF0YTsgbmV4dH0gYXMgYykpIGFzIHNsb3QgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGYga2V5IGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjIG5leHRcbiAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIHNsb3RcbiAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gc2xvdFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBjLmRhdGEgPC0gZGF0YTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHNsb3QgbmV4dFxuICAgICAgZW5kXG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgRW1wdHkgaC5kYXRhLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzZWVkZWRfaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IGtleSBuZXh0XG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIG1lbV9pbl9idWNrZXQga2V5IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgICBsZXQgdG9fc2VxID0gdG9fc2VxXG4gICAgbGV0IHRvX3NlcV9rZXlzID0gdG9fc2VxX2tleXNcbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyA9IHRvX3NlcV92YWx1ZXNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IHNlZWRlZF9oYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgcmVjIG1lbV9pbl9idWNrZXQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBrZXkgbmV4dFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbWVtX2luX2J1Y2tldCBrZXkgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxubGV0IHJlYnVpbGQgPyhyYW5kb20gPSBBdG9taWMuZ2V0IHJhbmRvbWl6ZWQpIGggPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIGluXG4gIGxldCBzZWVkID1cbiAgICBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoRG9tYWluLkRMUy5nZXQgcHJuZ19rZXkpXG4gICAgZWxzZSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguc2VlZFxuICAgIGVsc2UgMCBpblxuICBsZXQgaCcgPSB7XG4gICAgc2l6ZSA9IGguc2l6ZTtcbiAgICBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5O1xuICAgIHNlZWQgPSBzZWVkO1xuICAgIGluaXRpYWxfc2l6ZSA9IGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5pbml0aWFsX3NpemUgZWxzZSBzXG4gIH0gaW5cbiAgaW5zZXJ0X2FsbF9idWNrZXRzIChrZXlfaW5kZXggaCcpIGZhbHNlIGguZGF0YSBoJy5kYXRhO1xuICBoJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgISdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyXG4gKiAgICAtIExpbmtcbiAqICAgIC0gRGF0YSAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMiAoKiBDQU1MX0VQSEVfRklSU1RfS0VZIGluIHdlYWsuaCAqKVxuXG5sZXQgY3JlYXRlIGwgPVxuICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IE9iai5FcGhlbWVyb24ubWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgaW52YWxpZF9hcmcoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgY3JlYXRlIGxcblxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgaW52YWxpZF9hcmcobXNnKVxuXG5leHRlcm5hbCBzZXQnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuZXh0ZXJuYWwgdW5zZXQgOiAnYSB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbmxldCBzZXQgZSBvIHggPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLnNldFwiO1xuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHVuc2V0IGUgb1xuICB8IFNvbWUgeCAtPiBzZXQnIGUgbyB4XG5cbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5sZXQgZ2V0IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0XCI7XG4gIGdldCBlIG9cblxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5sZXQgZ2V0X2NvcHkgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRfY29weVwiO1xuICBnZXRfY29weSBlIG9cblxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxubGV0IGNoZWNrIGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuY2hlY2tcIjtcbiAgY2hlY2sgZSBvXG5cbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5sZXQgYmxpdCBlMSBvMSBlMiBvMiBsID1cbiAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXZWFrLmJsaXRcIlxuICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXQgZTEgbzEgZTIgbzIgbFxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGFyIC0gbGVuXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhY2MgLT4gJ2FjYykgLT4gdCAtPiAnYWNjIC0+ICdhY2NcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IEludC5taW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIEludC5taW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cbiAgKCogR2VuZXJhbCBhdXhpbGlhcnkgZnVuY3Rpb24gZm9yIHNlYXJjaGluZyBmb3IgYSBwYXJ0aWN1bGFyIHZhbHVlXG4gICAqIGluIGEgaGFzaC1zZXQsIGFuZCBhY3RpbmcgYWNjb3JkaW5nIHRvIHdoZXRoZXIgb3Igbm90IGl0J3MgZm91bmQgKilcblxuICBsZXQgZmluZF9hdXggdCBkIGZvdW5kIG5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IGFzIG9wdCB3aGVuIEguZXF1YWwgdiBkIC0+IGZvdW5kIGJ1Y2tldCBpIG9wdCB2XG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9IGZpbmRfYXV4IHQgZCAoZnVuIF9iIF9pICBvIF92IC0+IG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biBfaCBfaSAtPiBOb25lKVxuXG4gIGxldCBtZXJnZSB0IGQgICAgPSBmaW5kX2F1eCB0IGQgKGZ1biBfYiBfaSBfbyAgdiAtPiB2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gIGggIGkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaTsgZClcblxuICBsZXQgZmluZCB0IGQgICAgID0gZmluZF9hdXggdCBkIChmdW4gX2IgX2kgX28gIHYgLT4gdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIF9oIF9pIC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgcmVtb3ZlIHQgZCAgID0gZmluZF9hdXggdCBkIChmdW4gIGIgIGkgX28gX3YgLT4gc2V0IGIgaSBOb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gX2ggX2kgLT4gKCkpXG5cbiAgbGV0IG1lbSB0IGQgICAgICA9IGZpbmRfYXV4IHQgZCAoZnVuIF9iIF9pIF9vIF92IC0+IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biBfaCBfaSAtPiBmYWxzZSlcblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxubGV0IGlkIHggPSB4XG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG5tb2R1bGUgU2l6ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgdW5rbm93biA6IHRcbiAgdmFsIGlzX2tub3duIDogdCAtPiBib29sXG5lbmQgID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgPSBpZFxuICBsZXQgb2ZfaW50ID0gaWRcbiAgbGV0IHplcm8gPSAwXG4gIGxldCB1bmtub3duID0gLTFcbiAgbGV0IGlzX2tub3duIG4gPSBuID49IDBcbmVuZFxuXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgeyAgICAgICAgICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgICAgIGZpdHM6IHN0cmluZyAqIGludCAqIHN0cmluZzsgICAoKiBsaW5lIGlzIG5vdCBzcGxpdCAqKVxuICAgICAgYnJlYWtzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICgqIGxpbmUgaXMgc3BsaXQgKilcbiAgICB9XG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiBzdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgc3RhZyA9IC4uXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cbnR5cGUgdGFnID0gc3RyaW5nXG50eXBlIHN0YWcgKz0gU3RyaW5nX3RhZyBvZiB0YWdcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBzaXplIDogU2l6ZS50O1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBRdWV1ZS50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IHtcbiAgbGVmdF90b3RhbCA6IGludDsgKCogVmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IHdhcyBlbnF1ZXVlZC4gKilcbiAgcXVldWVfZWxlbSA6IHBwX3F1ZXVlX2VsZW1cbn1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0geyBib3hfdHlwZSA6IGJveF90eXBlOyB3aWR0aCA6IGludCB9XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuICBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9lbGVtIFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrLiAqKVxuICBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfZWxlbSBTdGFjay50O1xuICBwcF90Ym94X3N0YWNrIDogdGJveCBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjay4gKilcbiAgcHBfdGFnX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICBwcF9tYXJrX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogc3RhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbiA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgdG9rZW4ubGVuZ3RoO1xuICBRdWV1ZS5hZGQgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIFF1ZXVlLmNsZWFyIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIEZvcm1hdCBhIHRleHR1YWwgdG9rZW4gKilcbmxldCBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHRleHQgPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHRleHQ7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbigqIEZvcm1hdCBhIHN0cmluZyBieSBpdHMgbGVuZ3RoLCBpZiBub3QgZW1wdHkgKilcbmxldCBmb3JtYXRfc3RyaW5nIHN0YXRlIHMgPVxuICBpZiBzIDw+IFwiXCIgdGhlbiBmb3JtYXRfcHBfdGV4dCBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSAoYmVmb3JlLCBvZmZzZXQsIGFmdGVyKSB3aWR0aCA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gSW50Lm1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIDAsIFwiXCIpIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoYmVmb3JlLCB3aWR0aCwgYWZ0ZXIpID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoO1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2ZpdHMgfCBQcF9oYm94IC0+ICgpXG4gICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnRha2Vfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHByaW50X2lmX25ld2xpbmUgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3QgcHJpbnRpbmcgY29tbWFuZCAqKVxuICB8IFNvbWUgeyBzaXplOyBsZW5ndGg7IF8gfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbmd0aDtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBTaXplLnRvX2ludCBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSBzXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IHdpZHRoID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBib3hfdHlwZSA9XG4gICAgICBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzIGluXG4gICAgU3RhY2sucHVzaCB7IGJveF90eXBlOyB3aWR0aCB9IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIFN0YWNrLnB1c2ggdGJveCBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgW10gLT4gaW5zZXJ0aW9uX3BvaW50XG4gICAgICAgIHwgZmlyc3QgOjogXyAtPlxuICAgICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGhlYWQgOjogdGFpbCAtPlxuICAgICAgICAgICAgICBpZiBoZWFkID49IGluc2VydGlvbl9wb2ludCB0aGVuIGhlYWQgZWxzZSBmaW5kIHRhaWxcbiAgICAgICAgICAgIHwgW10gLT4gZmlyc3QgaW5cbiAgICAgICAgICBmaW5kICF0YWJzIGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKFwiXCIsIG9mZnNldCArIG4sIFwiXCIpXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCB0YWIgKyBvZmYsIFwiXCIpIHN0YXRlLnBwX21hcmdpblxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgd2lkdGg7IF99IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IC0+XG4gICAgbGV0IGJlZm9yZSwgb2ZmLCBfID0gYnJlYWtzIGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHMgZWxzZVxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXJcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCByZWMgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgbWF0Y2ggUXVldWUucGVla19vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogTm8gdG9rZW5zIHRvIHByaW50ICopXG4gIHwgU29tZSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSAtPlxuICAgIGxldCBwZW5kaW5nX2NvdW50ID0gc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIGluXG4gICAgaWYgU2l6ZS5pc19rbm93biBzaXplIHx8IHBlbmRpbmdfY291bnQgPj0gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIGJlZ2luXG4gICAgICBRdWV1ZS50YWtlIHN0YXRlLnBwX3F1ZXVlIHw+IGlnbm9yZTsgKCogTm90IGVtcHR5OiB3ZSBwZWVrIGludG8gaXQgKilcbiAgICAgIGxldCBzaXplID0gaWYgU2l6ZS5pc19rbm93biBzaXplIHRoZW4gU2l6ZS50b19pbnQgc2l6ZSBlbHNlIHBwX2luZmluaXR5IGluXG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSB0b2tlbjtcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuZ3RoICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIChhZHZhbmNlX2xlZnQgW0B0YWlsY2FsbF0pIHN0YXRlXG4gICAgZW5kXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZTsgdG9rZW4gPSBQcF90ZXh0IHM7IGxlbmd0aCA9IFNpemUudG9faW50IHNpemUgfVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKFNpemUub2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhY2sgPVxuICBTdGFjay5jbGVhciBzdGFjaztcbiAgbGV0IHF1ZXVlX2VsZW0gPSB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfdGV4dCBcIlwiOyBsZW5ndGggPSAwIH0gaW5cbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAtMTsgcXVldWVfZWxlbSB9IHN0YWNrXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuICB8IFNvbWUgeyBsZWZ0X3RvdGFsOyBxdWV1ZV9lbGVtIH0gLT5cbiAgICBsZXQgc2l6ZSA9IFNpemUudG9faW50IHF1ZXVlX2VsZW0uc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdGFsIDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuXG4gICAgICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFja1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIHF1ZXVlX2VsZW0udG9rZW4gd2l0aFxuICAgICAgfCBQcF9icmVhayBfIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rZW4gPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgbGV0IGVsZW0gPSB7IGxlZnRfdG90YWwgPSBzdGF0ZS5wcF9yaWdodF90b3RhbDsgcXVldWVfZWxlbSA9IHRva2VuIH0gaW5cbiAgU3RhY2sucHVzaCBlbGVtIHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KTsgbGVuZ3RoID0gMCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwIH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl9zdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIGxldCB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuOyBsZW5ndGggPSAwIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfY2xvc2VfdGFnOyBsZW5ndGggPSAwIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICAgIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWVcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV9zdGFnIHN0YXRlICgpKSBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB+ZW5kX3dpdGhfbmV3bGluZSA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgZW5kX3dpdGhfbmV3bGluZSB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChTaXplLm9mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxubGV0IHBwX3ByaW50X2J5dGVzIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoQnl0ZXMubGVuZ3RoIHMpIChCeXRlcy50b19zdHJpbmcgcylcblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgfmVuZF93aXRoX25ld2xpbmU6dHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB+ZW5kX3dpdGhfbmV3bGluZTpmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBJbnQubWF4IChJbnQubWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG4oKiogR2VvbWV0cnkgZnVuY3Rpb25zIGFuZCB0eXBlcyAqKVxudHlwZSBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDppbnQ7IG1hcmdpbjogaW50fVxuXG5sZXQgdmFsaWRhdGVfZ2VvbWV0cnkge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBpZiBtYXhfaW5kZW50IDwgMiB0aGVuXG4gICAgRXJyb3IgXCJtYXhfaW5kZW50IDwgMlwiXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgIEVycm9yIFwibWFyZ2luIDw9IG1heF9pbmRlbnRcIlxuICBlbHNlIE9rICgpXG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBPayAoKSAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG5sZXQgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjtcbiAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudDtcbiAgKClcblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogXCIgXiBtc2cpKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBfbXNnIC0+XG4gICAgICgpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG5sZXQgcHBfdXBkYXRlX2dlb21ldHJ5IHN0YXRlIHVwZGF0ZSA9XG4gIGxldCBnZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSBpblxuICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSAodXBkYXRlIGdlb21ldHJ5KVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbU3RkbGliLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1N0ZGxpYi5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG4oKiBJbml0aWFsaXNlIGRvbWFpbiBsb2NhbCBzdGF0ZSAqKVxubW9kdWxlIERMUyA9IERvbWFpbi5ETFNcblxubGV0IHN0ZGJ1Zl9rZXkgPSBETFMubmV3X2tleSBwcF9tYWtlX2J1ZmZlclxubGV0IF8gPSBETFMuc2V0IHN0ZGJ1Zl9rZXkgc3RkYnVmXG5cbmxldCBzdHJfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgZm9ybWF0dGVyX29mX2J1ZmZlciAoRExTLmdldCBzdGRidWZfa2V5KSlcbmxldCBfID0gRExTLnNldCBzdHJfZm9ybWF0dGVyX2tleSBzdHJfZm9ybWF0dGVyXG5cbmxldCBidWZmZXJlZF9vdXRfc3RyaW5nIGtleSBzdHIgb2ZzIGxlbiA9XG4gIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIChEb21haW4uRExTLmdldCBrZXkpIHN0ciBvZnMgbGVuXG5cbmxldCBidWZmZXJlZF9vdXRfZmx1c2ggb2Mga2V5ICgpID1cbiAgbGV0IGJ1ZiA9IERvbWFpbi5ETFMuZ2V0IGtleSBpblxuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgbGV0IHN0ciA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgb3V0cHV0X3N1YnN0cmluZyBvYyBzdHIgMCBsZW4gO1xuICBTdGRsaWIuZmx1c2ggb2M7XG4gIEJ1ZmZlci5jbGVhciBidWZcblxubGV0IHN0ZF9idWZfa2V5ID0gRG9tYWluLkRMUy5uZXdfa2V5IChmdW4gKCkgLT4gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZSlcbmxldCBlcnJfYnVmX2tleSA9IERvbWFpbi5ETFMubmV3X2tleSAoZnVuICgpIC0+IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemUpXG5cbmxldCBzdGRfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgbGV0IHBwZiA9XG4gICAgcHBfbWFrZV9mb3JtYXR0ZXIgKGJ1ZmZlcmVkX291dF9zdHJpbmcgc3RkX2J1Zl9rZXkpXG4gICAgICAoYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRvdXQgc3RkX2J1Zl9rZXkpIGlnbm9yZSBpZ25vcmUgaWdub3JlXG4gIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgRG9tYWluLmF0X2V4aXQgKHBwX3ByaW50X2ZsdXNoIHBwZik7XG4gIHBwZilcbmxldCBfID0gRExTLnNldCBzdGRfZm9ybWF0dGVyX2tleSBzdGRfZm9ybWF0dGVyXG5cbmxldCBlcnJfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgbGV0IHBwZiA9XG4gICAgcHBfbWFrZV9mb3JtYXR0ZXIgKGJ1ZmZlcmVkX291dF9zdHJpbmcgZXJyX2J1Zl9rZXkpXG4gICAgICAoYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRlcnIgZXJyX2J1Zl9rZXkpIGlnbm9yZSBpZ25vcmUgaWdub3JlXG4gIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgRG9tYWluLmF0X2V4aXQgKHBwX3ByaW50X2ZsdXNoIHBwZik7XG4gIHBwZilcbmxldCBfID0gRExTLnNldCBlcnJfZm9ybWF0dGVyX2tleSBlcnJfZm9ybWF0dGVyXG5cbmxldCBnZXRfc3RkX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfZXJyX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgZXJyX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfc3RyX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgc3RyX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfc3RkYnVmICgpID0gRExTLmdldCBzdGRidWZfa2V5XG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgfmVuZF93aXRoX25ld2xpbmU6ZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID1cbiAgbGV0IHN0ZGJ1ZiA9IERMUy5nZXQgc3RkYnVmX2tleSBpblxuICBsZXQgc3RyX2Zvcm1hdHRlciA9IERMUy5nZXQgc3RyX2Zvcm1hdHRlcl9rZXkgaW5cbiAgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG5sZXQgbWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBvdXRwdXQnID0gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGluXG4gICAgbGV0IGZsdXNoJyAoKSA9XG4gICAgICBvdXRwdXQgKEJ1ZmZlci5jb250ZW50cyBidWYpIDAgKEJ1ZmZlci5sZW5ndGggYnVmKTtcbiAgICAgIEJ1ZmZlci5jbGVhciBidWY7XG4gICAgICBmbHVzaCAoKVxuICAgIGluXG4gICAgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0JyBmbHVzaCcpXG5cbmxldCBzeW5jaHJvbml6ZWRfZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggdiA9IHBwX29wZW5faGJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fdmJveCB2ID0gcHBfb3Blbl92Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Blbl9odmJveCB2ID0gcHBfb3Blbl9odmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5faG92Ym94IHYgPSBwcF9vcGVuX2hvdmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fYm94IHYgPSBwcF9vcGVuX2JveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGNsb3NlX2JveCB2ID0gcHBfY2xvc2VfYm94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Blbl9zdGFnIHYgPSBwcF9vcGVuX3N0YWcgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV9zdGFnIHYgPSBwcF9jbG9zZV9zdGFnIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYXMgdiB3ID0gcHBfcHJpbnRfYXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHYgd1xuYW5kIHByaW50X3N0cmluZyB2ID0gcHBfcHJpbnRfc3RyaW5nIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYnl0ZXMgdiA9IHBwX3ByaW50X2J5dGVzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfaW50IHYgPSBwcF9wcmludF9pbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9mbG9hdCB2ID0gcHBfcHJpbnRfZmxvYXQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9jaGFyIHYgPSBwcF9wcmludF9jaGFyIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYm9vbCB2ID0gcHBfcHJpbnRfYm9vbCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2JyZWFrIHYgdyA9IHBwX3ByaW50X2JyZWFrIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2IHdcbmFuZCBwcmludF9jdXQgdiA9IHBwX3ByaW50X2N1dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X3NwYWNlIHYgPSBwcF9wcmludF9zcGFjZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGZvcmNlX25ld2xpbmUgdiA9IHBwX2ZvcmNlX25ld2xpbmUgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9mbHVzaCB2ID0gcHBfcHJpbnRfZmx1c2ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9uZXdsaW5lIHYgPSBwcF9wcmludF9uZXdsaW5lIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfaWZfbmV3bGluZSB2ID0gcHBfcHJpbnRfaWZfbmV3bGluZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgb3Blbl90Ym94IHYgPSBwcF9vcGVuX3Rib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV90Ym94IHYgPSBwcF9jbG9zZV90Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfdGJyZWFrIHYgdyA9IHBwX3ByaW50X3RicmVhayAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5cbmFuZCBzZXRfdGFiIHYgPSBwcF9zZXRfdGFiIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfdGFiIHYgPSBwcF9wcmludF90YWIgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9tYXJnaW4gdiA9IHBwX3NldF9tYXJnaW4gKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWFyZ2luIHYgPSBwcF9nZXRfbWFyZ2luIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfbWF4X2luZGVudCB2ID0gcHBfc2V0X21heF9pbmRlbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWF4X2luZGVudCB2ID0gcHBfZ2V0X21heF9pbmRlbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9nZW9tZXRyeSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgcHBfc2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB+bWF4X2luZGVudCB+bWFyZ2luXG5hbmQgc2FmZV9zZXRfZ2VvbWV0cnkgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIHBwX3NhZmVfc2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB+bWF4X2luZGVudCB+bWFyZ2luXG5hbmQgZ2V0X2dlb21ldHJ5IHYgPSBwcF9nZXRfZ2VvbWV0cnkgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCB1cGRhdGVfZ2VvbWV0cnkgdiA9IHBwX3VwZGF0ZV9nZW9tZXRyeSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X21heF9ib3hlcyB2ID0gcHBfc2V0X21heF9ib3hlcyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9tYXhfYm94ZXMgdiA9IHBwX2dldF9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBvdmVyX21heF9ib3hlcyB2ID0gcHBfb3Zlcl9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0IHYgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9lbGxpcHNpc190ZXh0IHYgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCB2ID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgdiA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHYgdyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgdiA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X3ByaW50X3RhZ3MgdiA9XG4gIHBwX3NldF9wcmludF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X3ByaW50X3RhZ3MgdiA9XG4gIHBwX2dldF9wcmludF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X21hcmtfdGFncyB2ID1cbiAgcHBfc2V0X21hcmtfdGFncyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9tYXJrX3RhZ3MgdiA9XG4gIHBwX2dldF9tYXJrX3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBzZXRfdGFncyB2ID1cbiAgcHBfc2V0X3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxubGV0IHBwX3ByaW50X2l0ZXIgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIGl0ZXIgcHBfdiBwcGYgdiA9XG4gIGxldCBpc19maXJzdCA9IHJlZiB0cnVlIGluXG4gIGxldCBwcF92IHYgPVxuICAgIGlmICFpc19maXJzdCB0aGVuIGlzX2ZpcnN0IDo9IGZhbHNlIGVsc2UgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF92IHBwZiB2XG4gIGluXG4gIGl0ZXIgcHBfdiB2XG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiB2ID1cbiAgcHBfcHJpbnRfaXRlciB+cHBfc2VwIExpc3QuaXRlciBwcF92IHBwZiB2XG5cbigqIFRvIGZvcm1hdCBhbiBhcnJheSAqKVxubGV0IHBwX3ByaW50X2FycmF5ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiB2ID1cbiAgcHBfcHJpbnRfaXRlciB+cHBfc2VwIEFycmF5Lml0ZXIgcHBfdiBwcGYgdlxuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgcHBfcHJpbnRfaXRlciB+cHBfc2VwIFNlcS5pdGVyIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG5sZXQgcHBfcHJpbnRfZWl0aGVyIH5sZWZ0IH5yaWdodCBwcGYgPSBmdW5jdGlvblxufCBFaXRoZXIuTGVmdCBsIC0+IGxlZnQgcHBmIGxcbnwgRWl0aGVyLlJpZ2h0IHIgLT4gcmlnaHQgcHBmIHJcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2Vfc3RhZyBwcGYgKClcbiAgfCBCcmVhayAoXywgd2lkdGgsIG9mZnNldCkgIC0+IHBwX3ByaW50X2JyZWFrIHBwZiB3aWR0aCBvZmZzZXRcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2ZsdXNoIHBwZiAoKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX3ByaW50X25ld2xpbmUgcHBmICgpXG4gIHwgTWFnaWNfc2l6ZSAoXywgXykgICAgICAgICAtPiAoKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnJSdcbiAgfCBTY2FuX2luZGljIGMgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJzsgcHBfcHJpbnRfY2hhciBwcGYgY1xuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYub3V0cHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIChmICgpKTtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqXG5cbiAgRGVmaW5pbmcgW2ZwcmludGZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW2ZwcmludGZdLlxuXG4qKVxuXG5sZXQga2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgcHBmIGFjYzsgayBwcGYpXG4gICAgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGlmcHJpbnRmIF9wcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgaWdub3JlICgpIGZtdFxuXG5sZXQgZnByaW50ZiBwcGYgPSBrZnByaW50ZiBpZ25vcmUgcHBmXG5cbmxldCBwcmludGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIGFjYylcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgZXByaW50ZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyAoRExTLmdldCBlcnJfZm9ybWF0dGVyX2tleSkgYWNjKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSAoKTtcbiAgcHBfcHJpbnRfZmx1c2ggKERMUy5nZXQgZXJyX2Zvcm1hdHRlcl9rZXkpICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG5sZXQgKCkgPSBEb21haW4uYmVmb3JlX2ZpcnN0X3NwYXduIChmdW4gKCkgLT5cbiAgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKTtcbiAgbGV0IGZzID0gcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXIgKCkgaW5cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiAgICB7ZnMgd2l0aCBvdXRfc3RyaW5nID0gYnVmZmVyZWRfb3V0X3N0cmluZyBzdGRfYnVmX2tleTtcbiAgICAgICAgICAgICBvdXRfZmx1c2ggPSBidWZmZXJlZF9vdXRfZmx1c2ggU3RkbGliLnN0ZG91dCBzdGRfYnVmX2tleX07XG5cbiAgbGV0IGZzID0gcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIGVycl9mb3JtYXR0ZXIgKCkgaW5cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIGVycl9mb3JtYXR0ZXJcbiAgICB7ZnMgd2l0aCBvdXRfc3RyaW5nID0gYnVmZmVyZWRfb3V0X3N0cmluZyBlcnJfYnVmX2tleTtcbiAgICAgICAgICAgICBvdXRfZmx1c2ggPSBidWZmZXJlZF9vdXRfZmx1c2ggU3RkbGliLnN0ZGVyciBlcnJfYnVmX2tleX07XG4pXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgU3RkbGliLmZvcm1hdDZcbiAgIGFuZCBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuXG4gICAodGhlIGZvcm1lciBpcyBpbiBmYWN0IGFuIGFsaWFzIGZvciB0aGUgbGF0dGVyLFxuICAgIGJ1dCB0aGUgYW1iaWd1aXR5IHdhcm5pbmcgZG9lc24ndCBjYXJlKVxuKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgU3RkbGliLmZvcm1hdDZcblxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2Nhbm5lcnMuICopXG5cbigqIFNjYW5uaW5nIGJ1ZmZlcnMuICopXG5tb2R1bGUgdHlwZSBTQ0FOTklORyA9IHNpZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbFxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHZhbCBzdGRpbiA6IGluX2NoYW5uZWxcbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIG5leHRfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcubmV4dF9jaGFyIGliXSBhZHZhbmNlIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIuXG4gICAgIElmIG5vIG1vcmUgY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGEgZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGludmFsaWRhdGVfY3VycmVudF9jaGFyIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYl0gbWFyayB0aGUgY3VycmVudF9jaGFyIGFzIGFscmVhZHlcbiAgICAgc2Nhbm5lZC4gKilcblxuICB2YWwgcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5wZWVrX2NoYXIgaWJdIHJldHVybnMgdGhlIGN1cnJlbnQgY2hhciBhdmFpbGFibGUgaW5cbiAgICAgdGhlIGJ1ZmZlciBvciByZWFkcyBvbmUgaWYgbmVjZXNzYXJ5ICh3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpc1xuICAgICBhbHJlYWR5IHNjYW5uZWQpLlxuICAgICBJZiBubyBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYW4gZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGNoZWNrZWRfcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFNhbWUgYXMgW1NjYW5uaW5nLnBlZWtfY2hhcl0gYWJvdmUgYnV0IGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgY2hhciBvclxuICAgICBmYWlsczogaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBudWxsIGNoYXIgd2hlbiB0aGUgcmVhZGluZyBtZXRob2Qgb2YgdGhlXG4gICAgIGlucHV0IGJ1ZmZlciBoYXMgcmVhY2hlZCBhbiBlbmQgb2YgZmlsZSwgdGhlIGZ1bmN0aW9uIHJhaXNlcyBleGNlcHRpb25cbiAgICAgW0VuZF9vZl9maWxlXS4gKilcblxuICB2YWwgc3RvcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGNoYXIgLT4gaW50XG4gICgqIFtTY2FubmluZy5zdG9yZV9jaGFyIGxpbSBpYiBjXSBhZGRzIFtjXSB0byB0aGUgdG9rZW4gYnVmZmVyXG4gICAgIG9mIHRoZSBzY2FubmluZyBidWZmZXIgW2liXS4gSXQgYWxzbyBhZHZhbmNlcyB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyIGFuZCByZXR1cm5zIFtsaW0gLSAxXSwgaW5kaWNhdGluZyB0aGUgbmV3IGxpbWl0IGZvciB0aGVcbiAgICAgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHRva2VuLiAqKVxuXG4gIHZhbCBza2lwX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnNraXBfY2hhciBsaW0gaWJdIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLiAqKVxuXG4gIHZhbCBpZ25vcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuaWdub3JlX2NoYXIgaWIgbGltXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3RlciBhbmRcbiAgICAgZGVjcmVtZW50cyB0aGUgbGltaXQuICopXG5cbiAgdmFsIHRva2VuIDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLnRva2VuIGliXSByZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGludG8gdGhlIHRva2VuXG4gICAgIGJ1ZmZlciBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyOiBpdCByZXR1cm5zIHRoZSB0b2tlbiBtYXRjaGVkIGJ5IHRoZVxuICAgICBmb3JtYXQuICopXG5cbiAgdmFsIHJlc2V0X3Rva2VuIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5yZXNldF90b2tlbiBpYl0gcmVzZXRzIHRoZSB0b2tlbiBidWZmZXIgb2ZcbiAgICAgdGhlIGdpdmVuIHNjYW5uaW5nIGJ1ZmZlci4gKilcblxuICB2YWwgY2hhcl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5jaGFyX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGxpbmVfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcubGluZV9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5ldyBsaW5lXG4gICAgIGNoYXJhY3RlcnMgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCB0b2tlbl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy50b2tlbl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRva2VucyByZWFkXG4gICAgIHNvIGZhciBmcm9tIFtpYl0uICopXG5cbiAgdmFsIGVvZiA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW9mIGliXSByZXR1cm5zIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGVuZF9vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyIChpZiBubyBjaGFyIGhhcyBldmVyIGJlZW4gcmVhZCwgYW4gYXR0ZW1wdCB0b1xuICAgICByZWFkIG9uZSBpcyBwZXJmb3JtZWQpLiAqKVxuXG4gIHZhbCBiZWdpbm5pbmdfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmJlZ2lubmluZ19vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGJlZ2lubmluZyBvZiBpbnB1dFxuICAgICBjb25kaXRpb24gb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbmFtZV9vZl9pbnB1dCA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy5uYW1lX29mX2lucHV0IGliXSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgc291cmNlIGZvciBpbnB1dCBidWZmZXIgW2liXS4gKilcblxuICB2YWwgb3Blbl9pbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBvcGVuX2luX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGUgOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX3N0cmluZyA6IHN0cmluZyAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2Z1bmN0aW9uIDogKHVuaXQgLT4gY2hhcikgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9maWxlIG9mIGZpbGVfbmFtZSAqIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2Z1bmN0aW9uXG4gICAgfCBGcm9tX3N0cmluZ1xuXG5cbiAgdHlwZSBpbl9jaGFubmVsID0ge1xuICAgIG11dGFibGUgaWNfZW9mIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhciA6IGNoYXI7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgOiBib29sO1xuICAgIG11dGFibGUgaWNfY2hhcl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2xpbmVfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY190b2tlbl9jb3VudCA6IGludDtcbiAgICBpY19nZXRfbmV4dF9jaGFyIDogdW5pdCAtPiBjaGFyO1xuICAgIGljX3Rva2VuX2J1ZmZlciA6IEJ1ZmZlci50O1xuICAgIGljX2lucHV0X25hbWUgOiBpbl9jaGFubmVsX25hbWU7XG4gIH1cblxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICBsZXQgbnVsbF9jaGFyID0gJ1xcMDAwJ1xuXG4gICgqIFJlYWRzIGEgbmV3IGNoYXJhY3RlciBmcm9tIGlucHV0IGJ1ZmZlci5cbiAgICAgTmV4dF9jaGFyIG5ldmVyIGZhaWxzLCBldmVuIGluIGNhc2Ugb2YgZW5kIG9mIGlucHV0OlxuICAgICBpdCB0aGVuIHNpbXBseSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24uICopXG4gIGxldCBuZXh0X2NoYXIgaWIgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpYi5pY19nZXRfbmV4dF9jaGFyICgpIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSB0cnVlO1xuICAgICAgaWIuaWNfY2hhcl9jb3VudCA8LSBzdWNjIGliLmljX2NoYXJfY291bnQ7XG4gICAgICBpZiBjID0gJ1xcbicgdGhlbiBpYi5pY19saW5lX2NvdW50IDwtIHN1Y2MgaWIuaWNfbGluZV9jb3VudDtcbiAgICAgIGMgd2l0aFxuICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgIGxldCBjID0gbnVsbF9jaGFyIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZTtcbiAgICAgIGliLmljX2VvZiA8LSB0cnVlO1xuICAgICAgY1xuXG5cbiAgbGV0IHBlZWtfY2hhciBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jdXJyZW50X2NoYXJcbiAgICBlbHNlIG5leHRfY2hhciBpYlxuXG5cbiAgKCogUmV0dXJucyBhIHZhbGlkIGN1cnJlbnQgY2hhciBmb3IgdGhlIGlucHV0IGJ1ZmZlci4gSW4gcGFydGljdWxhclxuICAgICBubyBpcnJlbGV2YW50IG51bGwgY2hhcmFjdGVyIChhcyBzZXQgYnkgW25leHRfY2hhcl0gaW4gY2FzZSBvZiBlbmRcbiAgICAgb2YgaW5wdXQpIGlzIHJldHVybmVkLCBzaW5jZSBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuXG4gICAgIFtuZXh0X2NoYXJdIHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhXG4gICAgIG5ldyBjaGFyYWN0ZXIuICopXG4gIGxldCBjaGVja2VkX3BlZWtfY2hhciBpYiA9XG4gICAgbGV0IGMgPSBwZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpYi5pY19lb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgICBjXG5cblxuICBsZXQgZW5kX29mX2lucHV0IGliID1cbiAgICBpZ25vcmUgKHBlZWtfY2hhciBpYik7XG4gICAgaWIuaWNfZW9mXG5cblxuICBsZXQgZW9mIGliID0gaWIuaWNfZW9mXG5cbiAgbGV0IGJlZ2lubmluZ19vZl9pbnB1dCBpYiA9IGliLmljX2NoYXJfY291bnQgPSAwXG5cbiAgbGV0IG5hbWVfb2ZfaW5wdXQgaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIF9pYyAtPiBcInVubmFtZWQgU3RkbGliIGlucHV0IGNoYW5uZWxcIlxuICAgIHwgRnJvbV9maWxlIChmbmFtZSwgX2ljKSAtPiBmbmFtZVxuICAgIHwgRnJvbV9mdW5jdGlvbiAtPiBcInVubmFtZWQgZnVuY3Rpb25cIlxuICAgIHwgRnJvbV9zdHJpbmcgLT4gXCJ1bm5hbWVkIGNoYXJhY3RlciBzdHJpbmdcIlxuXG5cbiAgbGV0IGNoYXJfY291bnQgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY2hhcl9jb3VudCAtIDFcbiAgICBlbHNlIGliLmljX2NoYXJfY291bnRcblxuXG4gIGxldCBsaW5lX2NvdW50IGliID0gaWIuaWNfbGluZV9jb3VudFxuXG4gIGxldCByZXNldF90b2tlbiBpYiA9IEJ1ZmZlci5yZXNldCBpYi5pY190b2tlbl9idWZmZXJcblxuICBsZXQgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgPSBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2VcblxuICBsZXQgdG9rZW4gaWIgPVxuICAgIGxldCB0b2tlbl9idWZmZXIgPSBpYi5pY190b2tlbl9idWZmZXIgaW5cbiAgICBsZXQgdG9rID0gQnVmZmVyLmNvbnRlbnRzIHRva2VuX2J1ZmZlciBpblxuICAgIEJ1ZmZlci5jbGVhciB0b2tlbl9idWZmZXI7XG4gICAgaWIuaWNfdG9rZW5fY291bnQgPC0gc3VjYyBpYi5pY190b2tlbl9jb3VudDtcbiAgICB0b2tcblxuXG4gIGxldCB0b2tlbl9jb3VudCBpYiA9IGliLmljX3Rva2VuX2NvdW50XG5cbiAgbGV0IHNraXBfY2hhciB3aWR0aCBpYiA9XG4gICAgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7XG4gICAgd2lkdGhcblxuXG4gIGxldCBpZ25vcmVfY2hhciB3aWR0aCBpYiA9IHNraXBfY2hhciAod2lkdGggLSAxKSBpYlxuXG4gIGxldCBzdG9yZV9jaGFyIHdpZHRoIGliIGMgPVxuICAgIEJ1ZmZlci5hZGRfY2hhciBpYi5pY190b2tlbl9idWZmZXIgYztcbiAgICBpZ25vcmVfY2hhciB3aWR0aCBpYlxuXG5cbiAgbGV0IGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUgPSAxMDI0XG5cbiAgbGV0IGNyZWF0ZSBpbmFtZSBuZXh0ID0ge1xuICAgIGljX2VvZiA9IGZhbHNlO1xuICAgIGljX2N1cnJlbnRfY2hhciA9IG51bGxfY2hhcjtcbiAgICBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPSBmYWxzZTtcbiAgICBpY19jaGFyX2NvdW50ID0gMDtcbiAgICBpY19saW5lX2NvdW50ID0gMDtcbiAgICBpY190b2tlbl9jb3VudCA9IDA7XG4gICAgaWNfZ2V0X25leHRfY2hhciA9IG5leHQ7XG4gICAgaWNfdG9rZW5fYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplO1xuICAgIGljX2lucHV0X25hbWUgPSBpbmFtZTtcbiAgfVxuXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPj0gbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZVxuICAgICAgbGV0IGMgPSBzLlshaV0gaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGMgaW5cbiAgICBjcmVhdGUgRnJvbV9zdHJpbmcgbmV4dFxuXG5cbiAgbGV0IGZyb21fZnVuY3Rpb24gPSBjcmVhdGUgRnJvbV9mdW5jdGlvblxuXG4gICgqIFNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbC4gKilcblxuICAoKiBQb3NpdGlvbiBvZiB0aGUgcHJvYmxlbTpcblxuICAgICBXZSBjYW5ub3QgcHJldmVudCB0aGUgc2Nhbm5pbmcgbWVjaGFuaXNtIHRvIHVzZSBvbmUgbG9va2FoZWFkIGNoYXJhY3RlcixcbiAgICAgaWYgbmVlZGVkIGJ5IHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGZvcm1hdCBzdHJpbmcgc3BlY2lmaWNhdGlvbnMgKGUuZy4gYVxuICAgICB0cmFpbGluZyAnc2tpcCBzcGFjZScgc3BlY2lmaWNhdGlvbiBpbiB0aGUgZm9ybWF0IHN0cmluZyk7IGluIHRoaXMgY2FzZSxcbiAgICAgdGhlIG1hbmRhdG9yeSBsb29rYWhlYWQgY2hhcmFjdGVyIGlzIGluZGVlZCByZWFkIGZyb20gdGhlIGlucHV0IGFuZCBub3RcbiAgICAgdXNlZCB0byByZXR1cm4gdGhlIHRva2VuIHJlYWQuIEl0IGlzIHRodXMgbWFuZGF0b3J5IHRvIGJlIGFibGUgdG8gc3RvcmVcbiAgICAgYW4gdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgc29tZXdoZXJlIHRvIGdldCBpdCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgIG9mIHRoZSBuZXh0IHNjYW4uXG5cbiAgICAgVG8gY2lyY3VtdmVudCB0aGlzIHByb2JsZW0sIGFsbCB0aGUgc2Nhbm5pbmcgZnVuY3Rpb25zIGdldCBhIGxvdyBsZXZlbFxuICAgICBpbnB1dCBidWZmZXIgYXJndW1lbnQgd2hlcmUgdGhleSBzdG9yZSB0aGUgbG9va2FoZWFkIGNoYXJhY3RlciB3aGVuXG4gICAgIG5lZWRlZDsgYWRkaXRpb25hbGx5LCB0aGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBvbmx5IHNvdXJjZSBvZiBjaGFyYWN0ZXIgb2ZcbiAgICAgYSBzY2FubmVyLiBUaGUgW3NjYW5idWZdIGlucHV0IGJ1ZmZlcnMgYXJlIGRlZmluZWQgaW4gbW9kdWxlIHshU2Nhbm5pbmd9LlxuXG4gICAgIE5vdyB3ZSB1bmRlcnN0YW5kIHRoYXQgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0aGF0IHJlbGF0ZWQgYW5kXG4gICAgIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gc2Nhbm5lcnMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgc2FtZSBpbnB1dCBidWZmZXIuXG4gICAgIEluIGVmZmVjdCwgaWYgYSBzY2FubmVyIFtzY2FuMV0gaXMgcmVhZGluZyBmcm9tIFtpYjFdIGFuZCBzdG9yZXMgYW5cbiAgICAgdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgW2MxXSBpbnRvIGl0cyBpbnB1dCBidWZmZXIgW2liMV0sIHRoZW5cbiAgICAgYW5vdGhlciBzY2FubmVyIFtzY2FuMl0gbm90IHJlYWRpbmcgZnJvbSB0aGUgc2FtZSBidWZmZXIgW2liMV0gd2lsbCBtaXNzXG4gICAgIHRoZSBjaGFyYWN0ZXIgW2MxXSwgc2VlbWluZ2x5IHZhbmlzaGVkIGluIHRoZSBhaXIgZnJvbSB0aGUgcG9pbnQgb2Ygdmlld1xuICAgICBvZiBbc2NhbjJdLlxuXG4gICAgIFRoaXMgbWVjaGFuaXNtIHdvcmtzIHBlcmZlY3RseSB0byByZWFkIGZyb20gc3RyaW5ncywgZnJvbSBmaWxlcywgYW5kIGZyb21cbiAgICAgZnVuY3Rpb25zLCBzaW5jZSBpbiB0aG9zZSBjYXNlcywgYWxsb2NhdGluZyB0d28gYnVmZmVycyByZWFkaW5nIGZyb20gdGhlXG4gICAgIHNhbWUgc291cmNlIGlzIHVubmF0dXJhbC5cblxuICAgICBTdGlsbCwgdGhlcmUgaXMgYSBkaWZmaWN1bHR5IGluIHRoZSBjYXNlIG9mIHNjYW5uaW5nIGZyb20gYW4gaW5wdXRcbiAgICAgY2hhbm5lbC4gSW4gZWZmZWN0LCB3aGVuIHNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbCBbaWNdLCB0aGlzIGNoYW5uZWxcbiAgICAgbWF5IG5vdCBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gd2l0aGluIHRoaXMgbGlicmFyeS4gSGVuY2UsIGl0IG1heSBiZVxuICAgICBzaGFyZWQgKHR3byBmdW5jdGlvbnMgb2YgdGhlIHVzZXIncyBwcm9ncmFtIG1heSBzdWNjZXNzaXZlbHkgcmVhZCBmcm9tXG4gICAgIFtpY10pLiBUaGlzIGlzIGhpZ2hseSBlcnJvciBwcm9uZSBzaW5jZSwgb25lIG9mIHRoZSBmdW5jdGlvbiBtYXkgc2VlayB0aGVcbiAgICAgaW5wdXQgY2hhbm5lbCwgd2hpbGUgdGhlIG90aGVyIGZ1bmN0aW9uIGhhcyBzdGlsbCBhbiB1bnVzZWQgbG9va2FoZWFkXG4gICAgIGNoYXJhY3RlciBpbiBpdHMgaW5wdXQgYnVmZmVyLiBJbiBjb25jbHVzaW9uLCB5b3Ugc2hvdWxkIG5ldmVyIG1peCBkaXJlY3RcbiAgICAgbG93IGxldmVsIHJlYWRpbmcgYW5kIGhpZ2ggbGV2ZWwgc2Nhbm5pbmcgZnJvbSB0aGUgc2FtZSBpbnB1dCBjaGFubmVsLlxuXG4gICopXG5cbiAgKCogUGVyZm9ybSBidWZmZXJpemVkIGlucHV0IHRvIGltcHJvdmUgZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZpbGVfYnVmZmVyX3NpemUgPSByZWYgMTAyNFxuXG4gICgqIFRoZSBzY2FubmVyIGNsb3NlcyB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQuICopXG4gIGxldCBzY2FuX2Nsb3NlX2F0X2VuZCBpYyA9IFN0ZGxpYi5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgT25lIGNvdWxkIHRyeSB0byBkZWZpbmUgW3N0ZGluXSBhcyBhIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGEgY2hhcmFjdGVyXG4gICAgIGF0IGEgdGltZSAobm8gYnVmZmVyaXphdGlvbiBhdCBhbGwpLCBidXQgdW5mb3J0dW5hdGVseSB0aGUgdG9wLWxldmVsXG4gICAgIGludGVyYWN0aW9uIHdvdWxkIGJlIHdyb25nLiBUaGlzIGlzIGR1ZSB0byBzb21lIGtpbmQgb2ZcbiAgICAgJ3JhY2UgY29uZGl0aW9uJyB3aGVuIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXSxcbiAgICAgc2luY2UgdGhlIGludGVyYWN0aXZlIGNvbXBpbGVyIGFuZCBbU2NhbmYuc2NhbmZdIHdpbGwgc2ltdWx0YW5lb3VzbHlcbiAgICAgcmVhZCB0aGUgbWF0ZXJpYWwgdGhleSBuZWVkIGZyb20gW1N0ZGxpYi5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFN0ZGxpYi5zdGRpbikpIFN0ZGxpYi5zdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cbmVuZFxuXG5cbigqIEZvcm1hdHRlZCBpbnB1dCBmdW5jdGlvbnMuICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lcl9vcHQgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2Qgb3B0aW9uLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICAgIClcbiAgICAgICAgICB8IF8gLT4gd2lkdGggaW5cbiAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgICAgfCBfIC0+IHdpZHRoXG4gIClcbiAgfCAnbicgfCAnTicgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJhblwiXG4gIHwgJ2knIHwgJ0knIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwibmZpbml0eVwiXG4gIHwgXyAtPiBiYWRfaGV4X2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICgqIFRoZSBlZmZlY3RpdmUgd2lkdGggYXZhaWxhYmxlIGZvciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IGlzXG4gICAgICAgdGhlIG1pbmltdW0gb2YgZGVjbGFyZWQgcHJlY2lzaW9uIGFuZCB3aWR0aCBsZWZ0LiAqKVxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9GIHwgRmxvYXRfQ0YpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRykpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9oIHwgRmxvYXRfSCkpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbmxldCBrc2NhbmZfZ2VuIGliIGVmIGFmIChGb3JtYXQgKGZtdCwgc3RyKSkgPVxuICBsZXQgcmVjIGFwcGx5IDogdHlwZSBhIGIgLiBhIC0+IChhLCBiKSBoZXRlcl9saXN0IC0+IGIgPVxuICAgIGZ1biBmIGFyZ3MgLT4gbWF0Y2ggYXJncyB3aXRoXG4gICAgfCBDb25zICh4LCByKSAtPiBhcHBseSAoZiB4KSByXG4gICAgfCBOaWwgLT4gZlxuICBpblxuICBsZXQgayByZWFkZXJzIGYgPVxuICAgIFNjYW5uaW5nLnJlc2V0X3Rva2VuIGliO1xuICAgIG1hdGNoIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMgd2l0aFxuICAgIHwgZXhjZXB0aW9uIChTY2FuX2ZhaWx1cmUgXyB8IEZhaWx1cmUgXyB8IEVuZF9vZl9maWxlIGFzIGV4YykgLT5cbiAgICAgICAgZWYgaWIgZXhjXG4gICAgfCBleGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB8IGFyZ3MgLT5cbiAgICAgICAgYWYgKGFwcGx5IGYgYXJncylcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG5sZXQga3NjYW5mIGliIGVmIGZtdCA9XG4gIGtzY2FuZl9nZW4gaWIgZWYgKGZ1biB4IC0+IHgpIGZtdFxuXG5sZXQga3NjYW5mX29wdCBpYiBmbXQgPVxuICBrc2NhbmZfZ2VuIGliIChmdW4gXyBfIC0+IE5vbmUpIChmdW4geCAtPiBTb21lIHgpIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcbmxldCBic2NhbmZfb3B0IGliIGZtdCA9IGtzY2FuZl9vcHQgaWIgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxubGV0IHNzY2FuZl9vcHQgcyBmbXQgPSBrc2NhbmZfb3B0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmbXRcblxubGV0IHNjYW5mIGZtdCA9IGtzY2FuZiBTY2FubmluZy5zdGRpbiBzY2FuZl9iYWRfaW5wdXQgZm10XG5sZXQgc2NhbmZfb3B0IGZtdCA9IGtzY2FuZl9vcHQgU2Nhbm5pbmcuc3RkaW4gZm10XG5cbigqKiopXG5cbigqIFNjYW5uaW5nIGZvcm1hdCBzdHJpbmdzLiAqKVxubGV0IGJzY2FuZl9mb3JtYXQgOlxuICBTY2FubmluZy5pbl9jaGFubmVsIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gaWIgZm9ybWF0IGYgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgbWF4X2ludCBpYiBpblxuICAgIGxldCBzdHIgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10JyA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIGZvcm1hdFxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnIGluXG4gICAgZiBmbXQnXG5cblxubGV0IHNzY2FuZl9mb3JtYXQgOlxuICBzdHJpbmcgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBzIGZvcm1hdCBmIC0+IGJzY2FuZl9mb3JtYXQgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGZvcm1hdCBmXG5cblxubGV0IGZvcm1hdF9mcm9tX3N0cmluZyBzIGZtdCA9XG4gIHNzY2FuZl9mb3JtYXQgKFwiXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgcyBeIFwiXFxcIlwiKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAoT2JqLm1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgT2JqLm1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBPYmoub2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIE9iai5tYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIE9iai5tYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIE9iai5tYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBPYmoubWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IE9iai5tYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgT2JqLm1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgT2JqLnJlcHIgaW5pdCB8XTtcbiAgICAgT2JqLm1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gT2JqLnJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBPYmoubWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IE9iai5tYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBPYmoubWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDA0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc2hhcGUgPVxuICB8IEZ1bmN0aW9uXG4gIHwgTGF6eVxuICB8IENsYXNzXG4gIHwgTW9kdWxlIG9mIHNoYXBlIGFycmF5XG4gIHwgVmFsdWUgb2YgT2JqLnRcblxubGV0IHJlYyBpbml0X21vZF9maWVsZCBtb2R1IGkgbG9jIHNoYXBlID1cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIHNoYXBlIHdpdGhcbiAgICB8IEZ1bmN0aW9uIC0+XG4gICAgICAgbGV0IHJlYyBmbiAoeCA6ICdhKSA9XG4gICAgICAgICBsZXQgZm4nIDogJ2EgLT4gJ2IgPSBPYmoub2JqIChPYmouZmllbGQgbW9kdSBpKSBpblxuICAgICAgICAgaWYgZm4gPT0gZm4nIHRoZW5cbiAgICAgICAgICAgcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYylcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgZm4nIHggaW5cbiAgICAgICBPYmoucmVwciBmblxuICAgIHwgTGF6eSAtPlxuICAgICAgIGxldCByZWMgbCA9XG4gICAgICAgICBsYXp5IChcbiAgICAgICAgICAgbGV0IGwnID0gT2JqLm9iaiAoT2JqLmZpZWxkIG1vZHUgaSkgaW5cbiAgICAgICAgICAgaWYgbCA9PSBsJyB0aGVuXG4gICAgICAgICAgICAgcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYylcbiAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgIExhenkuZm9yY2UgbCcpIGluXG4gICAgICAgT2JqLnJlcHIgbFxuICAgIHwgQ2xhc3MgLT5cbiAgICAgICBPYmoucmVwciAoQ2FtbGludGVybmFsT08uZHVtbXlfY2xhc3MgbG9jKVxuICAgIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgICAgT2JqLnJlcHIgKGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcylcbiAgICB8IFZhbHVlIHYgLT4gdlxuICBpblxuICBPYmouc2V0X2ZpZWxkIG1vZHUgaSBpbml0XG5cbmFuZCBpbml0X21vZF9ibG9jayBsb2MgY29tcHMgPVxuICBsZXQgbGVuZ3RoID0gQXJyYXkubGVuZ3RoIGNvbXBzIGluXG4gIGxldCBtb2R1ID0gT2JqLm5ld19ibG9jayAwIGxlbmd0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIC0gMSBkb1xuICAgIGluaXRfbW9kX2ZpZWxkIG1vZHUgaSBsb2MgY29tcHMuKGkpXG4gIGRvbmU7XG4gIG1vZHVcblxubGV0IGluaXRfbW9kIGxvYyBzaGFwZSA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgT2JqLnJlcHIgKGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcylcbiAgfCBfIC0+IGZhaWx3aXRoIFwiQ2FtbGludGVybmFsTW9kLmluaXRfbW9kOiBub3QgYSBtb2R1bGVcIlxuXG5sZXQgcmVjIHVwZGF0ZV9tb2RfZmllbGQgbW9kdSBpIHNoYXBlIG4gPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgRnVuY3Rpb24gfCBMYXp5IC0+XG4gICAgIE9iai5zZXRfZmllbGQgbW9kdSBpIG5cbiAgfCBWYWx1ZSBfIC0+XG4gICAgICgpICgqIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IHRoZXJlICopXG4gIHwgQ2xhc3MgLT5cbiAgICAgYXNzZXJ0IChPYmoudGFnIG4gPSAwICYmIE9iai5zaXplIG4gPSA0KTtcbiAgICAgbGV0IGNsID0gT2JqLmZpZWxkIG1vZHUgaSBpblxuICAgICBmb3IgaiA9IDAgdG8gMyBkb1xuICAgICAgIE9iai5zZXRfZmllbGQgY2wgaiAoT2JqLmZpZWxkIG4gailcbiAgICAgZG9uZVxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIChPYmouZmllbGQgbW9kdSBpKSBuXG5cbmFuZCB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIG8gbiA9XG4gIGFzc2VydCAoT2JqLnRhZyBuID0gMCAmJiBPYmouc2l6ZSBuID49IEFycmF5Lmxlbmd0aCBjb21wcyk7XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggY29tcHMgLSAxIGRvXG4gICAgdXBkYXRlX21vZF9maWVsZCBvIGkgY29tcHMuKGkpIChPYmouZmllbGQgbiBpKVxuICBkb25lXG5cbmxldCB1cGRhdGVfbW9kIHNoYXBlIG8gbiA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgdXBkYXRlX21vZF9ibG9jayBjb21wcyBvIG5cbiAgfCBfIC0+IGZhaWx3aXRoIFwiQ2FtbGludGVybmFsTW9kLnVwZGF0ZV9tb2Q6IG5vdCBhIG1vZHVsZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPSBzaWdcblxuICB0eXBlIGtleVxuICB0eXBlICEnYSB0XG4gIHZhbCBjcmVhdGUgOiA/cmFuZG9tICgqdGh3YXJ0IHRvb2xzL3N5bmNfc3RkbGliX2RvY3MqKSA6IGJvb2wgLT4gaW50IC0+ICdhIHRcbiAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gIHZhbCBmaW5kX29wdCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG5cbiAgdHlwZSBrZXlcbiAgdHlwZSAhJ2EgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+ICdhIHRcbiAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gIHZhbCBmaW5kX29wdCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgc2VlZGVkX2hhc2g6IGludCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogJ2EgY29udGFpbmVyIC0+IHQgLT4gZXF1YWxcbiAgICB2YWwgZ2V0X2RhdGE6ICdhIGNvbnRhaW5lciAtPiAnYSBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25zKGhrZXksIGNvbnRhaW5lciwgaC5kYXRhLihpKSkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoayA9IGhrZXkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IHRydWVcbiAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IG1lbV9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF9oaywgX2MsIHJlc3QpIC0+IG1lbV9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cbiAgICBsZXQgbGVuZ3RoIGggPSBoLnNpemVcblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSByZXN0XG5cbiAgICBsZXQgc3RhdHMgaCA9XG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gSC5jaGVja19rZXkgYyAtPlxuICAgICAgICAgIGJ1Y2tldF9sZW5ndGhfYWxpdmUgKGFjY3UgKyAxKSByZXN0XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1IHJlc3RcblxuICAgIGxldCBzdGF0c19hbGl2ZSBoID1cbiAgICAgIGxldCBzaXplID0gcmVmIDAgaW5cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnRcbiAgICAgICAgICAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiKSkgMCBoLmRhdGFcbiAgICAgIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAoazonaykgOiB1bml0ID0gT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuXG4gIGxldCBtYWtlIGtleSBkYXRhID1cbiAgICBsZXQgZXBoID0gY3JlYXRlICgpIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgc2V0X2tleSBlcGgga2V5O1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5ID1cbiAgICBtYXRjaCBnZXRfa2V5IGVwaCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5IC0+IGdldF9kYXRhIGVwaFxuICAgIHwgU29tZSBfIC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBzZWVkZWRfaGFzaCA9IEguc2VlZGVkX2hhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgc2VlZGVkX2hhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2ssICdkKSB0ID0gKCdrLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrMV9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsgZCA9IGIgOj0gazFfbWFrZSBrIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleSBrIGUgPVxuICAgICAgbWF0Y2ggZ2V0X2tleSBlIHdpdGhcbiAgICAgIHwgU29tZSB4IHdoZW4geCA9PSBrIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlbW92ZSBiIGsgPVxuICAgICAgbGV0IHJlYyBsb29wIGwgYWNjID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBoIDo6IHQgd2hlbiB0ZXN0X2tleSBrIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXkgaykgIWIgd2l0aFxuICAgICAgfCBTb21lIGUgLT4gZ2V0X2RhdGEgZVxuICAgICAgfCBOb25lIC0+IE5vbmVcblxuICAgIGxldCBsZW5ndGggYiA9IExpc3QubGVuZ3RoICFiXG4gICAgbGV0IGNsZWFyIGIgPSBiIDo9IFtdXG5cbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgY2hlY2tfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG5cbiAgbGV0IG1ha2Uga2V5MSBrZXkyIGRhdGEgPVxuICAgIGxldCBlcGggPSBjcmVhdGUgKCkgaW5cbiAgICBzZXRfZGF0YSBlcGggZGF0YTtcbiAgICBzZXRfa2V5MSBlcGgga2V5MTtcbiAgICBzZXRfa2V5MiBlcGgga2V5MjtcbiAgICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkga2V5MSk7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXkxIGtleTIgPVxuICAgIG1hdGNoIGdldF9rZXkxIGVwaCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5MSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBnZXRfa2V5MiBlcGggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5MiAtPiBnZXRfZGF0YSBlcGhcbiAgICAgICAgfCBTb21lIF8gLT4gTm9uZVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgXyAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IHNlZWRlZF9oYXNoIHNlZWQgKGsxLGsyKSA9XG4gICAgICAgIEgxLnNlZWRlZF9oYXNoIHNlZWQgazEgKyBIMi5zZWVkZWRfaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IHNlZWRlZF9oYXNoIChfc2VlZDogaW50KSB4ID0gSDEuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgyLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMi5lcXVhbFxuICAgICAgICAgIGxldCBzZWVkZWRfaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnazEsICdrMiwgJ2QpIHQgPSAoJ2sxLCAnazIsICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGsyX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgazEgazIgZCA9IGIgOj0gazJfbWFrZSBrMSBrMiBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXlzIGsxIGsyIGUgPVxuICAgICAgbWF0Y2ggZ2V0X2tleTEgZSwgZ2V0X2tleTIgZSB3aXRoXG4gICAgICB8IFNvbWUgeDEsIFNvbWUgeDIgd2hlbiB4MSA9PSBrMSAmJiB4MiA9PSBrMiAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrMSBrMiA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5cyBrMSBrMiBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrMSBrMiA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleXMgazEgazIpICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG5cbiAgbGV0IG1ha2Uga2V5cyBkYXRhID1cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBrZXlzIGluXG4gICAgbGV0IGVwaCA9IGNyZWF0ZSBsIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHNldF9rZXkgZXBoIGkga2V5cy4oaSkgZG9uZTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleXMgPVxuICAgIGxldCBsID0gbGVuZ3RoIGVwaCBpblxuICAgIHRyeVxuICAgICAgaWYgbCA8PiBBcnJheS5sZW5ndGgga2V5cyB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBlcGggaSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiByYWlzZSBFeGl0XG4gICAgICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXlzLihpKSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyAtPiByYWlzZSBFeGl0XG4gICAgICBkb25lO1xuICAgICAgZ2V0X2RhdGEgZXBoXG4gICAgd2l0aCBFeGl0IC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBzZWVkZWRfaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguc2VlZGVkX2hhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IHNlZWRlZF9oYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbiAgbW9kdWxlIEJ1Y2tldCA9IHN0cnVjdFxuXG4gICAgdHlwZSBub25yZWMgKCdrLCAnZCkgdCA9ICgnaywgJ2QpIHQgbGlzdCByZWZcbiAgICBsZXQga25fbWFrZSA9IG1ha2VcbiAgICBsZXQgbWFrZSAoKSA9IHJlZiBbXVxuICAgIGxldCBhZGQgYiBrIGQgPSBiIDo9IGtuX21ha2UgayBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXlzIGsgZSA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgbGVuZ3RoIGUgPD4gQXJyYXkubGVuZ3RoIGsgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGsgLSAxIGRvXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBlIGkgd2l0aFxuICAgICAgICAgIHwgU29tZSB4IHdoZW4geCA9PSBrLihpKSAtPiAoKVxuICAgICAgICAgIHwgXyAtPiByYWlzZSBFeGl0XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHRydWVcbiAgICAgIHdpdGggRXhpdCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlbW92ZSBiIGsgPVxuICAgICAgbGV0IHJlYyBsb29wIGwgYWNjID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBoIDo6IHQgd2hlbiB0ZXN0X2tleXMgayBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrID1cbiAgICAgIG1hdGNoIExpc3QuZmluZF9vcHQgKHRlc3Rfa2V5cyBrKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgWGF2aWVyIExlcm95IGFuZCBEYW1pZW4gRG9saWdleiwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBnZW5lcmljX3F1b3RlIHF1b3RlcXVvdGUgcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgaWYgcy5baV0gPSAnXFwnJ1xuICAgIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYiBxdW90ZXF1b3RlXG4gICAgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYiAgcy5baV1cbiAgZG9uZTtcbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMV1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9iYXNlbmFtZS5odG1sXG4gIEluIHN0ZXAgMSBvZiBbWzFdXSwgd2UgY2hvb3NlIHRvIHJldHVybiBcIi5cIiBmb3IgZW1wdHkgaW5wdXQuXG4gICAgKGZvciBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgT0NhbWwpXG4gIEluIHN0ZXAgMiwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuICBTdGVwIDYgaXMgbm90IGltcGxlbWVudGVkOiB3ZSBjb25zaWRlciB0aGF0IHRoZSBbc3VmZml4XSBvcGVyYW5kIGlzXG4gICAgYWx3YXlzIGFic2VudC4gIFN1ZmZpeGVzIGFyZSBoYW5kbGVkIGJ5IFtjaG9wX3N1ZmZpeF0gYW5kIFtjaG9wX2V4dGVuc2lvbl0uXG4qKVxubGV0IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIGZpbmRfZW5kIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBmaW5kX2VuZCAobiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyBuIChuICsgMSlcbiAgYW5kIGZpbmRfYmVnIG4gcCA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCBwXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIFN0cmluZy5zdWIgbmFtZSAobiArIDEpIChwIC0gbiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyAobiAtIDEpIHBcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgZmluZF9lbmQgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMl1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9kaXJuYW1lLmh0bWxcbiAgSW4gc3RlcCA2IG9mIFtbMl1dLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4qKVxubGV0IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgdHJhaWxpbmdfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiB0cmFpbGluZ19zZXAgKG4gLSAxKVxuICAgIGVsc2UgYmFzZSBuXG4gIGFuZCBiYXNlIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIG5cbiAgICBlbHNlIGJhc2UgKG4gLSAxKVxuICBhbmQgaW50ZXJtZWRpYXRlX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCAobiAtIDEpXG4gICAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAobiArIDEpXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIHRyYWlsaW5nX3NlcCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubW9kdWxlIHR5cGUgU1lTREVQUyA9IHNpZ1xuICB2YWwgbnVsbCA6IHN0cmluZ1xuICB2YWwgY3VycmVudF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcGFyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBkaXJfc2VwIDogc3RyaW5nXG4gIHZhbCBpc19kaXJfc2VwIDogc3RyaW5nIC0+IGludCAtPiBib29sXG4gIHZhbCBpc19yZWxhdGl2ZSA6IHN0cmluZyAtPiBib29sXG4gIHZhbCBpc19pbXBsaWNpdCA6IHN0cmluZyAtPiBib29sXG4gIHZhbCBjaGVja19zdWZmaXggOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNob3Bfc3VmZml4X29wdCA6IHN1ZmZpeDpzdHJpbmcgLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb25cbiAgdmFsIHRlbXBfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIHF1b3RlIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgcXVvdGVfY29tbWFuZCA6XG4gICAgc3RyaW5nIC0+ID9zdGRpbjogc3RyaW5nIC0+ID9zdGRvdXQ6IHN0cmluZyAtPiA/c3RkZXJyOiBzdHJpbmdcbiAgICAgICAgICAgLT4gc3RyaW5nIGxpc3QgLT4gc3RyaW5nXG4gIHZhbCBiYXNlbmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGRpcm5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nXG5lbmRcblxubW9kdWxlIFVuaXggOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCIvZGV2L251bGxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBzLltpXSA9ICcvJ1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9IFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICAgU3RyaW5nLmVuZHNfd2l0aCB+c3VmZml4OnN1ZmYgbmFtZVxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIHIgPSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgKGNtZCA6OiBhcmdzKSlcbiAgICBeIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGUgZilcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiTlVMXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSByID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuKCpcblF1b3RpbmcgY29tbWFuZHMgZm9yIGV4ZWN1dGlvbiBieSBjbWQuZXhlIGlzIGRpZmZpY3VsdC5cbjEtIEVhY2ggYXJndW1lbnQgaXMgZmlyc3QgcXVvdGVkIHVzaW5nIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmUsIHRvXG4gICBwcm90ZWN0IGl0IGFnYWluc3QgdGhlIHByb2Nlc3NpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLFxuICAgdGhlbiBjbWQuZXhlJ3Mgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggJ14nLCB1c2luZ1xuICAgdGhlIFwicXVvdGVfY21kXCIgZnVuY3Rpb24gYmVsb3cuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWVcbiAgIGh0dHBzOi8vYmxvZ3MubXNkbi5taWNyb3NvZnQuY29tL3R3aXN0eWxpdHRsZXBhc3NhZ2VzYWxsYWxpa2UvMjAxMS8wNC8yM1xuMi0gVGhlIGNvbW1hbmQgYW5kIHRoZSByZWRpcmVjdGlvbiBmaWxlcywgaWYgYW55LCBtdXN0IGJlIGRvdWJsZS1xdW90ZWRcbiAgIGluIGNhc2UgdGhleSBjb250YWluIHNwYWNlcy4gIFRoaXMgcXVvdGluZyBpcyBpbnRlcnByZXRlZCBieSBjbWQuZXhlLFxuICAgbm90IGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLCBoZW5jZSB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlXG4gICBjYW5ub3QgYmUgdXNlZC4gIFRoZSB0d28gY2hhcmFjdGVycyB3ZSBkb24ndCBrbm93IGhvdyB0byBxdW90ZVxuICAgaW5zaWRlIGEgZG91YmxlLXF1b3RlZCBjbWQuZXhlIHN0cmluZyBhcmUgZG91YmxlLXF1b3RlIGFuZCBwZXJjZW50LlxuICAgV2UganVzdCBmYWlsIGlmIHRoZSBjb21tYW5kIG5hbWUgb3IgdGhlIHJlZGlyZWN0aW9uIGZpbGUgbmFtZXNcbiAgIGNvbnRhaW4gYSBkb3VibGUgcXVvdGUgKG5vdCBhbGxvd2VkIGluIFdpbmRvd3MgZmlsZSBuYW1lcywgYW55d2F5KVxuICAgb3IgYSBwZXJjZW50LiAgU2VlIGZ1bmN0aW9uIFwicXVvdGVfY21kX2ZpbGVuYW1lXCIgYmVsb3cuXG4zLSBUaGUgd2hvbGUgc3RyaW5nIHBhc3NlZCB0byBTeXMuY29tbWFuZCBpcyB0aGVuIGVuY2xvc2VkIGluIGRvdWJsZVxuICAgcXVvdGVzLCB3aGljaCBhcmUgaW1tZWRpYXRlbHkgc3RyaXBwZWQgYnkgY21kLmV4ZS4gIE90aGVyd2lzZSxcbiAgIHNvbWUgb2YgdGhlIGRvdWJsZSBxdW90ZXMgZnJvbSBzdGVwIDIgYWJvdmUgY2FuIGJlIG1pc3BhcnNlZC5cbiAgIFNlZSBlLmcuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85OTY1MTQxXG4qKVxuICBsZXQgcXVvdGVfY21kIHMgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgMjApIGluXG4gICAgU3RyaW5nLml0ZXJcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnKCcgfCAnKScgfCAnIScgfCAnXicgfCAnJScgfCAnXFxcIicgfCAnPCcgfCAnPicgfCAnJicgfCAnfCcgLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdeJzsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGMpXG4gICAgICBzO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGxldCBxdW90ZV9jbWRfZmlsZW5hbWUgZiA9XG4gICAgaWYgU3RyaW5nLmV4aXN0cyAoZnVuY3Rpb24gJ1xcXCInIHwgJyUnIC0+IHRydWUgfCBfIC0+IGZhbHNlKSBmIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFN0cmluZy5jb25jYXQgXCJcIiBbXCJcXFwiXCI7IGY7IFwiXFxcIlwiXVxuICAgIGVsc2VcbiAgICAgIGZcbiAgKCogUmVkaXJlY3Rpb25zIGluIGNtZC5leGU6IHNlZSBodHRwczovL3NzNjQuY29tL250L3N5bnRheC1yZWRpcmVjdGlvbi5odG1sXG4gICAgIGFuZCBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy93aW5kb3dzL2l0LXByby93aW5kb3dzLXhwL2JiNDkwOTgyKHY9dGVjaG5ldC4xMClcbiAgKilcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIFtcbiAgICAgIFwiXFxcIlwiO1xuICAgICAgcXVvdGVfY21kX2ZpbGVuYW1lIGNtZDtcbiAgICAgIFwiIFwiO1xuICAgICAgcXVvdGVfY21kIChTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSBhcmdzKSk7XG4gICAgICAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgXCJcXFwiXCJcbiAgICBdXG4gIGxldCBoYXNfZHJpdmUgcyA9XG4gICAgbGV0IGlzX2xldHRlciA9IGZ1bmN0aW9uXG4gICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgU3RyaW5nLmxlbmd0aCBzID49IDIgJiYgaXNfbGV0dGVyIHMuWzBdICYmIHMuWzFdID0gJzonXG4gIGxldCBkcml2ZV9hbmRfcGF0aCBzID1cbiAgICBpZiBoYXNfZHJpdmUgc1xuICAgIHRoZW4gKFN0cmluZy5zdWIgcyAwIDIsIFN0cmluZy5zdWIgcyAyIChTdHJpbmcubGVuZ3RoIHMgLSAyKSlcbiAgICBlbHNlIChcIlwiLCBzKVxuICBsZXQgZGlybmFtZSBzID1cbiAgICBsZXQgKGRyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBsZXQgZGlyID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoIGluXG4gICAgZHJpdmUgXiBkaXJcbiAgbGV0IGJhc2VuYW1lIHMgPVxuICAgIGxldCAoX2RyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoXG5lbmRcblxubW9kdWxlIEN5Z3dpbiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgPSBXaW4zMi5jaG9wX3N1ZmZpeF9vcHRcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgcXVvdGVfY29tbWFuZCA9IFVuaXgucXVvdGVfY29tbWFuZFxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgU3lzZGVwcyA9XG4gICh2YWwgKG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgICAgICB8IFwiV2luMzJcIiAtPiAobW9kdWxlIFdpbjMyOiBTWVNERVBTKVxuICAgICAgIHwgXCJDeWd3aW5cIiAtPiAobW9kdWxlIEN5Z3dpbjogU1lTREVQUylcbiAgICAgICB8IF8gLT4gKG1vZHVsZSBVbml4OiBTWVNERVBTKSkpXG5cbmluY2x1ZGUgU3lzZGVwc1xuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBpZiBjaGVja19zdWZmaXggbmFtZSBzdWZmXG4gIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3Bfc3VmZml4XCJcblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nX2tleSA9XG4gIERvbWFpbi5ETFMubmV3X2tleSBSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXRcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmFuZG9tX3N0YXRlID0gRG9tYWluLkRMUy5nZXQgcHJuZ19rZXkgaW5cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyByYW5kb21fc3RhdGUpIGxhbmQgMHhGRkZGRkYgaW5cbiAgY29uY2F0IHRlbXBfZGlyIChQcmludGYuc3ByaW50ZiBcIiVzJTA2eCVzXCIgcHJlZml4IHJuZCBzdWZmaXgpXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPVxuICBEb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50OkZ1bi5pZCAoZnVuICgpIC0+IHRlbXBfZGlyX25hbWUpXG5cbmxldCBzZXRfdGVtcF9kaXJfbmFtZSBzID0gRG9tYWluLkRMUy5zZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lIHNcbmxldCBnZXRfdGVtcF9kaXJfbmFtZSAoKSA9IERvbWFpbi5ETFMuZ2V0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSBEb21haW4uRExTLmdldCBjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAyMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgPyh0ZW1wX2RpciA9IERvbWFpbi5ETFMuZ2V0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSlcbiAgICBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIChuYW1lLFxuICAgICAgIG9wZW5fb3V0X2dlbiAoT3Blbl93cm9ubHk6Ok9wZW5fY3JlYXQ6Ok9wZW5fZXhjbDo6bW9kZSkgcGVybXMgbmFtZSlcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMjAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG5cbmxldCB0ZW1wX2RpciA/KHRlbXBfZGlyID0gRG9tYWluLkRMUy5nZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lKVxuICAgID8ocGVybXMgPSAwbzcwMCkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICBTeXMubWtkaXIgbmFtZSBwZXJtcztcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMjAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID0gRmxvYXQuaHlwb3QgeC5yZSB4LmltXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGluX2NoYW5uZWxcblxudHlwZSBvcGVuX2ZsYWcgPSBTdGRsaWIub3Blbl9mbGFnID1cbiAgfCBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xuXG5sZXQgc3RkaW4gPSBTdGRsaWIuc3RkaW5cbmxldCBvcGVuX2JpbiA9IFN0ZGxpYi5vcGVuX2luX2JpblxubGV0IG9wZW5fdGV4dCA9IFN0ZGxpYi5vcGVuX2luXG5sZXQgb3Blbl9nZW4gPSBTdGRsaWIub3Blbl9pbl9nZW5cblxubGV0IHdpdGhfb3BlbiBvcGVuZnVuIHMgZiA9XG4gIGxldCBpYyA9IG9wZW5mdW4gcyBpblxuICBGdW4ucHJvdGVjdCB+ZmluYWxseTooZnVuICgpIC0+IFN0ZGxpYi5jbG9zZV9pbl9ub2VyciBpYylcbiAgICAoZnVuICgpIC0+IGYgaWMpXG5cbmxldCB3aXRoX29wZW5fYmluIHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9pbl9iaW4gcyBmXG5cbmxldCB3aXRoX29wZW5fdGV4dCBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5faW4gcyBmXG5cbmxldCB3aXRoX29wZW5fZ2VuIGZsYWdzIHBlcm0gcyBmID1cbiAgd2l0aF9vcGVuIChTdGRsaWIub3Blbl9pbl9nZW4gZmxhZ3MgcGVybSkgcyBmXG5cbmxldCBzZWVrID0gU3RkbGliLkxhcmdlRmlsZS5zZWVrX2luXG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3NfaW5cbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLmluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2UgPSBTdGRsaWIuY2xvc2VfaW5cbmxldCBjbG9zZV9ub2VyciA9IFN0ZGxpYi5jbG9zZV9pbl9ub2VyclxuXG5sZXQgaW5wdXRfY2hhciBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9jaGFyIGljIHdpdGhcbiAgfCBjIC0+IFNvbWUgY1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dF9ieXRlIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2J5dGUgaWMgd2l0aFxuICB8IG4gLT4gU29tZSBuXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0X2xpbmUgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfbGluZSBpYyB3aXRoXG4gIHwgcyAtPiBTb21lIHNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXQgPSBTdGRsaWIuaW5wdXRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBidWYgcG9zIGxlbiA9XG4gIG1hdGNoIFN0ZGxpYi5yZWFsbHlfaW5wdXQgaWMgYnVmIHBvcyBsZW4gd2l0aFxuICB8ICgpIC0+IFNvbWUgKClcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBtYXRjaCBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gd2l0aFxuICB8IHMgLT4gU29tZSBzXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxuKCogUmVhZCB1cCB0byBbbGVuXSBieXRlcyBpbnRvIFtidWZdLCBzdGFydGluZyBhdCBbb2ZzXS4gUmV0dXJuIHRvdGFsIGJ5dGVzXG4gICByZWFkLiAqKVxubGV0IHJlYWRfdXB0byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBvZnMgbGVuID1cbiAgICBpZiBsZW4gPSAwIHRoZW4gb2ZzXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBTdGRsaWIuaW5wdXQgaWMgYnVmIG9mcyBsZW4gaW5cbiAgICAgIGlmIHIgPSAwIHRoZW5cbiAgICAgICAgb2ZzXG4gICAgICBlbHNlXG4gICAgICAgIGxvb3AgKG9mcyArIHIpIChsZW4gLSByKVxuICAgIGVuZFxuICBpblxuICBsb29wIG9mcyBsZW4gLSBvZnNcblxuKCogQmVzdCBlZmZvcnQgYXR0ZW1wdCB0byByZXR1cm4gYSBidWZmZXIgd2l0aCA+PSAob2ZzICsgbikgYnl0ZXMgb2Ygc3RvcmFnZSxcbiAgIGFuZCBzdWNoIHRoYXQgaXQgY29pbmNpZGVzIHdpdGggW2J1Zl0gYXQgaW5kaWNlcyA8IFtvZnNdLlxuXG4gICBUaGUgcmV0dXJuZWQgYnVmZmVyIGlzIGVxdWFsIHRvIFtidWZdIGl0c2VsZiBpZiBpdCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50XG4gICBmcmVlIHNwYWNlLlxuXG4gICBUaGUgcmV0dXJuZWQgYnVmZmVyIG1heSBoYXZlICpmZXdlciogdGhhbiBbb2ZzICsgbl0gYnl0ZXMgb2Ygc3RvcmFnZSBpZiB0aGlzXG4gICBudW1iZXIgaXMgPiBbU3lzLm1heF9zdHJpbmdfbGVuZ3RoXS4gSG93ZXZlciB0aGUgcmV0dXJuZWQgYnVmZmVyIHdpbGxcbiAgICphbHdheXMqIGhhdmUgPiBbb2ZzXSBieXRlcyBvZiBzdG9yYWdlLiBJbiB0aGUgbGltaXRpbmcgY2FzZSB3aGVuIFtvZnMgPSBsZW5cbiAgID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXSAoc28gdGhhdCBpdCBpcyBub3QgcG9zc2libGUgdG8gcmVzaXplIHRoZSBidWZmZXIgYXRcbiAgIGFsbCksIGFuIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5cbmxldCBlbnN1cmUgYnVmIG9mcyBuID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuID49IG9mcyArIG4gdGhlbiBidWZcbiAgZWxzZSBiZWdpblxuICAgIGxldCBuZXdfbGVuID0gcmVmIGxlbiBpblxuICAgIHdoaWxlICFuZXdfbGVuIDwgb2ZzICsgbiBkb1xuICAgICAgbmV3X2xlbiA6PSAyICogIW5ld19sZW4gKyAxXG4gICAgZG9uZTtcbiAgICBsZXQgbmV3X2xlbiA9ICFuZXdfbGVuIGluXG4gICAgbGV0IG5ld19sZW4gPVxuICAgICAgaWYgbmV3X2xlbiA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBuZXdfbGVuXG4gICAgICBlbHNlIGlmIG9mcyA8IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBmYWlsd2l0aCBcIkluX2NoYW5uZWwuaW5wdXRfYWxsOiBjaGFubmVsIGNvbnRlbnQgXFxcbiAgICAgICAgICAgICAgICAgIGlzIGxhcmdlciB0aGFuIG1heGltdW0gc3RyaW5nIGxlbmd0aFwiXG4gICAgaW5cbiAgICBsZXQgbmV3X2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYgMCBuZXdfYnVmIDAgb2ZzO1xuICAgIG5ld19idWZcbiAgZW5kXG5cbmxldCBpbnB1dF9hbGwgaWMgPVxuICBsZXQgY2h1bmtfc2l6ZSA9IDY1NTM2IGluICgqIElPX0JVRkZFUl9TSVpFICopXG4gIGxldCBpbml0aWFsX3NpemUgPVxuICAgIHRyeVxuICAgICAgU3RkbGliLmluX2NoYW5uZWxfbGVuZ3RoIGljIC0gU3RkbGliLnBvc19pbiBpY1xuICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgIC0xXG4gIGluXG4gIGxldCBpbml0aWFsX3NpemUgPSBpZiBpbml0aWFsX3NpemUgPCAwIHRoZW4gY2h1bmtfc2l6ZSBlbHNlIGluaXRpYWxfc2l6ZSBpblxuICBsZXQgaW5pdGlhbF9zaXplID1cbiAgICBpZiBpbml0aWFsX3NpemUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgIGluaXRpYWxfc2l6ZVxuICAgIGVsc2VcbiAgICAgIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICBpblxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGluaXRpYWxfc2l6ZSBpblxuICBsZXQgbnJlYWQgPSByZWFkX3VwdG8gaWMgYnVmIDAgaW5pdGlhbF9zaXplIGluXG4gIGlmIG5yZWFkIDwgaW5pdGlhbF9zaXplIHRoZW4gKCogRU9GIHJlYWNoZWQsIGJ1ZmZlciBwYXJ0aWFsbHkgZmlsbGVkICopXG4gICAgQnl0ZXMuc3ViX3N0cmluZyBidWYgMCBucmVhZFxuICBlbHNlIGJlZ2luICgqIG5yZWFkID0gaW5pdGlhbF9zaXplLCBtYXliZSBFT0YgcmVhY2hlZCAqKVxuICAgIG1hdGNoIFN0ZGxpYi5pbnB1dF9jaGFyIGljIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPlxuICAgICAgICAoKiBFT0YgcmVhY2hlZCwgYnVmZmVyIGlzIGNvbXBsZXRlbHkgZmlsbGVkICopXG4gICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gICAgfCBjIC0+XG4gICAgICAgICgqIEVPRiBub3QgcmVhY2hlZCAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgYnVmIG9mcyA9XG4gICAgICAgICAgbGV0IGJ1ZiA9IGVuc3VyZSBidWYgb2ZzIGNodW5rX3NpemUgaW5cbiAgICAgICAgICBsZXQgcmVtID0gQnl0ZXMubGVuZ3RoIGJ1ZiAtIG9mcyBpblxuICAgICAgICAgICgqIFtyZW1dIGNhbiBiZSA8IFtjaHVua19zaXplXSBpZiBidWZmZXIgc2l6ZSBjbG9zZSB0b1xuICAgICAgICAgICAgIFtTeXMubWF4X3N0cmluZ19sZW5ndGhdICopXG4gICAgICAgICAgbGV0IHIgPSByZWFkX3VwdG8gaWMgYnVmIG9mcyByZW0gaW5cbiAgICAgICAgICBpZiByIDwgcmVtIHRoZW4gKCogRU9GIHJlYWNoZWQgKilcbiAgICAgICAgICAgIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmIDAgKG9mcyArIHIpXG4gICAgICAgICAgZWxzZSAoKiByID0gcmVtICopXG4gICAgICAgICAgICBsb29wIGJ1ZiAob2ZzICsgcmVtKVxuICAgICAgICBpblxuICAgICAgICBsZXQgYnVmID0gZW5zdXJlIGJ1ZiBucmVhZCAoY2h1bmtfc2l6ZSArIDEpIGluXG4gICAgICAgIEJ5dGVzLnNldCBidWYgbnJlYWQgYztcbiAgICAgICAgbG9vcCBidWYgKG5yZWFkICsgMSlcbiAgZW5kXG5cbmxldCBbQHRhaWxfbW9kX2NvbnNdIHJlYyBpbnB1dF9saW5lcyBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9saW5lIGljIHdpdGhcbiAgfCBsaW5lIC0+IGxpbmUgOjogaW5wdXRfbGluZXMgaWNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gW11cblxubGV0IHJlYyBmb2xkX2xpbmVzIGYgYWNjdSBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9saW5lIGljIHdpdGhcbiAgfCBsaW5lIC0+IGZvbGRfbGluZXMgZiAoZiBhY2N1IGxpbmUpIGljXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IGFjY3VcblxubGV0IHNldF9iaW5hcnlfbW9kZSA9IFN0ZGxpYi5zZXRfYmluYXJ5X21vZGVfaW5cblxuZXh0ZXJuYWwgaXNhdHR5IDogdCAtPiBib29sID0gXCJjYW1sX3N5c19pc2F0dHlcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBvdXRfY2hhbm5lbFxuXG50eXBlIG9wZW5fZmxhZyA9IFN0ZGxpYi5vcGVuX2ZsYWcgPVxuICB8IE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5cbmxldCBzdGRvdXQgPSBTdGRsaWIuc3Rkb3V0XG5sZXQgc3RkZXJyID0gU3RkbGliLnN0ZGVyclxubGV0IG9wZW5fYmluID0gU3RkbGliLm9wZW5fb3V0X2JpblxubGV0IG9wZW5fdGV4dCA9IFN0ZGxpYi5vcGVuX291dFxubGV0IG9wZW5fZ2VuID0gU3RkbGliLm9wZW5fb3V0X2dlblxuXG5sZXQgd2l0aF9vcGVuIG9wZW5mdW4gcyBmID1cbiAgbGV0IG9jID0gb3BlbmZ1biBzIGluXG4gIEZ1bi5wcm90ZWN0IH5maW5hbGx5OihmdW4gKCkgLT4gU3RkbGliLmNsb3NlX291dF9ub2VyciBvYylcbiAgICAoZnVuICgpIC0+IGYgb2MpXG5cbmxldCB3aXRoX29wZW5fYmluIHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9vdXRfYmluIHMgZlxuXG5sZXQgd2l0aF9vcGVuX3RleHQgcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX291dCBzIGZcblxubGV0IHdpdGhfb3Blbl9nZW4gZmxhZ3MgcGVybSBzIGYgPVxuICB3aXRoX29wZW4gKFN0ZGxpYi5vcGVuX291dF9nZW4gZmxhZ3MgcGVybSkgcyBmXG5cbmxldCBzZWVrID0gU3RkbGliLkxhcmdlRmlsZS5zZWVrX291dFxubGV0IHBvcyA9IFN0ZGxpYi5MYXJnZUZpbGUucG9zX291dFxubGV0IGxlbmd0aCA9IFN0ZGxpYi5MYXJnZUZpbGUub3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2UgPSBTdGRsaWIuY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfbm9lcnIgPSBTdGRsaWIuY2xvc2Vfb3V0X25vZXJyXG5sZXQgZmx1c2ggPSBTdGRsaWIuZmx1c2hcbmxldCBmbHVzaF9hbGwgPSBTdGRsaWIuZmx1c2hfYWxsXG5sZXQgb3V0cHV0X2NoYXIgPSBTdGRsaWIub3V0cHV0X2NoYXJcbmxldCBvdXRwdXRfYnl0ZSA9IFN0ZGxpYi5vdXRwdXRfYnl0ZVxubGV0IG91dHB1dF9zdHJpbmcgPSBTdGRsaWIub3V0cHV0X3N0cmluZ1xubGV0IG91dHB1dF9ieXRlcyA9IFN0ZGxpYi5vdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXQgPSBTdGRsaWIub3V0cHV0XG5sZXQgb3V0cHV0X3N1YnN0cmluZyA9IFN0ZGxpYi5vdXRwdXRfc3Vic3RyaW5nXG5sZXQgc2V0X2JpbmFyeV9tb2RlID0gU3RkbGliLnNldF9iaW5hcnlfbW9kZV9vdXRcblxuZXh0ZXJuYWwgc2V0X2J1ZmZlcmVkIDogdCAtPiBib29sIC0+IHVuaXQgPSBcImNhbWxfbWxfc2V0X2J1ZmZlcmVkXCJcblxuZXh0ZXJuYWwgaXNfYnVmZmVyZWQgOiB0IC0+IGJvb2wgPSBcImNhbWxfbWxfaXNfYnVmZmVyZWRcIlxuXG5leHRlcm5hbCBpc2F0dHkgOiB0IC0+IGJvb2wgPSBcImNhbWxfc3lzX2lzYXR0eVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgIEtDIFNpdmFyYW1ha3Jpc2huYW4sIEluZGlhbiBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgTWFkcmFzICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluZGlhbiBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgTWFkcmFzICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IC4uXG5leHRlcm5hbCBwZXJmb3JtIDogJ2EgdCAtPiAnYSA9IFwiJXBlcmZvcm1cIlxuXG50eXBlIGV4biArPSBVbmhhbmRsZWQ6ICdhIHQgLT4gZXhuXG5leGNlcHRpb24gQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFxuXG5sZXQgKCkgPVxuICBsZXQgcHJpbnRlciA9IGZ1bmN0aW9uXG4gICAgfCBVbmhhbmRsZWQgeCAtPlxuICAgICAgICBsZXQgbXNnID0gUHJpbnRmLnNwcmludGYgXCJTdGRsaWIuRWZmZWN0LlVuaGFuZGxlZCglcylcIlxuICAgICAgICAgICAgKFByaW50ZXhjLnN0cmluZ19vZl9leHRlbnNpb25fY29uc3RydWN0b3IgQEAgT2JqLnJlcHIgeClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSBtc2dcbiAgICB8IF8gLT4gTm9uZVxuICBpblxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIHByaW50ZXJcblxuKCogUmVnaXN0ZXIgdGhlIGV4Y2VwdGlvbnMgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gYWNjZXNzIGl0ICopXG50eXBlIF8gdCArPSBTaG91bGRfbm90X3NlZV90aGlzX18gOiB1bml0IHRcbmxldCBfID0gQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiRWZmZWN0LlVuaGFuZGxlZFwiXG4gICAgICAgICAgKFVuaGFuZGxlZCBTaG91bGRfbm90X3NlZV90aGlzX18pXG5sZXQgXyA9IENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIkVmZmVjdC5Db250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXCJcbiAgICAgICAgICBDb250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXG5cbnR5cGUgKCdhLCAnYikgc3RhY2tcblxuZXh0ZXJuYWwgcmVzdW1lIDogKCdhLCAnYikgc3RhY2sgLT4gKCdjIC0+ICdhKSAtPiAnYyAtPiAnYiA9IFwiJXJlc3VtZVwiXG5leHRlcm5hbCBydW5zdGFjayA6ICgnYSwgJ2IpIHN0YWNrIC0+ICgnYyAtPiAnYSkgLT4gJ2MgLT4gJ2IgPSBcIiVydW5zdGFja1wiXG5cbm1vZHVsZSBEZWVwID0gc3RydWN0XG5cbiAgdHlwZSAoJ2EsJ2IpIGNvbnRpbnVhdGlvblxuICB0eXBlIGxhc3RfZmliZXJcblxuICBleHRlcm5hbCB0YWtlX2NvbnRfbm9leGMgOiAoJ2EsICdiKSBjb250aW51YXRpb24gLT4gKCdhLCAnYikgc3RhY2sgPVxuICAgIFwiY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgYWxsb2Nfc3RhY2sgOlxuICAgICgnYSAtPiAnYikgLT5cbiAgICAoZXhuIC0+ICdiKSAtPlxuICAgICgnYyB0IC0+ICgnYywgJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyIC0+ICdiKSAtPlxuICAgICgnYSwgJ2IpIHN0YWNrID0gXCJjYW1sX2FsbG9jX3N0YWNrXCJcblxuICBsZXQgY29udGludWUgayB2ID0gcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biB4IC0+IHgpIHZcblxuICBsZXQgZGlzY29udGludWUgayBlID0gcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biBlIC0+IHJhaXNlIGUpIGVcblxuICBsZXQgZGlzY29udGludWVfd2l0aF9iYWNrdHJhY2UgayBlIGJ0ID0gcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biBlIC0+XG4gICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgZSBidCkgZVxuXG4gIHR5cGUgKCdhLCdiKSBoYW5kbGVyID1cbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgdCAtPiAoKCdjLCdiKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbiAgZXh0ZXJuYWwgcmVwZXJmb3JtIDpcbiAgICAnYSB0IC0+ICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyIC0+ICdiID0gXCIlcmVwZXJmb3JtXCJcblxuICBsZXQgbWF0Y2hfd2l0aCBjb21wIGFyZyBoYW5kbGVyID1cbiAgICBsZXQgZWZmYyBlZmYgayBsYXN0X2ZpYmVyID1cbiAgICAgIG1hdGNoIGhhbmRsZXIuZWZmYyBlZmYgd2l0aFxuICAgICAgfCBTb21lIGYgLT4gZiBrXG4gICAgICB8IE5vbmUgLT4gcmVwZXJmb3JtIGVmZiBrIGxhc3RfZmliZXJcbiAgICBpblxuICAgIGxldCBzID0gYWxsb2Nfc3RhY2sgaGFuZGxlci5yZXRjIGhhbmRsZXIuZXhuYyBlZmZjIGluXG4gICAgcnVuc3RhY2sgcyBjb21wIGFyZ1xuXG4gIHR5cGUgJ2EgZWZmZWN0X2hhbmRsZXIgPVxuICAgIHsgZWZmYzogJ2IuICdiIHQgLT4gKCgnYiwnYSkgY29udGludWF0aW9uIC0+ICdhKSBvcHRpb24gfVxuXG4gIGxldCB0cnlfd2l0aCBjb21wIGFyZyBoYW5kbGVyID1cbiAgICBsZXQgZWZmYycgZWZmIGsgbGFzdF9maWJlciA9XG4gICAgICBtYXRjaCBoYW5kbGVyLmVmZmMgZWZmIHdpdGhcbiAgICAgIHwgU29tZSBmIC0+IGYga1xuICAgICAgfCBOb25lIC0+IHJlcGVyZm9ybSBlZmYgayBsYXN0X2ZpYmVyXG4gICAgaW5cbiAgICBsZXQgcyA9IGFsbG9jX3N0YWNrIChmdW4geCAtPiB4KSAoZnVuIGUgLT4gcmFpc2UgZSkgZWZmYycgaW5cbiAgICBydW5zdGFjayBzIGNvbXAgYXJnXG5cbiAgZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjayA6XG4gICAgKCdhLCdiKSBjb250aW51YXRpb24gLT4gaW50IC0+IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgPVxuICAgIFwiY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1wiXG5lbmRcblxubW9kdWxlIFNoYWxsb3cgPSBzdHJ1Y3RcblxuICB0eXBlICgnYSwnYikgY29udGludWF0aW9uXG4gIHR5cGUgbGFzdF9maWJlclxuXG4gIGV4dGVybmFsIGFsbG9jX3N0YWNrIDpcbiAgICAoJ2EgLT4gJ2IpIC0+XG4gICAgKGV4biAtPiAnYikgLT5cbiAgICAoJ2MgdCAtPiAoJ2MsICdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciAtPiAnYikgLT5cbiAgICAoJ2EsICdiKSBzdGFjayA9IFwiY2FtbF9hbGxvY19zdGFja1wiXG5cblxuICBsZXQgZmliZXIgOiB0eXBlIGEgYi4gKGEgLT4gYikgLT4gKGEsIGIpIGNvbnRpbnVhdGlvbiA9IGZ1biBmIC0+XG4gICAgbGV0IG1vZHVsZSBNID0gc3RydWN0IHR5cGUgXyB0ICs9IEluaXRpYWxfc2V0dXBfXyA6IGEgdCBlbmQgaW5cbiAgICBsZXQgZXhjZXB0aW9uIEUgb2YgKGEsYikgY29udGludWF0aW9uIGluXG4gICAgbGV0IGYnICgpID0gZiAocGVyZm9ybSBNLkluaXRpYWxfc2V0dXBfXykgaW5cbiAgICBsZXQgZXJyb3IgXyA9IGZhaWx3aXRoIFwiaW1wb3NzaWJsZVwiIGluXG4gICAgbGV0IGVmZmMgZWZmIGsgX2xhc3RfZmliZXIgPVxuICAgICAgbWF0Y2ggZWZmIHdpdGhcbiAgICAgIHwgTS5Jbml0aWFsX3NldHVwX18gLT4gcmFpc2Vfbm90cmFjZSAoRSBrKVxuICAgICAgfCBfIC0+IGVycm9yICgpXG4gICAgaW5cbiAgICBsZXQgcyA9IGFsbG9jX3N0YWNrIGVycm9yIGVycm9yIGVmZmMgaW5cbiAgICBtYXRjaCBydW5zdGFjayBzIGYnICgpIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBFIGsgLT4ga1xuICAgIHwgXyAtPiBlcnJvciAoKVxuXG4gIHR5cGUgKCdhLCdiKSBoYW5kbGVyID1cbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgdCAtPiAoKCdjLCdhKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbiAgZXh0ZXJuYWwgdXBkYXRlX2hhbmRsZXIgOlxuICAgICgnYSwnYikgY29udGludWF0aW9uIC0+XG4gICAgKCdiIC0+ICdjKSAtPlxuICAgIChleG4gLT4gJ2MpIC0+XG4gICAgKCdkIHQgLT4gKCdkLCdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciAtPiAnYykgLT5cbiAgICAoJ2EsJ2MpIHN0YWNrID0gXCJjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjXCIgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCByZXBlcmZvcm0gOlxuICAgICdhIHQgLT4gKCdhLCAnYikgY29udGludWF0aW9uIC0+IGxhc3RfZmliZXIgLT4gJ2MgPSBcIiVyZXBlcmZvcm1cIlxuXG4gIGxldCBjb250aW51ZV9nZW4gayByZXN1bWVfZnVuIHYgaGFuZGxlciA9XG4gICAgbGV0IGVmZmMgZWZmIGsgbGFzdF9maWJlciA9XG4gICAgICBtYXRjaCBoYW5kbGVyLmVmZmMgZWZmIHdpdGhcbiAgICAgIHwgU29tZSBmIC0+IGYga1xuICAgICAgfCBOb25lIC0+IHJlcGVyZm9ybSBlZmYgayBsYXN0X2ZpYmVyXG4gICAgaW5cbiAgICBsZXQgc3RhY2sgPSB1cGRhdGVfaGFuZGxlciBrIGhhbmRsZXIucmV0YyBoYW5kbGVyLmV4bmMgZWZmYyBpblxuICAgIHJlc3VtZSBzdGFjayByZXN1bWVfZnVuIHZcblxuICBsZXQgY29udGludWVfd2l0aCBrIHYgaGFuZGxlciA9XG4gICAgY29udGludWVfZ2VuIGsgKGZ1biB4IC0+IHgpIHYgaGFuZGxlclxuXG4gIGxldCBkaXNjb250aW51ZV93aXRoIGsgdiBoYW5kbGVyID1cbiAgICBjb250aW51ZV9nZW4gayAoZnVuIGUgLT4gcmFpc2UgZSkgdiBoYW5kbGVyXG5cbiAgbGV0IGRpc2NvbnRpbnVlX3dpdGhfYmFja3RyYWNlIGsgdiBidCBoYW5kbGVyID1cbiAgICBjb250aW51ZV9nZW4gayAoZnVuIGUgLT4gUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgZSBidCkgdiBoYW5kbGVyXG5cbiAgZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjayA6XG4gICAgKCdhLCdiKSBjb250aW51YXRpb24gLT4gaW50IC0+IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgPVxuICAgIFwiY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1wiXG5lbmRcbiJdfQ==
