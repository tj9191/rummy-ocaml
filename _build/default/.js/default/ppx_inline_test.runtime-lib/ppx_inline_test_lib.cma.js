// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_inline_test_lib
//# unitInfo: Requires: Base, Base__Exn, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib$0 = "Ppx_inline_test_lib",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    initial = [0, 0, [0, "disabled", 0]],
    cst = cst$13,
    am_running_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    cst_source_tree_root$0 = "source_tree_root",
    cst_diff_path_prefix$0 = "diff_path_prefix",
    cst_diff_command = "diff_command",
    cst_in_place$0 = "in_place",
    cst_use_color = "use_color",
    _O_ =
      [0,
       [11,
        "ppx_inline_test error: attempted to access the [",
        [2, 0, [11, "] config before [init] was called", 0]]],
       "ppx_inline_test error: attempted to access the [%s] config before [init] was called"],
    _N_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _M_ = [0, 1, [0, 7, 0]],
    _F_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _G_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _B_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _C_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _D_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _E_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _H_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _I_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _K_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _L_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _J_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _z_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _A_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _t_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _u_ = [0, [2, 0, [10, 0]], cst_s],
    _v_ = [0, 1],
    _w_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _x_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _y_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _r_ = [0, [2, 0, [10, 0]], cst_s],
    _q_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib = cst_Ppx_inline_test_lib$0,
    _l_ = [0, 0],
    _j_ = [0, 0],
    cst_inline_tests_log = cst_inline_tests_log$0,
    _i_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _h_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    cst_The_inline_test_runner_can =
      "The inline test runner can only be initialized once, and has already been initialized.",
    cst_inline_test_runner = cst_inline_test_runner$0,
    _g_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Prefix_to_prepend_to_filep =
      " Prefix to prepend to filepaths in test output",
    cst_diff_path_prefix = "-diff-path-prefix",
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module into FILE",
    cst_list_partitions_into_file = "-list-partitions-into-file",
    cst_Lists_all_the_partitions_t$0 =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _f_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _e_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _d_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _c_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error",
    _k_ = [0, [2, 0, 0], cst_s$0],
    _R_ = [0, [2, 0, 0], cst_s$0],
    _p_ = [0, 187165616, 545942154],
    _P_ = [0, 187165616, -863538453];
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[26], combine, 0, ts);
   }
   var
    already_initialized = [0, 0],
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _T_ = 1, force_drop = _T_;
   }
   catch(_cb_){
    var _a_ = caml_wrap_exception(_cb_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _b_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _b$_ = caml_string_notequal(current[1], cst$13),
     _ca_ = _b$_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _b_, current[1]) : _b$_;
    return _ca_ ? caml_call3(Stdlib_Hashtbl[5], _b_, current[1], 0) : _ca_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return caml_string_equal(p, current[1]);
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var t = current$0[1];
    function _b9_(m){return m[2];}
    var _b__ = caml_call2(Stdlib_List[20], _b9_, t);
    return caml_call1(Stdlib_List[14], _b__);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    diff_path_prefix = [0, 0];
   function displayed_descr(descr, filename, line, start_pos, end_pos){
    var _b7_ = caml_obj_tag(descr);
    a:
    if(250 === _b7_)
     var descr$0 = descr[1];
    else{
     if(246 !== _b7_ && 244 !== _b7_){var descr$0 = descr; break a;}
     var descr$0 = caml_call1(CamlinternalLazy[2], descr);
    }
    var
     _b8_ =
       caml_string_equal(descr$0, cst$13)
        ? cst$0
        : caml_call2(Stdlib[28], cst$1, descr$0);
    return caml_call6
            (Stdlib_Printf[4], _c_, filename, line, start_pos, end_pos, _b8_);
   }
   function parse_argv(current, args){
    if(args){
     var _bs_ = args[2];
     if(_bs_){
      var name = args[1];
      if(! caml_string_notequal(_bs_[1], cst_inline_test_runner$0)){
       var match = _bs_[2];
       if(match){
        var rest = match[2], lib = match[1];
        if(already_initialized[1])
         throw caml_maybe_attach_backtrace
                ([0, Stdlib_Arg[8], cst_The_inline_test_runner_can], 1);
        already_initialized[1] = 1;
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, initial],
         name_filter = [0, 0],
         _bt_ =
           caml_call4
            (Stdlib_Printf[4], _g_, name, cst_inline_test_runner, lib),
         _bu_ =
           function(anon){
            var _b6_ = caml_call3(Stdlib_Printf[4], _h_, name, anon);
            throw caml_maybe_attach_backtrace([0, Stdlib_Arg[8], _b6_], 1);
           },
         _bv_ = 0,
         _bw_ =
           [0,
            [0,
             cst_diff_path_prefix,
             [4, function(s){diff_path_prefix[1] = [0, s]; return 0;}],
             cst_Prefix_to_prepend_to_filep],
            _bv_],
         _bx_ =
           [0,
            [0,
             cst_source_tree_root,
             [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
             cst_Path_to_the_root_of_the_so],
            _bw_],
         _by_ =
           [0,
            [0, cst_no_color, [3, use_color], cst_Summarize_tests_without_us],
            [0,
             [0, cst_in_place, [2, in_place], cst_Update_expect_tests_in_pla],
             [0,
              [0,
               cst_diff_cmd,
               [4, function(s){diff_command[1] = [0, s]; return 0;}],
               cst_Diff_command_for_tests_tha],
              _bx_]]],
         _bz_ =
           [0,
            [0,
             cst_only_test,
             [4,
              function(str){
               try{
                var
                 _bY_ =
                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                   },
                 _bZ_ = [0, caml_call3(Stdlib_Scanf[5], str, _f_, _bY_)],
                 match = _bZ_;
               }
               catch(_b3_){
                try{
                 var
                  _bW_ = function(file, line){return [0, file, [0, line]];},
                  _bX_ = [0, caml_call3(Stdlib_Scanf[5], str, _e_, _bW_)],
                  match = _bX_;
                }
                catch(_b4_){
                 try{
                  var
                   _bU_ = function(file){return [0, file, 0];},
                   _bV_ = [0, caml_call3(Stdlib_Scanf[5], str, _d_, _bU_)],
                   match = _bV_;
                 }
                 catch(_b5_){var match = 0;}
                }
               }
               if(match)
                var
                 match$0 = match[1],
                 index = match$0[2],
                 file = match$0[1],
                 index$0 = index,
                 filename = file;
               else if(caml_call2(Stdlib_String[15], str, 58)){
                var
                 i = caml_call2(Stdlib_String[36], str, 58),
                 filename$0 = caml_call3(Stdlib_String[16], str, 0, i),
                 index_string =
                   caml_call3
                    (Stdlib_String[16],
                     str,
                     i + 1 | 0,
                     (caml_ml_string_length(str) - i | 0) - 1 | 0);
                try{var index$1 = runtime.caml_int_of_string(index_string);}
                catch(_b2_){
                 var _b0_ = caml_wrap_exception(_b2_);
                 if(_b0_[1] !== Stdlib[7])
                  throw caml_maybe_attach_backtrace(_b0_, 0);
                 var _b1_ = caml_call2(Stdlib_Printf[4], _i_, str);
                 throw caml_maybe_attach_backtrace
                        ([0, Stdlib_Arg[8], _b1_], 1);
                }
                var index$0 = [0, index$1], filename = filename$0;
               }
               else
                var index$0 = 0, filename = str;
               tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
               return 0;
              }],
             cst_location_Run_only_the_test],
            _by_],
         _bA_ =
           [0,
            [0,
             cst_matching,
             [4,
              function(s){name_filter[1] = [0, s, name_filter[1]]; return 0;}],
             cst_substring_Only_run_tests_w],
            _bz_],
         _bB_ =
           [0,
            [0,
             cst_require_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bQ_ = t[2];
               function _bR_(_bT_){return caml_string_notequal(tag, _bT_);}
               var _bS_ = caml_call2(Stdlib_List[44], _bR_, _bQ_);
               tag_predicate[1] = [0, [0, tag, t[1]], _bS_];
               return 0;
              }],
             cst_tag_Only_run_tests_tagged_],
            _bA_],
         _bC_ =
           [0,
            [0,
             cst_drop_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bM_ = [0, tag, t[2]], _bN_ = t[1];
               function _bO_(_bP_){return caml_string_notequal(tag, _bP_);}
               tag_predicate[1] =
                [0, caml_call2(Stdlib_List[44], _bO_, _bN_), _bM_];
               return 0;
              }],
             cst_tag_Only_run_tests_not_tag],
            _bB_],
         _bD_ =
           [0,
            [0, cst_verbose, [2, verbose], cst_Show_the_tests_as_they_run],
            [0,
             [0,
              cst_stop_on_error,
              [2, stop_on_error],
              cst_Run_tests_only_up_to_the_f],
             [0,
              [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
              [0,
               [0,
                cst_show_counts,
                [2, show_counts],
                cst_Show_the_number_of_tests_r],
               [0,
                [0,
                 cst_log,
                 [0,
                  function(param){
                   try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                   catch(_bL_){}
                   log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                   return 0;
                  }],
                 cst_Log_the_tests_run_in_inlin],
                _bC_]]]]],
         _bE_ =
           [0,
            [0,
             cst_partition,
             [4, function(i){partition[1] = [0, i]; return 0;}],
             cst_Only_run_the_tests_in_the_],
            _bD_],
         _bF_ =
           [0,
            [0,
             cst_list_partitions_into_file,
             [4,
              function(file){list_partitions[1] = [0, [0, file]]; return 0;}],
             cst_Lists_all_the_partitions_t],
            _bE_],
         _bG_ =
           [0,
            [0,
             cst_list_partitions,
             [0, function(param){list_partitions[1] = _j_; return 0;}],
             cst_Lists_all_the_partitions_t$0],
            _bF_],
         _bH_ =
           [0,
            [0,
             cst_list_test_names,
             [0,
              function(param){
               list_test_names[1] = 1;
               verbose[1] = 1;
               return 0;
              }],
             cst_Do_not_run_tests_but_show_],
            _bG_],
         _bI_ = caml_call2(Stdlib_Arg[11], 0, _bH_),
         _bJ_ = caml_call1(Stdlib_Array[10], [0, name, rest]);
        caml_call5(Stdlib_Arg[3], current, _bJ_, _bI_, _bu_, _bt_);
        var match$0 = list_partitions[1];
        if(match$0)
         var
          where_to_list = match$0[1],
          _bK_ = [0, -260537174, where_to_list];
        else
         var _bK_ = [0, 1025081494, partition[1]];
        var
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _bK_]];
        action[1] = v;
        return;
       }
      }
     }
    }
    return;
   }
   if(Base[87][1])
    try{
     var _S_ = caml_sys_argv(0);
     parse_argv(0, caml_call1(Stdlib_Array[9], _S_));
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Stdlib_Arg[8]){
      var msg = exn[2];
      caml_call2(Stdlib_Printf[3], _k_, msg);
      caml_call1(Stdlib[99], 1);
     }
     else{
      if(exn[1] !== Stdlib_Arg[7]) throw caml_maybe_attach_backtrace(exn, 0);
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[2], _R_, msg$0);
      caml_call1(Stdlib[99], 0);
     }
    }
   function init(args){
    var current = [0, 0];
    try{parse_argv([0, current], args); return _l_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Stdlib_Arg[8]){var msg = exn[2]; return [1, msg];}
     if(exn[1] !== Stdlib_Arg[7]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$0 = exn[2];
     return [0, [0, msg$0]];
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(_bq_){
     var _m_ = caml_wrap_exception(_bq_);
     if(_m_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_m_, 0);
     b:
     {
      try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
      catch(_br_){
       var _n_ = caml_wrap_exception(_br_);
       if(_n_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_n_, 0);
       var _o_ = 0;
       break b;
      }
      var _Q_ = caml_string_notequal(val, "inline-test") ? 0 : 1, _o_ = _Q_;
     }
     var am_running = _o_;
     break a;
    }
    var am_running = 1;
   }
   var testing = am_test_runner ? _p_ : am_running ? _P_ : 822171972;
   function timestamp_ns(param){return caml_call1(Time_now[2], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _bo_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _bp_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib, _bo_);
        return caml_call2(Base_String[86][2], 0, _bp_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = timestamp_ns(0);
    try{var _bn_ = [0, caml_call1(f, 0)], res = _bn_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _bl_ = timestamp_ns(0),
     _bm_ = caml_call2(Base_Int63[46], _bl_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _bm_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_bk_){
        return caml_call1(Stdlib_Random[15][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_bj_){
        return caml_call1(Base_Random[19][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var t = current$0[1];
    function _bc_(m){return m[1];}
    var _bd_ = caml_call2(Stdlib_List[20], _bc_, t);
    function _be_(s){
     var
      _bg_ = caml_call1(Stdlib_String[29], s),
      _bh_ = caml_call2(Stdlib[28], _bg_, cst$3),
      _bi_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _bh_);
     return caml_call2(Stdlib[28], cst_in_TES, _bi_);
    }
    var _bf_ = caml_call2(Stdlib_List[20], _be_, _bd_);
    return caml_call2(Stdlib_String[7], cst$4, _bf_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[10], delayed_errors[1]);
    if(! delayed_errors$0) return;
    var _ba_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _q_, _ba_);
    function _bb_(message){return caml_call2(Stdlib_Printf[3], _r_, message);}
    return caml_call2(Stdlib_List[18], _bb_, delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    function _a__(s){
     if(verbose[1])
      delayed_errors[1] = [0, s, delayed_errors[1]];
     else
      caml_call2(Stdlib_Printf[3], _s_, s);
     var _a$_ = stop_on_error[1];
     return _a$_ ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2)) : _a$_;
    }
    return caml_call2(Stdlib_Printf[10], _a__, fmt);
   }
   function add_hooks(C, f, param){
    caml_call1(C[1], 0);
    return caml_call1(f, 0);
   }
   function hum_backtrace(backtrace){
    var
     _a2_ = caml_call1(Base_String[104], backtrace),
     _a3_ = Base_List[141],
     _a4_ =
       caml_call2
        (_a3_,
         _a2_,
         function(str){
          var _a8_ = caml_obj_tag(where_to_cut_backtrace);
          a:
          if(250 === _a8_)
           var _a9_ = where_to_cut_backtrace[1];
          else{
           if(246 !== _a8_ && 244 !== _a8_){
            var _a9_ = where_to_cut_backtrace;
            break a;
           }
           var _a9_ = caml_call1(CamlinternalLazy[2], where_to_cut_backtrace);
          }
          return 1 - caml_call2(Base_String[86][5], _a9_, str);
         }),
     _a5_ = Base_List[53],
     _a6_ =
       caml_call2
        (_a5_,
         _a4_,
         function(str){
          var _a7_ = caml_call2(Base[241], str, cst$5);
          return caml_call2(Base[241], cst$6, _a7_);
         });
    return caml_call2(Base_String[68], 0, _a6_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _aI_ = match[2],
     what_to_do = _aI_[2],
     match$0 = _aI_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1];
    function f$0(_a1_){return add_hooks(config, f, _a1_);}
    var
     descr$0 =
       [246,
        function(_a0_){
         return displayed_descr
                 (descr, def_filename, def_line_number, start_pos, end_pos);
        }],
     _aJ_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _aJ_),
     _aK_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_aK_){
     if(only_test_location)
      var
       _aG_ =
         function(param){
          var
           used = param[3],
           line_number_opt = param[2],
           filename = param[1],
           position_start =
             caml_ml_string_length(def_filename)
             - caml_ml_string_length(filename)
             | 0,
           _aV_ = 0 <= position_start ? 1 : 0;
          if(_aV_){
           var
            end_of_def_filename =
              caml_call3
               (Stdlib_String[16],
                def_filename,
                position_start,
                caml_ml_string_length(filename)),
            _aW_ = caml_string_equal(end_of_def_filename, filename);
           if(_aW_){
            var
             _aX_ = 0 === position_start ? 1 : 0,
             _aY_ =
               _aX_
               ||
                (47
                  ===
                   runtime.caml_string_get
                    (def_filename, position_start - 1 | 0)
                  ? 1
                  : 0);
            if(_aY_)
             if(line_number_opt)
              var
               line_number = line_number_opt[1],
               _aZ_ = caml_equal(def_line_number, line_number);
             else
              var _aZ_ = 1;
            else
             var _aZ_ = _aY_;
           }
           else
            var _aZ_ = _aW_;
           var found = _aZ_;
          }
          else
           var found = _aV_;
          if(found) used[1] = 1;
          return found;
         },
       _aL_ = caml_call2(Stdlib_List[34], _aG_, only_test_location);
     else
      var _aL_ = 1;
     if(_aL_){
      var
       _ax_ = which_tags[1],
       _ay_ =
         function(req){
          return 1 - caml_call2(Stdlib_List[37], req, complete_tags);
         },
       _az_ = caml_call2(Stdlib_List[34], _ay_, _ax_);
      if(_az_)
       var _aM_ = _az_;
      else
       var
        _aA_ = which_tags[2],
        _aB_ =
          function(dropped){
           return caml_call2(Stdlib_List[37], dropped, complete_tags);
          },
        _aM_ = caml_call2(Stdlib_List[34], _aB_, _aA_);
      var _aN_ = 1 - _aM_;
      if(_aN_){
       var _aO_ = caml_obj_tag(descr$0);
       a:
       if(250 === _aO_)
        var descr$1 = descr$0[1];
       else{
        if(246 !== _aO_ && 244 !== _aO_){var descr$1 = descr$0; break a;}
        var descr$1 = caml_call1(CamlinternalLazy[2], descr$0);
       }
       if(name_filter)
        var
         _aH_ =
           function(substring){
            return caml_call2(Base_String[92], descr$1, substring);
           },
         _aP_ = caml_call2(Stdlib_List[34], _aH_, name_filter);
       else
        var _aP_ = 1;
       var should_run = _aP_;
      }
      else
       var should_run = _aN_;
     }
     else
      var should_run = _aL_;
    }
    else
     var should_run = _aK_;
    if(! should_run) return should_run;
    if(1025081494 > what_to_do[1]) return found_test(0);
    var partition = what_to_do[2], _aQ_ = is_current(partition);
    if(! _aQ_) return _aQ_;
    var _aR_ = caml_obj_tag(descr$0);
    a:
    if(250 === _aR_)
     var descr$2 = descr$0[1];
    else{
     if(246 !== _aR_ && 244 !== _aR_){var descr$2 = descr$0; break a;}
     var descr$2 = caml_call1(CamlinternalLazy[2], descr$0);
    }
    tests_ran[1]++;
    var match$1 = log[1];
    if(match$1){
     var ch = match$1[1], _aS_ = string_of_module_descr(0);
     caml_call4(Stdlib_Printf[1], ch, _t_, descr$2, _aS_);
    }
    if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, descr$2);
    if(list_test_names[1])
     var result$0 = _v_;
    else{
     var
      caml_random_state = caml_call1(Stdlib_Random[16], 0),
      base_random_state = caml_call1(Base_Random[19][4], Base_Random[19][1]),
      _aC_ = caml_obj_tag(saved_caml_random_state);
     a:
     if(250 === _aC_)
      var _aD_ = saved_caml_random_state[1];
     else{
      if(246 !== _aC_ && 244 !== _aC_){
       var _aD_ = saved_caml_random_state;
       break a;
      }
      var _aD_ = caml_call1(CamlinternalLazy[2], saved_caml_random_state);
     }
     caml_call1(Stdlib_Random[17], _aD_);
     var _aE_ = caml_obj_tag(saved_base_random_state);
     a:
     if(250 === _aE_)
      var _aF_ = saved_base_random_state[1];
     else{
      if(246 !== _aE_ && 244 !== _aE_){
       var _aF_ = saved_base_random_state;
       break a;
      }
      var _aF_ = caml_call1(CamlinternalLazy[2], saved_base_random_state);
     }
     caml_call1(Base_Random[20], _aF_);
     var result = time_without_resetting_random_(f$0);
     caml_call1(Stdlib_Random[17], caml_random_state);
     caml_call1(Base_Random[20], base_random_state);
     var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
    }
    if(verbose[1]) caml_call2(Stdlib_Printf[2], _w_, time_sec[1]);
    if(0 !== result$0[0]){
     var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
     tests_failed[1]++;
     var
      backtrace$0 = hum_backtrace(backtrace),
      exn_str = caml_call1(Sexplib0_Sexp_conv[70], exn),
      sep = caml_call2(Stdlib_String[15], exn_str, 10) ? cst$7 : cst$8,
      _aU_ = string_of_module_descr(0);
     return caml_call5
             (eprintf_or_delay(_y_), descr$2, sep, exn_str, backtrace$0, _aU_);
    }
    if(result$0[1]) return 0;
    tests_failed[1]++;
    var _aT_ = string_of_module_descr(0);
    return caml_call2(eprintf_or_delay(_x_), descr$2, _aT_);
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _aw_ = caml_string_equal(which_tests[1], static_lib);
    if(! _aw_) return _aw_;
    a:
    {
     if(1025081494 <= what_to_do[1] && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(caml_string_equal(partition, cst$13) && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _au_ = caml_string_equal(lib, static_lib),
     _av_ = _au_ ? (dynamic_lib[1] = 0, 0) : _au_;
    return _av_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _an_ = match[2],
     what_to_do = _an_[2],
     match$0 = _an_[1],
     which_tags = match$0[4],
     libname = match$0[1];
    function f$0(_at_){return add_hooks(config, f, _at_);}
    var
     _ao_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _ao_),
     _ap_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_ap_)
     var
      _al_ = which_tags[2],
      _am_ =
        function(dropped){
         return caml_call2(Stdlib_List[37], dropped, partial_tags);
        },
      should_run = 1 - caml_call2(Stdlib_List[34], _am_, _al_);
    else
     var should_run = _ap_;
    if(! should_run) return should_run;
    if(1025081494 > what_to_do[1]) return found_test(0);
    var partition = what_to_do[2], _aq_ = is_current(partition);
    if(! _aq_) return _aq_;
    test_modules_ran[1]++;
    var
     descr$0 =
       displayed_descr
        (descr, def_filename, def_line_number, start_pos, end_pos),
     prev = current$0[1];
    current$0[1] = [0, [0, descr$0, tags], prev];
    try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     current$0[1] = prev;
     throw caml_maybe_attach_backtrace(e, 0);
    }
    if(0 === x[0]) return 0;
    var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
    test_modules_failed[1]++;
    var
     backtrace$0 = hum_backtrace(backtrace),
     exn_str = caml_call1(Sexplib0_Sexp_conv[70], exn),
     sep = caml_call2(Stdlib_String[15], exn_str, 10) ? cst$9 : cst$10,
     _ar_ = string_of_module_descr(0),
     _as_ = caml_call1(Stdlib_String[29], descr$0);
    return caml_call5
            (eprintf_or_delay(caml_call2(Stdlib[98], _A_, _z_)),
             _as_,
             sep,
             exn_str,
             backtrace$0,
             _ar_);
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var ___ = match[2], match$0 = ___[2], which_tests = ___[1];
     if(1025081494 > match$0[1]){
      var
       where_to_list = match$0[2],
       f =
         function(fout){
          var _ag_ = 0;
          function _ah_(k, param, acc){return [0, k, acc];}
          var
           _ai_ = caml_call3(Stdlib_Hashtbl[14], _ah_, _b_, _ag_),
           _aj_ = caml_call2(Stdlib_List[59], Stdlib_String[10], _ai_),
           _ak_ = caml_call2(Stdlib_Printf[1], fout, _N_);
          return caml_call2(Stdlib_List[18], _ak_, _aj_);
         };
      if(where_to_list){
       var
        file = where_to_list[1],
        _ae_ = caml_call3(Stdlib[62], _M_, 0, file),
        _af_ = caml_call1(Base_Exn[12], f);
       caml_call2(_af_, _ae_, Stdlib[76]);
      }
      else
       f(Stdlib[39]);
      return 0;
     }
     var match$1 = log[1];
     if(match$1){var ch = match$1[1]; caml_call1(Stdlib[76], ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], count_test_modules = test_modules_failed[1];
     if(0 === count && 0 === count_test_modules){
      if(show_counts[1])
       caml_call3(Stdlib_Printf[3], _D_, tests_ran[1], test_modules_ran[1]);
      var
       _$_ = which_tests[2],
       _aa_ = function(param){var used = param[3]; return 1 - used[1];},
       unused_tests = caml_call2(Stdlib_List[44], _aa_, _$_),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       caml_call1(Stdlib_Printf[3], _E_);
       var
        _ab_ =
          function(param){
           var line_number_opt = param[2], filename = param[1];
           if(! line_number_opt)
            return caml_call2(Stdlib_Printf[3], _G_, filename);
           var line_number = line_number_opt[1];
           return caml_call3(Stdlib_Printf[3], _F_, filename, line_number);
          };
       caml_call2(Stdlib_List[18], _ab_, tests);
       caml_call1(Stdlib_Printf[3], _H_);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       caml_call1(Stdlib_Printf[3], _I_);
       return 2;
      }
      return 0;
     }
     if(0 === count_test_modules)
      var _ac_ = cst$11;
     else
      var
       _ad_ = caml_call2(Stdlib[98], _L_, _K_),
       _ac_ = caml_call2(Stdlib_Printf[4], _ad_, count_test_modules);
     caml_call4(Stdlib_Printf[3], _J_, count, tests_ran[1], _ac_);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _Z_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if
       (caml_string_equal
         (caml_call1(Stdlib_Filename[13], _Z_), "inline_tests_runner.exe")){caml_call1(Stdlib_Printf[3], _B_); break a;}
     }
     caml_call1(Stdlib_Printf[3], _C_);
    }
    return 2;
   }
   function assert_test_configs_initialize(config){
    var _X_ = 1 - already_initialized[1];
    if(! _X_) return _X_;
    var _Y_ = caml_call2(Stdlib_Printf[4], _O_, config);
    return caml_call1(Stdlib[2], _Y_);
   }
   function use_color$0(param){
    assert_test_configs_initialize(cst_use_color);
    return use_color[1];
   }
   function in_place$0(param){
    assert_test_configs_initialize(cst_in_place$0);
    return in_place[1];
   }
   function diff_command$0(param){
    assert_test_configs_initialize(cst_diff_command);
    return diff_command[1];
   }
   function diff_path_prefix$0(param){
    assert_test_configs_initialize(cst_diff_path_prefix$0);
    return diff_path_prefix[1];
   }
   function source_tree_root$0(param){
    assert_test_configs_initialize(cst_source_tree_root$0);
    return source_tree_root[1];
   }
   var evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _U_ = caml_call1(Stdlib_List[10], evaluators[1]);
    function _V_(f){return caml_call1(f, 0);}
    switch(combine_all(caml_call2(Stdlib_List[20], _V_, _U_))){
      case 0:
       var _W_ = 0; break;
      case 1:
       var _W_ = 2; break;
      default: var _W_ = 1;
    }
    return caml_call1(Stdlib[99], _W_);
   }
   var
    Ppx_inline_test_lib =
      [0,
       am_running,
       am_running_env_var,
       testing,
       init,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       use_color$0,
       in_place$0,
       diff_command$0,
       diff_path_prefix$0,
       source_tree_root$0,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (137, Ppx_inline_test_lib, cst_Ppx_inline_test_lib$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJpbml0aWFsIiwiYW1fcnVubmluZ19lbnZfdmFyIiwidG9fc3RyaW5nIiwiY29tYmluZSIsInQxIiwidDIiLCJjb21iaW5lX2FsbCIsInRzIiwiYWxyZWFkeV9pbml0aWFsaXplZCIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnQkMCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJkaWZmX3BhdGhfcHJlZml4IiwiZGlzcGxheWVkX2Rlc2NyIiwiZGVzY3IiLCJmaWxlbmFtZSIsImxpbmUiLCJzdGFydF9wb3MiLCJlbmRfcG9zIiwiZGVzY3IkMCIsInBhcnNlX2FyZ3YiLCJhcmdzIiwibmFtZSIsInJlc3QiLCJsaWIiLCJ0ZXN0cyIsImxpc3RfcGFydGl0aW9ucyIsInBhcnRpdGlvbiIsInRhZ19wcmVkaWNhdGUiLCJuYW1lX2ZpbHRlciIsImFub24iLCJzIiwic3RyIiwiZmlsZSIsImluZGV4IiwiaW5kZXgkMCIsImkiLCJmaWxlbmFtZSQwIiwiaW5kZXhfc3RyaW5nIiwiaW5kZXgkMSIsInRhZyIsIndoZXJlX3RvX2xpc3QiLCJ2IiwibXNnIiwibXNnJDAiLCJpbml0IiwiYW1fdGVzdF9ydW5uZXIiLCJhbV9ydW5uaW5nIiwidGVzdGluZyIsInRpbWVzdGFtcF9ucyIsIndoZXJlX3RvX2N1dF9iYWNrdHJhY2UiLCJ0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV8iLCJmIiwiYmVmb3JlX25zIiwicmVzIiwiZXhuJDAiLCJleG4iLCJzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSIsInNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlIiwic3RyaW5nX29mX21vZHVsZV9kZXNjciIsInByaW50X2RlbGF5ZWRfZXJyb3JzIiwiZGVsYXllZF9lcnJvcnMkMCIsIm1lc3NhZ2UiLCJlcHJpbnRmX29yX2RlbGF5IiwiZm10IiwiYWRkX2hvb2tzIiwiQyIsImh1bV9iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJ0ZXN0X2lubmVyIiwiY29uZmlnIiwidGFncyIsImRlZl9maWxlbmFtZSIsImRlZl9saW5lX251bWJlciIsImJvb2xfb2ZfZiIsIndoYXRfdG9fZG8iLCJ3aGljaF90YWdzIiwib25seV90ZXN0X2xvY2F0aW9uIiwibGlibmFtZSIsImYkMCIsImNvbXBsZXRlX3RhZ3MiLCJ1c2VkIiwibGluZV9udW1iZXJfb3B0IiwicG9zaXRpb25fc3RhcnQiLCJlbmRfb2ZfZGVmX2ZpbGVuYW1lIiwibGluZV9udW1iZXIiLCJmb3VuZCIsInJlcSIsImRyb3BwZWQiLCJkZXNjciQxIiwic3Vic3RyaW5nIiwic2hvdWxkX3J1biIsImRlc2NyJDIiLCJjaCIsInJlc3VsdCQwIiwiY2FtbF9yYW5kb21fc3RhdGUiLCJiYXNlX3JhbmRvbV9zdGF0ZSIsInJlc3VsdCIsImJhY2t0cmFjZSQwIiwiZXhuX3N0ciIsInNlcCIsInNldF9saWJfYW5kX3BhcnRpdGlvbiIsInN0YXRpY19saWIiLCJ3aGljaF90ZXN0cyIsInJlcXVpcmVzX3BhcnRpdGlvbiIsInVuc2V0X2xpYiIsInRlc3QiLCJiIiwidGVzdF91bml0IiwidGVzdF9tb2R1bGUiLCJwYXJ0aWFsX3RhZ3MiLCJwcmV2IiwieCIsImUkMCIsImUiLCJzdW1tYXJpemUiLCJmb3V0IiwiayIsImFjYyIsImNvdW50IiwiY291bnRfdGVzdF9tb2R1bGVzIiwidW51c2VkX3Rlc3RzIiwiZXJyb3JzIiwiYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplIiwidXNlX2NvbG9yJDAiLCJpbl9wbGFjZSQwIiwiZGlmZl9jb21tYW5kJDAiLCJkaWZmX3BhdGhfcHJlZml4JDAiLCJzb3VyY2VfdHJlZV9yb290JDAiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHB4X2lubGluZV90ZXN0L3J1bnRpbWUtbGliL3BweF9pbmxpbmVfdGVzdF9saWIubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEyRE1BOztJQTRVRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTNYRUM7SUFBWTs7T0FDRDs7T0FDQTtlQUNGOztHQUFPO1lBR2hCQyxRQUFRQyxJQUFHQztJQUNiOztZQURVRDs7YUFBR0MsSUFFUzs7OztjQUZUQSxJQUlnQjs7SUFESjtHQUNXO1lBR2xDQyxZQUFZQztJQUFLLE9BQUEsNEJBUGpCSixZQU9ZSTtHQUFzQztHQUs5QjtJQUF0QkM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFnRkVDOztJQUlRO0lBQ1IsSUFBQSxTQUhBQzs7Ozs7UUFBQUE7O1lBUUFDLFdBTUYsT0FkRUQsMEJBRkFELFVBZ0Jx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R2hDLE9BQUE7R0FJVztZQUdYc0Q7SUFWQUQ7V0ExbEJBbkg7R0FzbUJRO1lBR1JxSDtJQWZBRjtXQXpsQkFsSDtHQTBtQk87WUFHUHFIO0lBcEJBSDtXQXhsQkFqSDtHQThtQlc7WUFHWHFIO0lBekJBSjtXQXRsQkEvRztHQWluQmU7WUFHZm9IO0lBOUJBTDtXQXZsQkFoSDtHQXVuQmU7R0FHRixJQUFic0gscUJBakhBZDtZQWtIQWUsY0FBZTlFLEdBRGY2RSxvQkFDZTdFLEdBRGY2RSx5QkFDaUQ7WUFFakRFO0lBQ3VCLFVBQUEsNEJBSnZCRjtpQkFJWTdFLEdBQUssT0FBQSxXQUFMQSxNQUFTO1dBL3lCbkJ2RSxZQSt5Qko7Ozs7Ozs7SUFBQSxPQUFBO0dBR087Ozs7T0E1YkxrRTtPQVJBdkU7T0FtQkF3RTtPQW5DQUg7V0FyV0VuRSxTQU9BRyxhQWJBSjtPQW9sQkY0SDtPQTBCQUk7T0FVQUM7T0FLQUU7T0FLZUM7T0E2SmZlO09BS0FDO09BS0FDO09BS0FDO09BS0FDO09BTUFFO09BRUFDOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgVGVzdF9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFN1Y2Nlc3NcbiAgICB8IEZhaWx1cmVcbiAgICB8IEVycm9yXG5cbiAgbGV0IHRvX2V4aXRfY29kZSA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IDBcbiAgICB8IEZhaWx1cmUgLT4gMlxuICAgIHwgRXJyb3IgLT4gMVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgU3VjY2VzcyAtPiBcInN1Y2Nlc3NcIlxuICAgIHwgRmFpbHVyZSAtPiBcImZhaWx1cmVcIlxuICAgIHwgRXJyb3IgLT4gXCJlcnJvclwiXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmUgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBTdWNjZXNzLCBTdWNjZXNzIC0+IFN1Y2Nlc3NcbiAgICB8IEVycm9yLCBfIHwgXywgRXJyb3IgLT4gRXJyb3JcbiAgICB8IEZhaWx1cmUsIF8gfCBfLCBGYWlsdXJlIC0+IEZhaWx1cmVcbiAgOztcblxuICBsZXQgY29tYmluZV9hbGwgdHMgPSBMaXN0LmZvbGRfbGVmdCBjb21iaW5lIFN1Y2Nlc3MgdHNcbmVuZFxuXG50eXBlIGRlc2NyID0gc3RyaW5nXG5cbmxldCBhbHJlYWR5X2luaXRpYWxpemVkID0gcmVmIGZhbHNlXG5sZXQgdGVzdF9tb2R1bGVzX3JhbiA9IHJlZiAwXG5sZXQgdGVzdF9tb2R1bGVzX2ZhaWxlZCA9IHJlZiAwXG5sZXQgdGVzdHNfcmFuID0gcmVmIDBcbmxldCB0ZXN0c19mYWlsZWQgPSByZWYgMFxubGV0IGR5bmFtaWNfbGliIDogc3RyaW5nIG9wdGlvbiByZWYgPSByZWYgTm9uZVxuXG50eXBlIGZpbGVuYW1lID0gc3RyaW5nXG50eXBlIGxpbmVfbnVtYmVyID0gaW50XG50eXBlIHN0YXJ0X3BvcyA9IGludFxudHlwZSBlbmRfcG9zID0gaW50XG50eXBlIGNvbmZpZyA9IChtb2R1bGUgSW5saW5lX3Rlc3RfY29uZmlnLlMpXG5cbnR5cGUgJ2EgdGVzdF9mdW5jdGlvbl9hcmdzID1cbiAgY29uZmlnOmNvbmZpZ1xuICAtPiBkZXNjcjpkZXNjciBMYXp5LnRcbiAgLT4gdGFnczpzdHJpbmcgbGlzdFxuICAtPiBmaWxlbmFtZTpmaWxlbmFtZVxuICAtPiBsaW5lX251bWJlcjpsaW5lX251bWJlclxuICAtPiBzdGFydF9wb3M6c3RhcnRfcG9zXG4gIC0+IGVuZF9wb3M6ZW5kX3Bvc1xuICAtPiAnYVxuXG5tb2R1bGUgVGFnX3ByZWRpY2F0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcmVxdWlyZWRfdGFncyA6IHN0cmluZyBsaXN0XG4gICAgOyBkcm9wcGVkX3RhZ3MgOiBzdHJpbmcgbGlzdFxuICAgIH1cblxuICBsZXQgaW5pdGlhbCA9IHsgcmVxdWlyZWRfdGFncyA9IFtdOyBkcm9wcGVkX3RhZ3MgPSBbIFwiZGlzYWJsZWRcIiBdIH1cblxuICBsZXQgZHJvcCB0IHRhZyA9XG4gICAgeyBkcm9wcGVkX3RhZ3MgPSB0YWcgOjogdC5kcm9wcGVkX3RhZ3NcbiAgICA7IHJlcXVpcmVkX3RhZ3MgPSBMaXN0LmZpbHRlciAoKCA8PiApIHRhZykgdC5yZXF1aXJlZF90YWdzXG4gICAgfVxuICA7O1xuXG4gIGxldCByZXF1aXJlIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IExpc3QuZmlsdGVyICgoIDw+ICkgdGFnKSB0LmRyb3BwZWRfdGFnc1xuICAgIDsgcmVxdWlyZWRfdGFncyA9IHRhZyA6OiB0LnJlcXVpcmVkX3RhZ3NcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGVudGlyZV9tb2R1bGVfZGlzYWJsZWQgdCB+cGFydGlhbF90YWdzOnRhZ3MgPVxuICAgIExpc3QuZXhpc3RzIChmdW4gZHJvcHBlZCAtPiBMaXN0Lm1lbSBkcm9wcGVkIHRhZ3MpIHQuZHJvcHBlZF90YWdzXG4gIDs7XG5cbiAgbGV0IGRpc2FibGVkIHQgfmNvbXBsZXRlX3RhZ3M6dGFncyA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biByZXEgLT4gbm90IChMaXN0Lm1lbSByZXEgdGFncykpIHQucmVxdWlyZWRfdGFnc1xuICAgIHx8IExpc3QuZXhpc3RzIChmdW4gZHJvcHBlZCAtPiBMaXN0Lm1lbSBkcm9wcGVkIHRhZ3MpIHQuZHJvcHBlZF90YWdzXG4gIDs7XG5lbmRcblxubW9kdWxlIFdoZXJlX3RvX2xpc3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFN0ZG91dFxuICAgIHwgRmlsZSBvZiBzdHJpbmdcbmVuZFxuXG50eXBlIHdoaWNoX3Rlc3RzID1cbiAgeyBsaWJuYW1lIDogc3RyaW5nXG4gIDsgb25seV90ZXN0X2xvY2F0aW9uIDogKGZpbGVuYW1lICogbGluZV9udW1iZXIgb3B0aW9uICogYm9vbCByZWYpIGxpc3RcbiAgOyBuYW1lX2ZpbHRlciA6IHN0cmluZyBsaXN0XG4gIDsgd2hpY2hfdGFncyA6IFRhZ19wcmVkaWNhdGUudFxuICB9XG5cbnR5cGUgdGVzdF9tb2RlID1cbiAgeyB3aGljaF90ZXN0cyA6IHdoaWNoX3Rlc3RzXG4gIDsgd2hhdF90b19kbyA6IFsgYFJ1bl9wYXJ0aXRpb24gb2Ygc3RyaW5nIG9wdGlvbiB8IGBMaXN0X3BhcnRpdGlvbnMgb2YgV2hlcmVfdG9fbGlzdC50IF1cbiAgfVxuXG5tb2R1bGUgQWN0aW9uIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgWyBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICAgIF1cblxuICB2YWwgZ2V0IDogdW5pdCAtPiB0XG4gIHZhbCBzZXQgOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYElnbm9yZVxuICAgIHwgYFRlc3RfbW9kZSBvZiB0ZXN0X21vZGVcbiAgICBdXG5cbiAgbGV0IGFjdGlvbiA6IHQgcmVmID0gcmVmIGBJZ25vcmVcblxuICBsZXQgZm9yY2VfZHJvcCA9XG4gICAgdHJ5XG4gICAgICBpZ25vcmUgKFN5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0lOTElORV9URVNUXCIgOiBzdHJpbmcpO1xuICAgICAgdHJ1ZVxuICAgIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBnZXQgKCkgPVxuICAgICgqIFRoaXMgaXMgdXNlZnVsIHdoZW4gY29tcGlsaW5nIHRvIGphdmFzY3JpcHQuXG4gICAgICAgSnNfb2Zfb2NhbWwgY2FuIHN0YXRpY2FsbHkgZXZhbHVhdGUgW1N5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0lOTElORV9URVNUXCJdXG4gICAgICAgYW5kIGlubGluZSB0aGUgcmVzdWx0IChbYElnbm9yZV0pIHdoZW5ldmVyIFtnZXQgKCldIGlzIGNhbGxlZC5cbiAgICAgICBVbml0IHRlc3RzIGNhbiB0aGVuIGJlIHRyZWF0ZWQgYXMgZGVhZGNvZGUgc2luY2UgdGhlIGFyZ3VtZW50IFtmXSBvZiB0aGUgW3Rlc3RdXG4gICAgICAgZnVuY3Rpb24gYmVsb3cgaXMgbmV2ZXIgdXNlZC4gKilcbiAgICBpZiBmb3JjZV9kcm9wIHRoZW4gYElnbm9yZSBlbHNlICFhY3Rpb25cbiAgOztcblxuICBsZXQgc2V0IHYgPSBhY3Rpb24gOj0gdlxuZW5kXG5cbm1vZHVsZSBQYXJ0aXRpb24gOiBzaWdcbiAgdmFsIGZvdW5kX3Rlc3QgOiB1bml0IC0+IHVuaXRcbiAgdmFsIHNldF9jdXJyZW50IDogc3RyaW5nIC0+IHVuaXRcbiAgdmFsIGlzX2N1cnJlbnQgOiBzdHJpbmcgb3B0aW9uIC0+IGJvb2xcbiAgdmFsIGFsbCA6IHVuaXQgLT4gc3RyaW5nIGxpc3RcbmVuZCA9IHN0cnVjdFxuICBsZXQgYWxsID0gSGFzaHRibC5jcmVhdGUgMjNcbiAgbGV0IGN1cnJlbnQgPSByZWYgXCJcIlxuICBsZXQgc2V0X2N1cnJlbnQgeCA9IGN1cnJlbnQgOj0geFxuXG4gIGxldCBmb3VuZF90ZXN0ICgpID1cbiAgICBpZiAhY3VycmVudCA8PiBcIlwiICYmIG5vdCAoSGFzaHRibC5tZW0gYWxsICFjdXJyZW50KSB0aGVuIEhhc2h0YmwuYWRkIGFsbCAhY3VycmVudCAoKVxuICA7O1xuXG4gIGxldCBpc19jdXJyZW50ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgIHwgU29tZSBwIC0+IHAgPSAhY3VycmVudFxuICA7O1xuXG4gIGxldCBhbGwgKCkgPSBMaXN0LnNvcnQgU3RyaW5nLmNvbXBhcmUgKEhhc2h0YmwuZm9sZCAoZnVuIGsgKCkgYWNjIC0+IGsgOjogYWNjKSBhbGwgW10pXG5lbmRcblxubW9kdWxlIE1vZHVsZV9jb250ZXh0ID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSBvbmVfbW9kdWxlID1cbiAgICAgIHsgZGVzY3IgOiBzdHJpbmdcbiAgICAgIDsgdGFncyA6IHN0cmluZyBsaXN0XG4gICAgICB9XG5cbiAgICB0eXBlIHQgPSBvbmVfbW9kdWxlIGxpc3RcblxuICAgIGxldCBkZXNjciB0ID0gTGlzdC5tYXAgKGZ1biBtIC0+IG0uZGVzY3IpIHRcbiAgICBsZXQgdGFncyB0ID0gTGlzdC5jb25jYXQgKExpc3QubWFwIChmdW4gbSAtPiBtLnRhZ3MpIHQpXG4gIGVuZFxuXG4gIGxldCBjdXJyZW50IDogVC50IHJlZiA9IHJlZiBbXVxuXG4gIGxldCB3aXRoXyB+ZGVzY3IgfnRhZ3MgZiA9XG4gICAgbGV0IHByZXYgPSAhY3VycmVudCBpblxuICAgIGN1cnJlbnQgOj0geyBULmRlc2NyOyB0YWdzIH0gOjogcHJldjtcbiAgICB0cnlcbiAgICAgIGxldCB4ID0gZiAoKSBpblxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgeFxuICAgIHdpdGhcbiAgICB8IGUgLT5cbiAgICAgIGN1cnJlbnQgOj0gcHJldjtcbiAgICAgIHJhaXNlIGVcbiAgOztcblxuICBsZXQgY3VycmVudF9kZXNjciAoKSA9IFQuZGVzY3IgIWN1cnJlbnRcbiAgbGV0IGN1cnJlbnRfdGFncyAoKSA9IFQudGFncyAhY3VycmVudFxuZW5kXG5cbmxldCB2ZXJib3NlID0gcmVmIGZhbHNlXG5sZXQgc3RyaWN0ID0gcmVmIGZhbHNlXG5sZXQgc2hvd19jb3VudHMgPSByZWYgZmFsc2VcbmxldCBsaXN0X3Rlc3RfbmFtZXMgPSByZWYgZmFsc2VcbmxldCBkZWxheWVkX2Vycm9ycyA9IHJlZiBbXVxubGV0IHN0b3Bfb25fZXJyb3IgPSByZWYgZmFsc2VcbmxldCBsb2cgPSByZWYgTm9uZVxubGV0IHRpbWVfc2VjID0gcmVmIDAuXG5sZXQgdXNlX2NvbG9yID0gcmVmIHRydWVcbmxldCBpbl9wbGFjZSA9IHJlZiBmYWxzZVxubGV0IGRpZmZfY29tbWFuZCA9IHJlZiBOb25lXG5sZXQgc291cmNlX3RyZWVfcm9vdCA9IHJlZiBOb25lXG5sZXQgZGlmZl9wYXRoX3ByZWZpeCA9IHJlZiBOb25lXG5cbmxldCBkaXNwbGF5ZWRfZGVzY3IgZGVzY3IgZmlsZW5hbWUgbGluZSBzdGFydF9wb3MgZW5kX3BvcyA9XG4gIGxldCAobGF6eSBkZXNjcikgPSBkZXNjciBpblxuICBQcmludGYuc3ByaW50ZlxuICAgIFwiRmlsZSAlUywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZCVzXCJcbiAgICBmaWxlbmFtZVxuICAgIGxpbmVcbiAgICBzdGFydF9wb3NcbiAgICBlbmRfcG9zXG4gICAgKGlmIGRlc2NyID0gXCJcIiB0aGVuIFwiXCIgZWxzZSBcIjogXCIgXiBkZXNjcilcbjs7XG5cbmxldCBwYXJzZV9kZXNjciBzdHIgPVxuICB0cnlcbiAgICBTb21lXG4gICAgICAoU2NhbmYuc3NjYW5mXG4gICAgICAgICBzdHJcbiAgICAgICAgIFwiIEZpbGUgJVMgLCBsaW5lICVkICwgY2hhcmFjdGVycyAlZCAtICVkICUhXCJcbiAgICAgICAgIChmdW4gZmlsZSBsaW5lIF9zdGFydF9wb3MgX2VuZF9wb3MgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgd2l0aFxuICB8IF8gLT5cbiAgICAodHJ5XG4gICAgICAgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICwgbGluZSAlZCAlIVwiIChmdW4gZmlsZSBsaW5lIC0+IGZpbGUsIFNvbWUgbGluZSkpXG4gICAgIHdpdGhcbiAgICAgfCBfIC0+XG4gICAgICAgKHRyeSBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgJSFcIiAoZnVuIGZpbGUgLT4gZmlsZSwgTm9uZSkpIHdpdGhcbiAgICAgICAgfCBfIC0+IE5vbmUpKVxuOztcblxubGV0IHBhcnNlX2FyZ3YgP2N1cnJlbnQgYXJncyA9XG4gIG1hdGNoIGFyZ3Mgd2l0aFxuICB8IG5hbWVcbiAgICA6OiBcImlubGluZS10ZXN0LXJ1bm5lclwiICgqIHdoZW4gd2Ugc2VlIHRoaXMgYXJndW1lbnQsIHdlIHN3aXRjaCB0byB0ZXN0IG1vZGUgKilcbiAgICA6OiBsaWJcbiAgICA6OiByZXN0IC0+XG4gICAgKCogaW5pdGlhbGl6YXRpb24gc2hvdWxkIG9ubHkgb2NjdXIgb25jZSAqKVxuICAgIGlmICFhbHJlYWR5X2luaXRpYWxpemVkXG4gICAgdGhlblxuICAgICAgcmFpc2VcbiAgICAgICAgKEFyZy5CYWRcbiAgICAgICAgICAgXCJUaGUgaW5saW5lIHRlc3QgcnVubmVyIGNhbiBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2UsIGFuZCBoYXMgYWxyZWFkeSBiZWVuIFxcXG4gICAgICAgICAgICBpbml0aWFsaXplZC5cIik7XG4gICAgYWxyZWFkeV9pbml0aWFsaXplZCA6PSB0cnVlO1xuICAgIGxldCB0ZXN0cyA9IHJlZiBbXSBpblxuICAgIGxldCBsaXN0X3BhcnRpdGlvbnMgPSAocmVmIE5vbmUgOiBXaGVyZV90b19saXN0LnQgb3B0aW9uIHJlZikgaW5cbiAgICBsZXQgcGFydGl0aW9uID0gcmVmIE5vbmUgaW5cbiAgICBsZXQgdGFnX3ByZWRpY2F0ZSA9IHJlZiBUYWdfcHJlZGljYXRlLmluaXRpYWwgaW5cbiAgICBsZXQgbmFtZV9maWx0ZXIgPSByZWYgW10gaW5cbiAgICBBcmcucGFyc2VfYXJndlxuICAgICAgP2N1cnJlbnRcbiAgICAgIChBcnJheS5vZl9saXN0IChuYW1lIDo6IHJlc3QpKVxuICAgICAgKEFyZy5hbGlnblxuICAgICAgICAgWyAoIFwiLWxpc3QtdGVzdC1uYW1lc1wiXG4gICAgICAgICAgICwgQXJnLlVuaXRcbiAgICAgICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgbGlzdF90ZXN0X25hbWVzIDo9IHRydWU7XG4gICAgICAgICAgICAgICAgIHZlcmJvc2UgOj0gdHJ1ZSlcbiAgICAgICAgICAgLCBcIiBEbyBub3QgcnVuIHRlc3RzIGJ1dCBzaG93IHdoYXQgd291bGQgaGF2ZSBiZWVuIHJ1blwiIClcbiAgICAgICAgIDsgKCBcIi1saXN0LXBhcnRpdGlvbnNcIlxuICAgICAgICAgICAsIEFyZy5Vbml0IChmdW4gKCkgLT4gbGlzdF9wYXJ0aXRpb25zIDo9IFNvbWUgU3Rkb3V0KVxuICAgICAgICAgICAsIFwiIExpc3RzIGFsbCB0aGUgcGFydGl0aW9ucyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHRlc3Qgb3IgdGVzdF9tb2R1bGVcIiApXG4gICAgICAgICA7ICggXCItbGlzdC1wYXJ0aXRpb25zLWludG8tZmlsZVwiXG4gICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIGZpbGUgLT4gbGlzdF9wYXJ0aXRpb25zIDo9IFNvbWUgKEZpbGUgZmlsZSkpXG4gICAgICAgICAgICwgXCIgTGlzdHMgYWxsIHRoZSBwYXJ0aXRpb25zIHRoYXQgY29udGFpbiBhdCBsZWFzdCBvbmUgdGVzdCBvciB0ZXN0X21vZHVsZSBcXFxuICAgICAgICAgICAgICBpbnRvIEZJTEVcIiApXG4gICAgICAgICA7ICggXCItcGFydGl0aW9uXCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gaSAtPiBwYXJ0aXRpb24gOj0gU29tZSBpKVxuICAgICAgICAgICAsIFwiIE9ubHkgcnVuIHRoZSB0ZXN0cyBpbiB0aGUgZ2l2ZW4gcGFydGl0aW9uXCIgKVxuICAgICAgICAgOyBcIi12ZXJib3NlXCIsIEFyZy5TZXQgdmVyYm9zZSwgXCIgU2hvdyB0aGUgdGVzdHMgYXMgdGhleSBydW5cIlxuICAgICAgICAgOyAoIFwiLXN0b3Atb24tZXJyb3JcIlxuICAgICAgICAgICAsIEFyZy5TZXQgc3RvcF9vbl9lcnJvclxuICAgICAgICAgICAsIFwiIFJ1biB0ZXN0cyBvbmx5IHVwIHRvIHRoZSBmaXJzdCBlcnJvciAoZG9lc24ndCB3b3JrIGZvciBleHBlY3QgdGVzdHMpXCIgKVxuICAgICAgICAgOyBcIi1zdHJpY3RcIiwgQXJnLlNldCBzdHJpY3QsIFwiIEVuZCB3aXRoIGFuIGVycm9yIGlmIG5vIHRlc3RzIHdlcmUgcnVuXCJcbiAgICAgICAgIDsgXCItc2hvdy1jb3VudHNcIiwgQXJnLlNldCBzaG93X2NvdW50cywgXCIgU2hvdyB0aGUgbnVtYmVyIG9mIHRlc3RzIHJhblwiXG4gICAgICAgICA7ICggXCItbG9nXCJcbiAgICAgICAgICAgLCBBcmcuVW5pdFxuICAgICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAodHJ5IFN5cy5yZW1vdmUgXCJpbmxpbmVfdGVzdHMubG9nXCIgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBfIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgbG9nIDo9IFNvbWUgKG9wZW5fb3V0IFwiaW5saW5lX3Rlc3RzLmxvZ1wiKSlcbiAgICAgICAgICAgLCBcIiBMb2cgdGhlIHRlc3RzIHJ1biBpbiBpbmxpbmVfdGVzdHMubG9nXCIgKVxuICAgICAgICAgOyAoIFwiLWRyb3AtdGFnXCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gcyAtPiB0YWdfcHJlZGljYXRlIDo9IFRhZ19wcmVkaWNhdGUuZHJvcCAhdGFnX3ByZWRpY2F0ZSBzKVxuICAgICAgICAgICAsIFwidGFnIE9ubHkgcnVuIHRlc3RzIG5vdCB0YWdnZWQgd2l0aCBbdGFnXSAob3ZlcnJpZGVzIHByZXZpb3VzIC1yZXF1aXJlLXRhZylcIlxuICAgICAgICAgICApXG4gICAgICAgICA7ICggXCItcmVxdWlyZS10YWdcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5yZXF1aXJlICF0YWdfcHJlZGljYXRlIHMpXG4gICAgICAgICAgICwgXCJ0YWcgT25seSBydW4gdGVzdHMgdGFnZ2VkIHdpdGggW3RhZ10gKG92ZXJyaWRlcyBwcmV2aW91cyAtZHJvcC10YWcpXCIgKVxuICAgICAgICAgOyAoIFwiLW1hdGNoaW5nXCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBuYW1lX2ZpbHRlciA6PSBzIDo6ICFuYW1lX2ZpbHRlcilcbiAgICAgICAgICAgLCBcInN1YnN0cmluZyBPbmx5IHJ1biB0ZXN0cyB3aG9zZSBuYW1lcyBjb250YWluIHRoZSBnaXZlbiBzdWJzdHJpbmdcIiApXG4gICAgICAgICA7ICggXCItb25seS10ZXN0XCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nXG4gICAgICAgICAgICAgICAoZnVuIHMgLT5cbiAgICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lLCBpbmRleCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggcGFyc2VfZGVzY3IgcyB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBTb21lIChmaWxlLCBpbmRleCkgLT4gZmlsZSwgaW5kZXhcbiAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgIGlmIFN0cmluZy5jb250YWlucyBzICc6J1xuICAgICAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJzonIGluXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IFN0cmluZy5zdWIgcyAwIGkgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4X3N0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nLnN1YiBzIChpICsgMSkgKFN0cmluZy5sZW5ndGggcyAtIGkgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPVxuICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIGluZGV4X3N0cmluZyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBcmcuQmFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFyZ3VtZW50ICVzIGRvZXNuJ3QgZml0IHRoZSBmb3JtYXQgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lWzpsaW5lX251bWJlcl1cXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJSFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUsIFNvbWUgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICBlbHNlIHMsIE5vbmVcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgdGVzdHMgOj0gKGZpbGVuYW1lLCBpbmRleCwgcmVmIGZhbHNlKSA6OiAhdGVzdHMpXG4gICAgICAgICAgICwgXCJsb2NhdGlvbiBSdW4gb25seSB0aGUgdGVzdHMgc3BlY2lmaWVkIGJ5IGFsbCB0aGUgLW9ubHktdGVzdCBvcHRpb25zLlxcblxcXG4gICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgTG9jYXRpb25zIGNhbiBiZSBvbmUgb2YgdGhlc2UgZm9ybXM6XFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIGZpbGUubWxcXG5cXFxuICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgIC0gZmlsZS5tbDpsaW5lX251bWJlclxcblxcXG4gICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIlxcblxcXG4gICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIiwgbGluZSAyM1xcblxcXG4gICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIiwgbGluZSAyMywgY2hhcmFjdGVycyAyLTNcIiApXG4gICAgICAgICA7IFwiLW5vLWNvbG9yXCIsIEFyZy5DbGVhciB1c2VfY29sb3IsIFwiIFN1bW1hcml6ZSB0ZXN0cyB3aXRob3V0IHVzaW5nIGNvbG9yXCJcbiAgICAgICAgIDsgXCItaW4tcGxhY2VcIiwgQXJnLlNldCBpbl9wbGFjZSwgXCIgVXBkYXRlIGV4cGVjdCB0ZXN0cyBpbiBwbGFjZVwiXG4gICAgICAgICA7ICggXCItZGlmZi1jbWRcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IGRpZmZfY29tbWFuZCA6PSBTb21lIHMpXG4gICAgICAgICAgICwgXCIgRGlmZiBjb21tYW5kIGZvciB0ZXN0cyB0aGF0IHJlcXVpcmUgZGlmZmluZyAodXNlIC0gdG8gZGlzYWJsZSBkaWZmaW5nKVwiIClcbiAgICAgICAgIDsgKCBcIi1zb3VyY2UtdHJlZS1yb290XCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBzb3VyY2VfdHJlZV9yb290IDo9IFNvbWUgcylcbiAgICAgICAgICAgLCBcIiBQYXRoIHRvIHRoZSByb290IG9mIHRoZSBzb3VyY2UgdHJlZVwiIClcbiAgICAgICAgIDsgKCBcIi1kaWZmLXBhdGgtcHJlZml4XCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBkaWZmX3BhdGhfcHJlZml4IDo9IFNvbWUgcylcbiAgICAgICAgICAgLCBcIiBQcmVmaXggdG8gcHJlcGVuZCB0byBmaWxlcGF0aHMgaW4gdGVzdCBvdXRwdXRcIiApXG4gICAgICAgICBdKVxuICAgICAgKGZ1biBhbm9uIC0+XG4gICAgICAgIHJhaXNlXG4gICAgICAgICAgKEFyZy5CYWQgKFByaW50Zi5zcHJpbnRmIFwiJXM6IHVuZXhwZWN0ZWQgYW5vbnltb3VzIGFyZ3VtZW50ICVzXFxuJSFcIiBuYW1lIGFub24pKSlcbiAgICAgIChQcmludGYuc3ByaW50ZiBcIiVzICVzICVzIFthcmdzXVwiIG5hbWUgXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiBsaWIpO1xuICAgIEFjdGlvbi5zZXRcbiAgICAgIChgVGVzdF9tb2RlXG4gICAgICAgIHsgd2hpY2hfdGVzdHMgPVxuICAgICAgICAgICAgeyBsaWJuYW1lID0gbGliXG4gICAgICAgICAgICA7IG9ubHlfdGVzdF9sb2NhdGlvbiA9ICF0ZXN0c1xuICAgICAgICAgICAgOyB3aGljaF90YWdzID0gIXRhZ19wcmVkaWNhdGVcbiAgICAgICAgICAgIDsgbmFtZV9maWx0ZXIgPSAhbmFtZV9maWx0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgOyB3aGF0X3RvX2RvID1cbiAgICAgICAgICAgIChtYXRjaCAhbGlzdF9wYXJ0aXRpb25zIHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgd2hlcmVfdG9fbGlzdCAtPiBgTGlzdF9wYXJ0aXRpb25zIHdoZXJlX3RvX2xpc3RcbiAgICAgICAgICAgICB8IE5vbmUgLT4gYFJ1bl9wYXJ0aXRpb24gIXBhcnRpdGlvbilcbiAgICAgICAgfSlcbiAgfCBfIC0+ICgpXG47O1xuXG5sZXQgKCkgPVxuICBpZiBCYXNlLkV4cG9ydGVkX2Zvcl9zcGVjaWZpY191c2VzLmFtX3Rlc3RpbmdcbiAgdGhlbiAoXG4gICAgdHJ5IHBhcnNlX2FyZ3YgKEFycmF5LnRvX2xpc3QgU3lzLmFyZ3YpIHdpdGhcbiAgICB8IEFyZy5CYWQgbXNnIC0+XG4gICAgICBQcmludGYuZXByaW50ZiBcIiVzXCIgbXNnO1xuICAgICAgZXhpdCAxXG4gICAgfCBBcmcuSGVscCBtc2cgLT5cbiAgICAgIFByaW50Zi5wcmludGYgXCIlc1wiIG1zZztcbiAgICAgIGV4aXQgMClcbjs7XG5cbmxldCBpbml0IGFyZ3MgPVxuICBsZXQgY3VycmVudCA9IHJlZiAwIGluXG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgfmN1cnJlbnQgYXJncztcbiAgICBPayBOb25lXG4gIHdpdGhcbiAgfCBBcmcuQmFkIG1zZyAtPiBFcnJvciBtc2dcbiAgfCBBcmcuSGVscCBtc2cgLT4gT2sgKFNvbWUgbXNnKVxuOztcblxubGV0IGFtX3Rlc3RfcnVubmVyID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYFRlc3RfbW9kZSBfIC0+IHRydWVcbiAgfCBgSWdub3JlIC0+IGZhbHNlXG47O1xuXG5sZXQgYW1fcnVubmluZ19lbnZfdmFyID1cbiAgKCogZm9yIGFwcHJveGltYXRlIGNvbXBhdGliaWxpdHksIGdpdmVuIHRoYXQgdGhlIHZhcmlhYmxlIGlzIG5vdCBleGFjdGx5IGVxdWl2YWxlbnRcbiAgICAgdG8gd2hhdCBQUFhfSU5MSU5FX1RFU1RfTElCX0FNX1JVTk5JTkdfSU5MSU5FX1RFU1QgdXNlZCB0byBiZSAqKVxuICBcIlRFU1RJTkdfRlJBTUVXT1JLXCJcbjs7XG5cbigqIFRoaXMgdmFsdWUgaXMgZGVwcmVjYXRlZCBpbiBwcmluY2lwbGUsIGluIGZhdm9yIG9mIENvcmUuYW1fcnVubmluZ190ZXN0LCBzb1xuICAgd2UncmUgZ29pbmcgdG8gbGl2ZSB3aXRoIHRoZSB1Z2x5IHBhdHRlcm4gbWF0Y2guICopXG5sZXQgYW1fcnVubmluZyA9XG4gIG1hdGNoIFN5cy5nZXRlbnYgXCJQUFhfSU5MSU5FX1RFU1RfTElCX0FNX1JVTk5JTkdfSU5MSU5FX1RFU1RcIiB3aXRoXG4gIHwgKF8gOiBzdHJpbmcpIC0+XG4gICAgdHJ1ZSAoKiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHBlb3BsZSBzZXR0aW5nIHRoaXMgdmFyaWFibGUgZGlyZWN0bHkgKilcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgKG1hdGNoIFN5cy5nZXRlbnYgYW1fcnVubmluZ19lbnZfdmFyIHdpdGhcbiAgICAgfCBcImlubGluZS10ZXN0XCIgLT4gdHJ1ZVxuICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gZmFsc2VcbiAgICAgfCBfIC0+IGZhbHNlKVxuOztcblxubGV0IHRlc3RpbmcgPVxuICBpZiBhbV90ZXN0X3J1bm5lclxuICB0aGVuIGBUZXN0aW5nIGBBbV90ZXN0X3J1bm5lclxuICBlbHNlIGlmIGFtX3J1bm5pbmdcbiAgdGhlbiBgVGVzdGluZyBgQW1fY2hpbGRfb2ZfdGVzdF9ydW5uZXJcbiAgZWxzZSBgTm90X3Rlc3Rpbmdcbjs7XG5cbigqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBpbnQ2MyByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBuYW5vcyBzaW5jZVxuICAgc29tZSAoZml4ZWQpIGJhc2VsaW5lLiAgT24gdW5peCwgdGhpcyBiYXNlbGluZSB3aWxsIGJlIHRoZSB1bml4IGVwb2NoLFxuICAgYW5kIGluIGphdmFzY3JpcHQsIHRoZSBiYXNlbGluZSB3aWxsIGJlIFwicHJvZ3JhbSBpbml0aWFsaXphdGlvbiB0aW1lLlwiXG4gICBSZWdhcmRsZXNzLCBpdCdzIGFsd2F5cyBzYWZlIHRvIHN1YnRyYWN0IHR3byB2YWx1ZXMgYW5kIHVzZSB0aGUgZGlmZixcbiAgIHdoaWNoIGlzIGFsbCB0aGF0IHBweF9pbmxpbmVfdGVzdF9saWIgdXNlcyBpdCBmb3IuICopXG5sZXQgdGltZXN0YW1wX25zICgpID0gVGltZV9ub3cubmFub3NlY29uZF9jb3VudGVyX2Zvcl90aW1pbmcgKClcblxubGV0IHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UgPVxuICBsYXp5XG4gICAgKEJhc2UuU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLmNyZWF0ZVxuICAgICAgIChfX01PRFVMRV9fIF4gXCIuXCIgXiBcInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzXCIpKVxuOztcblxubGV0IHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYgPVxuICBsZXQgYmVmb3JlX25zID0gdGltZXN0YW1wX25zICgpIGluXG4gIGxldCByZXMgPVxuICAgICgqIFRvIGF2b2lkIG5vaXNlIGluIGJhY2t0cmFjZXMsIHdlIGRvIHR3byB0aGluZ3MuXG5cbiAgICAgICBXZSB1c2UgW3doZXJlX3RvX2N1dF9iYWNrdHJhY2VdIGFib3ZlIHRvIHJlbW92ZSB0aGUgc3RhY2sgZnJhbWVzIGZvciB0aGUgY3VycmVudFxuICAgICAgIGZ1bmN0aW9uIGFuZCBhbnkgZnVuY3Rpb24gaXQgZ2V0cyBpbmxpbmVkIGludG8sIGFzIGl0J3Mgbm90IG9mIGFueSBpbnRlcmVzdCB0byB0aGVcbiAgICAgICB1c2VyLCBzaW5jZSBpdCdzIG5vdCB0YWxraW5nIGFib3V0IHRoZWlyIHRlc3QgYnV0IGluc3RlYWQgdGFsa2luZyBhYm91dCB0aGVcbiAgICAgICBwcHhfaW5saW5lX3Rlc3QgbWFjaGluZXJ5LlxuXG4gICAgICAgV2UgYWxzbyBhdm9pZCBpbnNlcnRpbmcgYW55IGNvZGUgYmV0d2VlbiB0aGUgW2ZdIHRoYXQgY29tZXMgZnJvbSB0aGUgdXNlcidzIGZpbGVcbiAgICAgICBhbmQgZ3JhYmJpbmcgdGhlIGJhY2t0cmFjZSBmcm9tIGl0cyBleGNlcHRpb25zIChubyB3cmFwcGluZyBvZiBbZl0gd2l0aCBoaWdoIG9yZGVyXG4gICAgICAgZnVuY3Rpb25zIGxpa2UgRXhuLnByb3RlY3QsIG9yIChmdW4gKCkgLT4gZiAoKTsgdHJ1ZSkpLiAqKVxuICAgIHRyeSBPayAoZiAoKSkgd2l0aFxuICAgIHwgZXhuIC0+IEVycm9yIChleG4sIFByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gIGluXG4gIHRpbWVfc2VjIDo9IEJhc2UuSW50NjMuKHRpbWVzdGFtcF9ucyAoKSAtIGJlZm9yZV9ucyB8PiB0b19mbG9hdCkgLy4gMWU5O1xuICByZXNcbjs7XG5cbmxldCBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSA9IGxhenkgKFN0ZGxpYi5SYW5kb20uU3RhdGUubWFrZSBbfCAxMDA7IDIwMDsgMzAwIHxdKVxubGV0IHNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlID0gbGF6eSAoQmFzZS5SYW5kb20uU3RhdGUubWFrZSBbfCAxMTE7IDIyMjsgMzMzIHxdKVxuXG5sZXQgdGltZV9hbmRfcmVzZXRfcmFuZG9tX3NlZWRzIGYgPVxuICBsZXQgY2FtbF9yYW5kb21fc3RhdGUgPSBTdGRsaWIuUmFuZG9tLmdldF9zdGF0ZSAoKSBpblxuICBsZXQgYmFzZV9yYW5kb21fc3RhdGUgPSBCYXNlLlJhbmRvbS5TdGF0ZS5jb3B5IEJhc2UuUmFuZG9tLlN0YXRlLmRlZmF1bHQgaW5cbiAgU3RkbGliLlJhbmRvbS5zZXRfc3RhdGUgKExhenkuZm9yY2Ugc2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUpO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgKExhenkuZm9yY2Ugc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUpO1xuICBsZXQgcmVzdWx0ID0gdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSBjYW1sX3JhbmRvbV9zdGF0ZTtcbiAgQmFzZS5SYW5kb20uc2V0X3N0YXRlIGJhc2VfcmFuZG9tX3N0YXRlO1xuICByZXN1bHRcbjs7XG5cbmxldCBzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpID1cbiAgU3RyaW5nLmNvbmNhdFxuICAgIFwiXCJcbiAgICAoTGlzdC5tYXBcbiAgICAgICAoZnVuIHMgLT4gXCIgIGluIFRFU1wiIF4gXCJUX01PRFVMRSBhdCBcIiBeIFN0cmluZy51bmNhcGl0YWxpemVfYXNjaWkgcyBeIFwiXFxuXCIpXG4gICAgICAgKE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfZGVzY3IgKCkpKVxuOztcblxubGV0IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgbCA9XG4gIExpc3QuZXhpc3RzXG4gICAgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgdXNlZCkgLT5cbiAgICAgIGxldCBwb3NpdGlvbl9zdGFydCA9IFN0cmluZy5sZW5ndGggZGVmX2ZpbGVuYW1lIC0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgICAgbGV0IGZvdW5kID1cbiAgICAgICAgcG9zaXRpb25fc3RhcnQgPj0gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgZW5kX29mX2RlZl9maWxlbmFtZSA9XG4gICAgICAgICAgU3RyaW5nLnN1YiBkZWZfZmlsZW5hbWUgcG9zaXRpb25fc3RhcnQgKFN0cmluZy5sZW5ndGggZmlsZW5hbWUpXG4gICAgICAgIGluXG4gICAgICAgIGVuZF9vZl9kZWZfZmlsZW5hbWUgPSBmaWxlbmFtZVxuICAgICAgICAmJiAocG9zaXRpb25fc3RhcnQgPSAwIHx8IGRlZl9maWxlbmFtZS5bcG9zaXRpb25fc3RhcnQgLSAxXSA9ICcvJylcbiAgICAgICAgJiZcbiAgICAgICAgbWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IGRlZl9saW5lX251bWJlciA9IGxpbmVfbnVtYmVyXG4gICAgICBpblxuICAgICAgaWYgZm91bmQgdGhlbiB1c2VkIDo9IHRydWU7XG4gICAgICBmb3VuZClcbiAgICBsXG47O1xuXG5sZXQgbmFtZV9maWx0ZXJfbWF0Y2ggfm5hbWVfZmlsdGVyIGRlc2NyID1cbiAgbWF0Y2ggbmFtZV9maWx0ZXIgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBfIDo6IF8gLT5cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHN1YnN0cmluZyAtPiBCYXNlLlN0cmluZy5pc19zdWJzdHJpbmcgfnN1YnN0cmluZyBkZXNjcikgbmFtZV9maWx0ZXJcbjs7XG5cbmxldCBwcmludF9kZWxheWVkX2Vycm9ycyAoKSA9XG4gIG1hdGNoIExpc3QucmV2ICFkZWxheWVkX2Vycm9ycyB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBfIDo6IF8gYXMgZGVsYXllZF9lcnJvcnMgLT5cbiAgICBQcmludGYuZXByaW50ZiBcIlxcbiVzXFxuJSFcIiAoU3RyaW5nLm1ha2UgNzAgJz0nKTtcbiAgICBMaXN0Lml0ZXIgKGZ1biBtZXNzYWdlIC0+IFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIG1lc3NhZ2UpIGRlbGF5ZWRfZXJyb3JzXG47O1xuXG5sZXQgZXByaW50Zl9vcl9kZWxheSBmbXQgPVxuICBQcmludGYua3NwcmludGZcbiAgICAoZnVuIHMgLT5cbiAgICAgIGlmICF2ZXJib3NlIHRoZW4gZGVsYXllZF9lcnJvcnMgOj0gcyA6OiAhZGVsYXllZF9lcnJvcnMgZWxzZSBQcmludGYuZXByaW50ZiBcIiVzJSFcIiBzO1xuICAgICAgaWYgIXN0b3Bfb25fZXJyb3JcbiAgICAgIHRoZW4gKFxuICAgICAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAgICAgZXhpdCAyKSlcbiAgICBmbXRcbjs7XG5cbmxldCBhZGRfaG9va3MgKChtb2R1bGUgQykgOiBjb25maWcpIGYgKCkgPVxuICBDLnByZV90ZXN0X2hvb2sgKCk7XG4gIGYgKClcbjs7XG5cbmxldCBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSA9XG4gIGxldCBvcGVuIEJhc2UgaW5cbiAgYmFja3RyYWNlXG4gIHw+IFN0cmluZy5zcGxpdF9saW5lc1xuICB8PiBMaXN0LnRha2Vfd2hpbGUgfmY6KGZ1biBzdHIgLT5cbiAgICAgICBub3QgKFN0cmluZy5TZWFyY2hfcGF0dGVybi5tYXRjaGVzIChmb3JjZSB3aGVyZV90b19jdXRfYmFja3RyYWNlKSBzdHIpKVxuICB8PiBMaXN0Lm1hcCB+ZjooZnVuIHN0ciAtPiBcIiAgXCIgXiBzdHIgXiBcIlxcblwiKVxuICB8PiBTdHJpbmcuY29uY2F0XG47O1xuXG5sZXRbQGlubGluZSBuZXZlcl0gdGVzdF9pbm5lclxuICB+Y29uZmlnXG4gIH5kZXNjclxuICB+dGFnc1xuICB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lXG4gIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgfnN0YXJ0X3Bvc1xuICB+ZW5kX3Bvc1xuICBmXG4gIGJvb2xfb2ZfZlxuICA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgVGVzdF9tb2RlXG4gICAgICB7IHdoaWNoX3Rlc3RzID0geyBsaWJuYW1lOyBvbmx5X3Rlc3RfbG9jYXRpb247IHdoaWNoX3RhZ3M7IG5hbWVfZmlsdGVyIH1cbiAgICAgIDsgd2hhdF90b19kb1xuICAgICAgfSAtPlxuICAgIGxldCBmID0gYWRkX2hvb2tzIGNvbmZpZyBmIGluXG4gICAgbGV0IGRlc2NyID1cbiAgICAgIGxhenkgKGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zKVxuICAgIGluXG4gICAgbGV0IGNvbXBsZXRlX3RhZ3MgPSB0YWdzIEAgTW9kdWxlX2NvbnRleHQuY3VycmVudF90YWdzICgpIGluXG4gICAgbGV0IHNob3VsZF9ydW4gPVxuICAgICAgU29tZSBsaWJuYW1lID0gIWR5bmFtaWNfbGliXG4gICAgICAmJiAobWF0Y2ggb25seV90ZXN0X2xvY2F0aW9uIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IHRydWVcbiAgICAgICAgICB8IF8gOjogXyAtPiBwb3NpdGlvbl9tYXRjaCBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIG9ubHlfdGVzdF9sb2NhdGlvbilcbiAgICAgICYmIChub3QgKFRhZ19wcmVkaWNhdGUuZGlzYWJsZWQgd2hpY2hfdGFncyB+Y29tcGxldGVfdGFncykpXG4gICAgICAmJiBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgKExhenkuZm9yY2UgZGVzY3IpXG4gICAgaW5cbiAgICBpZiBzaG91bGRfcnVuXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgIHwgYExpc3RfcGFydGl0aW9ucyBfIC0+IFBhcnRpdGlvbi5mb3VuZF90ZXN0ICgpXG4gICAgICB8IGBSdW5fcGFydGl0aW9uIHBhcnRpdGlvbiAtPlxuICAgICAgICBpZiBQYXJ0aXRpb24uaXNfY3VycmVudCBwYXJ0aXRpb25cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGRlc2NyID0gTGF6eS5mb3JjZSBkZXNjciBpblxuICAgICAgICAgIGluY3IgdGVzdHNfcmFuO1xuICAgICAgICAgIChtYXRjaCAhbG9nIHdpdGhcbiAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgIHwgU29tZSBjaCAtPiBQcmludGYuZnByaW50ZiBjaCBcIiVzXFxuJXNcIiBkZXNjciAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSkpO1xuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gUHJpbnRmLnByaW50ZiBcIiVzJSFcIiBkZXNjcjtcbiAgICAgICAgICBsZXQgcmVzdWx0ID1cbiAgICAgICAgICAgIGlmICFsaXN0X3Rlc3RfbmFtZXNcbiAgICAgICAgICAgIHRoZW4gT2sgdHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoKiBTZWUgW3RpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzXSBmb3Igd2h5IHdlIHVzZSBbYm9vbF9vZl9mXVxuICAgICAgICAgICAgICAgICByYXRoZXIgaGF2ZSB0aGUgY2FsbGVyIHdyYXAgW2ZdIHRvIGFkanVzdCBpdHMgcmV0dXJuIHZhbHVlLiAqKVxuICAgICAgICAgICAgICBSZXN1bHQubWFwIGJvb2xfb2ZfZiAodGltZV9hbmRfcmVzZXRfcmFuZG9tX3NlZWRzIGYpXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBJZiAhbGlzdF90ZXN0X25hbWVzLCB0aGlzIGlzIGlzIGEgaGFybWxlc3MgemVyby4gKilcbiAgICAgICAgICBpZiAhdmVyYm9zZSB0aGVuIFByaW50Zi5wcmludGYgXCIgKCUuM2Ygc2VjKVxcbiUhXCIgIXRpbWVfc2VjO1xuICAgICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgICAgfCBPayB0cnVlIC0+ICgpXG4gICAgICAgICAgfCBPayBmYWxzZSAtPlxuICAgICAgICAgICAgaW5jciB0ZXN0c19mYWlsZWQ7XG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5IFwiJXMgaXMgZmFsc2UuXFxuJXNcXG4lIVwiIGRlc2NyIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICAgIHwgRXJyb3IgKGV4biwgYmFja3RyYWNlKSAtPlxuICAgICAgICAgICAgaW5jciB0ZXN0c19mYWlsZWQ7XG4gICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgaW5cbiAgICAgICAgICAgIGxldCBleG5fc3RyID0gU2V4cGxpYjAuU2V4cF9jb252LnByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biBpblxuICAgICAgICAgICAgbGV0IHNlcCA9IGlmIFN0cmluZy5jb250YWlucyBleG5fc3RyICdcXG4nIHRoZW4gXCJcXG5cIiBlbHNlIFwiIFwiIGluXG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5XG4gICAgICAgICAgICAgIFwiJXMgdGhyZXclcyVzLlxcbiVzJXNcXG4lIVwiXG4gICAgICAgICAgICAgIGRlc2NyXG4gICAgICAgICAgICAgIHNlcFxuICAgICAgICAgICAgICBleG5fc3RyXG4gICAgICAgICAgICAgIGJhY2t0cmFjZVxuICAgICAgICAgICAgICAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSkpKVxuOztcblxubGV0IHNldF9saWJfYW5kX3BhcnRpdGlvbiBzdGF0aWNfbGliIHBhcnRpdGlvbiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgU29tZSBfIC0+XG4gICAgKCogcG9zc2libGUgaWYgdGhlIGludGVyZmFjZSBpcyB1c2VkIGV4cGxpY2l0bHkgb3IgaWYgd2UgaGFwcGVuIHRvIGR5bmxpbmsgc29tZXRoaW5nXG4gICAgICAgdGhhdCBjb250YWluIHRlc3RzICopXG4gICAgKClcbiAgfCBOb25lIC0+XG4gICAgZHluYW1pY19saWIgOj0gU29tZSBzdGF0aWNfbGliO1xuICAgIChtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgICAgfCBgSWdub3JlIC0+ICgpXG4gICAgIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzOyB3aGF0X3RvX2RvIH0gLT5cbiAgICAgICBpZiB3aGljaF90ZXN0cy5saWJuYW1lID0gc3RhdGljX2xpYlxuICAgICAgIHRoZW4gKFxuICAgICAgICAgbGV0IHJlcXVpcmVzX3BhcnRpdGlvbiA9XG4gICAgICAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgXyB8IGBSdW5fcGFydGl0aW9uIChTb21lIF8pIC0+IHRydWVcbiAgICAgICAgICAgfCBgUnVuX3BhcnRpdGlvbiBOb25lIC0+IGZhbHNlXG4gICAgICAgICBpblxuICAgICAgICAgaWYgcGFydGl0aW9uID0gXCJcIiAmJiByZXF1aXJlc19wYXJ0aXRpb25cbiAgICAgICAgIHRoZW5cbiAgICAgICAgICAgZmFpbHdpdGhcbiAgICAgICAgICAgICBcInBweF9pbmxpbmVfdGVzdDogY2Fubm90IHVzZSAtbGlzdC1wYXJ0aXRpb24gb3IgLXBhcnRpdGlvbiB3aXRob3V0IFxcXG4gICAgICAgICAgICAgIHNwZWNpZnlpbmcgYSBwYXJ0aXRpb24gYXQgcHJlcHJvY2Vzc2luZyB0aW1lXCJcbiAgICAgICAgIGVsc2UgUGFydGl0aW9uLnNldF9jdXJyZW50IHBhcnRpdGlvbikpXG47O1xuXG5sZXQgdW5zZXRfbGliIHN0YXRpY19saWIgPVxuICBtYXRjaCAhZHluYW1pY19saWIgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAoKiBub3QgZ2l2aW5nIGFuIGVycm9yLCBiZWNhdXNlIHdoZW4gc29tZSBhbm5veWluZyBwZW9wbGUgcHV0IHBhX291bml0IGluIHRoZWlyIGxpc3RcbiAgICAgICBvZiBwcmVwcm9jZXNzb3JzLCBwYV9vdW5pdCBpcyBzZXQgdXAgdHdpY2UgYW5kIHdlIGhhdmUgdHdvIGNhbGxzIHRvIHVuc2V0X2xpYiBhdFxuICAgICAgIHRoZSBlbmQgb2YgdGhlIGZpbGUsIGFuZCB0aGUgc2Vjb25kIG9uZSBjb21lcyBpbiB0aGlzIGJyYW5jaCAqKVxuICAgICgpXG4gIHwgU29tZSBsaWIgLT4gaWYgbGliID0gc3RhdGljX2xpYiB0aGVuIGR5bmFtaWNfbGliIDo9IE5vbmVcbjs7XG5cbmxldCB0ZXN0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiAoZnVuIGIgLT5cbiAgICBiKVxuOztcblxubGV0IHRlc3RfdW5pdCB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgKGZ1biAoKSAtPlxuICAgIHRydWUpXG47O1xuXG5sZXRbQGlubGluZSBuZXZlcl0gdGVzdF9tb2R1bGVcbiAgfmNvbmZpZ1xuICB+ZGVzY3JcbiAgfnRhZ3NcbiAgfmZpbGVuYW1lOmRlZl9maWxlbmFtZVxuICB+bGluZV9udW1iZXI6ZGVmX2xpbmVfbnVtYmVyXG4gIH5zdGFydF9wb3NcbiAgfmVuZF9wb3NcbiAgZlxuICA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgVGVzdF9tb2RlXG4gICAgICB7IHdoaWNoX3Rlc3RzID0geyBsaWJuYW1lOyBvbmx5X3Rlc3RfbG9jYXRpb24gPSBfOyBuYW1lX2ZpbHRlciA9IF87IHdoaWNoX3RhZ3MgfVxuICAgICAgOyB3aGF0X3RvX2RvXG4gICAgICB9IC0+XG4gICAgbGV0IGYgPSBhZGRfaG9va3MgY29uZmlnIGYgaW5cbiAgICBsZXQgZGVzY3IgKCkgPSBkaXNwbGF5ZWRfZGVzY3IgZGVzY3IgZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBzdGFydF9wb3MgZW5kX3BvcyBpblxuICAgIGxldCBwYXJ0aWFsX3RhZ3MgPSB0YWdzIEAgTW9kdWxlX2NvbnRleHQuY3VycmVudF90YWdzICgpIGluXG4gICAgbGV0IHNob3VsZF9ydW4gPVxuICAgICAgU29tZSBsaWJuYW1lID0gIWR5bmFtaWNfbGliXG4gICAgICAoKiBJZiwgbm8gbWF0dGVyIHdoYXQgdGFncyBhIHRlc3QgZGVmaW5lcywgd2UgY2VydGFpbmx5IHdpbGwgZHJvcCBhbGwgdGVzdHMgd2l0aGluXG4gICAgICAgICB0aGlzIG1vZHVsZSwgdGhlbiBkb24ndCBydW4gdGhlIG1vZHVsZSBhdCBhbGwuIFRoaXMgbWVhbnMgcGVvcGxlIGNhbiB3cml0ZVxuICAgICAgICAgdGhpbmdzIGxpa2UgdGhlIGZvbGxvd2luZyB3aXRob3V0IGJyZWFraW5nIHRoZSAzMi1iaXQgYnVpbGQ6XG4gICAgICAgICBsZXQldGVzdF9tb2R1bGUgW0B0YWdzIFwiNjQtYml0cy1vbmx5XCJdID0gKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgIGxldCBpID0gSW50NjQudG9faW50X2V4biAuLi4uXG4gICAgICAgICBlbmQpXG4gICAgICAgICBXZSBkb24ndCBzaG9ydGN1dCBiYXNlZCBvbiBwb3NpdGlvbiwgYXMgd2UgY2FuJ3QgdGVsbCB3aGF0IHBvc2l0aW9ucyB0aGVcbiAgICAgICAgIGlubmVyIHRlc3RzIHdpbGwgaGF2ZS4gKilcbiAgICAgICYmIG5vdCAoVGFnX3ByZWRpY2F0ZS5lbnRpcmVfbW9kdWxlX2Rpc2FibGVkIHdoaWNoX3RhZ3MgfnBhcnRpYWxfdGFncylcbiAgICBpblxuICAgIGlmIHNob3VsZF9ydW5cbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIF8gLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19yYW47XG4gICAgICAgICAgbGV0IGRlc2NyID0gZGVzY3IgKCkgaW5cbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgTW9kdWxlX2NvbnRleHQud2l0aF8gfmRlc2NyIH50YWdzIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgKCogV2UgZG8gbm90IHJlc2V0IHJhbmRvbSBzdGF0ZXMgdXBvbiBlbnRlcmluZyBbbGV0JXRlc3RfbW9kdWxlXS5cblxuICAgICAgICAgICAgICAgICBDb246IENvZGUgaW4gdGVzdCBtb2R1bGVzIGNhbiBhY2NpZGVudGFsbHkgZGVwZW5kIG9uIHRvcC1sZXZlbCByYW5kb21cbiAgICAgICAgICAgICAgICAgc3RhdGUgZWZmZWN0cy5cblxuICAgICAgICAgICAgICAgICBQcm9zOiAoMSkgV2UgZG9uJ3QgcmVzZXQgdG8gdGhlIHNhbWUgc2VlZCBvbiBlbnRlcmluZyBhIFtsZXQldGVzdF9tb2R1bGVdXG4gICAgICAgICAgICAgICAgIGFuZCB0aGVuIGEgW2xldCV0ZXN0XSBpbnNpZGUgdGhhdCBtb2R1bGUsIHdoaWNoIGNvdWxkIGxlYWQgdG9cbiAgICAgICAgICAgICAgICAgYWNjaWRlbnRhbGx5IHJhbmRvbWx5IGdlbmVyYXRpbmcgdGhlIHNhbWUgdmFsdWVzIGluIHNvbWUgdGVzdC4gKDIpIE1vdmluZ1xuICAgICAgICAgICAgICAgICBjb2RlIGludG8gYW5kIG91dCBvZiBbbGV0JXRlc3RfbW9kdWxlXSBkb2VzIG5vdCBjaGFuZ2UgaXRzIHJhbmRvbSBzZWVkLlxuICAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgICB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19mYWlsZWQ7XG4gICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgaW5cbiAgICAgICAgICAgIGxldCBleG5fc3RyID0gU2V4cGxpYjAuU2V4cF9jb252LnByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biBpblxuICAgICAgICAgICAgbGV0IHNlcCA9IGlmIFN0cmluZy5jb250YWlucyBleG5fc3RyICdcXG4nIHRoZW4gXCJcXG5cIiBlbHNlIFwiIFwiIGluXG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5XG4gICAgICAgICAgICAgIChcIlRFU1wiIF5eIFwiVF9NT0RVTEUgYXQgJXMgdGhyZXclcyVzLlxcbiVzJXNcXG4lIVwiKVxuICAgICAgICAgICAgICAoU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBkZXNjcilcbiAgICAgICAgICAgICAgc2VwXG4gICAgICAgICAgICAgIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlXG4gICAgICAgICAgICAgIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSkpXG47O1xuXG5sZXQgc3VtbWFyaXplICgpID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPlxuICAgIGlmIFN5cy5hcmd2IDw+IFt8fF0gJiYgRmlsZW5hbWUuYmFzZW5hbWUgU3lzLmFyZ3YuKDApID0gXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZVwiXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcnVuIGJ5IGhhbmQsIHlvdSBcXG5cXFxuICAgICAgICAgc2hvdWxkIHJ1biB0aGUgaW5saW5lX3Rlc3RzX3J1bm5lciBzY3JpcHQgaW5zdGVhZC5cXG5cXFxuICAgICAgICAgJSFcIlxuICAgIGVsc2VcbiAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgIFwiWW91IGFyZSBkb2luZyBzb21ldGhpbmcgdW5leHBlY3RlZCB3aXRoIHRoZSB0ZXN0cy4gTm8gdGVzdHMgaGF2ZSBcXG5cXFxuICAgICAgICAgYmVlbiBydW4uIFlvdSBzaG91bGQgdXNlIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCB0byBydW4gXFxuXFxcbiAgICAgICAgIHRlc3RzLlxcblxcXG4gICAgICAgICAlIVwiO1xuICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0gXzsgd2hhdF90b19kbyA9IGBMaXN0X3BhcnRpdGlvbnMgd2hlcmVfdG9fbGlzdCB9IC0+XG4gICAgbGV0IHdpdGhfb3V0X2NoYW5uZWwgZiA9XG4gICAgICBtYXRjaCB3aGVyZV90b19saXN0IHdpdGhcbiAgICAgIHwgU3Rkb3V0IC0+IGYgc3Rkb3V0XG4gICAgICB8IEZpbGUgZmlsZSAtPlxuICAgICAgICAoKiBOb3QgcGFzc2luZyBPcGVuX2NyZWF0IGVuc3VyZXMgdGhhdCB0aGUgZmlsZSB3ZSBhcmUgc3VwcG9zZWQgdG8gd3JpdGUgdG8gZXhpc3RzICopXG4gICAgICAgIG9wZW5fb3V0X2dlbiBbIE9wZW5fd3Jvbmx5OyBPcGVuX3RleHQgXSAwIGZpbGVcbiAgICAgICAgfD4gQmFzZS5FeG4ucHJvdGVjdHggfmYgfmZpbmFsbHk6Y2xvc2Vfb3V0XG4gICAgaW5cbiAgICB3aXRoX291dF9jaGFubmVsIChmdW4gZm91dCAtPlxuICAgICAgTGlzdC5pdGVyIChQcmludGYuZnByaW50ZiBmb3V0IFwiJXNcXG5cIikgKFBhcnRpdGlvbi5hbGwgKCkpKTtcbiAgICBUZXN0X3Jlc3VsdC5TdWNjZXNzXG4gIHwgYFRlc3RfbW9kZSB7IHdoYXRfdG9fZG8gPSBgUnVuX3BhcnRpdGlvbiBfOyB3aGljaF90ZXN0cyB9IC0+XG4gICAgKG1hdGNoICFsb2cgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGNoIC0+IGNsb3NlX291dCBjaCk7XG4gICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgKG1hdGNoICF0ZXN0c19mYWlsZWQsICF0ZXN0X21vZHVsZXNfZmFpbGVkIHdpdGhcbiAgICAgfCAwLCAwIC0+XG4gICAgICAgaWYgIXNob3dfY291bnRzXG4gICAgICAgdGhlblxuICAgICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgICAgXCIlZCB0ZXN0cyByYW4sICVkIHRlc3RfbW9kdWxlcyByYW5cXG4lIVwiXG4gICAgICAgICAgICF0ZXN0c19yYW5cbiAgICAgICAgICAgIXRlc3RfbW9kdWxlc19yYW47XG4gICAgICAgbGV0IGVycm9ycyA9XG4gICAgICAgICBsZXQgdW51c2VkX3Rlc3RzID1cbiAgICAgICAgICAgTGlzdC5maWx0ZXIgKGZ1biAoXywgXywgdXNlZCkgLT4gbm90ICF1c2VkKSB3aGljaF90ZXN0cy5vbmx5X3Rlc3RfbG9jYXRpb25cbiAgICAgICAgIGluXG4gICAgICAgICBtYXRjaCB1bnVzZWRfdGVzdHMgd2l0aFxuICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICB8IF8gOjogXyAtPiBTb21lIHVudXNlZF90ZXN0c1xuICAgICAgIGluXG4gICAgICAgKG1hdGNoIGVycm9ycyB3aXRoXG4gICAgICAgIHwgU29tZSB0ZXN0cyAtPlxuICAgICAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgICAgICBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogdGhlIGZvbGxvd2luZyAtb25seS10ZXN0IGZsYWdzIG1hdGNoZWQgbm90aGluZzpcIjtcbiAgICAgICAgICBMaXN0Lml0ZXJcbiAgICAgICAgICAgIChmdW4gKGZpbGVuYW1lLCBsaW5lX251bWJlcl9vcHQsIF8pIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGxpbmVfbnVtYmVyX29wdCB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBQcmludGYuZXByaW50ZiBcIiAlc1wiIGZpbGVuYW1lXG4gICAgICAgICAgICAgIHwgU29tZSBsaW5lX251bWJlciAtPiBQcmludGYuZXByaW50ZiBcIiAlczolZFwiIGZpbGVuYW1lIGxpbmVfbnVtYmVyKVxuICAgICAgICAgICAgdGVzdHM7XG4gICAgICAgICAgUHJpbnRmLmVwcmludGYgXCIuXFxuJSFcIjtcbiAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvclxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBpZiAhdGVzdHNfcmFuID0gMCAmJiAhc3RyaWN0XG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogbm8gdGVzdHMgaGF2ZSBiZWVuIHJ1bi5cXG4lIVwiO1xuICAgICAgICAgICAgVGVzdF9yZXN1bHQuRXJyb3IpXG4gICAgICAgICAgZWxzZSBUZXN0X3Jlc3VsdC5TdWNjZXNzKVxuICAgICB8IGNvdW50LCBjb3VudF90ZXN0X21vZHVsZXMgLT5cbiAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgXCJGQUlMRUQgJWQgLyAlZCB0ZXN0cyVzXFxuJSFcIlxuICAgICAgICAgY291bnRcbiAgICAgICAgICF0ZXN0c19yYW5cbiAgICAgICAgIChpZiBjb3VudF90ZXN0X21vZHVsZXMgPSAwXG4gICAgICAgICAgdGhlbiBcIlwiXG4gICAgICAgICAgZWxzZSBQcmludGYuc3ByaW50ZiAoXCIsICVkIFRFU1wiIF5eIFwiVF9NT0RVTEVTXCIpIGNvdW50X3Rlc3RfbW9kdWxlcyk7XG4gICAgICAgVGVzdF9yZXN1bHQuRmFpbHVyZSlcbjs7XG5cbmxldCBhc3NlcnRfdGVzdF9jb25maWdzX2luaXRpYWxpemVkIGNvbmZpZyA9XG4gIGlmIG5vdCAhYWxyZWFkeV9pbml0aWFsaXplZFxuICB0aGVuXG4gICAgUHJpbnRmLnNwcmludGZcbiAgICAgIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiBhdHRlbXB0ZWQgdG8gYWNjZXNzIHRoZSBbJXNdIGNvbmZpZyBiZWZvcmUgW2luaXRdIHdhcyBcXFxuICAgICAgIGNhbGxlZFwiXG4gICAgICBjb25maWdcbiAgICB8PiBmYWlsd2l0aFxuOztcblxubGV0IHVzZV9jb2xvciAoKSA9XG4gIGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgXCJ1c2VfY29sb3JcIjtcbiAgIXVzZV9jb2xvclxuOztcblxubGV0IGluX3BsYWNlICgpID1cbiAgYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplZCBcImluX3BsYWNlXCI7XG4gICFpbl9wbGFjZVxuOztcblxubGV0IGRpZmZfY29tbWFuZCAoKSA9XG4gIGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgXCJkaWZmX2NvbW1hbmRcIjtcbiAgIWRpZmZfY29tbWFuZFxuOztcblxubGV0IGRpZmZfcGF0aF9wcmVmaXggKCkgPVxuICBhc3NlcnRfdGVzdF9jb25maWdzX2luaXRpYWxpemVkIFwiZGlmZl9wYXRoX3ByZWZpeFwiO1xuICAhZGlmZl9wYXRoX3ByZWZpeFxuOztcblxubGV0IHNvdXJjZV90cmVlX3Jvb3QgKCkgPVxuICBhc3NlcnRfdGVzdF9jb25maWdzX2luaXRpYWxpemVkIFwic291cmNlX3RyZWVfcm9vdFwiO1xuICAhc291cmNlX3RyZWVfcm9vdFxuOztcblxubGV0IGV2YWx1YXRvcnMgPSByZWYgWyBzdW1tYXJpemUgXVxubGV0IGFkZF9ldmFsdWF0b3IgfmYgPSBldmFsdWF0b3JzIDo9IGYgOjogIWV2YWx1YXRvcnNcblxubGV0IGV4aXQgKCkgPVxuICBMaXN0Lm1hcCAoZnVuIGYgLT4gZiAoKSkgKExpc3QucmV2ICFldmFsdWF0b3JzKVxuICB8PiBUZXN0X3Jlc3VsdC5jb21iaW5lX2FsbFxuICB8PiBUZXN0X3Jlc3VsdC50b19leGl0X2NvZGVcbiAgfD4gZXhpdFxuOztcbiJdfQ==
