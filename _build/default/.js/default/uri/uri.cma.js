// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Uri
//# unitInfo: Requires: Angstrom, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Lazy, Stdlib__List, Stdlib__Option, Stdlib__Printf, Stdlib__Result, Stdlib__String, Stringext
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$34 = "",
    cst$37 = ",",
    cst$36 = ".",
    cst$39 = "..",
    cst$33 = "/",
    cst$38 = "//",
    cst$35 = ":",
    cst_http$0 = "http",
    cst_https$0 = "https",
    cst_int_of_hex_char$1 = "int_of_hex_char",
    cst_localhost$0 = "localhost",
    caml_check_bound = runtime.caml_check_bound,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$33,
    cst$31 = cst$34,
    cst$30 = cst$33,
    cst$28 = cst$34,
    cst$24 = cst$35,
    cst$25 = cst$35,
    cst$26 = "::",
    cst$23 = cst$34,
    cst$21 = cst$36,
    cst$22 = cst$36,
    cst$20 = cst$34,
    cst$19 = cst$34,
    cst$18 = cst$33,
    cst$17 = cst$37,
    cst$16 = cst$33,
    cst$15 = cst$34,
    cst$13 = cst$34,
    cst$14 = cst$34,
    cst$12 = cst$34,
    cst$9 = cst$38,
    cst$10 = cst$35,
    cst$11 = "./",
    cst$8 = cst$37,
    cst$7 = "&",
    cst$6 = cst$33,
    cst$5 = cst$33,
    cst$4 = cst$34,
    cst$2 = cst$33,
    cst$3 = cst$33,
    cst$0 = cst$33,
    cst$1 = cst$33,
    cst = cst$34,
    cst$27 = cst$34,
    cst$29 = cst$38,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stringext = global_data.Stringext,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Result = global_data.Stdlib__Result,
    _aS_ = [0, 0],
    _aN_ = [0, 3854881, "host is required for HTTP(S) uris"],
    _aP_ = [0, -1042355253],
    _aQ_ = [0, 804243368],
    _aO_ =
      [0,
       [11,
        "Only http and https URIs are supported. ",
        [2, 0, [11, " is invalid.", 0]]],
       "Only http and https URIs are supported. %s is invalid."],
    _aR_ = [1, [0, 3854881, "No scheme present in URI"]],
    cst_http = cst_http$0,
    cst_https = cst_https$0,
    _aM_ = [0, cst$34],
    _aL_ = [0, 0],
    _C_ = [0, 0, 0],
    cst_too_many_parts_in_IPv6_add = "too many parts in IPv6 address",
    _B_ = [0, cst$34, 0],
    cst_invalid_octect = "invalid octect",
    _k_ = [0, [11, "/?", [2, 0, 0]], "/?%s"],
    _j_ = [0, [2, 0, [12, 63, [2, 0, 0]]], "%s?%s"],
    cst_localhost = cst_localhost$0,
    _f_ = [0, cst$34, 0],
    _g_ = [0, cst$34, 0],
    _h_ = [0, 2],
    _i_ = [0, [0, cst$34, 0], 0],
    _c_ = [0, 2],
    _d_ = [0, cst$34, 0],
    cst_int_of_hex_char = cst_int_of_hex_char$1,
    cst_int_of_hex_char$0 = cst_int_of_hex_char$1,
    _b_ = [0, [12, 37, [4, 8, [0, 2, 2], 0, 0]], "%%%02X"],
    _a_ = [0, cst$33, 0],
    _ak_ = [0, 0, 0, 0];
   function iter_concat(fn, sep, buf, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var last = param$0[1];
     if(! param$0[2]) return caml_call2(fn, buf, last);
     var rest = param$0[2];
     caml_call2(fn, buf, last);
     caml_call2(Stdlib_Buffer[16], buf, sep);
     var param$0 = rest;
    }
   }
   function compare_opt(c, t$0, t){
    if(! t$0) return t ? -1 : 0;
    var a = t$0[1];
    if(! t) return 1;
    var b = t[1];
    return caml_call2(c, a, b);
   }
   function compare_list(f, t$0, t){
    var t$2 = t$0, t$1 = t;
    for(;;){
     if(! t$2) return t$1 ? -1 : 0;
     var xs = t$2[2], x = t$2[1];
     if(! t$1) return 1;
     var ys = t$1[2], y = t$1[1], c = caml_call2(f, x, y);
     if(0 !== c) return c;
     var t$2 = xs, t$1 = ys;
    }
   }
   function sub_delims(a){
    var i = 0;
    for(;;){
     var c = caml_string_get("!$&'()*+,;=", i);
     caml_check_bound(a, c)[1 + c] = 1;
     var _d3_ = i + 1 | 0;
     if(10 === i) return a;
     var i = _d3_;
    }
   }
   var safe_chars = caml_make_vect(256, 0), i = 0;
   for(;;){
    var
     c =
       caml_string_get
        ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~",
         i);
    caml_check_bound(safe_chars, c)[1 + c] = 1;
    var _aT_ = i + 1 | 0;
    if(65 === i) break;
    var i = _aT_;
   }
   var pchar = sub_delims(caml_call1(Stdlib_Array[6], safe_chars));
   caml_check_bound(pchar, 58)[59] = 1;
   caml_check_bound(pchar, 64)[65] = 1;
   var safe_chars_for_scheme = caml_call1(Stdlib_Array[6], safe_chars);
   caml_check_bound(safe_chars_for_scheme, 43)[44] = 1;
   var safe_chars_for_path = sub_delims(caml_call1(Stdlib_Array[6], pchar));
   caml_check_bound(safe_chars_for_path, 47)[48] = 0;
   var safe_chars_for_query = caml_call1(Stdlib_Array[6], pchar);
   caml_check_bound(safe_chars_for_query, 47)[48] = 1;
   caml_check_bound(safe_chars_for_query, 63)[64] = 1;
   caml_check_bound(safe_chars_for_query, 38)[39] = 0;
   caml_check_bound(safe_chars_for_query, 59)[60] = 0;
   caml_check_bound(safe_chars_for_query, 43)[44] = 0;
   var
    safe_chars_for_query_key =
      caml_call1(Stdlib_Array[6], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_key, 61)[62] = 0;
   var
    safe_chars_for_query_value =
      caml_call1(Stdlib_Array[6], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_value, 44)[45] = 0;
   var safe_chars_for_userinfo = caml_call1(Stdlib_Array[6], safe_chars);
   caml_check_bound(safe_chars_for_userinfo, 58)[59] = 0;
   function safe_chars_for_component(param){
    if(typeof param === "number")
     if(-145160102 <= param){
      if(127343601 <= param){
       if(795008922 === param) return safe_chars_for_query_value;
       if(892015045 === param) return safe_chars_for_path;
      }
      else if(61643255 !== param && 127343600 <= param)
       return safe_chars_for_query;
     }
     else if(-250086679 <= param){
      if(-178940859 === param) return safe_chars_for_scheme;
      if(-145160103 <= param) return safe_chars_for_userinfo;
     }
     else{
      if(-911188600 === param) return safe_chars_for_query_key;
      if(-250086680 <= param) return safe_chars_for_query;
     }
    else if(-198771759 === param[1]){
     var
      match = param[2],
      unsafe = match[3],
      safe = match[2],
      component = match[1],
      _dW_ = safe_chars_for_component(component),
      safe_chars$0 = caml_call1(Stdlib_Array[6], _dW_),
      _dY_ = caml_ml_string_length(safe) - 1 | 0,
      _dX_ = 0;
     if(_dY_ >= 0){
      var i$0 = _dX_;
      for(;;){
       var c$0 = caml_string_get(safe, i$0);
       caml_check_bound(safe_chars$0, c$0)[1 + c$0] = 1;
       var _d2_ = i$0 + 1 | 0;
       if(_dY_ === i$0) break;
       var i$0 = _d2_;
      }
     }
     var _d0_ = caml_ml_string_length(unsafe) - 1 | 0, _dZ_ = 0;
     if(_d0_ >= 0){
      var i = _dZ_;
      for(;;){
       var c = caml_string_get(unsafe, i);
       caml_check_bound(safe_chars$0, c)[1 + c] = 0;
       var _d1_ = i + 1 | 0;
       if(_d0_ === i) break;
       var i = _d1_;
      }
     }
     return safe_chars$0;
    }
    return safe_chars;
   }
   function normalize_host(hso){return hso;}
   function canonicalize_port(port){return port;}
   function canonicalize_path(path){return path;}
   var
    Generic =
      [0,
       safe_chars_for_component,
       normalize_host,
       canonicalize_port,
       canonicalize_path],
    safe_chars_for_component$0 = Generic[1];
   function normalize_host$0(hs){return caml_call1(Stdlib_String[27], hs);}
   function canonicalize_port$0(param){
    if(! param) return 0;
    var x = param[1];
    return 80 === x ? 0 : [0, x];
   }
   function canonicalize_path$0(x){return x ? x : _a_;}
   var
    Http =
      [0,
       safe_chars_for_component$0,
       normalize_host$0,
       canonicalize_port$0,
       canonicalize_path$0],
    safe_chars_for_component$1 = Http[1],
    normalize_host$1 = Http[2],
    canonicalize_path$1 = Http[4];
   function canonicalize_port$1(param){
    if(! param) return 0;
    var x = param[1];
    return 443 === x ? 0 : [0, x];
   }
   var
    Https =
      [0,
       safe_chars_for_component$1,
       normalize_host$1,
       canonicalize_port$1,
       canonicalize_path$1],
    safe_chars_for_component$2 = Generic[1],
    canonicalize_port$2 = Generic[3],
    canonicalize_path$2 = Generic[4];
   function normalize_host$2(hs){
    var hs$0 = caml_call1(Stdlib_String[27], hs);
    return caml_string_equal(hs$0, cst_localhost$0) ? cst : hs$0;
   }
   var
    File =
      [0,
       safe_chars_for_component$2,
       normalize_host$2,
       canonicalize_port$2,
       canonicalize_path$2],
    safe_chars_for_component$3 = Generic[1],
    normalize_host$3 = Generic[2],
    canonicalize_port$3 = Generic[3],
    canonicalize_path$3 = Generic[4],
    Urn =
      [0,
       safe_chars_for_component$3,
       normalize_host$3,
       canonicalize_port$3,
       canonicalize_path$3];
   function module_of_scheme(param){
    if(! param) return Generic;
    var s = param[1], match = caml_call1(Stdlib_String[27], s);
    return caml_string_notequal(match, "file")
            ? caml_string_notequal
               (match, cst_http$0)
              ? caml_string_notequal
                 (match, cst_https$0)
                ? caml_string_notequal(match, "urn") ? Generic : Urn
                : Https
              : Http
            : File;
   }
   function encode(scheme, opt, b){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var
     Scheme = module_of_scheme(scheme),
     safe_chars = Scheme[1].call(null, component),
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur){
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var c = caml_string_get(b, cur);
     if(caml_check_bound(safe_chars, c)[1 + c])
      var cur$0 = cur + 1 | 0, cur = cur$0;
     else{
      if(start < cur)
       caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var _dV_ = caml_call2(Stdlib_Printf[4], _b_, c);
      caml_call2(Stdlib_Buffer[16], buf, _dV_);
      var
       cur$1 = cur + 1 | 0,
       start$0 = cur + 1 | 0,
       start = start$0,
       cur = cur$1;
     }
    }
   }
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[4], c) - 48 | 0;
    if(9 >= c$0)
     return 0 <= c$0 ? c$0 : caml_call1(Stdlib[2], cst_int_of_hex_char$0);
    if(16 < c$0 && 23 > c$0) return c$0 - 7 | 0;
    return caml_call1(Stdlib[2], cst_int_of_hex_char);
   }
   function decode(b){
    var
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur)
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
     else{
      if(37 !== caml_string_get(b, cur)){
       var cur$1 = cur + 1 | 0, cur = cur$1;
       continue;
      }
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var start$0 = cur + 1 | 0;
      if(len <= start$0)
       caml_call2(Stdlib_Buffer[12], buf, 37);
      else{
       try{var highbits = int_of_hex_char(caml_string_get(b, start$0));}
       catch(_dU_){
        caml_call2(Stdlib_Buffer[12], buf, 37);
        var start = start$0, cur = start$0;
        continue;
       }
       var cur$0 = start$0 + 1 | 0;
       if(len > cur$0){
        a:
        {
         try{var lowbits = int_of_hex_char(caml_string_get(b, cur$0));}
         catch(_dT_){
          caml_call2(Stdlib_Buffer[12], buf, 37);
          var _dR_ = caml_string_get(b, cur$0 - 1 | 0);
          caml_call2(Stdlib_Buffer[12], buf, _dR_);
          var start_at = cur$0;
          break a;
         }
         var _dS_ = caml_call1(Stdlib_Char[1], (highbits << 4) + lowbits | 0);
         caml_call2(Stdlib_Buffer[12], buf, _dS_);
         var start_at = cur$0 + 1 | 0;
        }
        var start = start_at, cur = start_at;
        continue;
       }
       caml_call2(Stdlib_Buffer[12], buf, 37);
       var _dQ_ = caml_string_get(b, cur$0 - 1 | 0);
       caml_call2(Stdlib_Buffer[12], buf, _dQ_);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function pct_encode(scheme, opt, s){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    return encode(scheme, [0, component], s);
   }
   function pct_encoder(opt, _dP_, _dO_, _dN_, _dM_, _dL_, _dK_, param){
    if(opt) var sth = opt[1], scheme = sth; else var scheme = -178940859;
    if(_dP_)
     var sth$0 = _dP_[1], userinfo = sth$0;
    else
     var userinfo = -145160103;
    if(_dO_) var sth$1 = _dO_[1], host = sth$1; else var host = 803994504;
    if(_dN_) var sth$2 = _dN_[1], path = sth$2; else var path = 892015045;
    if(_dM_)
     var sth$3 = _dM_[1], query_key = sth$3;
    else
     var query_key = -911188600;
    if(_dL_)
     var sth$4 = _dL_[1], query_value = sth$4;
    else
     var query_value = 795008922;
    if(_dK_)
     var sth$5 = _dK_[1], fragment = sth$5;
    else
     var fragment = 127343600;
    return [0, scheme, userinfo, host, path, query_key, query_value, fragment];
   }
   function pct_decode(s){return decode(s);}
   function compare(param, _dJ_){
    var
     p = _dJ_[2],
     u = _dJ_[1],
     p$0 = param[2],
     u$0 = param[1],
     c = caml_call2(Stdlib_String[10], u$0, u);
    return 0 === c ? compare_opt(Stdlib_String[10], p$0, p) : c;
   }
   function userinfo_of_encoded(us){
    var match = caml_call3(Stringext[3], _c_, us, 58);
    if(! match) return _d_;
    var match$0 = match[2], u = match[1];
    if(! match$0) return [0, pct_decode(u), 0];
    var p = match$0[1], _dI_ = [0, pct_decode(p)];
    return [0, pct_decode(u), _dI_];
   }
   function encoded_of_userinfo(scheme, component){
    return function(param){
     var po = param[2], u = param[1];
     if(po) var p = po[1], _dF_ = caml_ml_string_length(p); else var _dF_ = 0;
     var
      len = (1 + caml_ml_string_length(u) | 0) + _dF_ | 0,
      buf = caml_call1(Stdlib_Buffer[1], len),
      _dG_ = pct_encode(scheme, [0, component], u);
     caml_call2(Stdlib_Buffer[16], buf, _dG_);
     if(po){
      var p$0 = po[1];
      caml_call2(Stdlib_Buffer[12], buf, 58);
      var _dH_ = pct_encode(scheme, [0, component], p$0);
      caml_call2(Stdlib_Buffer[16], buf, _dH_);
     }
     return caml_call1(Stdlib_Buffer[2], buf);};
   }
   var _e_ = Stdlib_String[10];
   function path_of_encoded(ps){
    var tokl = caml_call2(Stringext[4], ps, 47);
    return caml_call2(Stdlib_List[20], pct_decode, tokl);
   }
   function remove_dot_segments(p){
    var
     revp = caml_call1(Stdlib_List[10], p),
     ascension = 0,
     outp = 0,
     param$0 = revp;
    for(;;){
     a:
     {
      b:
      if(param$0){
       var _dB_ = param$0[1];
       c:
       {
        if(caml_string_notequal(_dB_, cst$36)){
         if(caml_string_notequal(_dB_, cst$39)){
          if(caml_string_notequal(_dB_, cst$33)) break a;
          var _dD_ = param$0[2];
          if(! _dD_) break b;
          var _dE_ = _dD_[1];
          if(! caml_string_notequal(_dE_, cst$36)){var r$3 = _dD_[2]; break c;}
          if(caml_string_notequal(_dE_, cst$39)){
           if(! caml_string_notequal(_dE_, cst$33)){
            var r$1 = _dD_[2];
            if(0 < ascension){
             var
              ascension$1 = ascension - 1 | 0,
              ascension = ascension$1,
              param$0 = [0, cst$2, r$1];
             continue;
            }
           }
           var r$0 = _dD_[2];
           if(0 >= ascension) break a;
           var
            ascension$0 = ascension - 1 | 0,
            ascension = ascension$0,
            param$0 = r$0;
           continue;
          }
          var r$2 = _dD_[2];
         }
         else
          var r$2 = param$0[2];
         var
          ascension$2 = ascension + 1 | 0,
          ascension = ascension$2,
          param$0 = r$2;
         continue;
        }
        var r$3 = param$0[2];
       }
       var param$0 = r$3;
       continue;
      }
      if
       (0 < caml_call1(Stdlib_List[1], p)
        && caml_string_equal(caml_call1(Stdlib_List[6], p), cst$33))
       return [0, cst$3, outp];
     }
     if(! param$0) break;
     var
      r = param$0[2],
      s = param$0[1],
      outp$0 = [0, s, outp],
      ascension = 0,
      outp = outp$0,
      param$0 = r;
    }
    if(0 >= ascension){
     if
      (0 < caml_call1(Stdlib_List[1], outp)
       && caml_string_equal(caml_call1(Stdlib_List[6], outp), cst$33))
      return caml_call1(Stdlib_List[7], outp);
     return outp;
    }
    var lst = caml_call1(Stdlib_Array[9], caml_make_vect(ascension, cst$39));
    if(lst){
     var t = lst[2], h = lst[1], acc$1 = [0, h, 0], acc = acc$1, param = t;
     for(;;){
      if(! param){var _dC_ = acc; break;}
      var
       xs = param[2],
       x = param[1],
       acc$0 = [0, x, [0, cst$0, acc]],
       acc = acc$0,
       param = xs;
     }
    }
    else
     var _dC_ = 0;
    return caml_call2(Stdlib_List[13], [0, cst$1, _dC_], outp);
   }
   function encoded_of_path(scheme, component){
    return function(p){
     var _dy_ = 0;
     function _dz_(c, tok){return caml_ml_string_length(tok) + c | 0;}
     var
      len = caml_call3(Stdlib_List[26], _dz_, _dy_, p),
      buf = caml_call1(Stdlib_Buffer[1], len);
     iter_concat
      (function(buf, seg){
        if(! caml_string_notequal(seg, cst$33))
         return caml_call2(Stdlib_Buffer[12], buf, 47);
        var _dA_ = pct_encode(scheme, [0, component], seg);
        return caml_call2(Stdlib_Buffer[16], buf, _dA_);
       },
       cst$4,
       buf,
       p);
     return caml_call1(Stdlib_Buffer[2], buf);};
   }
   function query_of_encoded(qs){
    var els = caml_call3(Stringext[3], 0, qs, 38);
    function plus_to_space(s){
     var
      s$0 = caml_call1(Stdlib_Bytes[45], s),
      _dw_ = runtime.caml_ml_bytes_length(s$0) - 1 | 0,
      _dv_ = 0;
     if(_dw_ >= 0){
      var i = _dv_;
      for(;;){
       if(43 === runtime.caml_bytes_get(s$0, i))
        runtime.caml_bytes_set(s$0, i, 32);
       var _dx_ = i + 1 | 0;
       if(_dw_ === i) break;
       var i = _dx_;
      }
     }
     return caml_call1(Stdlib_Bytes[44], s$0);
    }
    if(els){
     var
      _dr_ = function(el){return caml_call3(Stringext[3], _h_, el, 61);},
      acc = 0,
      param = caml_call2(Stdlib_List[22], _dr_, els);
     for(;;){
      if(! param){var _ds_ = acc; break;}
      var _dp_ = param[1];
      if(_dp_){
       var match = _dp_[2], k = _dp_[1];
       if(match)
        var
         tl = param[2],
         v = match[1],
         _dq_ = plus_to_space(v),
         l = caml_call3(Stringext[3], 0, _dq_, 44),
         l$0 = l || _f_,
         n = [0, plus_to_space(k), l$0],
         acc$0 = [0, n, acc],
         acc = acc$0,
         param = tl;
       else
        var
         tl$0 = param[2],
         n$0 = [0, plus_to_space(k), 0],
         acc$1 = [0, n$0, acc],
         acc = acc$1,
         param = tl$0;
      }
      else
       var tl$1 = param[2], acc$2 = [0, _g_, acc], acc = acc$2, param = tl$1;
     }
    }
    else
     var _ds_ = _i_;
    function _dt_(param){
     var
      v = param[2],
      k = param[1],
      _du_ = caml_call2(Stdlib_List[20], pct_decode, v);
     return [0, pct_decode(k), _du_];
    }
    return caml_call2(Stdlib_List[20], _dt_, _ds_);
   }
   function encoded_of_query(scheme, opt, l){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var _di_ = -1;
    function _dj_(a, param){
     var v = param[2], k = param[1], _dn_ = 0;
     function _do_(a, s){return (a + caml_ml_string_length(s) | 0) + 1 | 0;}
     return ((a + caml_ml_string_length(k) | 0)
            + caml_call3(Stdlib_List[26], _do_, _dn_, v)
            | 0)
            + 2
            | 0;
    }
    var
     len = caml_call3(Stdlib_List[26], _dj_, _di_, l),
     buf = caml_call1(Stdlib_Buffer[1], len);
    iter_concat
     (function(buf, param){
       var
        v = param[2],
        k = param[1],
        _dk_ = pct_encode(scheme, [0, pct_encoder$0[5]], k);
       caml_call2(Stdlib_Buffer[16], buf, _dk_);
       var _dl_ = 0 !== v ? 1 : 0;
       return _dl_
               ? (caml_call2
                  (Stdlib_Buffer[12], buf, 61),
                 iter_concat
                  (function(buf, s){
                    var _dm_ = pct_encode(scheme, [0, pct_encoder$0[6]], s);
                    return caml_call2(Stdlib_Buffer[16], buf, _dm_);
                   },
                   cst$8,
                   buf,
                   v))
               : _dl_;
      },
      cst$7,
      buf,
      l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_raw(qs){
    function _dh_(param){return query_of_encoded(qs);}
    var lazy_query = caml_call1(Stdlib_Lazy[6], _dh_);
    return [1, [0, qs], lazy_query];
   }
   function kv(param){
    if(0 === param[0])
     var kv = param[1];
    else{
     var _de_ = param[2], _df_ = caml_obj_tag(_de_);
     a:
     if(250 === _df_)
      var _dg_ = _de_[1];
     else{
      if(246 !== _df_ && 244 !== _df_){var _dg_ = _de_; break a;}
      var _dg_ = caml_call1(CamlinternalLazy[2], _de_);
     }
     var kv = _dg_;
    }
    return kv;
   }
   function encoded_of_query$0(scheme){
    return function(_dc_, _dd_){return encoded_of_query(scheme, _dc_, _dd_);};
   }
   var
    empty = [0, 0, 0, 0, 0, 0, [1, 0, caml_call1(Stdlib_Lazy[4], 0)], 0],
    compare_decoded = Stdlib_String[10];
   function compare_decoded_opt(_da_, _db_){
    return compare_opt(compare_decoded, _da_, _db_);
   }
   function compare_host(h1, h2){
    if(typeof h1 !== "number"){
     var _c$_ = h1[1];
     if(-367671627 === _c$_){
      if(typeof h2 !== "number" && -367671627 === h2[1]){
       var ip2 = h2[2], ip1 = h1[2];
       return caml_call2(Stdlib_String[10], ip1, ip2);
      }
     }
     else
      if(267950263 === _c$_){
       if(typeof h2 !== "number" && 267950263 === h2[1]){
        var ip2$0 = h2[2], ip1$0 = h1[2];
        return caml_call2(Stdlib_String[10], ip1$0, ip2$0);
       }
      }
      else if
       (803994504 === _c$_ && typeof h2 !== "number" && 803994504 === h2[1]){
       var h2$0 = h2[2], h1$0 = h1[2];
       return caml_call2(compare_decoded, h1$0, h2$0);
      }
    }
    return -1;
   }
   function compare$0(t$0, t){
    var c$3 = compare_opt(compare_host, t$0[3], t[3]);
    if(0 !== c$3) return c$3;
    var c = compare_decoded_opt(t$0[1], t[1]);
    if(0 !== c) return c;
    var
     _c8_ = t[4],
     _c9_ = t$0[4],
     c$0 =
       compare_opt
        (function(p$0, p){return p$0 < p ? -1 : p < p$0 ? 1 : 0;}, _c9_, _c8_);
    if(0 !== c$0) return c$0;
    var c$1 = compare_opt(compare, t$0[2], t[2]);
    if(0 !== c$1) return c$1;
    var c$4 = compare_list(_e_, t$0[5], t[5]);
    if(0 !== c$4) return c$4;
    var y = t[6], x = t$0[6];
    a:
    {
     if(0 === x[0]){
      var _c1_ = x[1];
      if(0 === y[0])
       var kvl$0 = y[1], kvl = _c1_;
      else{
       var _c2_ = y[2], _c3_ = caml_obj_tag(_c2_);
       b:
       if(250 === _c3_)
        var _c4_ = _c2_[1];
       else{
        if(246 !== _c3_ && 244 !== _c3_){var _c4_ = _c2_; break b;}
        var _c4_ = caml_call1(CamlinternalLazy[2], _c2_);
       }
       var kvl$0 = _c4_, kvl = _c1_;
      }
     }
     else{
      var _c5_ = x[2], raw = x[1];
      if(0 !== y[0]){
       var raw$0 = y[1], c$2 = compare_opt(Stdlib_String[10], raw, raw$0);
       break a;
      }
      var _c6_ = caml_obj_tag(_c5_);
      b:
      if(250 === _c6_)
       var _c7_ = _c5_[1];
      else{
       if(246 !== _c6_ && 244 !== _c6_){var _c7_ = _c5_; break b;}
       var _c7_ = caml_call1(CamlinternalLazy[2], _c5_);
      }
      var kvl$0 = y[1], kvl = _c7_;
     }
     var
      c$2 =
        compare_list
         (function(param, _c__){
           var
            vl = _c__[2],
            k = _c__[1],
            vl$0 = param[2],
            k$0 = param[1],
            c = caml_call2(Stdlib_String[10], k$0, k);
           return 0 === c ? compare_list(Stdlib_String[10], vl$0, vl) : c;
          },
          kvl,
          kvl$0);
    }
    return 0 === c$2 ? compare_decoded_opt(t$0[7], t[7]) : c$2;
   }
   function equal(t$0, t){return 0 === compare$0(t$0, t) ? 1 : 0;}
   function uncast_opt(param){
    if(! param) return 0;
    var h = param[1];
    return [0, h];
   }
   function normalize(schem, init){
    var
     Scheme = module_of_scheme(uncast_opt(schem)),
     _cV_ = init[3],
     _cR_ = init[7],
     _cS_ = init[6],
     _cT_ = init[5],
     _cU_ = init[4];
    if(_cV_){
     var match = _cV_[1], _cW_ = match[1];
     if(267950263 === _cW_)
      var
       host = match[2],
       _cX_ = [0, [0, 267950263, Scheme[2].call(null, host)]];
     else if(803994504 <= _cW_)
      var
       host$0 = match[2],
       _cX_ = [0, [0, 803994504, Scheme[2].call(null, host$0)]];
     else
      var
       host$1 = match[2],
       _cX_ = [0, [0, -367671627, Scheme[2].call(null, host$1)]];
     var _cY_ = _cX_;
    }
    else
     var _cY_ = 0;
    var param = init[1], f = Stdlib_String[27], _cZ_ = init[2];
    if(param)
     var x = param[1], _c0_ = [0, caml_call1(f, x)];
    else
     var _c0_ = 0;
    return [0, _c0_, _cZ_, _cY_, _cU_, _cT_, _cS_, _cR_];
   }
   function to_string(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match) var s = match[1], scheme = [0, s]; else var scheme = 0;
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function add_pct_string(opt, x){
     if(opt)
      var sth = opt[1], component = sth;
     else
      var component = 892015045;
     var _cQ_ = encode(scheme, [0, component], x);
     return caml_call2(Stdlib_Buffer[16], buf, _cQ_);
    }
    var match$0 = uri[1];
    if(match$0){
     var x = match$0[1];
     add_pct_string([0, pct_encoder$0[1]], x);
     caml_call2(Stdlib_Buffer[12], buf, 58);
    }
    a:
    {
     var _cy_ = uri[3], _cz_ = uri[4];
     if(! uri[2] && ! _cy_ && ! _cz_){var _cA_ = 0; break a;}
     var _cA_ = 1;
    }
    if(_cA_) caml_call2(Stdlib_Buffer[16], buf, cst$9);
    var match$1 = uri[2];
    if(match$1){
     var
      userinfo = match$1[1],
      _cB_ = encoded_of_userinfo(scheme, pct_encoder$0[2])(userinfo);
     caml_call2(Stdlib_Buffer[16], buf, _cB_);
     caml_call2(Stdlib_Buffer[12], buf, 64);
    }
    var _cC_ = uri[3];
    if(_cC_){
     var match$2 = _cC_[1], _cD_ = match$2[1];
     if(267950263 === _cD_){
      var host = match$2[2];
      caml_call2(Stdlib_Buffer[12], buf, 91);
      caml_call2(Stdlib_Buffer[16], buf, host);
      caml_call2(Stdlib_Buffer[12], buf, 93);
     }
     else if(803994504 <= _cD_){
      var host$0 = match$2[2];
      add_pct_string([0, pct_encoder$0[3]], host$0);
     }
     else{var host$1 = match$2[2]; caml_call2(Stdlib_Buffer[16], buf, host$1);
     }
    }
    var match$3 = uri[4];
    if(match$3){
     var port = match$3[1];
     caml_call2(Stdlib_Buffer[12], buf, 58);
     var _cE_ = caml_call1(Stdlib[33], port);
     caml_call2(Stdlib_Buffer[16], buf, _cE_);
    }
    var _cF_ = uri[5];
    if(_cF_){
     var first_segment = _cF_[1];
     if(caml_string_notequal(first_segment, cst$33)){
      if(uri[3])
       caml_call2(Stdlib_Buffer[12], buf, 47);
      else if(caml_call3(Stringext[12], 0, first_segment, cst$10) && ! scheme)
       caml_call2(Stdlib_Buffer[16], buf, cst$11);
      var
       _cG_ = uri[5],
       _cH_ = encoded_of_path(scheme, pct_encoder$0[4])(_cG_);
      caml_call2(Stdlib_Buffer[16], buf, _cH_);
     }
     else{
      var
       _cO_ = uri[5],
       _cP_ = encoded_of_path(scheme, pct_encoder$0[4])(_cO_);
      caml_call2(Stdlib_Buffer[16], buf, _cP_);
     }
    }
    var _cI_ = uri[6];
    a:
    {
     b:
     {
      if(0 === _cI_[0]){
       var _cJ_ = _cI_[1];
       if(_cJ_){var q = _cJ_; break b;}
      }
      else if(_cI_[1]){
       var _cL_ = _cI_[2], _cM_ = caml_obj_tag(_cL_);
       c:
       if(250 === _cM_)
        var _cN_ = _cL_[1];
       else{
        if(246 !== _cM_ && 244 !== _cM_){var _cN_ = _cL_; break c;}
        var _cN_ = caml_call1(CamlinternalLazy[2], _cL_);
       }
       var q = _cN_;
       break b;
      }
      break a;
     }
     caml_call2(Stdlib_Buffer[12], buf, 63);
     var _cK_ = encoded_of_query(scheme, [0, pct_encoder$0], q);
     caml_call2(Stdlib_Buffer[16], buf, _cK_);
    }
    var match$4 = uri[7];
    if(match$4){
     var f = match$4[1];
     caml_call2(Stdlib_Buffer[12], buf, 35);
     add_pct_string([0, pct_encoder$0[7]], f);
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function get_decoded_opt(param){
    if(! param) return 0;
    var x = param[1];
    return [0, x];
   }
   function scheme(uri){return get_decoded_opt(uri[1]);}
   function with_scheme(uri, param){
    if(! param) return [0, 0, uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
    var scheme = param[1];
    return [0, [0, scheme], uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
   }
   function host(uri){
    var _cx_ = uri[3];
    if(! _cx_) return 0;
    var match = _cx_[1];
    if(803994504 <= match[1]){var h = match[2]; return [0, h];}
    var h$0 = match[2];
    return [0, h$0];
   }
   function host_with_default(opt, uri){
    if(opt)
     var sth = opt[1], default$0 = sth;
    else
     var default$0 = cst_localhost;
    var match = host(uri);
    if(! match) return default$0;
    var h = match[1];
    return h;
   }
   function userinfo(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[2];
    if(! match) return 0;
    var userinfo = match[1], match$0 = uri[1];
    if(match$0)
     var
      s = match$0[1],
      _cw_ = encoded_of_userinfo([0, s], pct_encoder$0[2])(userinfo);
    else
     var _cw_ = encoded_of_userinfo(0, pct_encoder$0[2])(userinfo);
    return [0, _cw_];
   }
   function with_userinfo(uri, userinfo){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    return host(uri)
            ? [0, uri[1], userinfo$0, uri[3], uri[4], uri[5], uri[6], uri[7]]
            : [0,
              uri[1],
              userinfo$0,
              [0, [0, 803994504, cst$12]],
              uri[4],
              uri[5],
              uri[6],
              uri[7]];
   }
   function user(uri){
    var _cv_ = uri[2];
    if(! _cv_) return 0;
    var user = _cv_[1][1];
    return [0, user];
   }
   function password(uri){
    var _cu_ = uri[2];
    if(_cu_){
     var match = _cu_[1][2];
     if(match){var pass = match[1]; return [0, pass];}
    }
    return 0;
   }
   function with_password(uri, password){
    function result(userinfo){
     return host(uri)
             ? [0, uri[1], userinfo, uri[3], uri[4], uri[5], uri[6], uri[7]]
             : [0,
               uri[1],
               userinfo,
               [0, [0, 803994504, cst$13]],
               uri[4],
               uri[5],
               uri[6],
               uri[7]];
    }
    var _ct_ = uri[2];
    if(! _ct_) return password ? result([0, [0, cst$14, password]]) : uri;
    var user = _ct_[1][1];
    return result([0, [0, user, password]]);
   }
   function port(uri){return uri[4];}
   function with_port(uri, port){
    return host(uri)
            ? [0, uri[1], uri[2], uri[3], port, uri[5], uri[6], uri[7]]
            : port
              ? [0,
                uri[1],
                uri[2],
                [0, [0, 803994504, cst$15]],
                port,
                uri[5],
                uri[6],
                uri[7]]
              : [0, uri[1], uri[2], 0, 0, uri[5], uri[6], uri[7]];
   }
   function path(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match)
     var
      s = match[1],
      _cq_ = uri[5],
      _cr_ = encoded_of_path([0, s], pct_encoder$0[4])(_cq_);
    else
     var _cs_ = uri[5], _cr_ = encoded_of_path(0, pct_encoder$0[4])(_cs_);
    return _cr_;
   }
   function with_path(uri, path){
    var path$0 = path_of_encoded(path);
    if(host(uri) && path$0 && caml_string_notequal(path$0[1], cst$33))
     return [0,
             uri[1],
             uri[2],
             uri[3],
             uri[4],
             [0, cst$16, path$0],
             uri[6],
             uri[7]];
    return [0, uri[1], uri[2], uri[3], uri[4], path$0, uri[6], uri[7]];
   }
   function fragment(uri){return get_decoded_opt(uri[7]);}
   function with_fragment(uri, param){
    if(! param) return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], 0];
    var frag = param[1];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], [0, frag]];
   }
   function query(uri){return kv(uri[6]);}
   function verbatim_query(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[6];
    if(0 === match[0]){
     var kv = match[1];
     return kv
             ? [0, encoded_of_query(scheme(uri), [0, pct_encoder$0], kv)]
             : 0;
    }
    var qs = match[1];
    return qs;
   }
   function get_query_param(uri, k){
    var q = kv(uri[6]);
    try{var _co_ = [0, caml_call2(Stdlib_List[49], k, q)]; return _co_;}
    catch(_cp_){
     var _cn_ = caml_wrap_exception(_cp_);
     if(_cn_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_cn_, 0);
    }
   }
   function get_query_param$0(uri, k){
    var match = get_query_param(uri, k);
    if(! match) return 0;
    var v = match[1];
    return [0, caml_call2(Stdlib_String[7], cst$17, v)];
   }
   function with_query(uri, query){
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], [0, query], uri[7]];
   }
   function q_s(q){
    function _cm_(param){
     var v = param[2], k = param[1];
     return [0, k, [0, v, 0]];
    }
    return caml_call2(Stdlib_List[20], _cm_, q);
   }
   function with_query$0(uri, query){return with_query(uri, q_s(query));}
   function add_query_param(uri, p){
    var _ck_ = uri[7], _cl_ = [0, [0, p, kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _cl_, _ck_];
   }
   function add_query_param$0(uri, param){
    var
     v = param[2],
     k = param[1],
     _ci_ = uri[7],
     _cj_ = [0, [0, [0, k, [0, v, 0]], kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _cj_, _ci_];
   }
   function add_query_params(uri, ps){
    var
     _cf_ = uri[7],
     _cg_ = kv(uri[6]),
     _ch_ = [0, caml_call2(Stdlib[37], ps, _cg_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ch_, _cf_];
   }
   function add_query_params$0(uri, ps){
    var
     _cb_ = uri[7],
     _cc_ = kv(uri[6]),
     _cd_ = q_s(ps),
     _ce_ = [0, caml_call2(Stdlib[37], _cd_, _cc_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ce_, _cb_];
   }
   function remove_query_param(uri, k){
    var _b9_ = uri[7], _b__ = kv(uri[6]);
    function _b$_(param){
     var k$0 = param[1];
     return caml_string_notequal(k, k$0);
    }
    var _ca_ = [0, caml_call2(Stdlib_List[44], _b$_, _b__)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ca_, _b9_];
   }
   function path_and_query(uri){
    var p = path(0, uri), match = query(uri);
    if(caml_string_notequal(p, cst$34)){
     if(! match) return p;
     var
      scheme = uncast_opt(uri[1]),
      _b7_ = encoded_of_query$0(scheme)(0, match);
     return caml_call3(Stdlib_Printf[4], _j_, p, _b7_);
    }
    if(! match) return cst$18;
    var
     scheme$0 = uncast_opt(uri[1]),
     _b8_ = encoded_of_query$0(scheme$0)(0, match);
    return caml_call2(Stdlib_Printf[4], _k_, _b8_);
   }
   function resolve(schem, base, uri){
    var match$0 = scheme(base);
    if(match$0)
     var scheme$0 = match$0[1], scheme$1 = scheme$0;
    else
     var scheme$1 = schem;
    var
     schem$0 = [0, scheme$1],
     match$1 = scheme(uri),
     match$2 = userinfo(0, uri);
    a:
    {
     var match$3 = host(uri);
     if(match$1)
      var
       _bQ_ = uri[7],
       _bR_ = uri[6],
       _bS_ = remove_dot_segments(uri[5]),
       _bT_ = [0, uri[1], uri[2], uri[3], uri[4], _bS_, _bR_, _bQ_];
     else{
      if(! match$2 && ! match$3){
       var
        init = [0, base[1], base[2], base[3], base[4], uri[5], uri[6], uri[7]],
        path_str = path(0, init);
       if(caml_string_equal(path_str, cst$34))
        var
         _bX_ = init[7],
         _bY_ = init[6][1] ? init[6] : base[6],
         _bZ_ = [0, init[1], init[2], init[3], init[4], base[5], _bY_, _bX_];
       else if(47 === caml_string_get(path_str, 0))
        var
         _b0_ = init[7],
         _b1_ = init[6],
         _b2_ = remove_dot_segments(init[5]),
         _bZ_ = [0, init[1], init[2], init[3], init[4], _b2_, _b1_, _b0_];
       else{
        var
         relpath = init[5],
         bpath = base[5],
         bhost = base[3],
         _b3_ = init[7],
         _b4_ = init[6],
         match = caml_call1(Stdlib_List[10], bpath);
        b:
        {
         if(bhost && ! match){var _b5_ = [0, cst$6, relpath]; break b;}
         c:
         if(match){
          if(caml_string_notequal(match[1], cst$33)){
           var _bP_ = match[2];
           if(! _bP_) break c;
           if(caml_string_notequal(_bP_[1], cst$33)) break c;
           var rbpath = _bP_[2];
          }
          else
           var rbpath = match[2];
          var _b5_ = caml_call2(Stdlib_List[13], [0, cst$5, rbpath], relpath);
          break b;
         }
         var _b5_ = relpath;
        }
        var
         _b6_ = remove_dot_segments(_b5_),
         _bZ_ = [0, init[1], init[2], init[3], init[4], _b6_, _b4_, _b3_];
       }
       var _bT_ = _bZ_;
       break a;
      }
      var
       _bU_ = uri[7],
       _bV_ = uri[6],
       _bW_ = remove_dot_segments(uri[5]),
       _bT_ = [0, base[1], uri[2], uri[3], uri[4], _bW_, _bV_, _bU_];
     }
    }
    return normalize(schem$0, _bT_);
   }
   function canonicalize(uri){
    var
     uri$0 = resolve(cst$19, empty, uri),
     Scheme = module_of_scheme(uncast_opt(uri$0[1])),
     _bL_ = uri$0[7],
     _bM_ = uri$0[6],
     _bN_ = Scheme[4].call(null, uri$0[5]),
     _bO_ = Scheme[3].call(null, uri$0[4]);
    return [0, uri$0[1], uri$0[2], uri$0[3], _bO_, _bN_, _bM_, _bL_];
   }
   function pp(ppf, uri){
    var _bK_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bK_);
   }
   function pp_hum(ppf, uri){
    var _bJ_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bJ_);
   }
   var string_of_char = caml_call1(Stdlib_String[1], 1);
   function string_of_char_list(chars){
    var _bI_ = caml_call2(Stdlib_List[20], string_of_char, chars);
    return caml_call2(Stdlib_String[7], cst$20, _bI_);
   }
   var _l_ = caml_call1(Angstrom[51], 0), _m_ = caml_call1(Angstrom[4], 58);
   function _n_(c){
    var _bE_ = 58 !== c ? 1 : 0;
    if(_bE_){
     var _bF_ = 47 !== c ? 1 : 0;
     if(_bF_)
      var _bG_ = 63 !== c ? 1 : 0, _bH_ = _bG_ ? 35 !== c ? 1 : 0 : _bG_;
     else
      var _bH_ = _bF_;
    }
    else
     var _bH_ = _bE_;
    return _bH_;
   }
   var
    _o_ = caml_call1(Angstrom[13], _n_),
    _p_ = caml_call2(Angstrom[59], _o_, _m_);
   function _q_(s){return [0, decode(s)];}
   var
    _r_ = caml_call2(Angstrom[60], _q_, _p_),
    scheme$0 = caml_call2(Angstrom[47], _r_, _l_);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function _s_(param){
    var _bD_ = param - 48 | 0;
    a:
    {
     if(22 < _bD_ >>> 0){
      if(5 < _bD_ - 49 >>> 0) break a;
     }
     else if(6 >= _bD_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   var
    hex_digit = caml_call1(Angstrom[7], _s_),
    _t_ = caml_call1(Angstrom[38], hex_digit),
    hexadecimal = caml_call2(Angstrom[60], string_of_char_list, _t_),
    c_dot = caml_call1(Angstrom[4], 46),
    c_at = caml_call1(Angstrom[4], 64),
    c_colon = caml_call1(Angstrom[4], 58);
   function _u_(num){
    return 256 <= caml_int_of_string(num)
            ? caml_call1(Angstrom[52], cst_invalid_octect)
            : caml_call1(Angstrom[51], num);
   }
   function _v_(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    _w_ = caml_call1(Angstrom[14], _v_),
    dec_octet = caml_call2(Angstrom[53], _w_, _u_),
    _x_ = caml_call2(Angstrom[59], dec_octet, c_dot),
    _y_ = caml_call2(Angstrom[37], 3, _x_);
   function _z_(three, one){
    var
     _bB_ = caml_call2(Stdlib[28], cst$21, one),
     _bC_ = caml_call2(Stdlib_String[7], cst$22, three);
    return caml_call2(Stdlib[28], _bC_, _bB_);
   }
   var ipv4_address = caml_call3(Angstrom[61], _z_, _y_, dec_octet);
   function _A_(f){
    var
     _bv_ = caml_call1(Angstrom[51], 0),
     _bw_ = caml_call2(Angstrom[58], c_colon, f),
     _bx_ = caml_call2(Angstrom[47], _bw_, _bv_);
    function _by_(x, y){return [0, x, y];}
    var
     _bz_ = caml_call3(Angstrom[61], _by_, hexadecimal, _bx_),
     _bA_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
    return caml_call2(Angstrom[47], _bA_, _bz_);
   }
   var after_double_colon = caml_call1(Angstrom[45], _A_);
   function double_colon(count){
    var _bs_ = caml_call1(Angstrom[51], _B_);
    function _bt_(rest){
     var
      filler_length = (8 - count | 0) - caml_call1(Stdlib_List[1], rest) | 0;
     return 0 < filler_length
             ? caml_call1(Angstrom[51], [0, cst$23, rest])
             : caml_call1(Angstrom[52], cst_too_many_parts_in_IPv6_add);
    }
    var _bu_ = caml_call2(Angstrom[53], after_double_colon, _bt_);
    return caml_call2(Angstrom[47], _bu_, _bs_);
   }
   function part(n){
    if(6 === n){
     var
      _bp_ = hex_part(6),
      _bq_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
     return caml_call2(Angstrom[47], _bq_, _bp_);
    }
    if(7 !== n) return hex_part(n);
    function _br_(x){return [0, x, 0];}
    return caml_call2(Angstrom[60], _br_, hexadecimal);
   }
   function hex_part(n){
    var
     _bj_ = part(n + 1 | 0),
     _bk_ = double_colon(n + 1 | 0),
     _bl_ = caml_call2(Angstrom[58], c_colon, _bk_),
     _bm_ = caml_call2(Angstrom[47], _bl_, _bj_),
     _bn_ = caml_call2(Angstrom[58], c_colon, _bm_);
    function _bo_(x, y){return [0, x, y];}
    return caml_call3(Angstrom[61], _bo_, hexadecimal, _bn_);
   }
   function split_with(f, xs){
    if(! xs) return _C_;
    var ys = xs[2], y = xs[1];
    if(! caml_call1(f, y)) return [0, 0, xs];
    var match = split_with(f, ys), ts = match[2], zs = match[1];
    return [0, [0, y, zs], ts];
   }
   function format_addr(segments){
    var
     match =
       split_with
        (function(segment){return caml_string_notequal(segment, cst$34);},
         segments),
     after_double_colon = match[2],
     before_double_colon = match[1],
     before = caml_call2(Stdlib_String[7], cst$24, before_double_colon);
    a:
    {
     if
      (after_double_colon
       && ! caml_string_notequal(after_double_colon[1], cst$34)){
      var
       xs = after_double_colon[2],
       _bh_ = caml_call2(Stdlib_String[7], cst$25, xs),
       _bi_ = caml_call2(Stdlib[28], cst$26, _bh_),
       res = caml_call2(Stdlib[28], before, _bi_);
      break a;
     }
     var res = before;
    }
    return res;
   }
   var
    _D_ = part(0),
    _E_ = double_colon(0),
    _F_ = caml_call2(Angstrom[58], c_colon, c_colon),
    _G_ = caml_call2(Angstrom[58], _F_, _E_),
    _H_ = caml_call2(Angstrom[47], _G_, _D_),
    ipv6 = caml_call2(Angstrom[60], format_addr, _H_),
    _I_ = caml_call1(Angstrom[4], 93),
    _J_ = caml_call1(Angstrom[4], 91),
    _K_ = caml_call2(Angstrom[58], _J_, ipv6),
    ipv6_address = caml_call2(Angstrom[59], _K_, _I_),
    _L_ = caml_call2(Angstrom[37], 2, hex_digit),
    _M_ = caml_call1(Angstrom[4], 37);
   function _N_(pct, digits){return string_of_char_list([0, pct, digits]);}
   var pct_encoded = caml_call3(Angstrom[61], _N_, _M_, _L_);
   function _O_(param){
    var _bf_ = param - 59 | 0;
    a:
    {
     if(2 < _bf_ >>> 0){
      var _bg_ = _bf_ + 26 | 0;
      if(11 < _bg_ >>> 0) break a;
      switch(_bg_){case 1:case 2:case 4: break a;
      }
     }
     else if(1 === _bf_) break a;
     return 1;
    }
    return 0;
   }
   var sub_delims$0 = caml_call1(Angstrom[7], _O_);
   function _P_(param){
    a:
    {
     if(91 <= param){
      var _bd_ = param - 95 | 0;
      if(27 < _bd_ >>> 0){
       if(31 !== _bd_) break a;
      }
      else if(1 === _bd_) break a;
     }
     else{
      var _be_ = param - 45 | 0;
      if(12 < _be_ >>> 0){if(20 > _be_) break a;} else if(2 === _be_) break a;
     }
     return 1;
    }
    return 0;
   }
   var
    unreserved = caml_call1(Angstrom[7], _P_),
    _Q_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), 0]],
    _R_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _Q_],
    _S_ = caml_call2(Angstrom[48], 0, _R_),
    _T_ = caml_call1(Angstrom[38], _S_),
    _U_ = caml_call1(Stdlib_String[7], cst$27),
    reg_name = caml_call2(Angstrom[60], _U_, _T_),
    _V_ = 0;
   function _W_(s){return [0, 803994504, decode(s)];}
   var _X_ = [0, caml_call2(Angstrom[55], reg_name, _W_), _V_];
   function _Y_(h){return [0, 267950263, h];}
   var _Z_ = [0, caml_call2(Angstrom[55], ipv6_address, _Y_), _X_];
   function ___(h){return [0, -367671627, h];}
   var
    _$_ = [0, caml_call2(Angstrom[55], ipv4_address, ___), _Z_],
    host$0 = caml_call2(Angstrom[48], 0, _$_),
    _aa_ = caml_call1(Angstrom[51], 0),
    _ab_ = [0, caml_call2(Angstrom[57], string_of_char, c_colon), 0],
    _ac_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), _ab_]],
    _ad_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _ac_],
    _ae_ = caml_call2(Angstrom[48], 0, _ad_),
    _af_ = caml_call1(Angstrom[38], _ae_),
    _ag_ = caml_call2(Angstrom[59], _af_, c_at);
   function _ah_(x){
    var s = caml_call2(Stdlib_String[7], cst$28, x);
    return [0, userinfo_of_encoded(s)];
   }
   var
    _ai_ = caml_call2(Angstrom[60], _ah_, _ag_),
    userinfo$0 = caml_call2(Angstrom[47], _ai_, _aa_);
   function _aj_(param){
    if(param && 58 === param[1]){
     var
      _a__ =
        function(port){
         var decoded = decode(port);
         try{var _bb_ = [0, caml_int_of_string(decoded)]; return _bb_;}
         catch(_bc_){return 0;}
        },
      _a$_ = caml_call1(Angstrom[13], is_digit),
      _ba_ = caml_call2(Angstrom[58], c_colon, _a$_);
     return caml_call2(Angstrom[55], _ba_, _a__);
    }
    return caml_call1(Angstrom[51], 0);
   }
   var
    port$0 = caml_call2(Angstrom[53], Angstrom[1], _aj_),
    _al_ = caml_call1(Angstrom[51], _ak_);
   function _am_(userinfo, host, port){return [0, userinfo, [0, host], port];}
   var
    _an_ = caml_call4(Angstrom[62], _am_, userinfo$0, host$0, port$0),
    _ao_ = caml_call1(Angstrom[8], cst$29),
    _ap_ = caml_call2(Angstrom[58], _ao_, _an_),
    authority = caml_call2(Angstrom[47], _ap_, _al_);
   function _aq_(param){if(35 !== param && 63 !== param) return 1; return 0;}
   var
    _ar_ = caml_call1(Angstrom[13], _aq_),
    path$0 = caml_call2(Angstrom[60], path_of_encoded, _ar_),
    _as_ = [1, 0, caml_call1(Stdlib_Lazy[4], 0)],
    _at_ = caml_call1(Angstrom[51], _as_);
   function _au_(param){return 35 === param ? 1 : 0;}
   var
    _av_ = caml_call1(Angstrom[15], _au_),
    _aw_ = caml_call1(Angstrom[4], 63),
    _ax_ = caml_call2(Angstrom[58], _aw_, _av_),
    _ay_ = caml_call2(Angstrom[60], of_raw, _ax_),
    query$0 = caml_call2(Angstrom[47], _ay_, _at_),
    _az_ = caml_call1(Angstrom[51], 0);
   function _aA_(param){return 1;}
   var
    _aB_ = caml_call1(Angstrom[13], _aA_),
    _aC_ = caml_call1(Angstrom[4], 35),
    _aD_ = caml_call2(Angstrom[58], _aC_, _aB_);
   function _aE_(s){return [0, decode(s)];}
   var
    _aF_ = caml_call2(Angstrom[60], _aE_, _aD_),
    fragment$0 = caml_call2(Angstrom[47], _aF_, _az_);
   function _aG_(scheme, param, path, query, fragment){
    var port = param[3], host = param[2], userinfo = param[1];
    return normalize
            (scheme, [0, scheme, userinfo, host, port, path, query, fragment]);
   }
   var
    _aH_ =
      caml_call5(Angstrom[63], _aG_, scheme$0, authority, path$0, query$0),
    uri_reference = caml_call2(Angstrom[56], _aH_, fragment$0);
   function _aI_(s){
    var match = caml_call3(Angstrom[75], 1, uri_reference, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   function _aJ_(param){return 10 === param ? 0 : 1;}
   var
    _aK_ = caml_call1(Angstrom[13], _aJ_),
    uri_reference$0 = caml_call2(Angstrom[55], _aK_, _aI_);
   function decode_host(host){
    var match = caml_call3(Angstrom[75], 1, host$0, host);
    if(0 === match[0]){var parsed = match[1]; return parsed;}
    var match$0 = caml_call3(Angstrom[75], 1, ipv6, host);
    if(0 !== match$0[0]) return [0, 803994504, host];
    var parsed$0 = match$0[1];
    return [0, 267950263, parsed$0];
   }
   function make(scheme, userinfo, host, port, path, query, fragment, param){
    function decode(param){
     if(! param) return 0;
     var x = param[1];
     return [0, x];
    }
    a:
    {
     b:
     if(! host){if(! port && ! userinfo) break b; var host$0 = _aM_; break a;}
     var host$0 = host;
    }
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(host$0 && path$0 && caml_string_notequal(path$0[1], cst$33)){var _a7_ = [0, cst$30, path$0]; break a;}
      var _a7_ = path$0;
     }
     var path$1 = _a7_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _aL_;
    var scheme$0 = decode(scheme), _a8_ = decode(fragment);
    if(host$0)
     var host$1 = host$0[1], _a9_ = [0, decode_host(host$1)];
    else
     var _a9_ = 0;
    return normalize
            (scheme$0,
             [0, scheme$0, userinfo$0, _a9_, port, path$1, query$0, _a8_]);
   }
   function with_host(init, host){
    var _a2_ = init[7], _a3_ = init[6], _a4_ = init[5], _a5_ = init[4];
    if(host)
     var host$0 = host[1], _a6_ = [0, decode_host(host$0)];
    else
     var _a6_ = 0;
    return [0, init[1], init[2], _a6_, _a5_, _a4_, _a3_, _a2_];
   }
   function with_uri(scheme, userinfo, host, port, path, query, fragment, uri){
    function with_path_opt(u, o){
     if(! o) return with_path(u, cst$31);
     var p = o[1];
     return with_path(u, p);
    }
    function with_query_opt(u, o){
     if(! o) return with_query(u, 0);
     var q = o[1];
     return with_query(u, q);
    }
    function with$0(f, o, u){
     if(! o) return u;
     var x = o[1];
     return caml_call2(f, u, x);
    }
    return with$0
            (with_fragment,
             fragment,
             with$0
              (with_query_opt,
               query,
               with$0
                (with_path_opt,
                 path,
                 with$0
                  (with_port,
                   port,
                   with$0
                    (with_host,
                     host,
                     with$0
                      (with_userinfo, userinfo, with$0(with_scheme, scheme, uri)))))));
   }
   function of_string(s){
    var match = caml_call3(Angstrom[75], 0, uri_reference$0, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   var let$0 = Stdlib_Result[6];
   function to_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1],
     scheme$0 = 804243368 <= scheme ? cst_http : cst_https;
    return [0,
            [0, scheme$0],
            userinfo,
            [0, host],
            port,
            path,
            query,
            fragment];
   }
   function of_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1];
    function _aY_(scheme){
     function _a1_(host){
      return [0, [0, scheme, userinfo, host, port, path, query, fragment]];
     }
     return caml_call2(let$0, caml_call2(Stdlib_Option[14], _aN_, host), _a1_);
    }
    if(scheme)
     var
      unsupported_scheme = scheme[1],
      _aZ_ =
        caml_string_notequal(unsupported_scheme, cst_http$0)
         ? caml_string_notequal
            (unsupported_scheme, cst_https$0)
           ? [1,
             [0,
              3854881,
              caml_call2(Stdlib_Printf[4], _aO_, unsupported_scheme)]]
           : _aP_
         : _aQ_,
      _a0_ = _aZ_;
    else
     var _a0_ = _aR_;
    return caml_call2(let$0, _a0_, _aY_);
   }
   function of_string$0(s){
    var match = of_uri(of_string(s));
    if(0 === match[0]){var t = match[1]; return t;}
    var error = match[1][2];
    return caml_call1(Stdlib[2], error);
   }
   function to_string$0(pct_encoder, t){
    return to_string(pct_encoder, to_uri(t));
   }
   function make$0
   (scheme, host$2, userinfo, port, path, query, fragment, param){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(path$0 && caml_string_notequal(path$0[1], cst$33)){var _aW_ = [0, cst$32, path$0]; break a;}
      var _aW_ = path$0;
     }
     var path$1 = _aW_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _aS_;
    if(fragment) var x = fragment[1], _aX_ = [0, x]; else var _aX_ = 0;
    var match = decode_host(host$2), _aU_ = match[1];
    if(267950263 === _aU_)
     var
      host = match[2],
      _aV_ = [0, 267950263, caml_call1(Stdlib_String[27], host)];
    else if(803994504 <= _aU_)
     var
      host$0 = match[2],
      _aV_ = [0, 803994504, caml_call1(Stdlib_String[27], host$0)];
    else
     var
      host$1 = match[2],
      _aV_ = [0, -367671627, caml_call1(Stdlib_String[27], host$1)];
    return [0, scheme, userinfo$0, _aV_, port, path$1, query$0, _aX_];
   }
   function host$1(t){
    var match = t[3];
    if(803994504 <= match[1]){var h = match[2]; return h;}
    var h$0 = match[2];
    return h$0;
   }
   function scheme$1(t){return t[1];}
   var
    Uri =
      [0,
       empty,
       compare$0,
       equal,
       pct_encode,
       pct_encoder,
       pct_decode,
       of_string,
       to_string,
       resolve,
       canonicalize,
       make,
       with_uri,
       query,
       verbatim_query,
       encoded_of_query$0,
       query_of_encoded,
       with_query,
       with_query$0,
       get_query_param,
       get_query_param$0,
       add_query_param,
       add_query_param$0,
       add_query_params,
       add_query_params$0,
       remove_query_param,
       path,
       path_and_query,
       with_path,
       scheme,
       with_scheme,
       userinfo,
       with_userinfo,
       user,
       password,
       with_password,
       host,
       with_host,
       host_with_default,
       port,
       with_port,
       fragment,
       with_fragment,
       pp,
       pp_hum,
       [0, ipv6, uri_reference$0],
       [0, of_uri, to_uri, of_string$0, to_string$0, make$0, host$1, scheme$1]];
   runtime.caml_register_global(107, Uri, "Uri");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1cmkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImNzdCQwIiwiaXRlcl9jb25jYXQiLCJmbiIsInNlcCIsImJ1ZiIsImxhc3QiLCJyZXN0IiwiY29tcGFyZV9vcHQiLCJjIiwidCQwIiwidCIsImEiLCJiIiwiY29tcGFyZV9saXN0IiwiZiIsInQkMiIsInQkMSIsInhzIiwieCIsInlzIiwieSIsInN1Yl9kZWxpbXMiLCJpIiwic2FmZV9jaGFycyIsInBjaGFyIiwic2FmZV9jaGFyc19mb3Jfc2NoZW1lIiwic2FmZV9jaGFyc19mb3JfcGF0aCIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUiLCJzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCIsInVuc2FmZSIsInNhZmUiLCJjb21wb25lbnQiLCJzYWZlX2NoYXJzJDAiLCJpJDAiLCJjJDAiLCJub3JtYWxpemVfaG9zdCIsImhzbyIsImNhbm9uaWNhbGl6ZV9wb3J0IiwicG9ydCIsImNhbm9uaWNhbGl6ZV9wYXRoIiwicGF0aCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQwIiwibm9ybWFsaXplX2hvc3QkMCIsImhzIiwiY2Fub25pY2FsaXplX3BvcnQkMCIsImNhbm9uaWNhbGl6ZV9wYXRoJDAiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQkMSIsIm5vcm1hbGl6ZV9ob3N0JDEiLCJjYW5vbmljYWxpemVfcGF0aCQxIiwiY2Fub25pY2FsaXplX3BvcnQkMSIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQyIiwiY2Fub25pY2FsaXplX3BvcnQkMiIsImNhbm9uaWNhbGl6ZV9wYXRoJDIiLCJub3JtYWxpemVfaG9zdCQyIiwiaHMkMCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQzIiwibm9ybWFsaXplX2hvc3QkMyIsImNhbm9uaWNhbGl6ZV9wb3J0JDMiLCJjYW5vbmljYWxpemVfcGF0aCQzIiwibW9kdWxlX29mX3NjaGVtZSIsInMiLCJlbmNvZGUiLCJzY2hlbWUiLCJvcHQiLCJzdGgiLCJsZW4iLCJzdGFydCIsImN1ciIsImN1ciQwIiwiY3VyJDEiLCJzdGFydCQwIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwiaGlnaGJpdHMiLCJsb3diaXRzIiwic3RhcnRfYXQiLCJwY3RfZW5jb2RlIiwicGN0X2VuY29kZXIiLCJzdGgkMCIsInVzZXJpbmZvIiwic3RoJDEiLCJob3N0Iiwic3RoJDIiLCJzdGgkMyIsInF1ZXJ5X2tleSIsInN0aCQ0IiwicXVlcnlfdmFsdWUiLCJzdGgkNSIsImZyYWdtZW50IiwicGN0X2RlY29kZSIsImNvbXBhcmUiLCJwIiwidSIsInAkMCIsInUkMCIsInVzZXJpbmZvX29mX2VuY29kZWQiLCJ1cyIsImVuY29kZWRfb2ZfdXNlcmluZm8iLCJwbyIsInBhdGhfb2ZfZW5jb2RlZCIsInBzIiwidG9rbCIsInJlbW92ZV9kb3Rfc2VnbWVudHMiLCJyZXZwIiwiYXNjZW5zaW9uIiwib3V0cCIsInIkMyIsInIkMSIsInIkMCIsInIkMiIsInIiLCJsc3QiLCJoIiwiYWNjIiwiZW5jb2RlZF9vZl9wYXRoIiwidG9rIiwic2VnIiwicXVlcnlfb2ZfZW5jb2RlZCIsInFzIiwiZWxzIiwicGx1c190b19zcGFjZSIsInMkMCIsImVsIiwiayIsInRsIiwidiIsImwiLCJsJDAiLCJuIiwidGwkMCIsIm4kMCIsInRsJDEiLCJlbmNvZGVkX29mX3F1ZXJ5IiwicGN0X2VuY29kZXIkMCIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVuY29kZWRfb2ZfcXVlcnkkMCIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkIiwiY29tcGFyZV9kZWNvZGVkX29wdCIsImNvbXBhcmVfaG9zdCIsImgxIiwiaDIiLCJpcDIiLCJpcDEiLCJpcDIkMCIsImlwMSQwIiwiaDIkMCIsImgxJDAiLCJjb21wYXJlJDAiLCJjJDMiLCJjJDEiLCJjJDQiLCJrdmwkMCIsImt2bCIsInJhdyIsInJhdyQwIiwiYyQyIiwidmwiLCJ2bCQwIiwiayQwIiwiZXF1YWwiLCJ1bmNhc3Rfb3B0Iiwibm9ybWFsaXplIiwic2NoZW0iLCJpbml0IiwiaG9zdCQwIiwiaG9zdCQxIiwidG9fc3RyaW5nIiwidXJpIiwiYWRkX3BjdF9zdHJpbmciLCJmaXJzdF9zZWdtZW50IiwicSIsImdldF9kZWNvZGVkX29wdCIsIndpdGhfc2NoZW1lIiwiaCQwIiwiaG9zdF93aXRoX2RlZmF1bHQiLCJkZWZhdWx0JDAiLCJ3aXRoX3VzZXJpbmZvIiwidXNlcmluZm8kMCIsInVzZXIiLCJwYXNzd29yZCIsInBhc3MiLCJ3aXRoX3Bhc3N3b3JkIiwicmVzdWx0Iiwid2l0aF9wb3J0Iiwid2l0aF9wYXRoIiwicGF0aCQwIiwid2l0aF9mcmFnbWVudCIsImZyYWciLCJxdWVyeSIsInZlcmJhdGltX3F1ZXJ5IiwiZ2V0X3F1ZXJ5X3BhcmFtIiwiZ2V0X3F1ZXJ5X3BhcmFtJDAiLCJ3aXRoX3F1ZXJ5IiwicV9zIiwid2l0aF9xdWVyeSQwIiwiYWRkX3F1ZXJ5X3BhcmFtIiwiYWRkX3F1ZXJ5X3BhcmFtJDAiLCJhZGRfcXVlcnlfcGFyYW1zIiwiYWRkX3F1ZXJ5X3BhcmFtcyQwIiwicmVtb3ZlX3F1ZXJ5X3BhcmFtIiwicGF0aF9hbmRfcXVlcnkiLCJtYXRjaCIsInNjaGVtZSQwIiwicmVzb2x2ZSIsImJhc2UiLCJzY2hlbWUkMSIsInNjaGVtJDAiLCJwYXRoX3N0ciIsInJlbHBhdGgiLCJicGF0aCIsImJob3N0IiwicmJwYXRoIiwiY2Fub25pY2FsaXplIiwidXJpJDAiLCJwcCIsInBwZiIsInBwX2h1bSIsInN0cmluZ19vZl9jaGFyIiwic3RyaW5nX29mX2NoYXJfbGlzdCIsImNoYXJzIiwiaXNfZGlnaXQiLCJoZXhfZGlnaXQiLCJoZXhhZGVjaW1hbCIsImNfZG90IiwiY19hdCIsImNfY29sb24iLCJudW0iLCJkZWNfb2N0ZXQiLCJ0aHJlZSIsIm9uZSIsImlwdjRfYWRkcmVzcyIsImFmdGVyX2RvdWJsZV9jb2xvbiIsImRvdWJsZV9jb2xvbiIsImNvdW50IiwiZmlsbGVyX2xlbmd0aCIsInBhcnQiLCJoZXhfcGFydCIsInNwbGl0X3dpdGgiLCJ0cyIsInpzIiwiZm9ybWF0X2FkZHIiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJiZWZvcmVfZG91YmxlX2NvbG9uIiwiYmVmb3JlIiwicmVzIiwiaXB2NiIsImlwdjZfYWRkcmVzcyIsInBjdCIsImRpZ2l0cyIsInBjdF9lbmNvZGVkIiwic3ViX2RlbGltcyQwIiwidW5yZXNlcnZlZCIsInJlZ19uYW1lIiwiZGVjb2RlZCIsInBvcnQkMCIsImF1dGhvcml0eSIsInF1ZXJ5JDAiLCJmcmFnbWVudCQwIiwidXJpX3JlZmVyZW5jZSIsInVyaV9yZWZlcmVuY2UkMCIsImRlY29kZV9ob3N0IiwicGFyc2VkIiwicGFyc2VkJDAiLCJtYWtlIiwicGF0aCQxIiwid2l0aF9ob3N0Iiwid2l0aF91cmkiLCJ3aXRoX3BhdGhfb3B0IiwibyIsIndpdGhfcXVlcnlfb3B0Iiwid2l0aCQwIiwib2Zfc3RyaW5nIiwibGV0JDAiLCJ0b191cmkiLCJvZl91cmkiLCJ1bnN1cHBvcnRlZF9zY2hlbWUiLCJvZl9zdHJpbmckMCIsImVycm9yIiwidG9fc3RyaW5nJDAiLCJtYWtlJDAiLCJob3N0JDIiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdXJpL3VyaS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvRGtCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFSVkMsWUFBWUMsSUFBR0MsS0FBSUM7OzttQkFNakI7U0FMTkM7c0JBQVksT0FBQSxXQURJSCxJQUFPRSxLQUN2QkM7U0FDSUM7S0FDSixXQUhnQkosSUFBT0UsS0FDdkJDO0tBR0Es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U0FBQUE7SUFPSixHQVo0QzdFLFdBY25DbEcsTUFkbUNrRyxVQVl4Q3FFLGNBRUt2SyxlQUZMdUs7T0FaK0M1SyxjQUUzQ3pFLElBRjJDeUUsd0JBRTNDekU7SUFpQkUsSUFBQSxRQXZLVnlQLFlBb0pnQm9COzs7TUFOSTNNOzRCQUNBLDhCQURBQTs7O01BRVJzRjs0QkFDa0IsOEJBRGxCQTs7O01BSlFDOzZCQUNBLDhCQURBQTtJQUZwQixXQVVRMUcsUUFHSnNILGtCQUg0QjlJLE1BSzVCc08sUUFPQVI7R0FPcUU7WUFFdkU1RixPQUFLaks7SUFDUCxZQURPQTtrQ0FHRXlHLGNBQU0sT0FBTkE7UUFEUWdFO0lBQXdCLE9BQXhCQTtHQUNvQjtZQUVuQ2dDLFNBQU96TSxHQUFJLE9BQUpBLEtBQVk7Ozs7T0F6ckJyQm1JO09Bb0JBWTtPQWlCQVk7T0ExT0F0RjtPQUdBQztPQVlBWTtPQXl3QkEwTDtPQW5oQkExRztPQTZMQXFDO09BOEJBUztPQTRQQW9EO09Bb0NBRztPQXRXQS9FO09BQ0FDO09Bck9BdkQ7T0FEQXBCO09BaVBBOEU7T0FFQUU7T0FSQUo7T0FDQUM7T0FRQUk7T0FDQUM7T0FFQUM7T0FDQUM7T0FFQUM7T0FwQ0FsSztPQXlDQW1LO09BdENBaEI7T0E5REE3SDtPQUNBaUg7T0FnQkFoRztPQUtBb0c7T0FTQUU7T0FJQUM7T0FHQUU7T0FoQ0F2RztPQW1hQTRMO09BN1pBNUY7T0FvQ0EzSTtPQUNBb0o7T0FtQkFsRztPQUNBcUc7T0FvRkE0QjtPQUNBRTtXQXlGRThCLE1Bb0lBYztXQXlIQWUsUUFmQUQsUUFrQ0FHLGFBSUFFLGFBYUFDLFFBcUJBbkgsUUFLQXdDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBBbmlsIE1hZGhhdmFwZWRkeSA8YW5pbEByZWNvaWwub3JnPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGF2aWQgU2hlZXRzIDxzaGVldHNAYWx1bS5taXQuZWR1PlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5cbnR5cGUgY29tcG9uZW50ID0gW1xuICB8IGBTY2hlbWVcbiAgfCBgQXV0aG9yaXR5XG4gIHwgYFVzZXJpbmZvICgqIHN1YmNvbXBvbmVudCBvZiBhdXRob3JpdHkgaW4gc29tZSBzY2hlbWVzICopXG4gIHwgYEhvc3QgKCogc3ViY29tcG9uZW50IG9mIGF1dGhvcml0eSBpbiBzb21lIHNjaGVtZXMgKilcbiAgfCBgUGF0aFxuICB8IGBRdWVyeVxuICB8IGBRdWVyeV9rZXlcbiAgfCBgUXVlcnlfdmFsdWVcbiAgfCBgRnJhZ21lbnRcbiAgfCBgR2VuZXJpY1xuICB8IGBDdXN0b20gb2YgKGNvbXBvbmVudCAqIHN0cmluZyAqIHN0cmluZykgKCogKGNvbXBvbmVudCAqIHNhZmUgY2hhcnMgKiB1bnNhZmUgY2hhcnMpICopXG5dXG5cbnR5cGUgcGN0X2VuY29kZXIgPSB7XG4gICAgc2NoZW1lOiBjb21wb25lbnQ7XG4gICAgdXNlcmluZm86IGNvbXBvbmVudDtcbiAgICBob3N0OiBjb21wb25lbnQ7XG4gICAgcGF0aDogY29tcG9uZW50O1xuICAgIHF1ZXJ5X2tleTogY29tcG9uZW50O1xuICAgIHF1ZXJ5X3ZhbHVlOiBjb21wb25lbnQ7XG4gICAgZnJhZ21lbnQ6IGNvbXBvbmVudDtcbiAgfVxuXG5sZXQgcmVjIGl0ZXJfY29uY2F0IGZuIHNlcCBidWYgPSBmdW5jdGlvblxuICB8IGxhc3Q6OltdIC0+IGZuIGJ1ZiBsYXN0XG4gIHwgZWw6OnJlc3QgLT5cbiAgICBmbiBidWYgZWw7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHNlcDtcbiAgICBpdGVyX2NvbmNhdCBmbiBzZXAgYnVmIHJlc3RcbiAgfCBbXSAtPiAoKVxuXG5sZXQgcmV2X2ludGVyamVjdCBlIGxzdCA9XG4gIGxldCByZWMgYXV4IGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgLT4gYWNjXG4gICAgfCB4Ojp4cyAtPiBhdXggKHg6OmU6OmFjYykgeHNcbiAgaW4gbWF0Y2ggbHN0IHdpdGhcbiAgfCBbXSAgLT4gW11cbiAgfCBoOjp0IC0+IGF1eCBbaF0gdFxuXG5sZXQgY29tcGFyZV9vcHQgYyB0IHQnID0gbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5vbmUsICAgTm9uZSAgIC0+IDBcbiAgfCBTb21lIF8sIE5vbmUgICAtPiAxXG4gIHwgTm9uZSwgICBTb21lIF8gLT4gLTFcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBjIGEgYlxuXG5sZXQgcmVjIGNvbXBhcmVfbGlzdCBmIHQgdCcgPSBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgW10sICAgIFtdICAgIC0+ICAwXG4gIHwgXzo6XywgIFtdICAgIC0+ICAxXG4gIHwgW10sICAgIF86Ol8gIC0+IC0xXG4gIHwgeDo6eHMsIHk6OnlzIC0+XG4gICAgbWF0Y2ggZiB4IHkgd2l0aCAwIC0+IGNvbXBhcmVfbGlzdCBmIHhzIHlzIHwgYyAtPiBjXG5cbigqKiBTYWZlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYWx3YXlzIGFsbG93ZWQgaW4gYSBVUklcbiAgKiBVbmZvcnR1bmF0ZWx5LCB0aGlzIHZhcmllcyBkZXBlbmRpbmcgb24gd2hpY2ggYml0IG9mIHRoZSBVUklcbiAgKiBpcyBiZWluZyBwYXJzZWQsIHNvIHRoZXJlIGFyZSBtdWx0aXBsZSB2YXJpYW50cyAoYW5kIHRoaXNcbiAgKiBzZXQgaXMgcHJvYmFibHkgbm90IGV4aGF1c3RpdmUuIFRPRE86IGNoZWNrLlxuKilcbnR5cGUgc2FmZV9jaGFycyA9IGJvb2wgYXJyYXlcblxubW9kdWxlIHR5cGUgU2NoZW1lID0gc2lnXG4gIHZhbCBzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgOiBjb21wb25lbnQgLT4gc2FmZV9jaGFyc1xuICB2YWwgbm9ybWFsaXplX2hvc3QgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBjYW5vbmljYWxpemVfcG9ydCA6IGludCBvcHRpb24gLT4gaW50IG9wdGlvblxuICB2YWwgY2Fub25pY2FsaXplX3BhdGggOiBzdHJpbmcgbGlzdCAtPiBzdHJpbmcgbGlzdFxuZW5kXG5cbm1vZHVsZSBHZW5lcmljIDogU2NoZW1lID0gc3RydWN0XG4gIGxldCBzdWJfZGVsaW1zIGEgPVxuICAgIGxldCBzdWJkID0gXCIhJCYnKCkqKyw7PVwiIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3ViZCAtIDEgZG9cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIHN1YmQuW2ldIGluXG4gICAgICBhLihjKSA8LSB0cnVlXG4gICAgZG9uZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnMgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5Lm1ha2UgMjU2IGZhbHNlIGluXG4gICAgbGV0IGFsd2F5c19zYWZlID1cbiAgICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLi1+XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBhbHdheXNfc2FmZSAtIDEgZG9cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIGFsd2F5c19zYWZlLltpXSBpblxuICAgICAgYS4oYykgPC0gdHJ1ZVxuICAgIGRvbmU7XG4gICAgYVxuXG4gIGxldCBwY2hhciA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gc3ViX2RlbGltcyAoQXJyYXkuY29weSBzYWZlX2NoYXJzKSBpblxuICAgIGEuKENoYXIuY29kZSAnOicpIDwtIHRydWU7XG4gICAgYS4oQ2hhci5jb2RlICdAJykgPC0gdHJ1ZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3NjaGVtZSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzIGluXG4gICAgYS4oQ2hhci5jb2RlICcrJykgPC0gdHJ1ZTtcbiAgICBhXG5cbiAgKCoqIFNhZmUgY2hhcmFjdGVycyBmb3IgdGhlIHBhdGggY29tcG9uZW50IG9mIGEgVVJJICopXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9wYXRoIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBzdWJfZGVsaW1zIChBcnJheS5jb3B5IHBjaGFyKSBpblxuICAgICgqIGRlbGltaXRlcjogbm9uLXNlZ21lbnQgZGVsaW1pdGluZyB1c2VzIHNob3VsZCBiZSBwY3QgZW5jb2RlZCAqKVxuICAgIGEuKENoYXIuY29kZSAnLycpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnkgOiBzYWZlX2NoYXJzID1cbiAgICAoKiBUT0RPOiBXaGF0IGFib3V0IHtcIiFcIixcIiRcIixcIixcIn0/IFNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2F2c20vb2NhbWwtdXJpL2NvbW1pdC8xZWYzZjFkZmI0MWJkYjRmMzNmMjIzZmZlMTZlNjJhMzM5NzU2NjFhI2RpZmYtNzQwZjJkZTUzYzllYjM2ZTk2NzBkZGZiZGI5YmE5MTRSMTcxPiAqKVxuICAgIGxldCBhID0gQXJyYXkuY29weSBwY2hhciBpblxuICAgIGEuKENoYXIuY29kZSAnLycpIDwtIHRydWU7XG4gICAgYS4oQ2hhci5jb2RlICc/JykgPC0gdHJ1ZTtcbiAgICAoKiAnJicgaXMgc2FmZSBidXQgd2Ugc2hvdWxkIGVuY29kZSBsaXRlcmFscyB0byBhdm9pZCBhbWJpZ3VpdHlcbiAgICAgICB3aXRoIHRoZSBhbHJlYWR5IHBhcnNlZCBxcyBwYXJhbXMgKilcbiAgICBhLihDaGFyLmNvZGUgJyYnKSA8LSBmYWxzZTtcbiAgICAoKiAnOycgaXMgc2FmZSBidXQgc29tZSBzeXN0ZW1zIHRyZWF0IGl0IGxpa2UgJyYnLiAqKVxuICAgIGEuKENoYXIuY29kZSAnOycpIDwtIGZhbHNlO1xuICAgIGEuKENoYXIuY29kZSAnKycpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5IDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IGluXG4gICAgYS4oQ2hhci5jb2RlICc9JykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeV92YWx1ZSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzX2Zvcl9xdWVyeSBpblxuICAgIGEuKENoYXIuY29kZSAnLCcpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfZnJhZ21lbnQgOiBzYWZlX2NoYXJzID0gc2FmZV9jaGFyc19mb3JfcXVlcnlcblxuICAoKiogU2FmZSBjaGFyYWN0ZXJzIGZvciB0aGUgdXNlcmluZm8gc3ViY29tcG9uZW50IG9mIGEgVVJJLlxuICAgICAgVE9ETzogdGhpcyBuZWVkcyBtb3JlIHJlc2VydmVkIGNoYXJhY3RlcnMgYWRkZWQgKilcbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3VzZXJpbmZvIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnMgaW5cbiAgICAoKiBkZWxpbWl0ZXI6IG5vbi1zZWdtZW50IGRlbGltaXRpbmcgdXNlcyBzaG91bGQgYmUgcGN0IGVuY29kZWQgKilcbiAgICBhLihDaGFyLmNvZGUgJzonKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHJlYyBzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgPSBmdW5jdGlvblxuICAgIHwgYFBhdGggLT4gc2FmZV9jaGFyc19mb3JfcGF0aFxuICAgIHwgYFVzZXJpbmZvIC0+IHNhZmVfY2hhcnNfZm9yX3VzZXJpbmZvXG4gICAgfCBgUXVlcnkgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlcbiAgICB8IGBRdWVyeV9rZXkgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5XG4gICAgfCBgUXVlcnlfdmFsdWUgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWVcbiAgICB8IGBGcmFnbWVudCAtPiBzYWZlX2NoYXJzX2Zvcl9mcmFnbWVudFxuICAgIHwgYFNjaGVtZSAtPiBzYWZlX2NoYXJzX2Zvcl9zY2hlbWVcbiAgICB8IGBDdXN0b20gKChjb21wb25lbnQgOiBjb21wb25lbnQpLCBzYWZlLCB1bnNhZmUpIC0+XG4gICAgICAgbGV0IHNhZmVfY2hhcnMgPSBBcnJheS5jb3B5IChzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgY29tcG9uZW50KSBpblxuICAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHNhZmUgLSAxIGRvXG4gICAgICAgICBsZXQgYyA9IENoYXIuY29kZSBzYWZlLltpXSBpblxuICAgICAgICAgc2FmZV9jaGFycy4oYykgPC0gdHJ1ZVxuICAgICAgIGRvbmU7XG4gICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggdW5zYWZlIC0gMSBkb1xuICAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgdW5zYWZlLltpXSBpblxuICAgICAgICAgc2FmZV9jaGFycy4oYykgPC0gZmFsc2VcbiAgICAgICBkb25lO1xuICAgICAgIHNhZmVfY2hhcnNcbiAgICB8IGBHZW5lcmljXG4gICAgfCBfIC0+IHNhZmVfY2hhcnNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHNvID0gaHNvXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0IHBvcnQgPSBwb3J0XG4gIGxldCBjYW5vbmljYWxpemVfcGF0aCBwYXRoID0gcGF0aFxuZW5kXG5cbm1vZHVsZSBIdHRwIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCBocyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaHNcblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIDgwIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIHhcblxuICBsZXQgY2Fub25pY2FsaXplX3BhdGggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW1wiL1wiXVxuICAgIHwgeCAgLT4geFxuZW5kXG5cbm1vZHVsZSBIdHRwcyA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEh0dHBcblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIDQ0MyAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSB4XG5lbmRcblxubW9kdWxlIEZpbGUgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0IGhzID1cbiAgICBsZXQgaHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhzIGluXG4gICAgaWYgaHM9XCJsb2NhbGhvc3RcIiB0aGVuIFwiXCIgZWxzZSBoc1xuZW5kXG5cbm1vZHVsZSBVcm4gOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbmVuZFxuXG5sZXQgbW9kdWxlX29mX3NjaGVtZSA9IGZ1bmN0aW9uXG4gIHwgU29tZSBzIC0+IGJlZ2luIG1hdGNoIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyB3aXRoXG4gICAgICB8IFwiaHR0cFwiIC0+IChtb2R1bGUgSHR0cCA6IFNjaGVtZSlcbiAgICAgIHwgXCJodHRwc1wiICAtPiAobW9kdWxlIEh0dHBzIDogU2NoZW1lKVxuICAgICAgfCBcImZpbGVcIiAtPiAobW9kdWxlIEZpbGUgOiBTY2hlbWUpXG4gICAgICB8IFwidXJuXCIgIC0+IChtb2R1bGUgVXJuIDogU2NoZW1lKVxuICAgICAgfCBfIC0+IChtb2R1bGUgR2VuZXJpYyA6IFNjaGVtZSlcbiAgICBlbmRcbiAgfCBOb25lIC0+IChtb2R1bGUgR2VuZXJpYyA6IFNjaGVtZSlcblxuKCoqIFBvcnRpb25zIG9mIHRoZSBVUkwgbXVzdCBiZSBjb252ZXJ0ZWQgdG8tYW5kLWZyb20gcGVyY2VudC1lbmNvZGluZ1xuICAqIGFuZCB0aGlzIHJlYWxseSwgcmVhbGx5IHNob3VsZG4ndCBiZSBtaXhlZCB1cC4gU28gdGhpcyBQY3QgbW9kdWxlXG4gICogZGVmaW5lcyBhYnN0cmFjdCBQY3QuZW5jb2RlZCBhbmQgUGN0LmRlY29kZWQgdHlwZXMgd2hpY2ggc2V0cyB0aGVcbiAgKiBzdGF0ZSBvZiB0aGUgdW5kZXJseWluZyBzdHJpbmcuICBUaGVyZSBhcmUgZnVuY3Rpb25zIHRvIFwiY2FzdFwiIHRvXG4gICogYW5kIGZyb20gdGhlc2UgYW5kIG5vcm1hbCBzdHJpbmdzLCBhbmQgdGhpcyBwcm9tb3RlcyBhIGJpdCBvZlxuICAqIGludGVybmFsIHNhZmV0eS4gIFRoZXNlIHR5cGVzIGFyZSBub3QgZXhwb3NlZCB0byB0aGUgZXh0ZXJuYWxcbiAgKiBpbnRlcmZhY2UsIGFzIGNhc3RpbmcgdG8tYW5kLWZyb20gaXMgcXVpdGUgYSBiaXQgb2YgaGFzc2xlIGFuZFxuICAqIHByb2JhYmx5IG5vdCBhIGxvdCBvZiB1c2UgdG8gdGhlIGF2ZXJhZ2UgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5XG4qKVxubW9kdWxlIFBjdCA6IHNpZ1xuICB0eXBlIGVuY29kZWRcbiAgdHlwZSBkZWNvZGVkXG5cbiAgdmFsIGVuY29kZSA6ID9zY2hlbWU6c3RyaW5nIC0+ID9jb21wb25lbnQ6Y29tcG9uZW50IC0+IGRlY29kZWQgLT4gZW5jb2RlZFxuICB2YWwgZGVjb2RlIDogZW5jb2RlZCAtPiBkZWNvZGVkXG5cbiAgKCogVGhlIGVtcHR5IGRlY29kZWQgc3RyaW5nICopXG4gIHZhbCBlbXB0eV9kZWNvZGVkIDogZGVjb2RlZFxuICAoKiBJZGVudGl0eSBmdW5jdGlvbnMgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IGNhc3Qgd2hlbiB1c2luZyB0aGVtIGJlbG93ICopXG4gIHZhbCBjYXN0X2VuY29kZWQgOiBzdHJpbmcgLT4gZW5jb2RlZFxuICB2YWwgY2FzdF9kZWNvZGVkIDogc3RyaW5nIC0+IGRlY29kZWRcbiAgdmFsIHVuY2FzdF9lbmNvZGVkIDogZW5jb2RlZCAtPiBzdHJpbmdcbiAgdmFsIHVuY2FzdF9kZWNvZGVkIDogZGVjb2RlZCAtPiBzdHJpbmdcbiAgKCogTGlmdCBIT0ZzIGZvciBtYXBzIG92ZXIgZW5jb2RpbmdzLCBkZWNvZGluZ3MsIGFuZCBzdHJpbmdzICopXG4gIHZhbCBsaWZ0X2VuY29kZWQgOiAoZW5jb2RlZCAtPiBlbmNvZGVkKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBsaWZ0X2RlY29kZWQgOiAoZGVjb2RlZCAtPiBkZWNvZGVkKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCB1bmxpZnRfZW5jb2RlZCA6IChzdHJpbmcgLT4gc3RyaW5nKSAtPiBlbmNvZGVkIC0+IGVuY29kZWRcbiAgdmFsIHVubGlmdF9kZWNvZGVkIDogKHN0cmluZyAtPiBzdHJpbmcpIC0+IGRlY29kZWQgLT4gZGVjb2RlZFxuICB2YWwgdW5saWZ0X2RlY29kZWQyIDogKHN0cmluZyAtPiBzdHJpbmcgLT4gJ2EpIC0+IGRlY29kZWQgLT4gZGVjb2RlZCAtPiAnYVxuZW5kID0gc3RydWN0XG4gIHR5cGUgZW5jb2RlZCA9IHN0cmluZ1xuICB0eXBlIGRlY29kZWQgPSBzdHJpbmdcbiAgbGV0IGNhc3RfZW5jb2RlZCB4ID0geFxuICBsZXQgY2FzdF9kZWNvZGVkIHggPSB4XG4gIGxldCBlbXB0eV9kZWNvZGVkID0gXCJcIlxuICBsZXQgdW5jYXN0X2RlY29kZWQgeCA9IHhcbiAgbGV0IHVuY2FzdF9lbmNvZGVkIHggPSB4XG5cbiAgbGV0IGxpZnRfZW5jb2RlZCBmID0gZlxuICBsZXQgbGlmdF9kZWNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZW5jb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2RlY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9kZWNvZGVkMiBmID0gZlxuXG4gICgqKiBTY2FuIGZvciByZXNlcnZlZCBjaGFyYWN0ZXJzIGFuZCByZXBsYWNlIHRoZW0gd2l0aFxuICAgICAgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzLlxuICAgICAgQHJldHVybiBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IGVuY29kZSA/c2NoZW1lID8oY29tcG9uZW50PWBQYXRoKSBiID1cbiAgICBsZXQgbW9kdWxlIFNjaGVtZSA9ICh2YWwgKG1vZHVsZV9vZl9zY2hlbWUgc2NoZW1lKSA6IFNjaGVtZSkgaW5cbiAgICBsZXQgc2FmZV9jaGFycyA9IFNjaGVtZS5zYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgY29tcG9uZW50IGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggYiBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgc2NhbiBzdGFydCBjdXIgPVxuICAgICAgaWYgY3VyID49IGxlbiB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgYi5bY3VyXSBpblxuICAgICAgICBpZiBzYWZlX2NoYXJzLihjKSB0aGVuXG4gICAgICAgICAgc2NhbiBzdGFydCAoY3VyKzEpXG4gICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICBpZiBjdXIgPiBzdGFydCB0aGVuIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpO1xuICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUHJpbnRmLnNwcmludGYgXCIlJSUwMlhcIiBjKTtcbiAgICAgICAgICBzY2FuIChjdXIrMSkgKGN1cisxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGluXG4gICAgc2NhbiAwIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4gIGxldCBpbnRfb2ZfaGV4X2NoYXIgYyA9XG4gICAgbGV0IGMgPSBpbnRfb2ZfY2hhciAoQ2hhci51cHBlcmNhc2VfYXNjaWkgYykgLSA0OCBpblxuICAgIGlmIGMgPiA5XG4gICAgdGhlbiBpZiBjID4gMTYgJiYgYyA8IDIzXG4gICAgICB0aGVuIGMgLSA3XG4gICAgICBlbHNlIGZhaWx3aXRoIFwiaW50X29mX2hleF9jaGFyXCJcbiAgICBlbHNlIGlmIGMgPj0gMFxuICAgIHRoZW4gY1xuICAgIGVsc2UgZmFpbHdpdGggXCJpbnRfb2ZfaGV4X2NoYXJcIlxuXG4gICgqKiBTY2FuIGZvciBwZXJjZW50LWVuY29kaW5nIGFuZCBjb252ZXJ0IHRoZW0gaW50byBBU0NJSS5cbiAgICAgIEByZXR1cm4gYSBwZXJjZW50LWRlY29kZWQgc3RyaW5nICopXG4gIGxldCBkZWNvZGUgYiA9XG4gICAgKCogVE9ETzogU2hvdWxkIGJvdGggc3RyaWN0IGFuZCBub24tc3RyaWN0IHZlcnNpb25zIGJlIGV4cG9zZWQ/ICopXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggYiBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgc2NhbiBzdGFydCBjdXIgPVxuICAgICAgaWYgY3VyID49IGxlbiB0aGVuIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpXG4gICAgICBlbHNlIGlmIGIuW2N1cl0gPSAnJScgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgICAgbGV0IGN1ciA9IGN1ciArIDEgaW5cbiAgICAgICAgaWYgY3VyID49IGxlbiB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnXG4gICAgICAgIGVsc2UgbWF0Y2ggaW50X29mX2hleF9jaGFyIGIuW2N1cl0gd2l0aFxuICAgICAgICB8IGV4Y2VwdGlvbiBfIC0+XG4gICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgICAgICAgc2NhbiBjdXIgY3VyXG4gICAgICAgIHwgaGlnaGJpdHMgLT4gYmVnaW5cbiAgICAgICAgICBsZXQgY3VyID0gY3VyICsgMSBpblxuICAgICAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBiZWdpblxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGIuW2N1ci0xXVxuICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICBsZXQgc3RhcnRfYXQgPVxuICAgICAgICAgICAgICBtYXRjaCBpbnRfb2ZfaGV4X2NoYXIgYi5bY3VyXSB3aXRoXG4gICAgICAgICAgICAgIHwgbG93Yml0cyAtPlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgKENoYXIuY2hyIChoaWdoYml0cyBsc2wgNCArIGxvd2JpdHMpKTtcbiAgICAgICAgICAgICAgICBjdXIrMVxuICAgICAgICAgICAgICB8IGV4Y2VwdGlvbiBfIC0+XG4gICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBiLltjdXItMV07XG4gICAgICAgICAgICAgICAgY3VyXG4gICAgICAgICAgICBpbiBzY2FuIHN0YXJ0X2F0IHN0YXJ0X2F0XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2Ugc2NhbiBzdGFydCAoY3VyKzEpXG4gICAgaW5cbiAgICBzY2FuIDAgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5lbmRcblxuKCogUGVyY2VudCBlbmNvZGUgYSBzdHJpbmcgKilcbmxldCBwY3RfZW5jb2RlID9zY2hlbWUgPyhjb21wb25lbnQ9YFBhdGgpIHMgPVxuICBQY3QuKHVuY2FzdF9lbmNvZGVkIChlbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IChjYXN0X2RlY29kZWQgcykpKVxuXG5sZXQgcGN0X2VuY29kZXJcbiAgICAgID8oc2NoZW1lPWBTY2hlbWUpXG4gICAgICA/KHVzZXJpbmZvPWBVc2VyaW5mbylcbiAgICAgID8oaG9zdD1gSG9zdClcbiAgICAgID8ocGF0aD1gUGF0aClcbiAgICAgID8ocXVlcnlfa2V5PWBRdWVyeV9rZXkpXG4gICAgICA/KHF1ZXJ5X3ZhbHVlPWBRdWVyeV92YWx1ZSlcbiAgICAgID8oZnJhZ21lbnQ9YEZyYWdtZW50KVxuICAgICAgKCkgPVxuICB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBhdGg7IHF1ZXJ5X2tleTsgcXVlcnlfdmFsdWU7IGZyYWdtZW50IH1cblxuKCogUGVyY2VudCBkZWNvZGUgYSBzdHJpbmcgKilcbmxldCBwY3RfZGVjb2RlIHMgPSBQY3QuKHVuY2FzdF9kZWNvZGVkIChkZWNvZGUgKGNhc3RfZW5jb2RlZCBzKSkpXG5cbigqIFVzZXJpbmZvIHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYW4gaWQgKiBjcmVkZW50aWFsIHBhaXIgKilcbm1vZHVsZSBVc2VyaW5mbyA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgKiBzdHJpbmcgb3B0aW9uXG5cbiAgbGV0IGNvbXBhcmUgKHUscCkgKHUnLHAnKSA9XG4gICAgbWF0Y2ggU3RyaW5nLmNvbXBhcmUgdSB1JyB3aXRoXG4gICAgfCAwIC0+IGNvbXBhcmVfb3B0IFN0cmluZy5jb21wYXJlIHAgcCdcbiAgICB8IGMgLT4gY1xuXG4gIGxldCB1c2VyaW5mb19vZl9lbmNvZGVkIHVzID1cbiAgICBtYXRjaCBTdHJpbmdleHQuc3BsaXQgfm1heDoyIH5vbjonOicgdXMgd2l0aFxuICAgIHwgW10gLT4gKFwiXCIsTm9uZSlcbiAgICB8IFt1XSAtPiAocGN0X2RlY29kZSB1LE5vbmUpXG4gICAgfCB1OjpwOjpfIC0+IChwY3RfZGVjb2RlIHUsU29tZSAocGN0X2RlY29kZSBwKSlcblxuICBsZXQgZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQgKHUscG8pID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLihcbiAgICAgIDEgKyAobGVuZ3RoIHUpICsgKG1hdGNoIHBvIHdpdGggTm9uZSAtPiAwIHwgU29tZSBwIC0+IGxlbmd0aCBwKSlcbiAgICBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgdSk7XG4gICAgYmVnaW4gbWF0Y2ggcG8gd2l0aCBOb25lIC0+ICgpO1xuICAgIHwgU29tZSBwIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc6JztcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgcClcbiAgICBlbmQ7XG4gICAgUGN0LmNhc3RfZW5jb2RlZCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZilcbmVuZFxuXG5sZXQgdXNlcmluZm9fb2ZfZW5jb2RlZCA9IFVzZXJpbmZvLnVzZXJpbmZvX29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudCA9IFVzZXJpbmZvLmVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50XG5cbigqIFBhdGggc3RyaW5nIGhhbmRsaW5nLCB0byBhbmQgZnJvbSBhIGxpc3Qgb2YgcGF0aCB0b2tlbnMgKilcbm1vZHVsZSBQYXRoID0gc3RydWN0XG4gICgqIEludmFyaWFudDogZXZlcnkgZWxlbWVudCBpcyBub24temVybywgc2xhc2hlcyAoLykgb25seSBvY2N1ciBhbG9uZS4gKilcbiAgKCogWWVzLCBpdCdzIGJldHRlciB0aGlzIHdheS4gVGhpcyBtZWFucyB5b3UgY2FuIHJldGFpbiBzZXBhcmF0b3JcbiAgICAgY29udGV4dCBpbiByZWN1cnNpb24gKGUuZy4gcmVtb3ZlX2RvdF9zZWdtZW50cyBmb3IgcmVsYXRpdmUgcmVzb2x1dGlvbikuICopXG5cbiAgdHlwZSB0ID0gc3RyaW5nIGxpc3RcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVfbGlzdCBTdHJpbmcuY29tcGFyZVxuXG4gICgqIE1ha2UgYSBwYXRoIHRva2VuIGxpc3QgZnJvbSBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IHBhdGhfb2ZfZW5jb2RlZCBwcyA9XG4gICAgbGV0IHRva2wgPSBTdHJpbmdleHQuZnVsbF9zcGxpdCBwcyB+b246Jy8nIGluXG4gICAgTGlzdC5tYXAgcGN0X2RlY29kZSB0b2tsXG5cbiAgKCogU3Vicm91dGluZSBmb3IgcmVzb2x2ZSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40PiAqKVxuICBsZXQgcmVtb3ZlX2RvdF9zZWdtZW50cyBwID1cbiAgICBsZXQgcmV2cCA9IExpc3QucmV2IHAgaW5cbiAgICBsZXQgcmVjIGxvb3AgYXNjZW5zaW9uIG91dHAgPSBmdW5jdGlvblxuICAgICAgfCBcIi9cIjo6XCIuLlwiOjpyIHwgXCIuLlwiOjpyIC0+IGxvb3AgKGFzY2Vuc2lvbiArIDEpIG91dHAgclxuICAgICAgfCBcIi9cIjo6XCIuXCI6OnIgIHwgXCIuXCI6OnIgIC0+IGxvb3AgYXNjZW5zaW9uIG91dHAgclxuICAgICAgfCBcIi9cIjo6W10gfCBbXSB3aGVuIExpc3QuKGxlbmd0aCBwID4gMCAmJiBoZCBwID0gXCIvXCIpIC0+IFwiL1wiOjpvdXRwXG4gICAgICB8IFtdIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBMaXN0LnJldl9hcHBlbmRcbiAgICAgICAgKFwiL1wiOjoocmV2X2ludGVyamVjdCBcIi9cIiBBcnJheS4odG9fbGlzdCAobWFrZSBhc2NlbnNpb24gXCIuLlwiKSkpKSBvdXRwXG4gICAgICB8IFtdIC0+IExpc3QuKGlmIGxlbmd0aCBvdXRwID4gMCAmJiBoZCBvdXRwID0gXCIvXCIgdGhlbiB0bCBvdXRwIGVsc2Ugb3V0cClcbiAgICAgIHwgXCIvXCI6OlwiL1wiOjpyIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBsb29wIChhc2NlbnNpb24gLSAxKSBvdXRwIChcIi9cIjo6cilcbiAgICAgIHwgXCIvXCI6Ol86OnIgd2hlbiBhc2NlbnNpb24gPiAwIC0+IGxvb3AgKGFzY2Vuc2lvbiAtIDEpIG91dHAgclxuICAgICAgfCBzOjpyIC0+IGxvb3AgMCAoczo6b3V0cCkgclxuICAgIGluIGxvb3AgMCBbXSByZXZwXG5cbiAgbGV0IGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQgcCA9XG4gICAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYyB0b2sgLT4gU3RyaW5nLmxlbmd0aCB0b2sgKyBjKSAwIHAgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiAtPiBmdW5jdGlvblxuICAgIHwgXCIvXCIgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLydcbiAgICB8IHNlZyAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHNlZylcbiAgICApIFwiXCIgYnVmIHA7XG4gICAgUGN0LmNhc3RfZW5jb2RlZCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZilcblxuICAoKiBTdWJyb3V0aW5lIGZvciByZXNvbHZlIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjM+ICopXG4gIGxldCBtZXJnZSBiaG9zdCBicGF0aCByZWxwYXRoID1cbiAgICBtYXRjaCBiaG9zdCwgTGlzdC5yZXYgYnBhdGggd2l0aFxuICAgIHwgU29tZSBfLCBbXSAtPiBcIi9cIjo6cmVscGF0aFxuICAgIHwgXywgKFwiL1wiOjpyYnBhdGggfCBfOjpcIi9cIjo6cmJwYXRoKSAtPiBMaXN0LnJldl9hcHBlbmQgKFwiL1wiOjpyYnBhdGgpIHJlbHBhdGhcbiAgICB8IF8sIF8gLT4gcmVscGF0aFxuZW5kXG5cbmxldCBwYXRoX29mX2VuY29kZWQgPSBQYXRoLnBhdGhfb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQgPSBQYXRoLmVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnRcblxuKCogUXVlcnkgc3RyaW5nIGhhbmRsaW5nLCB0byBhbmQgZnJvbSBhbiBhc3NvYyBsaXN0IG9mIGtleS92YWx1ZXMgKilcbm1vZHVsZSBRdWVyeSA9IHN0cnVjdFxuXG4gIHR5cGUga3YgPSAoc3RyaW5nICogc3RyaW5nIGxpc3QpIGxpc3RcblxuICB0eXBlIHQgPVxuICAgIHwgS1Ygb2Yga3ZcbiAgICB8IFJhdyBvZiBzdHJpbmcgb3B0aW9uICoga3YgTGF6eS50XG5cbiAgbGV0IGNvbXBhcmUgeCB5ID0gbWF0Y2ggeCwgeSB3aXRoXG4gICAgfCBLViBrdmwsIEtWIGt2bCdcbiAgICB8IFJhdyAoXywgbGF6eSBrdmwpLCBLViBrdmwnXG4gICAgfCBLViBrdmwsIFJhdyAoXywgbGF6eSBrdmwnKSAtPlxuICAgICAgY29tcGFyZV9saXN0IChmdW4gKGssdmwpIChrJyx2bCcpIC0+XG4gICAgICAgIG1hdGNoIFN0cmluZy5jb21wYXJlIGsgaycgd2l0aFxuICAgICAgICB8IDAgLT4gY29tcGFyZV9saXN0IFN0cmluZy5jb21wYXJlIHZsIHZsJ1xuICAgICAgICB8IGMgLT4gY1xuICAgICAgKSBrdmwga3ZsJ1xuICAgIHwgUmF3IChyYXcsXyksIFJhdyAocmF3JyxfKSAtPiBjb21wYXJlX29wdCBTdHJpbmcuY29tcGFyZSByYXcgcmF3J1xuXG4gIGxldCBmaW5kIHEgayA9IHRyeSBTb21lIChMaXN0LmFzc29jIGsgcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG4gIGxldCBzcGxpdF9xdWVyeSBxcyA9XG4gICAgbGV0IGVscyA9IFN0cmluZ2V4dC5zcGxpdCB+b246JyYnIHFzIGluXG4gICAgKCogUmVwbGFjZSBhICsgaW4gYSBxdWVyeSBzdHJpbmcgd2l0aCBhIHNwYWNlIGluLXBsYWNlICopXG4gICAgbGV0IHBsdXNfdG9fc3BhY2UgcyA9XG4gICAgICBsZXQgcyA9IEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgcyBpblxuICAgICAgZm9yIGkgPSAwIHRvIEJ5dGVzLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBpZiBCeXRlcy5nZXQgcyBpID0gJysnIHRoZW4gQnl0ZXMuc2V0IHMgaSAnICdcbiAgICAgIGRvbmU7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgICAgfCAoazo6djo6Xyk6OnRsIC0+XG4gICAgICAgIGxldCBuID0gcGx1c190b19zcGFjZSBrLFxuICAgICAgICAgICAgICAgIChtYXRjaCBTdHJpbmdleHQuc3BsaXQgfm9uOicsJyAocGx1c190b19zcGFjZSB2KSB3aXRoXG4gICAgICAgICAgICAgICAgIHwgW10gLT4gW1wiXCJdIHwgbCAtPiBsKSBpblxuICAgICAgICBsb29wIChuOjphY2MpIHRsXG4gICAgICB8IFtrXTo6dGwgLT5cbiAgICAgICAgbGV0IG4gPSBwbHVzX3RvX3NwYWNlIGssIFtdIGluXG4gICAgICAgIGxvb3AgKG46OmFjYykgdGxcbiAgICAgIHwgW106OnRsIC0+IGxvb3AgKChcIlwiLCBbXSk6OmFjYykgdGxcbiAgICAgIHwgW10gLT4gYWNjXG4gICAgaW5cbiAgICBtYXRjaCBlbHMgd2l0aFxuICAgIHwgW10gIC0+IFtcIlwiLFtdXVxuICAgIHwgZWxzIC0+IGxvb3AgW11cbiAgICAgIChMaXN0LnJldl9tYXAgKGZ1biBlbCAtPiBTdHJpbmdleHQuc3BsaXQgfm9uOic9JyBlbCB+bWF4OjIpIGVscylcblxuICAoKiBNYWtlIGEgcXVlcnkgdHVwbGUgbGlzdCBmcm9tIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZyAqKVxuICBsZXQgcXVlcnlfb2ZfZW5jb2RlZCBxcyA9XG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW4gKGssIHYpIC0+IChwY3RfZGVjb2RlIGssIExpc3QubWFwIHBjdF9kZWNvZGUgdikpXG4gICAgICAoc3BsaXRfcXVlcnkgcXMpXG5cbiAgKCogQXNzZW1ibGUgYSBxdWVyeSBzdHJpbmcgc3VpdGFibGUgZm9yIHB1dHRpbmcgaW50byBhIFVSSS5cbiAgICogVHVwbGUgaW5wdXRzIGFyZSBwZXJjZW50IGRlY29kZWQgYW5kIHdpbGwgYmUgZW5jb2RlZCBieVxuICAgKiB0aGlzIGZ1bmN0aW9uLlxuICAqKVxuICBsZXQgZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIGwgPVxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGEgKGssdikgLT5cbiAgICAgICAgYSArIChTdHJpbmcubGVuZ3RoIGspXG4gICAgICAgICsgKExpc3QuZm9sZF9sZWZ0IChmdW4gYSBzIC0+IGErKFN0cmluZy5sZW5ndGggcykrMSkgMCB2KSArIDIpICgtMSkgbCBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGl0ZXJfY29uY2F0IChmdW4gYnVmIChrLHYpIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucXVlcnlfa2V5IGspO1xuICAgICAgICBpZiB2IDw+IFtdIHRoZW4gKFxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJz0nO1xuICAgICAgICAgIGl0ZXJfY29uY2F0IChmdW4gYnVmIHMgLT5cbiAgICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAgICAgICAgICAgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnF1ZXJ5X3ZhbHVlIHMpXG4gICAgICAgICAgICApIFwiLFwiIGJ1ZiB2KVxuICAgICAgKSBcIiZcIiBidWYgbDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgbGV0IG9mX3JhdyBxcyA9XG4gICAgbGV0IGxhenlfcXVlcnkgPSBMYXp5LmZyb21fZnVuIChmdW4gKCkgLT4gcXVlcnlfb2ZfZW5jb2RlZCBxcykgaW5cbiAgICBSYXcgKFNvbWUgcXMsIGxhenlfcXVlcnkpXG5cbiAgbGV0IGt2ID0gZnVuY3Rpb24gUmF3IChfLCBsYXp5IGt2KSB8IEtWIGt2IC0+IGt2XG5lbmRcblxubGV0IHF1ZXJ5X29mX2VuY29kZWQgPSBRdWVyeS5xdWVyeV9vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lID0gUXVlcnkuZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lXG5cbigqIFR5cGUgb2YgdGhlIFVSSSwgd2l0aCBtb3N0IGJpdHMgYmVpbmcgb3B0aW9uYWwgKilcbnR5cGUgdCA9IHtcbiAgc2NoZW1lOiBQY3QuZGVjb2RlZCBvcHRpb247XG4gIHVzZXJpbmZvOiBVc2VyaW5mby50IG9wdGlvbjtcbiAgaG9zdDogWyBgSXB2NF9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICB8IGBJcHY2X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgIHwgYEhvc3Qgb2YgUGN0LmRlY29kZWRdIG9wdGlvbiA7XG4gIHBvcnQ6IGludCBvcHRpb247XG4gIHBhdGg6IFBhdGgudDtcbiAgcXVlcnk6IFF1ZXJ5LnQ7XG4gIGZyYWdtZW50OiBQY3QuZGVjb2RlZCBvcHRpb247XG59XG5cbmxldCBlbXB0eSA9IHtcbiAgc2NoZW1lID0gTm9uZTtcbiAgdXNlcmluZm8gPSBOb25lO1xuICBob3N0ID0gTm9uZTtcbiAgcG9ydCA9IE5vbmU7XG4gIHBhdGggPSBbXTtcbiAgcXVlcnkgPSBRdWVyeS5SYXcgKE5vbmUsIExhenkuZnJvbV92YWwgW10pO1xuICBmcmFnbWVudCA9IE5vbmU7XG59XG5cbmxldCBjb21wYXJlX2RlY29kZWQgPSBQY3QudW5saWZ0X2RlY29kZWQyIFN0cmluZy5jb21wYXJlXG5sZXQgY29tcGFyZV9kZWNvZGVkX29wdCA9IGNvbXBhcmVfb3B0IGNvbXBhcmVfZGVjb2RlZFxubGV0IGNvbXBhcmVfaG9zdCBoMSBoMiA9XG4gIG1hdGNoIGgxLCBoMiB3aXRoXG4gIHwgYElwdjRfbGl0ZXJhbCBpcDEsIGBJcHY0X2xpdGVyYWwgaXAyIC0+IFN0cmluZy5jb21wYXJlIGlwMSBpcDJcbiAgfCBgSXB2Nl9saXRlcmFsIGlwMSwgYElwdjZfbGl0ZXJhbCBpcDIgLT4gU3RyaW5nLmNvbXBhcmUgaXAxIGlwMlxuICB8IGBIb3N0IGgxLCBgSG9zdCBoMiAtPiBjb21wYXJlX2RlY29kZWQgaDEgaDJcbiAgfCBfIC0+IC0xXG5sZXQgY29tcGFyZV9ob3N0X29wdCA9IGNvbXBhcmVfb3B0IGNvbXBhcmVfaG9zdFxuXG5sZXQgY29tcGFyZSB0IHQnID1cbiAgKG1hdGNoIGNvbXBhcmVfaG9zdF9vcHQgdC5ob3N0IHQnLmhvc3Qgd2l0aFxuICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5zY2hlbWUgdCcuc2NoZW1lIHdpdGhcbiAgICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfb3B0IChmdW4gcCBwJyAtPlxuICAgICAgaWYgcCA8IHAnIHRoZW4gLTEgZWxzZSBpZiBwID4gcCcgdGhlbiAxIGVsc2UgMFxuICAgICkgdC5wb3J0IHQnLnBvcnQgd2l0aFxuICAgICAgfCAwIC0+IChtYXRjaCBjb21wYXJlX29wdCBVc2VyaW5mby5jb21wYXJlIHQudXNlcmluZm8gdCcudXNlcmluZm8gd2l0aFxuICAgICAgICB8IDAgLT4gKG1hdGNoIFBhdGguY29tcGFyZSB0LnBhdGggdCcucGF0aCB3aXRoXG4gICAgICAgICAgfCAwIC0+IChtYXRjaCBRdWVyeS5jb21wYXJlIHQucXVlcnkgdCcucXVlcnkgd2l0aFxuICAgICAgICAgICAgfCAwIC0+IGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5mcmFnbWVudCB0Jy5mcmFnbWVudFxuICAgICAgICAgICAgfCBjIC0+IGMpXG4gICAgICAgICAgfCBjIC0+IGMpXG4gICAgICAgIHwgYyAtPiBjKVxuICAgICAgfCBjIC0+IGMpXG4gICAgfCBjIC0+IGMpXG4gIHwgYyAtPiBjKVxuXG5sZXQgZXF1YWwgdCB0JyA9IGNvbXBhcmUgdCB0JyA9IDBcblxubGV0IHVuY2FzdF9vcHQgPSBmdW5jdGlvblxuICB8IFNvbWUgaCAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgaClcbiAgfCBOb25lIC0+IE5vbmVcblxubGV0IG5vcm1hbGl6ZSBzY2hlbSB1cmkgPVxuICBsZXQgbW9kdWxlIFNjaGVtZSA9XG4gICAgKHZhbCAobW9kdWxlX29mX3NjaGVtZSAodW5jYXN0X29wdCBzY2hlbSkpIDogU2NoZW1lKSBpblxuICBsZXQgZG9iIGYgPSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+IFNvbWUgKFBjdC51bmxpZnRfZGVjb2RlZCBmIHgpXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgaW4ge3VyaSB3aXRoXG4gICAgICBzY2hlbWU9ZG9iIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgdXJpLnNjaGVtZTtcbiAgICAgIGhvc3Q9IG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgICAgICB8IFNvbWUgKGBJcHY0X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIFNvbWUgKGBJcHY0X2xpdGVyYWwgKFNjaGVtZS5ub3JtYWxpemVfaG9zdCBob3N0KSlcbiAgICAgICB8IFNvbWUgKGBJcHY2X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIFNvbWUgKGBJcHY2X2xpdGVyYWwgKFNjaGVtZS5ub3JtYWxpemVfaG9zdCBob3N0KSlcbiAgICAgICB8IFNvbWUgKGBIb3N0IGhvc3QpIC0+XG4gICAgICAgICBTb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0IChQY3QudW5jYXN0X2RlY29kZWQgaG9zdCkpKSlcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICB9XG5cbigqKiBDb252ZXJ0IGEgVVJJIHN0cnVjdHVyZSBpbnRvIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZ1xuICAgIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4zPlxuKilcbmxldCB0b19zdHJpbmcgPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID1cbiAgbGV0IHNjaGVtZSA9IG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgIHwgU29tZSBzIC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCBzKVxuICAgIHwgTm9uZSAtPiBOb25lIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDEyOCBpblxuICAoKiBQZXJjZW50IGVuY29kZSBhIGRlY29kZWQgc3RyaW5nIGFuZCBhZGQgaXQgdG8gdGhlIGJ1ZmZlciAqKVxuICBsZXQgYWRkX3BjdF9zdHJpbmcgPyhjb21wb25lbnQ9YFBhdGgpIHggPVxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUGN0LnVuY2FzdF9lbmNvZGVkIChQY3QuZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCB4KSlcbiAgaW5cbiAgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgfE5vbmUgLT4gKClcbiAgIHxTb21lIHggLT5cbiAgICAgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5zY2hlbWUgeDtcbiAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOidcbiAgKTtcbiAgKCogVVJJIGhhcyBhIGhvc3QgaWYgYW55IGhvc3QtcmVsYXRlZCBjb21wb25lbnQgaXMgc2V0LiBEZWZhdWx0cyB0byBcIlwiLiAqKVxuICBpZiAobWF0Y2ggdXJpLnVzZXJpbmZvLCB1cmkuaG9zdCwgdXJpLnBvcnQgd2l0aFxuICB8IFNvbWUgXywgXywgXyB8IF8sIFNvbWUgXywgXyB8IF8sIF8sIFNvbWUgXyAtPiB0cnVlIHwgXyAtPiBmYWxzZSlcbiAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIvL1wiO1xuICAobWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgdXNlcmluZm8gLT5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWZcbiAgICAgIChQY3QudW5jYXN0X2VuY29kZWQgKGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvKSk7XG4gICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnQCdcbiAgKTtcbiAgKG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgKGBIb3N0IGhvc3QpIC0+XG4gICAgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5ob3N0IGhvc3Q7XG4gIHxTb21lIChgSXB2NF9saXRlcmFsIGhvc3QpIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBob3N0XG4gIHxTb21lIChgSXB2Nl9saXRlcmFsIGhvc3QpIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdbJztcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBob3N0O1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXSdcbiAgKTtcbiAgKG1hdGNoIHVyaS5wb3J0IHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgcG9ydCAtPlxuICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCBwb3J0KVxuICApO1xuICAobWF0Y2ggdXJpLnBhdGggd2l0aCAoKiBIYW5kbGUgcmVsYXRpdmUgcGF0aHMgY29ycmVjdGx5ICopXG4gIHwgW10gLT4gKClcbiAgfCBcIi9cIjo6XyAtPlxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUGN0LnVuY2FzdF9lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKSlcbiAgfCBmaXJzdF9zZWdtZW50OjpfIC0+XG4gICAgKG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgICAgfCBTb21lIF8gLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLydcbiAgICAgfCBOb25lIC0+XG4gICAgICAgKCogZW5zdXJlIHJvdW5kdHJpcCBieSBmb3JjaW5nIHJlbGF0aXZlIHBhdGggaW50ZXJwcmV0YXRpb24gbm90IHNjaGVtZSAqKVxuICAgICAgIG1hdGNoIFN0cmluZ2V4dC5maW5kX2Zyb20gZmlyc3Rfc2VnbWVudCB+cGF0dGVybjpcIjpcIiB3aXRoXG4gICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgfCBTb21lIF8gLT4gbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgICB8IE5vbmUgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiLi9cIlxuICAgICk7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAoUGN0LnVuY2FzdF9lbmNvZGVkIChlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpKVxuICApO1xuICBRdWVyeS4obWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgICB8IFJhdyAoTm9uZSxfKSB8IEtWIFtdIC0+ICgpXG4gICAgfCBSYXcgKF8sbGF6eSBxKSB8IEtWIHEgLT4gKCogbm9ybWFsaXplIGUuZy4gcGVyY2VudCBjYXBpdGFsaXphdGlvbiAqKVxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSB+cGN0X2VuY29kZXIgcSlcbiAgKTtcbiAgKG1hdGNoIHVyaS5mcmFnbWVudCB3aXRoXG4gICB8Tm9uZSAtPiAoKVxuICAgfFNvbWUgZiAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcjJzsgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5mcmFnbWVudCBmXG4gICk7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxuKCogVmFyaW91cyBhY2Nlc3NvciBmdW5jdGlvbnMsIGFzIHRoZSBleHRlcm5hbCB1cmkgdHlwZSBpcyBhYnN0cmFjdCAgKilcbmxldCBnZXRfZGVjb2RlZF9vcHQgPSBmdW5jdGlvbiBOb25lIC0+IE5vbmUgfFNvbWUgeCAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgeClcbmxldCBzY2hlbWUgdXJpID0gZ2V0X2RlY29kZWRfb3B0IHVyaS5zY2hlbWVcbmxldCB3aXRoX3NjaGVtZSB1cmkgPVxuICBmdW5jdGlvblxuICB8U29tZSBzY2hlbWUgLT4geyB1cmkgd2l0aCBzY2hlbWU9U29tZSAoUGN0LmNhc3RfZGVjb2RlZCBzY2hlbWUpIH1cbiAgfE5vbmUgLT4geyB1cmkgd2l0aCBzY2hlbWU9Tm9uZSB9XG5cbmxldCBob3N0IHVyaSA9XG4gIG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChgSXB2NF9saXRlcmFsIGggfCBgSXB2Nl9saXRlcmFsIGgpIC0+IFNvbWUgaFxuICB8IFNvbWUgKGBIb3N0IGgpIC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCBoKVxuXG5sZXQgaG9zdF93aXRoX2RlZmF1bHQgPyhkZWZhdWx0PVwibG9jYWxob3N0XCIpIHVyaSA9XG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfE5vbmUgLT4gZGVmYXVsdFxuICB8U29tZSBoIC0+IGhcblxubGV0IHVzZXJpbmZvID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB1c2VyaW5mbyAtPiBTb21lIChQY3QudW5jYXN0X2VuY29kZWQgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgIHwgTm9uZSAtPiBlbmNvZGVkX29mX3VzZXJpbmZvIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm9cbiAgICB8IFNvbWUgcyAtPiBlbmNvZGVkX29mX3VzZXJpbmZvIH5zY2hlbWU6KFBjdC51bmNhc3RfZGVjb2RlZCBzKSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvKSlcbmxldCB3aXRoX3VzZXJpbmZvIHVyaSB1c2VyaW5mbyA9XG4gIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgaW5cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpKTsgdXNlcmluZm89dXNlcmluZm8gfVxuICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIHVzZXJpbmZvPXVzZXJpbmZvIH1cblxubGV0IHVzZXIgdXJpID0gbWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lICh1c2VyLCBfKSAtPiBTb21lIHVzZXJcblxubGV0IHBhc3N3b3JkIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSB8IFNvbWUgKF8sIE5vbmUpIC0+IE5vbmVcbiAgfCBTb21lIChfLCBTb21lIHBhc3MpIC0+IFNvbWUgcGFzc1xubGV0IHdpdGhfcGFzc3dvcmQgdXJpIHBhc3N3b3JkID1cbiAgbGV0IHJlc3VsdCB1c2VyaW5mbyA9IG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpKTsgdXNlcmluZm89dXNlcmluZm8gfVxuICAgIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggdXNlcmluZm89dXNlcmluZm8gfVxuICBpblxuICBtYXRjaCB1cmkudXNlcmluZm8sIHBhc3N3b3JkIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHVyaVxuICB8IE5vbmUsIFNvbWUgXyAtPiByZXN1bHQgKFNvbWUgKFwiXCIscGFzc3dvcmQpKVxuICB8IFNvbWUgKHVzZXIsXyksIF8gLT4gcmVzdWx0IChTb21lICh1c2VyLCBwYXNzd29yZCkpXG5cbmxldCBwb3J0IHVyaSA9IHVyaS5wb3J0XG5sZXQgd2l0aF9wb3J0IHVyaSBwb3J0ID1cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIHBvcnQ9cG9ydCB9XG4gIHwgTm9uZSAtPiBiZWdpblxuICAgICBtYXRjaCBwb3J0IHdpdGhcbiAgICAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Ob25lOyBwb3J0PU5vbmUgfVxuICAgICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIGhvc3Q9U29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgXCJcIikpOyBwb3J0PXBvcnQgfVxuICBlbmRcblxuKCogUmV0dXJuIHRoZSBwYXRoIGNvbXBvbmVudCAqKVxubGV0IHBhdGggPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gUGN0LnVuY2FzdF9lbmNvZGVkIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgfCBOb25lIC0+IGVuY29kZWRfb2ZfcGF0aCB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGhcbiAgfCBTb21lIHMgLT4gZW5jb2RlZF9vZl9wYXRoIH5zY2hlbWU6KFBjdC51bmNhc3RfZGVjb2RlZCBzKSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpXG5sZXQgd2l0aF9wYXRoIHVyaSBwYXRoID1cbiAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcGF0aCBpblxuICBtYXRjaCBob3N0IHVyaSwgcGF0aCB3aXRoXG4gIHwgTm9uZSwgXyB8IFNvbWUgXywgXCIvXCI6Ol8gfCBTb21lIF8sIFtdIC0+IHsgdXJpIHdpdGggcGF0aD1wYXRoIH1cbiAgfCBTb21lIF8sIF8gIC0+IHsgdXJpIHdpdGggcGF0aD1cIi9cIjo6cGF0aCB9XG5cbmxldCBmcmFnbWVudCB1cmkgPSBnZXRfZGVjb2RlZF9vcHQgdXJpLmZyYWdtZW50XG5sZXQgd2l0aF9mcmFnbWVudCB1cmkgPVxuICBmdW5jdGlvblxuICB8Tm9uZSAtPiB7IHVyaSB3aXRoIGZyYWdtZW50PU5vbmUgfVxuICB8U29tZSBmcmFnIC0+IHsgdXJpIHdpdGggZnJhZ21lbnQ9U29tZSAoUGN0LmNhc3RfZGVjb2RlZCBmcmFnKSB9XG5cbmxldCBxdWVyeSB1cmkgPSBRdWVyeS5rdiB1cmkucXVlcnlcbmxldCB2ZXJiYXRpbV9xdWVyeSA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBRdWVyeS4obWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgfCBSYXcgKHFzLF8pIC0+IHFzXG4gIHwgS1YgW10gLT4gTm9uZVxuICB8IEtWIGt2IC0+IFNvbWUgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZTooc2NoZW1lIHVyaSkgfnBjdF9lbmNvZGVyIGt2KVxuKVxubGV0IGdldF9xdWVyeV9wYXJhbScgdXJpIGsgPSBRdWVyeS4oZmluZCAoa3YgdXJpLnF1ZXJ5KSBrKVxubGV0IGdldF9xdWVyeV9wYXJhbSB1cmkgayA9XG4gIG1hdGNoIGdldF9xdWVyeV9wYXJhbScgdXJpIGsgd2l0aFxuICB8Tm9uZSAtPiBOb25lXG4gIHxTb21lIHYgLT4gU29tZSAoU3RyaW5nLmNvbmNhdCBcIixcIiB2KVxuXG5sZXQgd2l0aF9xdWVyeSB1cmkgcXVlcnkgPSB7IHVyaSB3aXRoIHF1ZXJ5PVF1ZXJ5LktWIHF1ZXJ5IH1cbmxldCBxX3MgcSA9IExpc3QubWFwIChmdW4gKGssdikgLT4gayxbdl0pIHFcbmxldCB3aXRoX3F1ZXJ5JyB1cmkgcXVlcnkgPSB3aXRoX3F1ZXJ5IHVyaSAocV9zIHF1ZXJ5KVxubGV0IGFkZF9xdWVyeV9wYXJhbSB1cmkgcCA9IFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWIChwOjooa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW0nIHVyaSAoayx2KSA9XG4gIFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWICgoayxbdl0pOjooa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW1zIHVyaSBwcyA9IFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWIChwc0Aoa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW1zJyB1cmkgcHMgPVxuICBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAoKHFfcyBwcylAKGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgcmVtb3ZlX3F1ZXJ5X3BhcmFtIHVyaSBrID0gUXVlcnkuKFxuICB7IHVyaSB3aXRoIHF1ZXJ5PUtWIChMaXN0LmZpbHRlciAoZnVuIChrJyxfKSAtPiBrPD5rJykgKGt2IHVyaS5xdWVyeSkpIH1cbilcblxuKCogQ29uc3RydWN0IGVuY29kZWQgcGF0aCBhbmQgcXVlcnkgY29tcG9uZW50cyAqKVxubGV0IHBhdGhfYW5kX3F1ZXJ5IHVyaSA9XG4gIG1hdGNoIChwYXRoIHVyaSksIChxdWVyeSB1cmkpIHdpdGhcbiAgfFwiXCIsIFtdIC0+IFwiL1wiICgqIFRPRE86IFdoYXQgYWJvdXQgc2FtZSBkb2N1bWVudD8gKC8pICopXG4gIHxcIlwiLCBxIC0+ICgqIFRPRE86IFdoYXQgYWJvdXQgc2FtZSBkb2N1bWVudD8gKC8pICopXG4gICAgbGV0IHNjaGVtZSA9IHVuY2FzdF9vcHQgdXJpLnNjaGVtZSBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiLz8lc1wiIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgcSlcbiAgfHAsIFtdIC0+IHBcbiAgfHAsIHEgLT5cbiAgICBsZXQgc2NoZW1lID0gdW5jYXN0X29wdCB1cmkuc2NoZW1lIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIlcz8lc1wiIHAgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSBxKVxuXG4oKiBUT0RPOiBmdW5jdGlvbnMgdG8gYWRkIGFuZCByZW1vdmUgZnJvbSBhIFVSSSAqKVxuXG4oKiBSZXNvbHZlIGEgVVJJIHdydCBhIGJhc2UgVVJJIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yPiAqKVxubGV0IHJlc29sdmUgc2NoZW0gYmFzZSB1cmkgPVxuICBsZXQgc2NoZW0gPSBTb21lIChQY3QuY2FzdF9kZWNvZGVkIChtYXRjaCBzY2hlbWUgYmFzZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gIHNjaGVtXG4gICAgICB8IFNvbWUgc2NoZW1lIC0+IHNjaGVtZVxuICAgICkpIGluXG4gIG5vcm1hbGl6ZSBzY2hlbVxuICAgIFBhdGguKG1hdGNoIHNjaGVtZSB1cmksIHVzZXJpbmZvIHVyaSwgaG9zdCB1cmkgd2l0aFxuICAgIHwgU29tZSBfLCBfLCBfIC0+XG4gICAgICB7dXJpIHdpdGggcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgIHwgTm9uZSwgU29tZSBfLCBfXG4gICAgfCBOb25lLCBfLCBTb21lIF8gLT5cbiAgICAgIHt1cmkgd2l0aCBzY2hlbWU9YmFzZS5zY2hlbWU7IHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICB8IE5vbmUsIE5vbmUsIE5vbmUgLT5cbiAgICAgIGxldCB1cmkgPSB7dXJpIHdpdGggc2NoZW1lPWJhc2Uuc2NoZW1lOyB1c2VyaW5mbz1iYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0PWJhc2UuaG9zdDsgcG9ydD1iYXNlLnBvcnR9IGluXG4gICAgICBsZXQgcGF0aF9zdHIgPSBwYXRoIHVyaSBpblxuICAgICAgaWYgcGF0aF9zdHI9XCJcIlxuICAgICAgdGhlbiB7IHVyaSB3aXRoXG4gICAgICAgICAgICAgcGF0aD1iYXNlLnBhdGg7XG4gICAgICAgICAgICAgcXVlcnk9bWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgICAgICAgICAgICAgIHwgUXVlcnkuUmF3IChOb25lLF8pIHwgUXVlcnkuS1YgW10gLT4gYmFzZS5xdWVyeVxuICAgICAgICAgICAgICAgfCBfIC0+IHVyaS5xdWVyeVxuICAgICAgICAgICB9XG4gICAgICBlbHNlIGlmIHBhdGhfc3RyLlswXT0nLydcbiAgICAgIHRoZW4ge3VyaSB3aXRoIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICAgIGVsc2Uge3VyaSB3aXRoXG4gICAgICAgIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyAobWVyZ2UgYmFzZS5ob3N0IGJhc2UucGF0aCB1cmkucGF0aCk7XG4gICAgICB9XG4gICAgKVxuXG5sZXQgY2Fub25pY2FsaXplIHVyaSA9XG4gIGxldCB1cmkgPSByZXNvbHZlIFwiXCIgZW1wdHkgdXJpIGluXG4gIGxldCBtb2R1bGUgU2NoZW1lID1cbiAgICAodmFsIChtb2R1bGVfb2Zfc2NoZW1lICh1bmNhc3Rfb3B0IHVyaS5zY2hlbWUpKSA6IFNjaGVtZSkgaW5cbiAgeyB1cmkgd2l0aFxuICAgIHBvcnQ9U2NoZW1lLmNhbm9uaWNhbGl6ZV9wb3J0IHVyaS5wb3J0O1xuICAgIHBhdGg9U2NoZW1lLmNhbm9uaWNhbGl6ZV9wYXRoIHVyaS5wYXRoO1xuICB9XG5cbmxldCBwcCBwcGYgdXJpID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZyB1cmkpXG5sZXQgcHBfaHVtIHBwZiB1cmkgPSBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nIHVyaSlcblxubW9kdWxlIFBhcnNlciA9IHN0cnVjdFxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgbGV0IHN0cmluZ19vZl9jaGFyID0gU3RyaW5nLm1ha2UgMVxuXG4gIGxldCBzdHJpbmdfb2ZfY2hhcl9saXN0IGNoYXJzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIHN0cmluZ19vZl9jaGFyIGNoYXJzKVxuXG4gIGxldCBzY2hlbWUgPVxuICAgIGxpZnRcbiAgICAgIChmdW4gcyAtPiBTb21lIChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgICh0YWtlX3doaWxlIChmdW4gYyAtPiBjIDw+ICc6JyAmJiBjIDw+ICcvJyAmJiBjIDw+ICc/JyAmJiBjIDw+ICcjJylcbiAgICAgIDwqIGNoYXIgJzonKVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBpc19kaWdpdCA9IGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICBsZXQgaGV4X2RpZ2l0ID1cbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IGhleGFkZWNpbWFsID0gbGlmdCBzdHJpbmdfb2ZfY2hhcl9saXN0IChtYW55IGhleF9kaWdpdClcblxuICBsZXQgY19kb3QgPSBjaGFyICcuJ1xuXG4gIGxldCBjX2F0ID0gY2hhciAnQCdcblxuICBsZXQgY19jb2xvbiA9IGNoYXIgJzonXG5cbiAgbGV0IGRlY19vY3RldCA9XG4gICAgdGFrZV93aGlsZTEgKGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpID4+PSBmdW4gbnVtIC0+XG4gICAgaWYgaW50X29mX3N0cmluZyBudW0gPCAyNTYgdGhlblxuICAgICAgcmV0dXJuIG51bVxuICAgIGVsc2VcbiAgICAgIGZhaWwgXCJpbnZhbGlkIG9jdGVjdFwiXG5cbiAgbGV0IGlwdjRfYWRkcmVzcyA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4gdGhyZWUgb25lIC0+IFN0cmluZy5jb25jYXQgXCIuXCIgdGhyZWUgXiBcIi5cIiBeIG9uZSlcbiAgICAgIChjb3VudCAzIChkZWNfb2N0ZXQgPCogY19kb3QpKVxuICAgICAgZGVjX29jdGV0XG5cbiAgKCogLS0gYWZ0ZXIgZG91YmxlIGNvbG9uLCBJUHY0IGRvdHRlZCBub3RhdGlvbiBjb3VsZCBhcHBlYXIgYW55d2hlcmUgKilcbiAgbGV0IGFmdGVyX2RvdWJsZV9jb2xvbiA9XG4gICAgZml4IChmdW4gZiAtPlxuICAgICAgICBsaXN0IFsgaXB2NF9hZGRyZXNzIF1cbiAgICAgICAgPHw+IGxpZnQyIChmdW4geCB5IC0+IHggOjogeSkgaGV4YWRlY2ltYWwgKGNfY29sb24gKj4gZiA8fD4gcmV0dXJuIFtdKSlcblxuICBsZXQgZG91YmxlX2NvbG9uIGNvdW50ID1cbiAgICBhZnRlcl9kb3VibGVfY29sb24gPj49IChmdW4gcmVzdCAtPlxuICAgIGxldCBmaWxsZXJfbGVuZ3RoID0gOCAtIGNvdW50IC0gTGlzdC5sZW5ndGggcmVzdCBpblxuICAgIGlmIGZpbGxlcl9sZW5ndGggPD0gMCB0aGVuXG4gICAgICBmYWlsIFwidG9vIG1hbnkgcGFydHMgaW4gSVB2NiBhZGRyZXNzXCJcbiAgICBlbHNlXG4gICAgICByZXR1cm4gKFwiXCIgOjogcmVzdCkpXG4gICAgPHw+IHJldHVybiBbXCJcIl1cblxuICBsZXQgcmVjIHBhcnQgPSBmdW5jdGlvblxuICAgIHwgNyAtPlxuICAgICAgKCogbWF4IDggcGFydHMgaW4gYW4gSVB2NiBhZGRyZXNzICopXG4gICAgICBsaWZ0IChmdW4geCAtPiBbIHggXSkgaGV4YWRlY2ltYWxcbiAgICB8IDYgLT5cbiAgICAgICgqIGFmdGVyIDYgcGFydHMgaXQgY291bGQgZW5kIGluIElQdjQgZG90dGVkIG5vdGF0aW9uICopXG4gICAgICBsaXN0IFsgaXB2NF9hZGRyZXNzIF0gPHw+IGhleF9wYXJ0IDZcbiAgICB8IG4gLT5cbiAgICAgIGhleF9wYXJ0IG5cblxuICBhbmQgaGV4X3BhcnQgbiA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4geCB5IC0+IHggOjogeSlcbiAgICAgIGhleGFkZWNpbWFsXG4gICAgICAoY19jb2xvbiAqPiAoY19jb2xvbiAqPiBkb3VibGVfY29sb24gKG4gKyAxKSA8fD4gcGFydCAobiArIDEpKSlcblxuICBsZXQgcmVjIHNwbGl0X3dpdGggZiB4cyA9XG4gICAgbWF0Y2ggeHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIFtdLCBbXVxuICAgIHwgeSA6OiB5cyAtPlxuICAgICAgaWYgZiB5IHRoZW5cbiAgICAgICAgbGV0IHpzLCB0cyA9IHNwbGl0X3dpdGggZiB5cyBpblxuICAgICAgICB5IDo6IHpzLCB0c1xuICAgICAgZWxzZVxuICAgICAgICBbXSwgeHNcblxuICBsZXQgaXB2NiA9XG4gICAgbGV0IGZvcm1hdF9hZGRyIHNlZ21lbnRzID1cbiAgICAgIGxldCBiZWZvcmVfZG91YmxlX2NvbG9uLCBhZnRlcl9kb3VibGVfY29sb24gPVxuICAgICAgICBzcGxpdF93aXRoIChmdW4gc2VnbWVudCAtPiBzZWdtZW50IDw+IFwiXCIpIHNlZ21lbnRzXG4gICAgICBpblxuICAgICAgbGV0IGJlZm9yZSA9IFN0cmluZy5jb25jYXQgXCI6XCIgYmVmb3JlX2RvdWJsZV9jb2xvbiBpblxuICAgICAgbGV0IHJlcyA9XG4gICAgICAgIG1hdGNoIGFmdGVyX2RvdWJsZV9jb2xvbiB3aXRoXG4gICAgICAgIHwgXCJcIiA6OiB4cyAtPlxuICAgICAgICAgIGJlZm9yZSBeIFwiOjpcIiBeIFN0cmluZy5jb25jYXQgXCI6XCIgeHNcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgYmVmb3JlXG4gICAgICBpblxuICAgICAgcmVzXG4gICAgaW5cbiAgICBsaWZ0IGZvcm1hdF9hZGRyIChjX2NvbG9uICo+IGNfY29sb24gKj4gZG91YmxlX2NvbG9uIDAgPHw+IHBhcnQgMClcblxuICBsZXQgaXB2Nl9hZGRyZXNzID1cbiAgICAoY2hhciAnWycpICo+IGlwdjYgPCogKGNoYXIgJ10nKVxuXG4gIGxldCBwY3RfZW5jb2RlZCA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4gcGN0IGRpZ2l0cyAtPiBzdHJpbmdfb2ZfY2hhcl9saXN0IChwY3QgOjogZGlnaXRzKSlcbiAgICAgIChjaGFyICclJylcbiAgICAgIChjb3VudCAyIGhleF9kaWdpdClcblxuICBsZXQgc3ViX2RlbGltcyA9XG4gICAgc2F0aXNmeSAoZnVuY3Rpb25cbiAgICAgICAgfCAnIScgfCAnJCcgfCAnJicgfCAnXFwnJyB8ICcoJyB8ICcpJyB8ICcqJyB8ICcrJyB8ICcsJyB8ICc7JyB8ICc9JyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IHVucmVzZXJ2ZWQgPVxuICAgICgqIFwiW0EtWmEtejAtOS0uX35dXCIgKilcbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIHwgJzAnIC4uICc5JyB8ICctJyB8ICcuJyB8ICdfJyB8ICd+JyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IHJlZ19uYW1lID1cbiAgICBsaWZ0XG4gICAgICAoU3RyaW5nLmNvbmNhdCBcIlwiKVxuICAgICAgKG1hbnlcbiAgICAgICAgIChjaG9pY2VcbiAgICAgICAgICAgIFsgc3RyaW5nX29mX2NoYXIgPCQ+IHVucmVzZXJ2ZWRcbiAgICAgICAgICAgIDsgcGN0X2VuY29kZWRcbiAgICAgICAgICAgIDsgc3RyaW5nX29mX2NoYXIgPCQ+IHN1Yl9kZWxpbXNcbiAgICAgICAgICAgIF0pKVxuXG4gIGxldCBob3N0ID1cbiAgICBjaG9pY2VcbiAgICAgIFsgaXB2NF9hZGRyZXNzID4+fCAoZnVuIGggLT4gYElwdjRfbGl0ZXJhbCBoKVxuICAgICAgOyBpcHY2X2FkZHJlc3MgPj58IChmdW4gaCAtPiBgSXB2Nl9saXRlcmFsIGgpXG4gICAgICA7IHJlZ19uYW1lID4+fCAoZnVuIHMgLT4gYEhvc3QgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKCogVE9ETyhkaW5vc2F1cmUpOiBBY2NvcmRpbmcgdG8gUkZDMzk4NjpcblxuICAgICAgICAgaG9zdCAgICAgICAgPSBJUC1saXRlcmFsIC8gSVB2NGFkZHJlc3MgLyByZWctbmFtZVxuICAgICAgICAgSVAtbGl0ZXJhbCAgPSBcIltcIiAoIElQdjZhZGRyZXNzIC8gSVB2RnV0dXJlICApIFwiXVwiXG4gICAgICAgICBJUHZGdXR1cmUgICA9IFwidlwiIDEqSEVYRElHIFwiLlwiIDEqKCB1bnJlc2VydmVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcblxuICAgICAgICAgSVB2RnV0dXJlIGlzIG5vdCBpbXBsZW1lbnRlZC4gV2Ugc2hvdWxkIGhhbmRsZSBpdDpcblxuICAgICAgICAgSVB2RnV0dXJlICAgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgICAgKilcbiAgICAgIF1cblxuICBsZXQgdXNlcmluZm8gPVxuICAgIGxpZnRcbiAgICAgIChmdW4geCAtPlxuICAgICAgICBsZXQgcyA9IFN0cmluZy5jb25jYXQgXCJcIiB4IGluXG4gICAgICAgIFNvbWUgKFVzZXJpbmZvLnVzZXJpbmZvX29mX2VuY29kZWQgcykpXG4gICAgICAobWFueVxuICAgICAgICAgKGNob2ljZVxuICAgICAgICAgICAgWyBzdHJpbmdfb2ZfY2hhciA8JD4gdW5yZXNlcnZlZFxuICAgICAgICAgICAgOyBwY3RfZW5jb2RlZFxuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gc3ViX2RlbGltc1xuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gY19jb2xvblxuICAgICAgICAgICAgXSlcbiAgICAgIDwqIGNfYXQpXG4gICAgPHw+IHJldHVybiBOb25lXG5cbiAgbGV0IHBvcnQgPVxuICAgIHBlZWtfY2hhciA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgJzonIC0+XG4gICAgICBjX2NvbG9uICo+IHRha2Vfd2hpbGUgaXNfZGlnaXQgPj58IGZ1biBwb3J0IC0+XG4gICAgICBsZXQgZGVjb2RlZCA9IFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcG9ydCkgaW5cbiAgICAgICh0cnkgU29tZSAoaW50X29mX3N0cmluZyAoUGN0LnVuY2FzdF9kZWNvZGVkIGRlY29kZWQpKSB3aXRoIF8gLT4gTm9uZSlcbiAgICB8IFNvbWUgXyB8IE5vbmUgLT5cbiAgICAgIHJldHVybiBOb25lXG5cbiAgbGV0IGF1dGhvcml0eSA9XG4gICAgc3RyaW5nIFwiLy9cIlxuICAgICo+IGxpZnQzXG4gICAgICAgICAoZnVuIHVzZXJpbmZvIGhvc3QgcG9ydCAtPlxuICAgICAgICAgICB1c2VyaW5mbywgU29tZSBob3N0LCBwb3J0KVxuICAgICAgICAgdXNlcmluZm9cbiAgICAgICAgIGhvc3RcbiAgICAgICAgIHBvcnRcbiAgICA8fD4gcmV0dXJuIChOb25lLCBOb25lLCBOb25lKVxuXG4gIGxldCBwYXRoID1cbiAgICBsaWZ0XG4gICAgICBQYXRoLnBhdGhfb2ZfZW5jb2RlZFxuICAgICAgKHRha2Vfd2hpbGUgKGZ1bmN0aW9uICc/JyB8ICcjJyAtPiBmYWxzZSB8IF8gLT4gdHJ1ZSkpXG5cbiAgbGV0IHF1ZXJ5ID1cbiAgICBsaWZ0XG4gICAgICBRdWVyeS5vZl9yYXdcbiAgICAgIChjaGFyICc/JyAqPiB0YWtlX3RpbGwgKGZ1bmN0aW9uICcjJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkpXG4gICAgPHw+IHJldHVybiAoUXVlcnkuUmF3IChOb25lLCBMYXp5LmZyb21fdmFsIFtdKSlcblxuICBsZXQgZnJhZ21lbnQgPVxuICAgIGxpZnRcbiAgICAgIChmdW4gcyAtPiBTb21lIChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgIChjaGFyICcjJyAqPiB0YWtlX3doaWxlIChmdW4gXyAtPiB0cnVlKSlcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgX3VyaV9yZWZlcmVuY2UgPVxuICAgIGxpZnQ0XG4gICAgICAoZnVuIHNjaGVtZSAodXNlcmluZm8sIGhvc3QsIHBvcnQpIHBhdGggcXVlcnkgZnJhZ21lbnQgLT5cbiAgICAgICAgbm9ybWFsaXplIHNjaGVtZSB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9KVxuICAgICAgc2NoZW1lXG4gICAgICBhdXRob3JpdHlcbiAgICAgIHBhdGhcbiAgICAgIHF1ZXJ5XG4gICAgPCo+IGZyYWdtZW50XG5cbiAgKCogWFhYKGFubW9udGVpcm8pOiBGb3IgY29tcGF0aWJpbGl0eSByZWFzb25zIHdpdGggdGhlIG9sZCByZWdleCBwYXJzZXIsIHdlXG4gICAqIG9ubHkgcGFyc2UgdW50aWwgdGhlIGZpcnN0IG5ld2xpbmUgY2hhcmFjdGVyIGFuZCBkcm9wIGV2ZXJ5dGhpbmcgZWxzZVxuICAgKiBhZnRlciB0aGF0ICopXG4gIGxldCB1cmlfcmVmZXJlbmNlID1cbiAgICB0YWtlX3doaWxlIChmdW5jdGlvbiB8ICdcXG4nIC0+IGZhbHNlIHwgXyAtPiB0cnVlKSA+PnwgZnVuIHMgLT5cbiAgICAgIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgX3VyaV9yZWZlcmVuY2UgcyB3aXRoXG4gICAgICB8IE9rIHQgLT4gdFxuICAgICAgfCBFcnJvciBfIC0+XG4gICAgICAgICgqIFNob3VsZG4ndCByZWFsbHkgaGFwcGVuIGlmIHRoZSBwYXJzZXIgaXMgZm9yZ2l2aW5nLiAqKVxuICAgICAgICBlbXB0eVxuZW5kXG5cbmxldCBkZWNvZGVfaG9zdCBob3N0ID1cbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBQYXJzZXIuaG9zdCBob3N0IHdpdGhcbiAgfCBPayBwYXJzZWQgLT4gcGFyc2VkXG4gIHwgRXJyb3IgXyAtPlxuICAgIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgUGFyc2VyLmlwdjYgaG9zdCB3aXRoXG4gICAgfCBPayBwYXJzZWQgLT4gKGBJcHY2X2xpdGVyYWwgcGFyc2VkKVxuICAgIHwgRXJyb3IgXyAtPiAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgaG9zdCkpXG5cbigqIE1ha2UgYSBVUkkgcmVjb3JkLiBUaGlzIGlzIGEgYml0IG1vcmUgaW5lZmZpY2llbnQgdGhhbiBpdCBuZWVkcyB0byBiZSBkdWUgdG8gdGhlXG4gKiBjYXN0aW5nL3VuY2FzdGluZyAod2hpY2ggaXNuJ3QgZnVsbHkgaWRlbnRpdHkgZHVlIHRvIHRoZSBvcHRpb24gYm94KSwgYnV0IGl0IGlzXG4gKiBubyBiaWcgZGVhbCBmb3Igbm93LlxuKilcbmxldCBtYWtlID9zY2hlbWUgP3VzZXJpbmZvID9ob3N0ID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgKCkgPVxuICBsZXQgZGVjb2RlID0gZnVuY3Rpb25cbiAgICB8U29tZSB4IC0+IFNvbWUgKFBjdC5jYXN0X2RlY29kZWQgeCkgfE5vbmUgLT4gTm9uZSBpblxuICBsZXQgaG9zdCA9IG1hdGNoIHVzZXJpbmZvLCBob3N0LCBwb3J0IHdpdGhcbiAgICB8IF8sIFNvbWUgXywgXyB8IE5vbmUsIE5vbmUsIE5vbmUgLT4gaG9zdFxuICAgIHwgU29tZSBfLCBOb25lLCBfIHwgXywgTm9uZSwgU29tZSBfIC0+IFNvbWUgXCJcIlxuICBpblxuICBsZXQgdXNlcmluZm8gPSBtYXRjaCB1c2VyaW5mbyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmUgfCBTb21lIHUgLT4gU29tZSAodXNlcmluZm9fb2ZfZW5jb2RlZCB1KSBpblxuICBsZXQgcGF0aCA9IG1hdGNoIHBhdGggd2l0aFxuICAgIHxOb25lIC0+IFtdIHwgU29tZSBwIC0+XG4gICAgICBsZXQgcGF0aCA9IHBhdGhfb2ZfZW5jb2RlZCBwIGluXG4gICAgICBtYXRjaCBob3N0LCBwYXRoIHdpdGhcbiAgICAgIHwgTm9uZSwgXyB8IFNvbWUgXywgXCIvXCI6Ol8gfCBTb21lIF8sIFtdIC0+IHBhdGhcbiAgICAgIHwgU29tZSBfLCBfICAtPiBcIi9cIjo6cGF0aFxuICBpblxuICBsZXQgcXVlcnkgPSBtYXRjaCBxdWVyeSB3aXRoXG4gICAgfCBOb25lIC0+IFF1ZXJ5LktWIFtdXG4gICAgfCBTb21lIHAgLT4gUXVlcnkuS1YgcFxuICBpblxuICBsZXQgc2NoZW1lID0gZGVjb2RlIHNjaGVtZSBpblxuICBub3JtYWxpemUgc2NoZW1lXG4gICAgeyBzY2hlbWU7IHVzZXJpbmZvO1xuICAgICAgaG9zdCA9XG4gICAgICAgIChtYXRjaCBob3N0IHdpdGhcbiAgICAgICAgfCBTb21lIGhvc3QgLT4gU29tZSAoZGVjb2RlX2hvc3QgaG9zdClcbiAgICAgICAgfCBOb25lIC0+IE5vbmUpO1xuICAgICAgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50PWRlY29kZSBmcmFnbWVudCB9XG5cbmxldCB3aXRoX2hvc3QgdXJpIGhvc3QgPVxuICB7IHVyaSB3aXRoXG4gICAgaG9zdCA9IChtYXRjaCBob3N0IHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBob3N0IC0+IFNvbWUgKGRlY29kZV9ob3N0IGhvc3QpXG4gICAgICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgfVxuXG5sZXQgd2l0aF91cmkgP3NjaGVtZSA/dXNlcmluZm8gP2hvc3QgP3BvcnQgP3BhdGggP3F1ZXJ5ID9mcmFnbWVudCB1cmkgPVxuICBsZXQgd2l0aF9wYXRoX29wdCB1IG8gPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiB3aXRoX3BhdGggdSBcIlwiXG4gICAgfCBTb21lIHAgLT4gd2l0aF9wYXRoIHUgcFxuICBpblxuICBsZXQgd2l0aF9xdWVyeV9vcHQgdSBvID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gd2l0aF9xdWVyeSB1IFtdXG4gICAgfCBTb21lIHEgLT4gd2l0aF9xdWVyeSB1IHFcbiAgaW5cbiAgbGV0IHdpdGhfIGYgbyB1ID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gdVxuICAgIHwgU29tZSB4IC0+IGYgdSB4XG4gIGluXG4gIHdpdGhfIHdpdGhfc2NoZW1lIHNjaGVtZSB1cmlcbiAgfD4gd2l0aF8gd2l0aF91c2VyaW5mbyB1c2VyaW5mb1xuICB8PiB3aXRoXyB3aXRoX2hvc3QgaG9zdFxuICB8PiB3aXRoXyB3aXRoX3BvcnQgcG9ydFxuICB8PiB3aXRoXyB3aXRoX3BhdGhfb3B0IHBhdGhcbiAgfD4gd2l0aF8gd2l0aF9xdWVyeV9vcHQgcXVlcnlcbiAgfD4gd2l0aF8gd2l0aF9mcmFnbWVudCBmcmFnbWVudFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICAoKiBUbyBwcmVzZXJ2ZSB0aGUgb2xkIHJlZ2V4IHBhcnNlcidzIGJlaGF2aW9yLCB3ZSBvbmx5IHBhcnNlIGEgcHJlZml4LCBhbmRcbiAgICogc3RvcCB3aGVuZXZlciB3ZSBjYW4ndCBwYXJzZSBtb3JlLiAqKVxuICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6UHJlZml4IFBhcnNlci51cmlfcmVmZXJlbmNlIHMgd2l0aFxuICB8IE9rIHQgLT4gdFxuICB8IEVycm9yIF8gLT5cbiAgICAoKiBTaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiBpZiB0aGUgcGFyc2VyIGlzIGZvcmdpdmluZy4gKilcbiAgICBlbXB0eVxuXG5tb2R1bGUgQWJzb2x1dGVfaHR0cCA9IHN0cnVjdFxuICB0eXBlIHVyaSA9IHRcbiAgdHlwZSB0ID1cbiAgICB7IHNjaGVtZSA6IFsgYEh0dHAgfCBgSHR0cHMgXTtcbiAgICAgIHVzZXJpbmZvOiBVc2VyaW5mby50IG9wdGlvbjtcbiAgICAgIGhvc3Q6IFsgYElwdjRfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgICAgIHwgYElwdjZfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgICAgIHwgYEhvc3Qgb2YgUGN0LmRlY29kZWRdO1xuICAgICAgcG9ydCA6IGludCBvcHRpb247XG4gICAgICBwYXRoIDogUGF0aC50O1xuICAgICAgcXVlcnkgOiBRdWVyeS50O1xuICAgICAgZnJhZ21lbnQgOiBQY3QuZGVjb2RlZCBvcHRpb25cbiAgICB9XG5cbiAgbGV0ICggbGV0KiApID0gUmVzdWx0LmJpbmRcblxuICBsZXQgdG9fdXJpIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH0gPVxuICAgIGxldCBzY2hlbWUgPVxuICAgICAgbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgIHwgYEh0dHAgLT4gUGN0LmNhc3RfZGVjb2RlZCBcImh0dHBcIlxuICAgICAgfCBgSHR0cHMgLT4gUGN0LmNhc3RfZGVjb2RlZCBcImh0dHBzXCJcbiAgICBpblxuICAgICh7IHNjaGVtZSA9IFNvbWUgc2NoZW1lO1xuICAgICAgIHVzZXJpbmZvO1xuICAgICAgIGhvc3QgPSBTb21lIGhvc3Q7XG4gICAgICAgcG9ydDtcbiAgICAgICBwYXRoO1xuICAgICAgIHF1ZXJ5O1xuICAgICAgIGZyYWdtZW50IH0gOiB1cmkpXG4gIDs7XG5cbiAgbGV0IG9mX3VyaSAoeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfTogdXJpKSA9XG4gICAgbGV0KiBzY2hlbWUgPVxuICAgICAgbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFcnJvciAoYE1zZyBcIk5vIHNjaGVtZSBwcmVzZW50IGluIFVSSVwiKVxuICAgICAgfCBTb21lIHNjaGVtZSAtPlxuICAgICAgICAobWF0Y2ggUGN0LnVuY2FzdF9kZWNvZGVkIHNjaGVtZSB3aXRoXG4gICAgICAgICB8IFwiaHR0cFwiIC0+IE9rIGBIdHRwXG4gICAgICAgICB8IFwiaHR0cHNcIiAtPiBPayBgSHR0cHNcbiAgICAgICAgIHwgdW5zdXBwb3J0ZWRfc2NoZW1lIC0+XG4gICAgICAgICAgIEVycm9yXG4gICAgICAgICAgICAgKGBNc2dcbiAgICAgICAgICAgICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgICAgICBcIk9ubHkgaHR0cCBhbmQgaHR0cHMgVVJJcyBhcmUgc3VwcG9ydGVkLiAlcyBpcyBpbnZhbGlkLlwiXG4gICAgICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWRfc2NoZW1lKSkpXG4gICAgaW5cbiAgICBsZXQqIGhvc3QgPSBPcHRpb24udG9fcmVzdWx0IH5ub25lOihgTXNnIFwiaG9zdCBpcyByZXF1aXJlZCBmb3IgSFRUUChTKSB1cmlzXCIpIGhvc3QgaW5cbiAgICBPayB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9XG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzID0gbWF0Y2ggb2Zfc3RyaW5nIHMgfD4gb2ZfdXJpIHdpdGhcbiAgICB8IE9rIHQgLT4gdFxuICAgIHwgRXJyb3IgKGBNc2cgZXJyb3IpIC0+IGZhaWx3aXRoIGVycm9yXG5cbiAgbGV0IHRvX3N0cmluZyA/cGN0X2VuY29kZXIgdCA9IHRvX3VyaSB0IHw+IHRvX3N0cmluZyA/cGN0X2VuY29kZXJcblxuICBsZXQgbm9ybWFsaXplIHQgPVxuICAgIHsgdCB3aXRoXG4gICAgICBob3N0ID0gbWF0Y2ggdC5ob3N0IHdpdGhcbiAgICAgICB8IChgSXB2NF9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICAoYElwdjRfbGl0ZXJhbCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBob3N0KSlcbiAgICAgICB8IChgSXB2Nl9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICAoYElwdjZfbGl0ZXJhbCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBob3N0KSlcbiAgICAgICB8IChgSG9zdCBob3N0KSAtPlxuICAgICAgICAgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIChQY3QudW5jYXN0X2RlY29kZWQgaG9zdCkpKSlcbiAgICB9XG5cbiAgbGV0IG1ha2UgfnNjaGVtZSB+aG9zdCA/dXNlcmluZm8gP3BvcnQgP3BhdGggP3F1ZXJ5ID9mcmFnbWVudCAoKSA9XG4gICAgbGV0IGRlY29kZSA9IGZ1bmN0aW9uXG4gICAgICB8U29tZSB4IC0+IFNvbWUgKFBjdC5jYXN0X2RlY29kZWQgeCkgfE5vbmUgLT4gTm9uZSBpblxuICAgIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSkgaW5cbiAgICBsZXQgcGF0aCA9IG1hdGNoIHBhdGggd2l0aFxuICAgICAgfE5vbmUgLT4gW10gfCBTb21lIHAgLT5cbiAgICAgICAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcCBpblxuICAgICAgICBtYXRjaCBwYXRoIHdpdGhcbiAgICAgICAgfCAgXCIvXCI6Ol8gfCAgW10gLT4gcGF0aFxuICAgICAgICB8IF8gIC0+IFwiL1wiOjpwYXRoXG4gICAgaW5cbiAgICBsZXQgcXVlcnkgPSBtYXRjaCBxdWVyeSB3aXRoXG4gICAgICB8IE5vbmUgLT4gUXVlcnkuS1YgW11cbiAgICAgIHwgU29tZSBwIC0+IFF1ZXJ5LktWIHBcbiAgICBpblxuICAgIG5vcm1hbGl6ZVxuICAgICAgeyBzY2hlbWU7XG4gICAgICAgIHVzZXJpbmZvO1xuICAgICAgICBob3N0PSBkZWNvZGVfaG9zdCBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQ9ZGVjb2RlIGZyYWdtZW50IH1cblxuICBsZXQgaG9zdCB0ID1cbiAgICBtYXRjaCB0Lmhvc3Qgd2l0aFxuICAgIHwgKGBJcHY0X2xpdGVyYWwgaCB8IGBJcHY2X2xpdGVyYWwgaCkgLT4gaFxuICAgIHwgKGBIb3N0IGgpIC0+IChQY3QudW5jYXN0X2RlY29kZWQgaClcblxuICBsZXQgc2NoZW1lIHQgPSB0LnNjaGVtZVxuZW5kXG4iXX0=
