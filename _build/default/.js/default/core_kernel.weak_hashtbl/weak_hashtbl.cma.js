// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Weak_hashtbl
//# unitInfo: Requires: Base__Error, Base__Exn, Base__Hashable, Base__Hashtbl, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Weak_pointer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Weak_hashtbl$0 = "Weak_hashtbl",
    cst = "_",
    cst_weak_hashtbl$0 = "weak_hashtbl",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Weak_pointer = global_data.Weak_pointer,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Error = global_data.Base__Error,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Base_Hashable = global_data.Base__Hashable,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Weak_hashtbl$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_weak_hashtbl$0);
   caml_call1(Ppx_expect_runtime[1][1], "weak_hashtbl/src/weak_hashtbl.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_weak_hashtbl$0, "weak_hashtbl.ml");
   var
    _e_ = [0, cst],
    _d_ = [0, cst],
    cst_weak_hashtbl_src_weak_hash = "weak_hashtbl/src/weak_hashtbl.ml:74:71",
    cst_Weak_hashtbl_add_exn_of_ke = "Weak_hashtbl.add_exn of key in use",
    _a_ = [0, "thread_safe_run_when_unused_data"],
    _b_ = [0, "keys_with_unused_data"],
    _c_ = [0, "entry_by_key"],
    cst_weak_hashtbl = cst_weak_hashtbl$0,
    cst_Weak_hashtbl = cst_Weak_hashtbl$0;
   function sexp_of_t(of_a_001, of_b_002, param){
    var
     keys_with_unused_data_006 = param[2],
     entry_by_key_004 = param[1],
     bnds_003 = 0;
    function _t_(_v_){return 0;}
    var
     arg_009 = caml_call1(Sexplib0_Sexp_conv[24], _t_),
     bnds_003$0 = [0, [1, [0, _a_, [0, arg_009, 0]]], bnds_003],
     arg_007 =
       caml_call2(Thread_safe_queue[1], of_a_001, keys_with_unused_data_006),
     bnds_003$1 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_003$0],
     _u_ = caml_call1(Weak_pointer[1], of_b_002),
     arg_005 = caml_call3(Base_Hashtbl[3], of_a_001, _u_, entry_by_key_004),
     bnds_003$2 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   function create(growth_allowed, size, hashable){
    function _p_(_s_){return 0;}
    var
     _q_ = caml_call1(Thread_safe_queue[3], 0),
     _r_ = caml_call1(Base_Hashable[4], hashable);
    return [0,
            caml_call3(Base_Hashtbl[4], growth_allowed, size, _r_),
            _q_,
            _p_];
   }
   var Using_hashable = [0, create];
   function create$0(growth_allowed, size, m){
    var _o_ = caml_call1(Base_Hashable[3], m);
    return caml_call3(Using_hashable[1], growth_allowed, size, _o_);
   }
   function set_run_when_unused_data(t, thread_safe_f){t[3] = thread_safe_f; return 0;
   }
   function remove(t, key){return caml_call2(Base_Hashtbl[32], t[1], key);}
   function clear(t){return caml_call1(Base_Hashtbl[16], t[1]);}
   function reclaim_space_for_keys_with_un(t){
    for(;;){
     if(0 >= caml_call1(Thread_safe_queue[4], t[2])) return 0;
     var
      key = caml_call1(Thread_safe_queue[6], t[2]),
      match = caml_call2(Base_Hashtbl[56], t[1], key);
     if(match){
      var entry = match[1];
      if(caml_call1(Weak_pointer[6], entry)) remove(t, key);
     }
    }
   }
   function get_entry(t, key){
    function _n_(param){return caml_call1(Weak_pointer[2], 0);}
    return caml_call3(Base_Hashtbl[54], t[1], key, _n_);
   }
   function mem(t, key){
    var match = caml_call2(Base_Hashtbl[56], t[1], key);
    if(! match) return 0;
    var entry = match[1];
    return caml_call1(Weak_pointer[5], entry);
   }
   function key_is_using_space(t, key){
    return caml_call2(Base_Hashtbl[31], t[1], key);
   }
   function set_data(t, key, entry, data){
    caml_call2(Weak_pointer[7], entry, data);
    function cleanup(param){
     function _m_(param){
      caml_call2(Thread_safe_queue[5], t[2], key);
      return caml_call1(t[3], 0);
     }
     return caml_call1(Base_Exn[15], _m_);
    }
    try{var _k_ = caml_call2(Stdlib_Gc[4], cleanup, data); return _k_;}
    catch(_l_){
     var _j_ = caml_wrap_exception(_l_);
     if(_j_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_j_, 0);
    }
   }
   function replace(t, key, data){
    return set_data(t, key, get_entry(t, key), data);
   }
   function add_exn(x_010, key, data){
    var entry = get_entry(x_010, key);
    if(caml_call1(Weak_pointer[5], entry)){
     var
      _f_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_weak_hashtbl_src_weak_hash),
         0],
      _g_ = function(param){return _d_;},
      _h_ = [0, sexp_of_t(function(param){return _e_;}, _g_, x_010), _f_],
      _i_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Weak_hashtbl_add_exn_of_ke),
          _h_]];
     caml_call1(Base_Error[32], _i_);
    }
    return set_data(x_010, key, entry, data);
   }
   function find(t, key){
    var match = caml_call2(Base_Hashtbl[56], t[1], key);
    if(! match) return 0;
    var entry = match[1];
    return caml_call1(Weak_pointer[4], entry);
   }
   function find_or_add(t, key, default$0){
    var entry = get_entry(t, key), match = caml_call1(Weak_pointer[4], entry);
    if(match){var v = match[1]; return v;}
    var data = caml_call1(default$0, 0);
    set_data(t, key, entry, data);
    return data;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_weak_hashtbl);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Weak_hashtbl);
   var
    Weak_hashtbl =
      [0,
       sexp_of_t,
       create$0,
       Using_hashable,
       mem,
       find,
       find_or_add,
       remove,
       clear,
       add_exn,
       replace,
       key_is_using_space,
       reclaim_space_for_keys_with_un,
       set_run_when_unused_data];
   runtime.caml_register_global(27, Weak_hashtbl, cst_Weak_hashtbl$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ3ZWFrX2hhc2h0YmwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInNleHBfb2ZfdCIsIm9mX2FfMDAxIiwib2ZfYl8wMDIiLCJrZXlzX3dpdGhfdW51c2VkX2RhdGFfMDA2IiwiZW50cnlfYnlfa2V5XzAwNCIsImJuZHNfMDAzIiwiYXJnXzAwOSIsImJuZHNfMDAzJDAiLCJhcmdfMDA3IiwiYm5kc18wMDMkMSIsImFyZ18wMDUiLCJibmRzXzAwMyQyIiwiY3JlYXRlIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplIiwiaGFzaGFibGUiLCJjcmVhdGUkMCIsIm0iLCJzZXRfcnVuX3doZW5fdW51c2VkX2RhdGEiLCJ0IiwidGhyZWFkX3NhZmVfZiIsInJlbW92ZSIsImtleSIsImNsZWFyIiwicmVjbGFpbV9zcGFjZV9mb3Jfa2V5c193aXRoX3VuIiwiZW50cnkiLCJnZXRfZW50cnkiLCJtZW0iLCJrZXlfaXNfdXNpbmdfc3BhY2UiLCJzZXRfZGF0YSIsImRhdGEiLCJjbGVhbnVwIiwicmVwbGFjZSIsImFkZF9leG4iLCJ4XzAxMCIsImZpbmQiLCJmaW5kX29yX2FkZCIsImRlZmF1bHQkMCIsInYiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZV9rZXJuZWwvd2Vha19oYXNodGJsL3dlYWtfaGFzaHRibC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBRUEsU0FBQUEsVUFBTUMsVUFBSUM7SUFBVjtLQUVJQztLQURBQztLQURKQztzQjtJQUdZO0tBQUFDO0tBSFpDLGtDQUdZRCxlQUhaRDtLQUVJRztPQUFBLGlDQUZFUCxVQUVGRTtLQUZKTSxrQ0FFSUQsZUFGSkQ7dUNBQVVMO0tBQ05RLFVBQUEsNEJBREVULGVBQ0ZHO0tBREpPLGtDQUNJRCxlQURKRDtJQUFBLFdBQUFFO0dBS29CO1lBR2RDLE9BQVFDLGdCQUFnQkMsTUFBS0M7SUFDL0Isa0I7SUFDMEI7S0FBQSxNQUFBO0tBRDRCLE1BQUEsNkJBRHZCQTtJQUMvQjtZQUFpQiw0QkFEUEYsZ0JBQWdCQzs7O0dBSXpCO0dBTG1CLHlCQUNsQkY7WUFRRkksU0FBUUgsZ0JBQWdCQyxNQUFLRztJQUNhLFVBQUEsNkJBRGJBO0lBQ2EsT0FBQSw4QkFEbENKLGdCQUFnQkM7R0FDcUM7WUFHN0RJLHlCQUF5QkMsR0FBR0MsZUFBSEQsT0FBR0M7R0FDcUI7WUFHakRDLE9BQU9GLEdBQUVHLEtBQU0sT0FBQSw2QkFBUkgsTUFBRUcsS0FBdUM7WUFDaERDLE1BQU1KLEdBQUksb0NBQUpBLE1BQWdDO1lBS3RDSywrQkFBd0NMO0lBQzFDO0tBQU0sUUFBQSxpQ0FEb0NBO0tBRTlCO01BQU5HLE1BQU0saUNBRjhCSDtNQUdsQyxRQUFBLDZCQUhrQ0EsTUFFcENHOztVQUdHRztNQUFZLEdBQUEsNEJBQVpBLFFBWFBKLE9BTXdDRixHQUVwQ0c7OztHQUlGO1lBR0ZJLFVBQVVQLEdBQUVHO0lBQ2Qsb0JBQTJELE9BQUEsK0JBQXNCO0lBQWpDLE9BQUEsNkJBRHBDSCxNQUFFRztHQUNvRTtZQUdoRkssSUFBSVIsR0FBRUc7SUFDRixZQUFBLDZCQURBSCxNQUFFRztnQkFFRTtRQUNIRztJQUFTLE9BQUEsNEJBQVRBO0dBQW1DO1lBR3hDRyxtQkFBbUJULEdBQUVHO0lBQU0sT0FBQSw2QkFBUkgsTUFBRUc7R0FBb0M7WUFFekRPLFNBQVNWLEdBQUVHLEtBQUlHLE9BQU9LO0lBQ3hCLDRCQURpQkwsT0FBT0s7YUFFcEJDOztNQUVBLGlDQUpPWixNQUFFRztNQUlULE9BQUEsV0FKT0g7S0FLOEI7S0FGVixPQUFBO0lBRVc7SUFFMUMsSUFBSSxVQUFBLHlCQUxBWSxTQUZvQkQsT0FPcEI7Ozs4QkFHb0I7OztHQUFFO1lBR3hCRSxRQUFRYixHQUFHRyxLQUFLUTtJQUFPLE9BYnZCRCxTQWFRVixHQUFHRyxLQXpCWEksVUF5QlFQLEdBQUdHLE1BQUtRO0dBQTRDO1lBRTVERyxRQUFRQyxPQUFHWixLQUFLUTtJQUNOLElBQVJMLFFBNUJGQyxVQTJCUVEsT0FBR1o7SUFFVixHQUFBLDRCQURDRzs7Ozs7OzRCO2dCQW5FTnpCLDBCLG1CQWtFWWtDOzs7Ozs7S0FJUjs7SUFBQSxPQW5CQUwsU0FlUUssT0FBR1osS0FDVEcsT0FEY0s7R0FNTztZQUd2QkssS0FBS2hCLEdBQUVHO0lBQ0gsWUFBQSw2QkFEQ0gsTUFBRUc7Z0JBRUM7UUFDSEc7SUFBUyxPQUFBLDRCQUFUQTtHQUErQjtZQUdwQ1csWUFBWWpCLEdBQUVHLEtBQUtlO0lBQ3JCLElBQUlaLFFBM0NGQyxVQTBDWVAsR0FBRUcsTUFFVixRQUFBLDRCQURGRztrQkFFR2EsY0FBSyxPQUFMQTtJQUVNLElBQVBSLE9BQU8sV0FMUU87SUE5Qm5CUixTQThCWVYsR0FBRUcsS0FDWkcsT0FJRUs7SUFDSixPQURJQTtHQUVBOzs7Ozs7OztPQXhGUjlCO09BZ0JJZ0I7O09BMkJBVztPQWdDQVE7T0FNQUM7T0F6REFmO09BQ0FFO09BeUNBVTtPQUZBRDtPQWZBSjtPQW5CQUo7T0FWQU47OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IGVudHJ5X2J5X2tleSA6ICgnYSwgJ2IgV2Vha19wb2ludGVyLnQpIEhhc2h0YmwudFxuICA7IGtleXNfd2l0aF91bnVzZWRfZGF0YSA6ICdhIFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgOyBtdXRhYmxlIHRocmVhZF9zYWZlX3J1bl93aGVuX3VudXNlZF9kYXRhIDogdW5pdCAtPiB1bml0XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbm1vZHVsZSBVc2luZ19oYXNoYWJsZSA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBoYXNoYWJsZSA9XG4gICAgeyBlbnRyeV9ieV9rZXkgPSBIYXNodGJsLmNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEJhc2UuSGFzaGFibGUudG9fa2V5IGhhc2hhYmxlKVxuICAgIDsga2V5c193aXRoX3VudXNlZF9kYXRhID0gVGhyZWFkX3NhZmVfcXVldWUuY3JlYXRlICgpXG4gICAgOyB0aHJlYWRfc2FmZV9ydW5fd2hlbl91bnVzZWRfZGF0YSA9IGlnbm9yZVxuICAgIH1cbiAgOztcbmVuZFxuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID1cbiAgVXNpbmdfaGFzaGFibGUuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUub2Zfa2V5IG0pXG47O1xuXG5sZXQgc2V0X3J1bl93aGVuX3VudXNlZF9kYXRhIHQgfnRocmVhZF9zYWZlX2YgPVxuICB0LnRocmVhZF9zYWZlX3J1bl93aGVuX3VudXNlZF9kYXRhIDwtIHRocmVhZF9zYWZlX2Zcbjs7XG5cbmxldCByZW1vdmUgdCBrZXkgPSBIYXNodGJsLnJlbW92ZSB0LmVudHJ5X2J5X2tleSBrZXlcbmxldCBjbGVhciB0ID0gSGFzaHRibC5jbGVhciB0LmVudHJ5X2J5X2tleVxuXG4oKiBJbiBvcmRlciBmb3IgYSBjYWxsIHRvIFtyZWNsYWltX3NwYWNlX2Zvcl9rZXlzX3dpdGhfdW51c2VkX2RhdGFdIHRvIHJlY2xhaW0gYSBrZXkgdGhhdFxuICAgd2FzIHByZXZpb3VzbHkgZmluYWxpemVkLCB0aGUgd2VhayBwb2ludGVyIG11c3QgaGF2ZSBiZWVuIGNsZWFyZWQuICBUaGlzIHJlbGllcyBvbiB0aGVcbiAgIGZhY3QgdGhhdCB0aGUgT0NhbWwgZ2FyYmFnZSBjb2xsZWN0b3IgY2xlYXJzIHdlYWtzIGFuZCB0aGVuIHJ1bnMgZmluYWxpemVycy4gKilcbmxldCByZWNsYWltX3NwYWNlX2Zvcl9rZXlzX3dpdGhfdW51c2VkX2RhdGEgdCA9XG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCB0LmtleXNfd2l0aF91bnVzZWRfZGF0YSA+IDAgZG9cbiAgICBsZXQga2V5ID0gVGhyZWFkX3NhZmVfcXVldWUuZGVxdWV1ZV9leG4gdC5rZXlzX3dpdGhfdW51c2VkX2RhdGEgaW5cbiAgICBtYXRjaCBIYXNodGJsLmZpbmQgdC5lbnRyeV9ieV9rZXkga2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgZW50cnkgLT4gaWYgV2Vha19wb2ludGVyLmlzX25vbmUgZW50cnkgdGhlbiByZW1vdmUgdCBrZXlcbiAgZG9uZVxuOztcblxubGV0IGdldF9lbnRyeSB0IGtleSA9XG4gIEhhc2h0YmwuZmluZF9vcl9hZGQgdC5lbnRyeV9ieV9rZXkga2V5IH5kZWZhdWx0OihmdW4gKCkgLT4gV2Vha19wb2ludGVyLmNyZWF0ZSAoKSlcbjs7XG5cbmxldCBtZW0gdCBrZXkgPVxuICBtYXRjaCBIYXNodGJsLmZpbmQgdC5lbnRyeV9ieV9rZXkga2V5IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSBlbnRyeSAtPiBXZWFrX3BvaW50ZXIuaXNfc29tZSBlbnRyeVxuOztcblxubGV0IGtleV9pc191c2luZ19zcGFjZSB0IGtleSA9IEhhc2h0YmwubWVtIHQuZW50cnlfYnlfa2V5IGtleVxuXG5sZXQgc2V0X2RhdGEgdCBrZXkgZW50cnkgKGRhdGEgOiBfIEhlYXBfYmxvY2sudCkgPVxuICBXZWFrX3BvaW50ZXIuc2V0IGVudHJ5IGRhdGE7XG4gIGxldCBjbGVhbnVwICgpID1cbiAgICBFeG4uaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IChmdW4gKCkgLT5cbiAgICAgIFRocmVhZF9zYWZlX3F1ZXVlLmVucXVldWUgdC5rZXlzX3dpdGhfdW51c2VkX2RhdGEga2V5O1xuICAgICAgdC50aHJlYWRfc2FmZV9ydW5fd2hlbl91bnVzZWRfZGF0YSAoKSlcbiAgaW5cbiAgdHJ5IFN0ZGxpYi5HYy5maW5hbGlzZV9sYXN0IGNsZWFudXAgZGF0YSB3aXRoXG4gICgqIEluIHRoaXMgY2FzZSwgW3hdIGlzIGtub3duIHRvIGJlIHN0YXRpYyBkYXRhLCB3aGljaCB3aWxsXG4gICAgIG5ldmVyIGJlIGNvbGxlY3RlZCBieSB0aGUgR0MgYW55d2F5LCBzbyBpdCdzIHNhZmUgdG8gZHJvcCAqKVxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiAoKVxuOztcblxubGV0IHJlcGxhY2UgdCB+a2V5IH5kYXRhID0gc2V0X2RhdGEgdCBrZXkgKGdldF9lbnRyeSB0IGtleSkgZGF0YVxuXG5sZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICBsZXQgZW50cnkgPSBnZXRfZW50cnkgdCBrZXkgaW5cbiAgaWYgV2Vha19wb2ludGVyLmlzX3NvbWUgZW50cnlcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIldlYWtfaGFzaHRibC5hZGRfZXhuIG9mIGtleSBpbiB1c2VcIiB+XzoodCA6IChfLCBfKSB0KSBbJWhlcmVdXTtcbiAgc2V0X2RhdGEgdCBrZXkgZW50cnkgZGF0YVxuOztcblxubGV0IGZpbmQgdCBrZXkgPVxuICBtYXRjaCBIYXNodGJsLmZpbmQgdC5lbnRyeV9ieV9rZXkga2V5IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGVudHJ5IC0+IFdlYWtfcG9pbnRlci5nZXQgZW50cnlcbjs7XG5cbmxldCBmaW5kX29yX2FkZCB0IGtleSB+ZGVmYXVsdCA9XG4gIGxldCBlbnRyeSA9IGdldF9lbnRyeSB0IGtleSBpblxuICBtYXRjaCBXZWFrX3BvaW50ZXIuZ2V0IGVudHJ5IHdpdGhcbiAgfCBTb21lIHYgLT4gdlxuICB8IE5vbmUgLT5cbiAgICBsZXQgZGF0YSA9IGRlZmF1bHQgKCkgaW5cbiAgICBzZXRfZGF0YSB0IGtleSBlbnRyeSBkYXRhO1xuICAgIGRhdGFcbjs7XG4iXX0=
