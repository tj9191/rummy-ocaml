// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Univ_map__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Univ_map = [0],
    Univ_map$0 = [0, Univ_map];
   runtime.caml_register_global(0, Univ_map$0, "Univ_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Univ_map__Univ_map_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Univ_map_Univ_map_intf = "Univ_map__Univ_map_intf",
    cst_univ_map = "univ_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Univ_map_Univ_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_univ_map);
   caml_call1(Ppx_expect_runtime[1][1], "univ_map/src/univ_map_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_univ_map, "univ_map_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_univ_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Univ_map_Univ_map_intf);
   var Univ_map_Univ_map_intf = [0];
   runtime.caml_register_global
    (11, Univ_map_Univ_map_intf, cst_Univ_map_Univ_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Univ_map
//# unitInfo: Requires: Base, Base__Invariant, Base__List, Base__Map, Base__Option, Base__Printf, Base__Set, Base__String, Base__Type_equal, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Univ_map__Univ_map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Univ_map$0 = "Univ_map",
    cst = "_",
    cst_univ_map$0 = "univ_map",
    cst_univ_map_src_univ_map_ml = "univ_map/src/univ_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Option = global_data.Base__Option,
    Base_Type_equal = global_data.Base__Type_equal,
    Base_Map = global_data.Base__Map,
    Base = global_data.Base,
    Base_Set = global_data.Base__Set,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Univ_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_univ_map$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_univ_map_src_univ_map_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_univ_map$0, "univ_map.ml");
   var
    _m_ =
      [0,
       [11, "Univ_map.change_exn on unknown key ", [2, 0, 0]],
       "Univ_map.change_exn on unknown key %s"],
    _l_ =
      [0,
       [11, "Univ_map.add_exn on existing key ", [2, 0, 0]],
       "Univ_map.add_exn on existing key %s"],
    _k_ =
      [0,
       [11, "Univ_map.find_exn on unknown key ", [2, 0, 0]],
       "Univ_map.find_exn on unknown key %s"],
    _i_ = [0, cst],
    _h_ = [0, cst_univ_map_src_univ_map_ml, 82, 40],
    _j_ = [0, cst_univ_map_src_univ_map_ml, 81, 2431, 2455],
    _f_ = [0, cst],
    _d_ = [0, "type_id2"],
    _e_ = [0, "type_id1"],
    _g_ = [0, "key"],
    cst_Key_type_id_must_not_provi =
      "[Key.type_id] must not provide different type ids when called on the same input",
    _a_ = [0, "<uid>"],
    _b_ = [0, "uid"],
    _c_ = [0, "name"],
    cst_univ_map = cst_univ_map$0,
    cst_Univ_map = cst_Univ_map$0;
   function Make1(Key, Data){
    var sexp_of_t = Key[1];
    function sexp_of_type_id(type_id){
     var _aG_ = 0, _aH_ = 0;
     if(Ppx_inline_test_lib[1])
      var _aI_ = _a_;
     else
      var
       _aL_ = caml_call1(Base_Type_equal[12][3], type_id),
       _aI_ = caml_call1(Base_Type_equal[12][2][3], _aL_);
     var
      _aJ_ =
        [0, [1, [0, _b_, [0, caml_call1(Base[85][5], _aI_), _aH_]]], _aG_],
      _aK_ = caml_call1(Base_Type_equal[12][6], type_id);
     return [1, [0, [1, [0, _c_, [0, caml_call1(Base[202], _aK_), 0]]], _aJ_]];
    }
    function type_id(x_003){
     var
      type_id1 = caml_call1(Key[2], x_003),
      type_id2 = caml_call1(Key[2], x_003);
     if(caml_call2(Base_Type_equal[12][9], type_id1, type_id2))
      return type_id1;
     var
      _aA_ = [0, [1, [0, _d_, [0, sexp_of_type_id(type_id2), 0]]], 0],
      _aB_ = [0, [1, [0, _e_, [0, sexp_of_type_id(type_id1), 0]]], _aA_],
      _aC_ = 0;
     function _aD_(param){return _f_;}
     var
      _aE_ =
        [0, [1, [0, _g_, [0, caml_call2(Key[1], _aD_, x_003), _aC_]]], _aB_],
      _aF_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Key_type_id_must_not_provi),
          _aE_]];
     return caml_call1(Base[246], _aF_);
    }
    var Key$0 = [0, sexp_of_t, sexp_of_type_id, type_id];
    function name_of_key(key){
     var _az_ = Key$0[3].call(null, key);
     return caml_call1(Base_Type_equal[12][6], _az_);
    }
    function uid_of_key(key){
     var _ay_ = Key$0[3].call(null, key);
     return caml_call1(Base_Type_equal[12][3], _ay_);
    }
    function sexp_of_t$0(sexp_of_a, param){
     var
      data = param[2],
      key = param[1],
      _aw_ = Key$0[3].call(null, key),
      _ax_ = caml_call1(Base_Type_equal[12][7], _aw_);
     return caml_call3(Data[1], sexp_of_a, _ax_, data);
    }
    function type_id_name(param){var key = param[1]; return name_of_key(key);}
    function type_id_uid(param){var key = param[1]; return uid_of_key(key);}
    function compare(t1, t2){
     var
      _as_ = type_id_name(t2),
      _at_ = type_id_name(t1),
      c = caml_call2(Base_String[51], _at_, _as_);
     if(0 !== c) return c;
     var _au_ = type_id_uid(t2), _av_ = type_id_uid(t1);
     return caml_call2(Base_Type_equal[12][2][11], _av_, _au_);
    }
    var Packed = [0, sexp_of_t$0, type_id_name, type_id_uid, compare];
    function to_alist(t){
     var _aq_ = Packed[4], _ar_ = caml_call1(Base_Map[74], t);
     return caml_call2(Base_List[83], _ar_, _aq_);
    }
    function sexp_of_t$1(sexp_of_a, t){
     function _an_(packed){return [0, Packed[2].call(null, packed), packed];}
     var _ao_ = to_alist(t), x_008 = caml_call2(Base_List[53], _ao_, _an_);
     function _ap_(param){
      var
       arg1_005 = param[2],
       arg0_004 = param[1],
       res0_006 = caml_call1(Base[202], arg0_004),
       res1_007 = Packed[1].call(null, sexp_of_a, arg1_005);
      return [1, [0, res0_006, [0, res1_007, 0]]];
     }
     return caml_call2(Base[165], _ap_, x_008);
    }
    function invariant(t){
     function _aj_(param){
      function _al_(key, data){
       var _am_ = Packed[3].call(null, data);
       if(caml_call2(Base_Type_equal[12][2][10], key, _am_)) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      return caml_call2(Base_Map[48], t, _al_);
     }
     function _ak_(x_009){
      return sexp_of_t$1(function(param){return _i_;}, x_009);
     }
     return caml_call4(Base_Invariant[1], _j_, t, _ak_, _aj_);
    }
    function set(t, key, data){
     var _ai_ = uid_of_key(key);
     return caml_call3(Base_Map[34], t, _ai_, [0, key, data]);
    }
    function mem_by_id(t, id){return caml_call2(Base_Map[45], t, id);}
    function mem(t, key){return mem_by_id(t, uid_of_key(key));}
    function remove_by_id(t, id){return caml_call2(Base_Map[44], t, id);}
    function remove(t, key){return remove_by_id(t, uid_of_key(key));}
    var empty = caml_call1(Base_Map[6], [0, Base_Type_equal[12][2][19]]);
    function singleton(key, data){
     var _ah_ = uid_of_key(key);
     return caml_call3
             (Base_Map[7],
              [0, Base_Type_equal[12][2][19]],
              _ah_,
              [0, key, data]);
    }
    var is_empty = Base_Map[32];
    function find(t, key){
     var _ae_ = uid_of_key(key), match = caml_call2(Base_Map[42], t, _ae_);
     if(! match) return 0;
     var
      match$0 = match[1],
      value = match$0[2],
      key$0 = match$0[1],
      _af_ = Key$0[3].call(null, key$0),
      _ag_ = Key$0[3].call(null, key);
     caml_call2(Base_Type_equal[12][11], _ag_, _af_);
     return [0, value];
    }
    function find_exn(t, key){
     var match = find(t, key);
     if(match){var data = match[1]; return data;}
     var _ad_ = name_of_key(key);
     return caml_call3(Base_Printf[6], _k_, _ad_, 0);
    }
    function add(t, key, data){
     return mem(t, key) ? -1024851605 : [0, 17724, set(t, key, data)];
    }
    function add_exn(t, key, data){
     var match = add(t, key, data);
     if(typeof match === "number"){
      var _ac_ = name_of_key(key);
      return caml_call3(Base_Printf[6], _l_, _ac_, 0);
     }
     var t$0 = match[2];
     return t$0;
    }
    function change_exn(t, key, update){
     var match = find(t, key);
     if(match){
      var data = match[1];
      return set(t, key, caml_call1(update, data));
     }
     var _ab_ = name_of_key(key);
     return caml_call3(Base_Printf[6], _m_, _ab_, 0);
    }
    function change(t, key, update){
     var orig = find(t, key), next = caml_call1(update, orig);
     if(! next) return caml_call1(Base_Option[52], orig) ? t : remove(t, key);
     var data = next[1];
     return set(t, key, data);
    }
    function update(t, key, f){
     return change(t, key, function(data){return [0, caml_call1(f, data)];});
    }
    function key_id_set(t){
     var _aa_ = caml_call1(Base_Map[73], t);
     return caml_call2(Base_Set[32], [0, Base_Type_equal[12][2][19]], _aa_);
    }
    function of_alist_exn(t){
     function ___(p){return [0, Packed[3].call(null, p), p];}
     var _$_ = caml_call2(Base_List[53], t, ___);
     return caml_call2(Base_Map[10], [0, Base_Type_equal[12][2][19]], _$_);
    }
    var
     find_packed_by_id = Base_Map[42],
     find_packed_by_id_exn = Base_Map[43];
    return [0,
            Key$0,
            ,
            ,
            ,
            to_alist,
            sexp_of_t$1,
            invariant,
            set,
            mem_by_id,
            mem,
            remove_by_id,
            remove,
            empty,
            singleton,
            is_empty,
            find,
            find_exn,
            add,
            add_exn,
            change_exn,
            change,
            update,
            key_id_set,
            of_alist_exn,
            find_packed_by_id,
            find_packed_by_id_exn,
            0];
   }
   function Make(Key, Data){
    function sexp_of_t(of_a_011, of_a_012, x_013){return caml_call2(Data[1], of_a_012, x_013);
    }
    var M = Make1(Key, [0, sexp_of_t]);
    function sexp_of_t$0(x_014){return M[6].call(null, Base[220], x_014);}
    var
     invariant = M[7],
     empty = M[13],
     singleton = M[14],
     is_empty = M[15],
     set = M[8],
     mem = M[10],
     mem_by_id = M[9],
     find = M[16],
     find_exn = M[17],
     add = M[18],
     add_exn = M[19],
     change = M[21],
     change_exn = M[20],
     update = M[22],
     remove = M[12],
     remove_by_id = M[11],
     Packed = [0],
     key_id_set = M[23],
     to_alist = M[5],
     of_alist_exn = M[24],
     find_packed_by_id = M[25],
     find_packed_by_id_exn = M[26];
    return [0,
            ,
            sexp_of_t$0,
            Key,
            invariant,
            empty,
            singleton,
            is_empty,
            set,
            mem,
            mem_by_id,
            find,
            find_exn,
            add,
            add_exn,
            change,
            change_exn,
            update,
            remove,
            remove_by_id,
            Packed,
            key_id_set,
            to_alist,
            of_alist_exn,
            find_packed_by_id,
            find_packed_by_id_exn,
            0];
   }
   var sexp_of_t = Base_Type_equal[12][1];
   function type_id(_Z_){return _Z_;}
   var Type_id_key = [0, sexp_of_t, type_id];
   function sexp_of_t$0(of_a_017){return of_a_017;}
   var
    _s_ = Make(Type_id_key, [0, sexp_of_t$0]),
    type_equal = _s_[26],
    find_packed_by_id_exn = _s_[25],
    find_packed_by_id = _s_[24],
    of_alist_exn = _s_[23],
    to_alist = _s_[22],
    key_id_set = _s_[21],
    Packed = _s_[20],
    remove_by_id = _s_[19],
    remove = _s_[18],
    update = _s_[17],
    change_exn = _s_[16],
    change = _s_[15],
    add_exn = _s_[14],
    add = _s_[13],
    find_exn = _s_[12],
    find = _s_[11],
    mem_by_id = _s_[10],
    mem = _s_[9],
    set = _s_[8],
    is_empty = _s_[7],
    singleton = _s_[6],
    empty = _s_[5],
    invariant = _s_[4],
    sexp_of_t$1 = _s_[2];
   function create(default$0, name, sexp_of){
    return [0, caml_call2(Base_Type_equal[12][4], name, sexp_of), default$0];
   }
   function id(t){return t[1];}
   var Key = [0, create, id];
   function find$0(t, param){
    var default$0 = param[2], key = param[1], _Y_ = find(t, key);
    return caml_call2(Base_Option[30], _Y_, default$0);
   }
   function set$0(t, param, data){
    var key = param[1];
    return set(t, key, data);
   }
   function change$0(t, key, update){
    return set$0(t, key, caml_call1(update, find$0(t, key)));
   }
   function create$0(init, f, name, sexp_of){
    return [0, caml_call3(Key[1], init, name, sexp_of), f];
   }
   function id$0(t){return caml_call1(Key[2], t[1]);}
   var Key$0 = [0, create$0, id$0];
   function find$1(t, param){var key = param[1]; return find$0(t, key);}
   function set$1(t, param, data){
    var key = param[1];
    return set$0(t, key, data);
   }
   function change$1(t, param, update){
    var key = param[1];
    return change$0(t, key, update);
   }
   function add$0(t, param, data){
    var f = param[2], key = param[1];
    return change$0(t, key, function(acc){return caml_call2(f, acc, data);});
   }
   function create$1(name, sexp_of){
    var _W_ = caml_call1(Base_List[6], sexp_of);
    function _X_(xs, x){return [0, x, xs];}
    return caml_call4(Key$0[1], 0, _X_, name, _W_);
   }
   var
    id$1 = Key$0[2],
    Key$1 = [0, create$1, id$1],
    Multi = [0, Key$1, set$1, find$1, add$0, change$1];
   caml_call1(Ppx_inline_test_lib[7], cst_univ_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Univ_map);
   var
    _n_ = [0, Key$0, set$1, find$1, add$0, change$1],
    _o_ = [0, Key, set$0, find$0, change$0];
   function _p_(Key, _M_, _L_, Output_data){
    Make1(Key, Output_data);
    function merge(t1, t2, param){
     var f = param[1];
     function f$0(key, merge_result){
      function _U_(data){return [0, key, data];}
      var _V_ = caml_call2(f, key, merge_result);
      return caml_call2(Base_Option[24], _V_, _U_);
     }
     function _N_(param, _O_){
      var _P_ = _O_[1];
      if(737457313 === _P_){
       var
        _Q_ = _O_[2],
        _R_ = _Q_[2],
        right_data = _R_[2],
        right_key = _R_[1],
        match = _Q_[1],
        left_data = match[2],
        left_key = match[1],
        _S_ = caml_call1(Key[2], right_key),
        _T_ = caml_call1(Key[2], left_key);
       caml_call2(Base_Type_equal[12][11], _T_, _S_);
       return f$0(left_key, [0, 737457313, [0, left_data, right_data]]);
      }
      if(847852583 <= _P_){
       var match$0 = _O_[2], data = match$0[2], key = match$0[1];
       return f$0(key, [0, 847852583, data]);
      }
      var match$1 = _O_[2], data$0 = match$1[2], key$0 = match$1[1];
      return f$0(key$0, [0, -57574468, data$0]);
     }
     return caml_call3(Base_Map[76], t1, t2, _N_);
    }
    return [0, merge];
   }
   function _q_(Key, _B_, _A_, Output_data){
    Make(Key, Output_data);
    function merge(t1, t2, param){
     var f = param[1];
     function f$0(key, merge_result){
      function _J_(data){return [0, key, data];}
      var _K_ = caml_call2(f, key, merge_result);
      return caml_call2(Base_Option[24], _K_, _J_);
     }
     function _C_(param, _D_){
      var _E_ = _D_[1];
      if(737457313 === _E_){
       var
        _F_ = _D_[2],
        _G_ = _F_[2],
        right_data = _G_[2],
        right_key = _G_[1],
        match = _F_[1],
        left_data = match[2],
        left_key = match[1],
        _H_ = caml_call1(Key[2], right_key),
        _I_ = caml_call1(Key[2], left_key);
       caml_call2(Base_Type_equal[12][11], _I_, _H_);
       return f$0(left_key, [0, 737457313, [0, left_data, right_data]]);
      }
      if(847852583 <= _E_){
       var match$0 = _D_[2], data = match$0[2], key = match$0[1];
       return f$0(key, [0, 847852583, data]);
      }
      var match$1 = _D_[2], data$0 = match$1[2], key$0 = match$1[1];
      return f$0(key$0, [0, -57574468, data$0]);
     }
     return caml_call3(Base_Map[76], t1, t2, _C_);
    }
    return [0, merge];
   }
   function _r_(_x_, _w_){
    var _y_ = Make1(_x_, _w_), _z_ = _y_[1];
    return [0,
            _y_[6],
            [0, _z_[1], _z_[3]],
            _y_[7],
            _y_[13],
            _y_[14],
            _y_[15],
            _y_[8],
            _y_[10],
            _y_[9],
            _y_[16],
            _y_[17],
            _y_[18],
            _y_[19],
            _y_[21],
            _y_[20],
            _y_[22],
            _y_[12],
            _y_[11],
            [0],
            _y_[23],
            _y_[5],
            _y_[24],
            _y_[25],
            _y_[26],
            _y_[27]];
   }
   var
    Univ_map =
      [0,
       Type_id_key,
       sexp_of_t$1,
       invariant,
       empty,
       singleton,
       is_empty,
       set,
       mem,
       mem_by_id,
       find,
       find_exn,
       add,
       add_exn,
       change,
       change_exn,
       update,
       remove,
       remove_by_id,
       Packed,
       key_id_set,
       to_alist,
       of_alist_exn,
       find_packed_by_id,
       find_packed_by_id_exn,
       type_equal,
       function(_u_, _t_){
        var _v_ = Make(_u_, _t_);
        return [0,
                _v_[2],
                _v_[3],
                _v_[4],
                _v_[5],
                _v_[6],
                _v_[7],
                _v_[8],
                _v_[9],
                _v_[10],
                _v_[11],
                _v_[12],
                _v_[13],
                _v_[14],
                _v_[15],
                _v_[16],
                _v_[17],
                _v_[18],
                _v_[19],
                _v_[20],
                _v_[21],
                _v_[22],
                _v_[23],
                _v_[24],
                _v_[25],
                _v_[26]];
       },
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       Multi];
   runtime.caml_register_global(36, Univ_map, cst_Univ_map$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1bml2X21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90Iiwic2V4cF9vZl90eXBlX2lkIiwidHlwZV9pZCIsInhfMDAzIiwidHlwZV9pZDEiLCJ0eXBlX2lkMiIsIm5hbWVfb2Zfa2V5Iiwia2V5IiwidWlkX29mX2tleSIsInNleHBfb2ZfdCQwIiwic2V4cF9vZl9hIiwiZGF0YSIsInR5cGVfaWRfbmFtZSIsInR5cGVfaWRfdWlkIiwiY29tcGFyZSIsInQxIiwidDIiLCJjIiwidG9fYWxpc3QiLCJ0Iiwic2V4cF9vZl90JDEiLCJwYWNrZWQiLCJ4XzAwOCIsImFyZzFfMDA1IiwiYXJnMF8wMDQiLCJyZXMwXzAwNiIsInJlczFfMDA3IiwiaW52YXJpYW50IiwieF8wMDkiLCJzZXQiLCJtZW1fYnlfaWQiLCJpZCIsIm1lbSIsInJlbW92ZV9ieV9pZCIsInJlbW92ZSIsImVtcHR5Iiwic2luZ2xldG9uIiwiaXNfZW1wdHkiLCJmaW5kIiwidmFsdWUiLCJrZXkkMCIsImZpbmRfZXhuIiwiYWRkIiwiYWRkX2V4biIsInQkMCIsImNoYW5nZV9leG4iLCJ1cGRhdGUiLCJjaGFuZ2UiLCJvcmlnIiwibmV4dCIsImYiLCJrZXlfaWRfc2V0Iiwib2ZfYWxpc3RfZXhuIiwicCIsImZpbmRfcGFja2VkX2J5X2lkIiwiZmluZF9wYWNrZWRfYnlfaWRfZXhuIiwib2ZfYV8wMTEiLCJvZl9hXzAxMiIsInhfMDEzIiwieF8wMTQiLCJvZl9hXzAxNyIsInR5cGVfZXF1YWwiLCJjcmVhdGUiLCJkZWZhdWx0JDAiLCJuYW1lIiwic2V4cF9vZiIsImZpbmQkMCIsInNldCQwIiwiY2hhbmdlJDAiLCJjcmVhdGUkMCIsImluaXQiLCJpZCQwIiwiZmluZCQxIiwic2V0JDEiLCJjaGFuZ2UkMSIsImFkZCQwIiwiYWNjIiwiY3JlYXRlJDEiLCJ4cyIsIngiLCJpZCQxIiwibWVyZ2UiLCJmJDAiLCJtZXJnZV9yZXN1bHQiLCJyaWdodF9kYXRhIiwicmlnaHRfa2V5IiwibGVmdF9kYXRhIiwibGVmdF9rZXkiLCJkYXRhJDAiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZS91bml2X21hcC91bml2X21hcF9fLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2NvcmUvdW5pdl9tYXAvdW5pdl9tYXAubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FLb0I7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNhaEJBO2FBR0lDLGdCQUFnQkM7Ozs7O01BTXNCO09BQUEsT0FBQSxtQ0FOdEJBO2NBTU47S0FKQTs7O01BQUEsT0FBQSxtQ0FGTUE7OzthQVdoQkEsUUFVYUM7S0FUZjtNQUFJQyxXQUFXLG1CQVNBRDtNQVJYRSxXQUFXLG1CQVFBRjtLQVBaLEdBQUEsbUNBRkNDLFVBQ0FDO01BRUMsT0FIREQ7O2tDQVpGSCxnQkFhRUk7a0NBYkZKLGdCQVlFRzs7MEI7OztzREFTV0Q7Ozs7Ozs7SUFFYztJQTNCcEIsZ0JBQ1hILFdBR0lDLGlCQVdBQzthQWtCRkksWUFBWUM7S0FBeUIsK0JBQXpCQTtLQUF5QixPQUFBO0lBQWlCO2FBQ3REQyxXQUFXRDtLQUF3QiwrQkFBeEJBO0tBQXdCLE9BQUE7SUFBaUI7YUFLbERFLFlBQVVDO0tBQ29DO01BRGpCQztNQUFMSjtNQUNzQiwyQkFEdEJBO01BQ0QsT0FBQTtLQUF6QixPQUFBLG9CQURZRyxpQkFBbUJDOzthQUk3QkMsd0JBQWlCTCxnQkFBVyxPQVY5QkQsWUFVbUJDO2FBQ2pCTSx1QkFBZ0JOLGdCQUFXLE9BVjdCQyxXQVVrQkQ7YUFFaEJPLFFBQVFDLElBQUdDO0tBQ2I7TUFBeUMsT0FKdkNKLGFBR1dJO01BQ1UsT0FKckJKLGFBR1FHO01BQ05F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QUFBQztPQUFBQztPQUFBUjtPQUFBRztPQUFBRjtPQUFBUTtPQUFBRztPQUFBQztPQUFBQztPQUFBSTtPQUFBRjtPQUFBQztPQUFBWjtPQUFBRDs7T0FBQWtCO09BQUFqQztPQUFBa0M7T0FBQUU7T0FBQUM7T0FBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBVbml2X21hcC5Vbml2X21hcF9pbnRmICopXG5tb2R1bGUgVW5pdl9tYXBfaW50ZiA9IFVuaXZfbWFwX19Vbml2X21hcF9pbnRmXG5cbm1vZHVsZSBVbml2X21hcF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBCYXNlXG5pbmNsdWRlIFVuaXZfbWFwX2ludGZcbm1vZHVsZSBVaWQgPSBUeXBlX2VxdWFsLklkLlVpZFxuXG5tb2R1bGUgTWFrZTFcbiAgKEtleSA6IEtleSkgKERhdGEgOiBzaWdcbiAgICB0eXBlICgncywgJ2EpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgKCogQSB3cmFwcGVyIGZvciB0aGUgW0tleV0gbW9kdWxlIHRoYXQgYWRkcyBhIGR5bmFtaWMgY2hlY2sgdG8gW0tleS50eXBlX2lkXS5cblxuICAgICBJdCdzIGEgYnVnIGlmIHRoZSB1c2VyLXByb3ZpZGVkIFtLZXkudHlwZV9pZF0gZ2l2ZXMgZGlmZmVyZW50IHR5cGUgaWRzIG9uIGRpZmZlcmVudFxuICAgICBjYWxscy4gIEJlY2F1c2UgdGhpcyBjaGVjayBzaG91bGQgYmUgZmFpcmx5IGNoZWFwLCB3ZSBkbyBpdCBkeW5hbWljYWxseSB0byBhdm9pZFxuICAgICBzdWJ0bGVyIHByb2JsZW1zIGxhdGVyLlxuXG4gICAgIE9mIGNvdXJzZSwgd2UncmUgbm90IGNoZWNraW5nIHRydWx5IHBhdGhvbG9naWNhbCB0aGluZ3MgbGlrZSB0aGUgcHJvdmlkZWRcbiAgICAgW0tleS50eXBlX2lkXSBvbmx5IGNoYW5nZXMgdGhlIHZhbHVlIGl0IHJldHVybnMgb24gZXZlcnkgdGhpcmQgY2FsbC4uLiAqKVxuICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgS2V5LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgICgqIHRlc3QtZnJpZW5kbHkgc2V4cCBjb252ZXJzaW9uICopXG4gICAgbGV0IHNleHBfb2ZfdHlwZV9pZCB0eXBlX2lkID1cbiAgICAgIFslc2V4cFxuICAgICAgICB7IG5hbWUgPSAoVHlwZV9lcXVhbC5JZC5uYW1lIHR5cGVfaWQgOiBzdHJpbmcpXG4gICAgICAgIDsgdWlkID1cbiAgICAgICAgICAgIChpZiBQcHhfaW5saW5lX3Rlc3RfbGliLmFtX3J1bm5pbmdcbiAgICAgICAgICAgICB0aGVuIFNleHAuQXRvbSBcIjx1aWQ+XCJcbiAgICAgICAgICAgICBlbHNlIFR5cGVfZXF1YWwuSWQuVWlkLnNleHBfb2ZfdCAoVHlwZV9lcXVhbC5JZC51aWQgdHlwZV9pZClcbiAgICAgICAgICAgICAgOiBTZXhwLnQpXG4gICAgICAgIH1dXG4gICAgOztcblxuICAgIGxldCB0eXBlX2lkIGtleSA9XG4gICAgICBsZXQgdHlwZV9pZDEgPSBLZXkudHlwZV9pZCBrZXkgaW5cbiAgICAgIGxldCB0eXBlX2lkMiA9IEtleS50eXBlX2lkIGtleSBpblxuICAgICAgaWYgVHlwZV9lcXVhbC5JZC5zYW1lIHR5cGVfaWQxIHR5cGVfaWQyXG4gICAgICB0aGVuIHR5cGVfaWQxXG4gICAgICBlbHNlXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiW0tleS50eXBlX2lkXSBtdXN0IG5vdCBwcm92aWRlIGRpZmZlcmVudCB0eXBlIGlkcyB3aGVuIGNhbGxlZCBvbiB0aGUgc2FtZSBcXFxuICAgICAgICAgICAgIGlucHV0XCJcbiAgICAgICAgICAgICAgKGtleSA6IF8gS2V5LnQpXG4gICAgICAgICAgICAgICh0eXBlX2lkMSA6IHR5cGVfaWQpXG4gICAgICAgICAgICAgICh0eXBlX2lkMiA6IHR5cGVfaWQpXVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgKCdzLCAnYSkgZGF0YSA9ICgncywgJ2EpIERhdGEudFxuXG4gIGxldCBuYW1lX29mX2tleSBrZXkgPSBUeXBlX2VxdWFsLklkLm5hbWUgKEtleS50eXBlX2lkIGtleSlcbiAgbGV0IHVpZF9vZl9rZXkga2V5ID0gVHlwZV9lcXVhbC5JZC51aWQgKEtleS50eXBlX2lkIGtleSlcblxuICBtb2R1bGUgUGFja2VkID0gc3RydWN0XG4gICAgdHlwZSAncyB0ID0gVCA6ICdhIEtleS50ICogKCdzLCAnYSkgRGF0YS50IC0+ICdzIHRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIChUIChrZXksIGRhdGEpKSA9XG4gICAgICBEYXRhLnNleHBfb2ZfdCBzZXhwX29mX2EgKFR5cGVfZXF1YWwuSWQudG9fc2V4cCAoS2V5LnR5cGVfaWQga2V5KSkgZGF0YVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZV9pZF9uYW1lIChUIChrZXksIF8pKSA9IG5hbWVfb2Zfa2V5IGtleVxuICAgIGxldCB0eXBlX2lkX3VpZCAoVCAoa2V5LCBfKSkgPSB1aWRfb2Zfa2V5IGtleVxuXG4gICAgbGV0IGNvbXBhcmUgdDEgdDIgPVxuICAgICAgbGV0IGMgPSBTdHJpbmcuY29tcGFyZSAodHlwZV9pZF9uYW1lIHQxKSAodHlwZV9pZF9uYW1lIHQyKSBpblxuICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIFVpZC5jb21wYXJlICh0eXBlX2lkX3VpZCB0MSkgKHR5cGVfaWRfdWlkIHQyKVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgJ3MgdCA9ICdzIFBhY2tlZC50IE1hcC5NKFVpZCkudFxuXG4gIGxldCB0b19hbGlzdCB0ID0gTWFwLmRhdGEgdCB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6UGFja2VkLmNvbXBhcmVcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICB0b19hbGlzdCB0XG4gICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBwYWNrZWQgLT4gUGFja2VkLnR5cGVfaWRfbmFtZSBwYWNrZWQsIHBhY2tlZClcbiAgICB8PiBbJXNleHBfb2Y6IChzdHJpbmcgKiBhIFBhY2tlZC50KSBsaXN0XVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgKHQgOiBfIHQpID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgTWFwLml0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGFzc2VydCAoVWlkLmVxdWFsIGtleSAoUGFja2VkLnR5cGVfaWRfdWlkIGRhdGEpKSkpXG4gIDs7XG5cbiAgbGV0IHNldCB0IH5rZXkgfmRhdGEgPSBNYXAuc2V0IHQgfmtleToodWlkX29mX2tleSBrZXkpIH5kYXRhOihQYWNrZWQuVCAoa2V5LCBkYXRhKSlcbiAgbGV0IG1lbV9ieV9pZCB0IGlkID0gTWFwLm1lbSB0IGlkXG4gIGxldCBtZW0gdCBrZXkgPSBtZW1fYnlfaWQgdCAodWlkX29mX2tleSBrZXkpXG4gIGxldCByZW1vdmVfYnlfaWQgdCBpZCA9IE1hcC5yZW1vdmUgdCBpZFxuICBsZXQgcmVtb3ZlIHQga2V5ID0gcmVtb3ZlX2J5X2lkIHQgKHVpZF9vZl9rZXkga2V5KVxuICBsZXQgZW1wdHkgPSBNYXAuZW1wdHkgKG1vZHVsZSBVaWQpXG5cbiAgbGV0IHNpbmdsZXRvbiBrZXkgZGF0YSA9XG4gICAgTWFwLnNpbmdsZXRvbiAobW9kdWxlIFVpZCkgKHVpZF9vZl9rZXkga2V5KSAoUGFja2VkLlQgKGtleSwgZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5ID0gTWFwLmlzX2VtcHR5XG5cbiAgbGV0IGZpbmQgKHR5cGUgYikgdCAoa2V5IDogYiBLZXkudCkgPVxuICAgIG1hdGNoIE1hcC5maW5kIHQgKHVpZF9vZl9rZXkga2V5KSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKFBhY2tlZC5UIChrZXknLCB2YWx1ZSkpIC0+XG4gICAgICAoKiBjYW5ub3QgcmFpc2UgLS0gc2VlIFtpbnZhcmlhbnRdICopXG4gICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgVHlwZV9lcXVhbC5JZC5zYW1lX3dpdG5lc3NfZXhuIChLZXkudHlwZV9pZCBrZXkpIChLZXkudHlwZV9pZCBrZXknKVxuICAgICAgaW5cbiAgICAgIFNvbWUgKHZhbHVlIDogKF8sIGIpIERhdGEudClcbiAgOztcblxuICBsZXQgZmluZF9leG4gdCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICAgIHwgU29tZSBkYXRhIC0+IGRhdGFcbiAgICB8IE5vbmUgLT4gUHJpbnRmLmZhaWx3aXRoZiBcIlVuaXZfbWFwLmZpbmRfZXhuIG9uIHVua25vd24ga2V5ICVzXCIgKG5hbWVfb2Zfa2V5IGtleSkgKClcbiAgOztcblxuICBsZXQgYWRkIHQgfmtleSB+ZGF0YSA9IGlmIG1lbSB0IGtleSB0aGVuIGBEdXBsaWNhdGUgZWxzZSBgT2sgKHNldCB0IH5rZXkgfmRhdGEpXG5cbiAgbGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgICBtYXRjaCBhZGQgdCB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IGBPayB0IC0+IHRcbiAgICB8IGBEdXBsaWNhdGUgLT5cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCJVbml2X21hcC5hZGRfZXhuIG9uIGV4aXN0aW5nIGtleSAlc1wiIChuYW1lX29mX2tleSBrZXkpICgpXG4gIDs7XG5cbiAgbGV0IGNoYW5nZV9leG4gdCBrZXkgfmY6dXBkYXRlID1cbiAgICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgICB8IFNvbWUgZGF0YSAtPiBzZXQgdCB+a2V5IH5kYXRhOih1cGRhdGUgZGF0YSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCJVbml2X21hcC5jaGFuZ2VfZXhuIG9uIHVua25vd24ga2V5ICVzXCIgKG5hbWVfb2Zfa2V5IGtleSkgKClcbiAgOztcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mOnVwZGF0ZSA9XG4gICAgbGV0IG9yaWcgPSBmaW5kIHQga2V5IGluXG4gICAgbGV0IG5leHQgPSB1cGRhdGUgb3JpZyBpblxuICAgIG1hdGNoIG5leHQgd2l0aFxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGFcbiAgICB8IE5vbmUgLT4gaWYgT3B0aW9uLmlzX25vbmUgb3JpZyB0aGVuIHQgZWxzZSByZW1vdmUgdCBrZXlcbiAgOztcblxuICBsZXQgdXBkYXRlIHQga2V5IH5mID0gY2hhbmdlIHQga2V5IH5mOihmdW4gZGF0YSAtPiBTb21lIChmIGRhdGEpKVxuICBsZXQga2V5X2lkX3NldCB0ID0gU2V0Lm9mX2xpc3QgKG1vZHVsZSBVaWQpIChNYXAua2V5cyB0KVxuXG4gIGxldCBvZl9hbGlzdF9leG4gdCA9XG4gICAgTWFwLm9mX2FsaXN0X2V4biAobW9kdWxlIFVpZCkgKExpc3QubWFwIHQgfmY6KGZ1biBwIC0+IFBhY2tlZC50eXBlX2lkX3VpZCBwLCBwKSlcbiAgOztcblxuICBsZXQgZmluZF9wYWNrZWRfYnlfaWQgPSBNYXAuZmluZFxuICBsZXQgZmluZF9wYWNrZWRfYnlfaWRfZXhuID0gTWFwLmZpbmRfZXhuXG4gIGxldCB0eXBlX2VxdWFsIDogKCdzIHQsICdzIFBhY2tlZC50IE1hcC5NKFR5cGVfZXF1YWwuSWQuVWlkKS50KSBUeXBlX2VxdWFsLnQgPSBUXG5lbmRcblxubW9kdWxlIE1ha2VcbiAgKEtleSA6IEtleSkgKERhdGEgOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIE0gPVxuICAgIE1ha2UxXG4gICAgICAoS2V5KVxuICAgICAgKHN0cnVjdFxuICAgICAgICB0eXBlIChfLCAnYSkgdCA9ICdhIERhdGEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgICAgZW5kKVxuXG4gIHR5cGUgdCA9IHVuaXQgTS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbW9kdWxlIEtleSA9IEtleVxuXG4gIHR5cGUgJ2EgZGF0YSA9ICdhIERhdGEudFxuXG4gIGxldCBpbnZhcmlhbnQgPSBNLmludmFyaWFudFxuICBsZXQgZW1wdHkgPSBNLmVtcHR5XG4gIGxldCBzaW5nbGV0b24gPSBNLnNpbmdsZXRvblxuICBsZXQgaXNfZW1wdHkgPSBNLmlzX2VtcHR5XG4gIGxldCBzZXQgPSBNLnNldFxuICBsZXQgbWVtID0gTS5tZW1cbiAgbGV0IG1lbV9ieV9pZCA9IE0ubWVtX2J5X2lkXG4gIGxldCBmaW5kID0gTS5maW5kXG4gIGxldCBmaW5kX2V4biA9IE0uZmluZF9leG5cbiAgbGV0IGFkZCA9IE0uYWRkXG4gIGxldCBhZGRfZXhuID0gTS5hZGRfZXhuXG4gIGxldCBjaGFuZ2UgPSBNLmNoYW5nZVxuICBsZXQgY2hhbmdlX2V4biA9IE0uY2hhbmdlX2V4blxuICBsZXQgdXBkYXRlID0gTS51cGRhdGVcbiAgbGV0IHJlbW92ZSA9IE0ucmVtb3ZlXG4gIGxldCByZW1vdmVfYnlfaWQgPSBNLnJlbW92ZV9ieV9pZFxuXG4gIG1vZHVsZSBQYWNrZWQgPSBzdHJ1Y3RcbiAgICB0eXBlICdzIHQxID0gJ3MgTS5QYWNrZWQudCA9IFQgOiAnYSBLZXkudCAqICdhIERhdGEudCAtPiAncyB0MVxuICAgIHR5cGUgdCA9IHVuaXQgdDFcbiAgZW5kXG5cbiAgbGV0IGtleV9pZF9zZXQgPSBNLmtleV9pZF9zZXRcbiAgbGV0IHRvX2FsaXN0ID0gTS50b19hbGlzdFxuICBsZXQgb2ZfYWxpc3RfZXhuID0gTS5vZl9hbGlzdF9leG5cbiAgbGV0IGZpbmRfcGFja2VkX2J5X2lkID0gTS5maW5kX3BhY2tlZF9ieV9pZFxuICBsZXQgZmluZF9wYWNrZWRfYnlfaWRfZXhuID0gTS5maW5kX3BhY2tlZF9ieV9pZF9leG5cbiAgbGV0IHR5cGVfZXF1YWwgOiAodCwgUGFja2VkLnQgTWFwLk0oVHlwZV9lcXVhbC5JZC5VaWQpLnQpIFR5cGVfZXF1YWwudCA9IFRcbmVuZFxuXG5tb2R1bGUgTWVyZ2UgKEtleSA6IEtleSkgKElucHV0MV9kYXRhIDogRGF0YSkgKElucHV0Ml9kYXRhIDogRGF0YSkgKE91dHB1dF9kYXRhIDogRGF0YSkgPVxuc3RydWN0XG4gIHR5cGUgZiA9XG4gICAgeyBmIDpcbiAgICAgICAgJ2EuXG4gICAgICAgIGtleTonYSBLZXkudFxuICAgICAgICAtPiBbIGBMZWZ0IG9mICdhIElucHV0MV9kYXRhLnRcbiAgICAgICAgICAgfCBgUmlnaHQgb2YgJ2EgSW5wdXQyX2RhdGEudFxuICAgICAgICAgICB8IGBCb3RoIG9mICdhIElucHV0MV9kYXRhLnQgKiAnYSBJbnB1dDJfZGF0YS50XG4gICAgICAgICAgIF1cbiAgICAgICAgLT4gJ2EgT3V0cHV0X2RhdGEudCBvcHRpb25cbiAgICB9XG5cbiAgbW9kdWxlIE91dHB1dCA9IE1ha2UgKEtleSkgKE91dHB1dF9kYXRhKVxuXG4gIGxldCBtZXJnZSAodDEgOiBNYWtlKEtleSkoSW5wdXQxX2RhdGEpLnQpICh0MiA6IE1ha2UoS2V5KShJbnB1dDJfZGF0YSkudCkgfmY6eyBmIH1cbiAgICA6IE1ha2UoS2V5KShPdXRwdXRfZGF0YSkudFxuICAgID1cbiAgICBsZXQgZiB+a2V5IG1lcmdlX3Jlc3VsdCA9XG4gICAgICBPcHRpb24ubWFwIChmIH5rZXkgbWVyZ2VfcmVzdWx0KSB+ZjooZnVuIGRhdGEgLT4gT3V0cHV0Lk0uUGFja2VkLlQgKGtleSwgZGF0YSkpXG4gICAgaW5cbiAgICBNYXAubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gLT4gZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgKFQgKGtleSwgZGF0YSkpIC0+IGYgfmtleSAoYExlZnQgZGF0YSlcbiAgICAgIHwgYFJpZ2h0IChUIChrZXksIGRhdGEpKSAtPiBmIH5rZXkgKGBSaWdodCBkYXRhKVxuICAgICAgfCBgQm90aCAoVCAobGVmdF9rZXksIGxlZnRfZGF0YSksIFQgKHJpZ2h0X2tleSwgcmlnaHRfZGF0YSkpIC0+XG4gICAgICAgICgqIENhbid0IHJhaXNlIGR1ZSB0byB0aGUgaW52YXJpYW50ICopXG4gICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biAoS2V5LnR5cGVfaWQgbGVmdF9rZXkpIChLZXkudHlwZV9pZCByaWdodF9rZXkpXG4gICAgICAgIGluXG4gICAgICAgIGYgfmtleTpsZWZ0X2tleSAoYEJvdGggKGxlZnRfZGF0YSwgcmlnaHRfZGF0YSkpKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNZXJnZTFcbiAgKEtleSA6IEtleSlcbiAgKElucHV0MV9kYXRhIDogRGF0YTEpXG4gIChJbnB1dDJfZGF0YSA6IERhdGExKVxuICAoT3V0cHV0X2RhdGEgOiBEYXRhMSkgPVxuc3RydWN0XG4gIHR5cGUgKCdzMSwgJ3MyLCAnczMpIGYgPVxuICAgIHsgZiA6XG4gICAgICAgICdhLlxuICAgICAgICBrZXk6J2EgS2V5LnRcbiAgICAgICAgLT4gWyBgTGVmdCBvZiAoJ3MxLCAnYSkgSW5wdXQxX2RhdGEudFxuICAgICAgICAgICB8IGBSaWdodCBvZiAoJ3MyLCAnYSkgSW5wdXQyX2RhdGEudFxuICAgICAgICAgICB8IGBCb3RoIG9mICgnczEsICdhKSBJbnB1dDFfZGF0YS50ICogKCdzMiwgJ2EpIElucHV0Ml9kYXRhLnRcbiAgICAgICAgICAgXVxuICAgICAgICAtPiAoJ3MzLCAnYSkgT3V0cHV0X2RhdGEudCBvcHRpb25cbiAgICB9XG5cbiAgbW9kdWxlIE91dHB1dCA9IE1ha2UxIChLZXkpIChPdXRwdXRfZGF0YSlcblxuICBsZXQgbWVyZ2VcbiAgICAodHlwZSBzMSBzMilcbiAgICAodDEgOiBzMSBNYWtlMShLZXkpKElucHV0MV9kYXRhKS50KVxuICAgICh0MiA6IHMyIE1ha2UxKEtleSkoSW5wdXQyX2RhdGEpLnQpXG4gICAgfmY6eyBmIH1cbiAgICA9XG4gICAgbGV0IGYgfmtleSBtZXJnZV9yZXN1bHQgPVxuICAgICAgT3B0aW9uLm1hcCAoZiB+a2V5IG1lcmdlX3Jlc3VsdCkgfmY6KGZ1biBkYXRhIC0+IE91dHB1dC5QYWNrZWQuVCAoa2V5LCBkYXRhKSlcbiAgICBpblxuICAgIE1hcC5tZXJnZSB0MSB0MiB+ZjooZnVuIH5rZXk6XyAtPiBmdW5jdGlvblxuICAgICAgfCBgTGVmdCAoVCAoa2V5LCBkYXRhKSkgLT4gZiB+a2V5IChgTGVmdCBkYXRhKVxuICAgICAgfCBgUmlnaHQgKFQgKGtleSwgZGF0YSkpIC0+IGYgfmtleSAoYFJpZ2h0IGRhdGEpXG4gICAgICB8IGBCb3RoIChUIChsZWZ0X2tleSwgbGVmdF9kYXRhKSwgVCAocmlnaHRfa2V5LCByaWdodF9kYXRhKSkgLT5cbiAgICAgICAgKCogQ2FuJ3QgcmFpc2UgZHVlIHRvIHRoZSBpbnZhcmlhbnQgKilcbiAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5JZC5zYW1lX3dpdG5lc3NfZXhuIChLZXkudHlwZV9pZCBsZWZ0X2tleSkgKEtleS50eXBlX2lkIHJpZ2h0X2tleSlcbiAgICAgICAgaW5cbiAgICAgICAgZiB+a2V5OmxlZnRfa2V5IChgQm90aCAobGVmdF9kYXRhLCByaWdodF9kYXRhKSkpXG4gIDs7XG5lbmRcblxubW9kdWxlIFR5cGVfaWRfa2V5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFR5cGVfZXF1YWwuSWQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCB0eXBlX2lkID0gRm4uaWRcbmVuZFxuXG5pbmNsdWRlIChcbiAgTWFrZVxuICAgIChUeXBlX2lkX2tleSlcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZCkgOlxuICAgICAgUyB3aXRoIHR5cGUgJ2EgZGF0YSA9ICdhIGFuZCBtb2R1bGUgS2V5IDo9IFR5cGVfaWRfa2V5KVxuXG5tb2R1bGUgS2V5ID0gVHlwZV9lcXVhbC5JZFxuXG5tb2R1bGUgV2l0aF9kZWZhdWx0ID0gc3RydWN0XG4gIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBrZXkgOiAnYSBUeXBlX2VxdWFsLklkLnRcbiAgICAgIDsgZGVmYXVsdCA6ICdhXG4gICAgICB9XG5cbiAgICBsZXQgY3JlYXRlIH5kZWZhdWx0IH5uYW1lIHNleHBfb2YgPVxuICAgICAgeyBkZWZhdWx0OyBrZXkgPSBUeXBlX2VxdWFsLklkLmNyZWF0ZSB+bmFtZSBzZXhwX29mIH1cbiAgICA7O1xuXG4gICAgbGV0IGlkIHQgPSB0LmtleVxuICBlbmRcblxuICBsZXQgZmluZCB0IHsgS2V5LmtleTsgZGVmYXVsdCB9ID0gT3B0aW9uLnZhbHVlIH5kZWZhdWx0IChmaW5kIHQga2V5KVxuICBsZXQgc2V0IHQgfmtleTp7IEtleS5rZXk7IGRlZmF1bHQgPSBfIH0gfmRhdGEgPSBzZXQgdCB+a2V5IH5kYXRhXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmY6dXBkYXRlID0gc2V0IHQgfmtleSB+ZGF0YToodXBkYXRlIChmaW5kIHQga2V5KSlcbmVuZFxuXG5tb2R1bGUgV2l0aF9mb2xkID0gc3RydWN0XG4gIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgICAgeyBrZXkgOiAnYiBXaXRoX2RlZmF1bHQuS2V5LnRcbiAgICAgIDsgZiA6ICdiIC0+ICdhIC0+ICdiXG4gICAgICB9XG5cbiAgICBsZXQgY3JlYXRlIH5pbml0IH5mIH5uYW1lIHNleHBfb2YgPVxuICAgICAgeyBmOyBrZXkgPSBXaXRoX2RlZmF1bHQuS2V5LmNyZWF0ZSB+ZGVmYXVsdDppbml0IH5uYW1lIHNleHBfb2YgfVxuICAgIDs7XG5cbiAgICBsZXQgaWQgdCA9IFdpdGhfZGVmYXVsdC5LZXkuaWQgdC5rZXlcbiAgZW5kXG5cbiAgbGV0IGZpbmQgdCB7IEtleS5rZXk7IGYgPSBfIH0gPSBXaXRoX2RlZmF1bHQuZmluZCB0IGtleVxuICBsZXQgc2V0IHQgfmtleTp7IEtleS5rZXk7IGYgPSBfIH0gfmRhdGEgPSBXaXRoX2RlZmF1bHQuc2V0IHQgfmtleSB+ZGF0YVxuICBsZXQgY2hhbmdlIHQgeyBLZXkua2V5OyBmID0gXyB9IH5mOnVwZGF0ZSA9IFdpdGhfZGVmYXVsdC5jaGFuZ2UgdCBrZXkgfmY6dXBkYXRlXG5cbiAgbGV0IGFkZCB0IH5rZXk6eyBLZXkua2V5OyBmIH0gfmRhdGEgPVxuICAgIFdpdGhfZGVmYXVsdC5jaGFuZ2UgdCBrZXkgfmY6KGZ1biBhY2MgLT4gZiBhY2MgZGF0YSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgTXVsdGkgPSBzdHJ1Y3RcbiAgb3BlbiBXaXRoX2ZvbGRcblxuICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gKCdhLCAnYSBsaXN0KSBLZXkudFxuXG4gICAgbGV0IGNyZWF0ZSB+bmFtZSBzZXhwX29mID1cbiAgICAgIEtleS5jcmVhdGUgfmluaXQ6W10gfmY6KGZ1biB4cyB4IC0+IHggOjogeHMpIH5uYW1lIChMaXN0LnNleHBfb2ZfdCBzZXhwX29mKVxuICAgIDs7XG5cbiAgICBsZXQgaWQgPSBXaXRoX2ZvbGQuS2V5LmlkXG4gIGVuZFxuXG4gIGxldCBzZXQgPSBzZXRcbiAgbGV0IGZpbmQgPSBmaW5kXG4gIGxldCBhZGQgPSBhZGRcbiAgbGV0IGNoYW5nZSA9IGNoYW5nZVxuZW5kXG4iXX0=
