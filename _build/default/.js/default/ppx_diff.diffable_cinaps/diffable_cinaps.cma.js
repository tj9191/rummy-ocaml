// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Diffable_cinaps__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Diffable_cinaps = [0],
    Diffable_cinaps$0 = [0, Diffable_cinaps];
   runtime.caml_register_global(0, Diffable_cinaps$0, "Diffable_cinaps__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Diffable_cinaps__Tuple_helpers
//# unitInfo: Requires: Base, Base__List, Base__Printf, Base__String, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Ppx_string_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst$45 = "\n",
    cst$39 = "\n\n",
    cst$48 = "\n\n        ",
    cst_module$6 = "\n\n        module ",
    cst_type$6 = "\n\n      type ",
    cst$47 = "\n          ",
    cst_open$2 = "\n          open ",
    cst_end_module$1 = "\n      end\n\n      module ",
    cst_module$7 = "\n      module ",
    cst_type$7 = "\n      type ",
    cst_module$8 = "\n    module ",
    cst$50 = "\n -> ",
    cst$41 = " ",
    cst$52 = " * ",
    cst$49 = " -> ",
    cst_local$4 = " -> local_ ",
    cst_to$3 = " -> to_: ",
    cst_sig$4 = " : sig\n        ",
    cst$51 = " = ",
    cst_struct$4 = " = struct\n        ",
    cst_Optional_diff_t$2 = " Optional_diff.t)",
    cst_deriving_sexp_bin_io$1 = " [@@deriving sexp, bin_io]",
    cst_list_local$1 = " list -> local_ ",
    cst_with_None_diff_Some_d$2 =
      " with\n               | None -> diff\n               | Some d -> ",
    cst$42 = "(",
    cst$40 = ")",
    cst$44 = ", ",
    cst_Variants_to_rank_t1$1 = ".Variants.to_rank t1) (",
    cst_t$4 = ".t",
    cst$46 = "?",
    cst_Diffable_cinaps_Tuple_help$0 = "Diffable_cinaps__Tuple_helpers",
    cst_exn = "_exn",
    cst_derived_on$1 = "derived_on",
    cst_diffable_cinaps$0 = "diffable_cinaps",
    cst_lib_cinaps_tuple_helpers_m = "lib/cinaps/tuple_helpers.ml",
    cst_local$3 = "local_ ",
    cst_t$3 = "t";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$40,
    cst$33 = cst$41,
    cst$34 = cst$42,
    cst$31 = cst$43,
    cst$30 = "\n          | _ :: _ -> ",
    cst$29 = "\n      | ",
    cst$27 = cst$46,
    cst$28 = "~",
    cst$26 = cst$41,
    cst$35 = cst$47,
    cst$36 = " =\n           ",
    cst$37 = " () =\n          ",
    cst$38 = cst$48,
    cst$21 = cst$44,
    cst$19 = ":",
    cst$20 = cst$46,
    cst$15 = cst$49,
    cst$16 = cst$49,
    cst$17 = cst$49,
    cst$18 = cst$49,
    cst$14 = cst$42,
    cst$10 = cst$40,
    cst$11 = cst$49,
    cst$12 = cst$49,
    cst$13 = cst$42,
    cst$22 = cst$47,
    cst$23 = cst$49,
    cst$24 = cst$49,
    cst$25 = cst$48,
    cst$8 = cst$51,
    cst$9 = cst$51,
    cst$7 = cst$51,
    cst$6 = cst$43,
    cst$0 = cst$43,
    cst$1 = cst$41,
    cst$2 = " =",
    cst$3 = " =\n          ",
    cst$4 = cst$41,
    cst$5 = cst$51,
    cst = cst$51,
    diff_module_name = "Diff",
    entry_diff_module_name = "Entry_diff",
    for_inlined_tuple_module_name = "For_inlined_tuple",
    max_supported =
      [0, 6, [0, cst_lib_cinaps_tuple_helpers_m, 334, 11197, 11220]],
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Ppx_string_runtime = global_data.Ppx_string_runtime,
    Base_Printf = global_data.Base__Printf,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Diffable_cinaps_Tuple_help$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_diffable_cinaps$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_lib_cinaps_tuple_helpers_m);
   caml_call2
    (Ppx_inline_test_lib[6], cst_diffable_cinaps$0, "tuple_helpers.ml");
   var
    _U_ = [0, cst$39],
    _T_ = [0, cst$39],
    cst_Variants = ".Variants.",
    _N_ = [0, [12, 95, [2, 0, 0]], "_%s"],
    cst_local$2 = cst_local$3,
    cst_failwith_BUG_non_empty_dif =
      'failwith "BUG: non-empty diff after apply"\n        ',
    _F_ = [0, ","],
    cst_match_diff_with = "\n          match diff with\n          | [] -> ",
    _G_ = [0, cst$43],
    cst_derived_on_in = " = derived_on in\n          ",
    _H_ = [0, cst$44],
    cst_derived_on_diff_let = " derived_on diff =\n          let ",
    _I_ = [0, cst$41],
    cst_match_diff_with_local_Opti =
      "\n            match diff with\n            | [] -> local_ Optional_diff.none\n            | _ :: _ -> local_ Optional_diff.return diff)\n\n\n        let apply_exn ",
    _J_ = [0, cst$43],
    cst_to_in_let_diff_in =
      " = to_ in\n            let diff = [] in\n            ",
    _K_ = [0, cst$44],
    cst_from_in_let = " = from in\n            let ",
    _L_ = [0, cst$44],
    cst_from_to_if_Base_phys_equal =
      " ~from ~to_ =\n          if Base.phys_equal from to_\n          then local_ Optional_diff.none\n          else (\n            let ",
    _M_ = [0, cst$41],
    cst_let_get = "\n        let get ",
    cst_d_acc_tl = " d :: acc) tl)\n         ",
    cst_d_ds_with_None_loop_acc_tl =
      " (d :: ds) with\n         | None -> loop acc tl\n         | Some d -> loop (",
    cst_x_x_assert_false_in_match_ =
      " x -> x\n          | _ -> assert false)\n        in\n        (match%optional.Optional_diff ",
    cst_true_false_in_let_ds_List_ =
      " _ -> true\n          | _ -> false)\n        in\n        let ds = List.map ds ~f:(function\n          | ",
    cst_d_tl_let_ds_tl_List_split_ =
      " d :: tl ->\n        let ds, tl = List.split_while tl ~f:(function\n          | ",
    cst_d_diff = " d :: diff\n            ",
    cst_with_None_diff_Some_d$0 = cst_with_None_diff_Some_d$2,
    cst_match_optional_Optional_di = " match%optional.Optional_diff ",
    cst_d_diff$0 = " d :: diff\n           ",
    cst_with_None_diff_Some_d$1 = cst_with_None_diff_Some_d$2,
    cst_match = " match ",
    cst_in = "\n          in\n        ",
    cst_let_diff = "let diff =\n            ",
    cst_diff$0 = "\n      diff",
    _E_ = [0, cst$45],
    cst_let_diff_in = "let diff = [] in\n      ",
    _D_ = [0, cst$41],
    cst_d_diff_in = " d :: diff\n          in\n       ",
    cst_with_None_diff_Some_d =
      " with\n            | None -> diff\n            | Some d -> ",
    cst_to$2 = " ~to_:",
    cst_from$2 = " ~from:",
    cst_let_diff_match_optional_Op =
      " let diff =\n            match%optional.Optional_diff ",
    cst_diff_in = ", diff\n         in\n         ",
    cst_d_tl = " d, tl\n          | _ -> ",
    cst_d_tl$0 = " d :: tl -> ",
    cst_diff_match_diff_with =
      ", diff =\n           match diff with\n          | ",
    cst_let = " let ",
    _y_ = [0, [2, 0, [4, 3, 0, 0, 0]], "%s%i"],
    _z_ = [0, [11, "{Gel.g = ", [2, 0, [12, 125, 0]]], "{Gel.g = %s}"],
    _v_ = [0, [11, "get", [4, 3, 0, 0, 0]], "get%i"],
    _w_ = [0, [11, "apply", [4, 3, 0, 0, [11, cst_exn, 0]]], "apply%i_exn"],
    _x_ =
      [0, [11, "of_list", [4, 3, 0, 0, [11, cst_exn, 0]]], "of_list%i_exn"],
    cst_from$1 = "from_",
    cst_to$1 = "to_",
    cst_derived_on$0 = cst_derived_on$1,
    cst_t$2 = cst_t$3,
    _A_ =
      [0,
       [12, 97, [4, 3, 0, 0, [11, "_diff_of_sexp", 0]]],
       "a%i_diff_of_sexp"],
    _B_ = [0, [12, 97, [4, 3, 0, 0, [11, "_of_sexp", 0]]], "a%i_of_sexp"],
    _C_ = [0, cst$41],
    _O_ = [0, cst$41],
    cst_in_local_Optional_diff_ret =
      "\n            in\n            local_ Optional_diff.return (loop [] diff)\n         ",
    _P_ = [0, cst$45],
    cst_ts_match_ts_with_local_Opt =
      " ts =\n        match ts with\n        | [] -> local_ Optional_diff.none\n        | _ :: _ ->\n          match List.concat ts |> List.stable_sort ~compare:compare_rank with\n          | [] -> local_ Optional_diff.return []\n          | _ :: _ as diff ->\n            let rec loop acc = function\n              | [] -> List.rev acc\n               ",
    cst_let_of_list_exn = "\n      let of_list_exn ",
    cst_let_of_list_exn_of_list_ex =
      "\n\n          let of_list_exn = of_list_exn\n        end\n      end\n    end\n       ",
    cst_open$0 = cst_open$2,
    cst_open$1 = cst_open$2,
    cst_struct$0 = " = struct\n          ",
    cst_module$3 = cst_module$6,
    cst_struct$1 = cst_struct$4,
    cst_end_module$0 = cst_end_module$1,
    cst_let_create_of_variants = "\n\n        let create_of_variants ",
    cst_Variants_to_name_dup_let_c =
      ".Variants.to_name dup)\n\n        let create ",
    cst_sexp_List_sort_compare_com =
      ' sexp |> List.sort ~compare:compare_rank in\n          match List.find_consecutive_duplicate l ~equal:equal_rank with\n          | None -> l\n          | Some (dup, _) ->\n           failwith ("Duplicate entry in tuple diff: " ^ ',
    cst_sexp_let_l_t_of_sexp = " sexp =\n          let l = t_of_sexp ",
    cst_let_singleton_entry_diff_e =
      "\n\n        let singleton entry_diff = [entry_diff]\n\n        let t_of_sexp ",
    cst_Variants_to_rank_t2 = ".Variants.to_rank t2)\n        ;;\n\n        ",
    cst_Variants_to_rank_t1 = cst_Variants_to_rank_t1$1,
    cst_Variants_to_rank_t2_let_eq =
      ".Variants.to_rank t2)\n        ;;\n\n        let equal_rank t1 t2 =\n          Int.equal (",
    cst_Variants_to_rank_t1$0 = cst_Variants_to_rank_t1$1,
    cst_let_compare_rank_t1_t2_Int =
      "\n\n        let compare_rank t1 t2 =\n          Int.compare (",
    cst_struct$2 = cst_struct$4,
    cst_module$4 = cst_module$7,
    cst_struct$3 = " = struct\n      ",
    cst_module$5 = cst_module$8,
    cst_Of_variant_t = ") Of_variant.t) ",
    cst_local$1 = ":local_ ((",
    _t_ = [0, cst$49],
    _s_ = [0, [11, cst_local$3, [2, 0, 0]], "local_ %s"],
    cst_Optional_diff_t$1 = " Optional_diff.t\n         ",
    cst_list_local$0 = cst_list_local$1,
    cst_val_of_list_exn = "\n\n        val of_list_exn : ",
    cst_Optional_diff_t_val_apply_ =
      " Optional_diff.t\n\n        val apply_exn : ",
    cst_local$0 = cst_local$4,
    cst_to$0 = cst_to$3,
    cst_from$0 = " -> from: ",
    cst_val_get = "\n        val get : ",
    cst_Optional_diff_t$0 = cst_Optional_diff_t$2,
    cst_list_local = cst_list_local$1,
    cst_Optional_diff_t = cst_Optional_diff_t$2,
    cst_local = cst_local$4,
    cst_to = cst_to$3,
    cst_from = "(from: ",
    _p_ = [0, cst$50],
    _q_ = [0, cst$50],
    _r_ = [0, cst$50],
    _u_ = [0, cst$49],
    cst_end_end_end = "\n        end\n      end\n    end\n       ",
    cst_sig$0 = " : sig\n          ",
    cst_module$0 = cst_module$6,
    cst_sig$1 = cst_sig$4,
    cst_end_module = cst_end_module$1,
    cst_val_create_of_variants = "\n\n        val create_of_variants : ",
    cst_unit = " -> unit -> ",
    cst_val_create = "\n\n        val create : ",
    cst_val_singleton = "\n\n        val singleton : ",
    cst_sig$2 = cst_sig$4,
    cst_module$1 = cst_module$7,
    cst_sig$3 = " : sig\n      ",
    cst_module$2 = cst_module$8,
    cst_deriving_sexp_bin_io_quick =
      " [@@deriving sexp, bin_io, quickcheck]\n  ",
    cst_type$4 = cst_type$6,
    cst_type$5 = cst_type$7,
    cst_deriving_sexp_bin_io$0 = cst_deriving_sexp_bin_io$1,
    _o_ = [0, cst$52],
    cst_type$3 = " type ",
    _m_ = [0, [11, "| ", [2, 0, [11, " of ", [2, 0, 0]]]], "| %s of %s"],
    _n_ = [0, cst$45],
    cst_private = " private",
    cst_open = "open ",
    cst_list_deriving_sexp_bin_io_ =
      " list [@@deriving sexp, bin_io, quickcheck]\n\n",
    cst_type$0 = cst_type$6,
    cst_deriving_variants_sexp_bin =
      "\n        [@@deriving variants, sexp, bin_io, quickcheck]\n      end\n      ",
    cst_type$1 = "\n        type ",
    cst_sig = ": sig",
    cst_struct = "= struct",
    cst_module = "\n\n      module ",
    cst_type$2 = cst_type$7,
    _l_ = [0, cst$52],
    cst_deriving_sexp_bin_io = cst_deriving_sexp_bin_io$1,
    cst_type = "type ",
    _e_ = [0, cst$44],
    _f_ = [0, [12, 40, [2, 0, [11, ") ", [2, 0, 0]]]], "(%s) %s"],
    _d_ = [0, [2, 0, [11, " Gel.t", 0]], "%s Gel.t"],
    _c_ = [0, [12, 116, [4, 3, 0, 0, 0]], "t%i"],
    cst_diff = "_diff",
    _b_ = [0, [11, "'a", [4, 3, 0, 0, 0]], "'a%i"],
    _a_ = [0, [11, "Tuple", [4, 3, 0, 0, 0]], "Tuple%i"],
    cst_t = cst_t$3,
    cst_derived_on = cst_derived_on$1,
    cst_t$0 = cst_t$4,
    cst_t$1 = cst_t$3,
    _i_ = [0, [2, 0, [11, cst_t$4, 0]], "%s.t"],
    _k_ = [0, [12, 84, [4, 3, 0, 0, 0]], "T%i"],
    _R_ = [0, 104758188],
    _S_ = [0, 104758188],
    cst_diffable_cinaps = cst_diffable_cinaps$0,
    cst_Diffable_cinaps_Tuple_help = cst_Diffable_cinaps_Tuple_help$0;
   function module_name(size){return caml_call2(Base_Printf[2], _a_, size);}
   function nums(size){
    function _ey_(_ez_){return 1 + _ez_ | 0;}
    return caml_call2(Base_List[40], size, _ey_);
   }
   function var$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function diff_var(i){
    var _ex_ = var$0(i);
    return caml_call2(Base[241], _ex_, cst_diff);
   }
   function create_arg(i){return caml_call2(Base_Printf[2], _c_, i);}
   function gel(i){
    var _ew_ = var$0(i);
    return caml_call2(Base_Printf[2], _d_, _ew_);
   }
   function vars(size){
    var _ev_ = nums(size);
    return caml_call2(Base_List[53], _ev_, var$0);
   }
   function diff_vars(size){
    var
     _es_ = nums(size),
     _et_ = caml_call2(Base_List[53], _es_, diff_var),
     _eu_ = vars(size);
    return caml_call2(Base[222], _eu_, _et_);
   }
   function type(name, vars, size){
    var
     _eq_ = caml_call1(vars, size),
     _er_ = caml_call2(Base_String[68], _e_, _eq_);
    return caml_call3(Base_Printf[2], _f_, _er_, name);
   }
   function t_type(_ep_){return type(cst_t, vars, _ep_);}
   function derived_on_type(_eo_){return type(cst_derived_on, vars, _eo_);}
   var
    _g_ =
      [0,
       entry_diff_module_name,
       [0, caml_call1(Ppx_string_runtime[1][2], cst_t$0), 0]],
    _h_ = caml_call1(Ppx_string_runtime[1][4], _g_);
   function entry_diff_type(_en_){return type(_h_, diff_vars, _en_);}
   function diff_type(_em_){return type(cst_t$1, diff_vars, _em_);}
   var
    _j_ = caml_call2(Base_Printf[2], _i_, diff_module_name),
    variant_name = caml_call1(Base_Printf[2], _k_);
   function type_declaration(size){
    var
     _eh_ = vars(size),
     tuple = caml_call2(Base_String[68], _l_, _eh_),
     _ei_ =
       [0,
        tuple,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_deriving_sexp_bin_io), 0]],
     _ej_ = [0, caml_call1(Ppx_string_runtime[1][2], cst), _ei_],
     _ek_ = [0, t_type(size), _ej_],
     _el_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type), _ek_];
    return caml_call1(Ppx_string_runtime[1][4], _el_);
   }
   function diff_type_declarations(size, signature){
    var maybe_private = signature ? cst_private : cst$6;
    if(signature)
     var maybe_open_entry_diff = cst$0;
    else
     var
      _ee_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_open),
         [0, entry_diff_module_name, 0]],
      maybe_open_entry_diff = caml_call1(Ppx_string_runtime[1][4], _ee_);
    var
     _dY_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_list_deriving_sexp_bin_io_),
        0],
     _dZ_ = [0, entry_diff_type(size), _dY_],
     _d0_ =
       [0,
        maybe_private,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$1), _dZ_]],
     _d1_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$2), _d0_],
     _d2_ = [0, diff_type(size), _d1_],
     _d3_ =
       [0,
        maybe_open_entry_diff,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_type$0), _d2_]],
     _d4_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_deriving_variants_sexp_bin),
        _d3_];
    function _dV_(i){
     var _ef_ = diff_var(i), _eg_ = caml_call1(variant_name, i);
     return caml_call3(Base_Printf[2], _m_, _eg_, _ef_);
    }
    var
     _dW_ = nums(size),
     _dX_ = caml_call2(Base_List[53], _dW_, _dV_),
     _d5_ = [0, caml_call2(Base_String[68], _n_, _dX_), _d4_],
     _d6_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$3), _d5_],
     _d7_ = [0, diff_type(size), _d6_],
     _d8_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$1), _d7_],
     _d9_ = signature ? cst_sig : cst_struct,
     _d__ =
       [0,
        entry_diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$4), [0, _d9_, _d8_]]],
     _d$_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module), _d__],
     _ea_ = [0, t_type(size), _d$_],
     _eb_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$5), _ea_],
     _ec_ = [0, derived_on_type(size), _eb_],
     _ed_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$2), _ec_];
    return caml_call1(Ppx_string_runtime[1][4], _ed_);
   }
   function for_inlined_tuple_type_declara(size){
    var
     _dO_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_deriving_sexp_bin_io$0),
        0],
     _dP_ = nums(size),
     _dQ_ = caml_call2(Base_List[53], _dP_, gel),
     _dR_ = [0, caml_call2(Base_String[68], _o_, _dQ_), _dO_],
     _dS_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$7), _dR_],
     _dT_ = [0, t_type(size), _dS_],
     _dU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$3), _dT_];
    return caml_call1(Ppx_string_runtime[1][4], _dU_);
   }
   function for_inlined_tuple_diff_type_de(size){
    var
     _dF_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_deriving_sexp_bin_io_quick),
        0],
     _dG_ = [0, type(_j_, diff_vars, size), _dF_],
     _dH_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$8), _dG_],
     _dI_ = [0, diff_type(size), _dH_],
     _dJ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$4), _dI_],
     _dK_ = [0, t_type(size), _dJ_],
     _dL_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$9), _dK_],
     _dM_ = [0, derived_on_type(size), _dL_],
     _dN_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_type$5), _dM_];
    return caml_call1(Ppx_string_runtime[1][4], _dN_);
   }
   function tuple_mli(size){
    var
     nums$0 = nums(size),
     derived_on_type$0 = derived_on_type(size),
     diff_type$0 = diff_type(size);
    function _cr_(i){
     var
      _dy_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t), 0],
      _dz_ = [0, diff_var(i), _dy_],
      _dA_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_local), _dz_],
      _dB_ = [0, var$0(i), _dA_],
      _dC_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_to), _dB_],
      _dD_ = [0, var$0(i), _dC_],
      _dE_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_from), _dD_];
     return caml_call1(Ppx_string_runtime[1][4], _dE_);
    }
    var
     _cs_ = caml_call2(Base_List[53], nums$0, _cr_),
     get_functions = caml_call2(Base_String[68], _p_, _cs_);
    function _ct_(i){
     var
      _dr_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$10), 0],
      _ds_ = [0, var$0(i), _dr_],
      _dt_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$11), _ds_],
      _du_ = [0, diff_var(i), _dt_],
      _dv_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$12), _du_],
      _dw_ = [0, var$0(i), _dv_],
      _dx_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$13), _dw_];
     return caml_call1(Ppx_string_runtime[1][4], _dx_);
    }
    var
     apply_functions = caml_call2(Base_List[53], nums$0, _ct_),
     apply_functions$0 = caml_call2(Base_String[68], _q_, apply_functions);
    function _cu_(i){
     var
      _dm_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t$0), 0],
      _dn_ = [0, diff_var(i), _dm_],
      _do_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_list_local), _dn_],
      _dp_ = [0, diff_var(i), _do_],
      _dq_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$14), _dp_];
     return caml_call1(Ppx_string_runtime[1][4], _dq_);
    }
    var of_list_functions = caml_call2(Base_List[53], nums$0, _cu_);
    function _cv_(param){
     var y = param[2], x = param[1];
     return [0, x, [0, y, 0]];
    }
    var
     _cw_ = caml_call2(Base_List[110], of_list_functions, apply_functions),
     _cx_ = caml_call2(Base_List[14], _cw_, _cv_),
     of_list_and_apply_functions = caml_call2(Base_String[68], _r_, _cx_);
    function function_declarations(local){
     var
      derived_on_type =
        local
         ? caml_call2(Base_Printf[2], _s_, derived_on_type$0)
         : derived_on_type$0,
      _da_ =
        [0,
         diff_type$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t$1), 0]],
      _db_ =
        [0,
         diff_type$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_list_local$0), _da_]],
      _dc_ =
        [0,
         of_list_and_apply_functions,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$15), _db_]],
      _dd_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_val_of_list_exn), _dc_]],
      _de_ =
        [0,
         diff_type$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$16), _dd_]],
      _df_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$17), _de_]],
      _dg_ =
        [0,
         apply_functions$0,
         [0, caml_call1(Ppx_string_runtime[1][2], cst$18), _df_]],
      _dh_ =
        [0,
         diff_type$0,
         [0,
          caml_call1(Ppx_string_runtime[1][2], cst_Optional_diff_t_val_apply_),
          _dg_]],
      _di_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_local$0), _dh_]],
      _dj_ =
        [0,
         derived_on_type,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_to$0), _di_]],
      _dk_ =
        [0,
         get_functions,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_from$0), _dj_]],
      _dl_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_val_get), _dk_];
     return caml_call1(Ppx_string_runtime[1][4], _dl_);
    }
    function _cA_(i){
     var
      _c6_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_Of_variant_t), 0],
      _c7_ = [0, entry_diff_type(size), _c6_],
      _c8_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$21), _c7_],
      _c9_ = [0, diff_var(i), _c8_],
      _c__ = [0, caml_call1(Ppx_string_runtime[1][2], cst_local$1), _c9_],
      _c$_ = [0, create_arg(i), _c__];
     return caml_call1(Ppx_string_runtime[1][4], _c$_);
    }
    var
     _cB_ = caml_call2(Base_List[53], nums$0, _cA_),
     create_of_variants_args = caml_call2(Base_String[68], _u_, _cB_),
     _cC_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_end_end_end), 0],
     _cD_ = [0, function_declarations(1), _cC_],
     _cE_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$22), _cD_],
     _cF_ = [0, for_inlined_tuple_diff_type_de(size), _cE_],
     _cG_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$0), _cF_]],
     _cH_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$0), _cG_],
     _cI_ = [0, for_inlined_tuple_type_declara(size), _cH_],
     _cJ_ =
       [0,
        for_inlined_tuple_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$1), _cI_]],
     _cK_ =
       [0,
        diff_type$0,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_end_module), _cJ_]],
     _cL_ =
       [0,
        create_of_variants_args,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$23), _cK_]],
     _cM_ =
       [0,
        diff_type$0,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_val_create_of_variants),
         _cL_]],
     _cN_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_unit), _cM_];
    function _cy_(i){
     var
      _c2_ = [0, diff_var(i), 0],
      _c3_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$19), _c2_],
      _c4_ = [0, create_arg(i), _c3_],
      _c5_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$20), _c4_];
     return caml_call1(Ppx_string_runtime[1][4], _c5_);
    }
    var
     _cz_ = caml_call2(Base_List[53], nums$0, _cy_),
     _cO_ = [0, caml_call2(Base_String[68], _t_, _cz_), _cN_],
     _cP_ =
       [0,
        diff_type$0,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_val_create), _cO_]],
     _cQ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$24), _cP_],
     _cR_ = [0, entry_diff_type(size), _cQ_],
     _cS_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_val_singleton), _cR_],
     _cT_ = [0, function_declarations(0), _cS_],
     _cU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$25), _cT_],
     _cV_ = [0, diff_type_declarations(size, 1), _cU_],
     _cW_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$2), _cV_]],
     _cX_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$1), _cW_],
     _cY_ = [0, type_declaration(size), _cX_],
     _cZ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_sig$3), _cY_],
     _c0_ = [0, module_name(size), _cZ_],
     _c1_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$2), _c0_];
    return caml_call1(Ppx_string_runtime[1][4], _c1_);
   }
   function tuple_ml(size){
    var
     nums$0 = nums(size),
     get = caml_call1(Base_Printf[2], _v_),
     apply = caml_call1(Base_Printf[2], _w_),
     of_list = caml_call1(Base_Printf[2], _x_);
    function maybe_gel(s, i, gel){
     var base = caml_call3(Base_Printf[2], _y_, s, i);
     return gel ? caml_call2(Base_Printf[2], _z_, base) : base;
    }
    function from(_cp_, _cq_){return maybe_gel(cst_from$1, _cp_, _cq_);}
    function to(_cn_, _co_){return maybe_gel(cst_to$1, _cn_, _co_);}
    function derived_on(_cl_, _cm_){
     return maybe_gel(cst_derived_on$0, _cl_, _cm_);
    }
    function t(_cj_, _ck_){return maybe_gel(cst_t$2, _cj_, _ck_);}
    function apply_diff(n){
     var
      _b__ = [0, caml_call1(Ppx_string_runtime[1][2], cst_diff_in), 0],
      _b$_ = [0, derived_on(n, 0), _b__],
      _ca_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_tl), _b$_],
      _cb_ = [0, derived_on(n, 0), _ca_],
      _cc_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$26), _cb_],
      _cd_ = [0, caml_call1(apply, n), _cc_],
      _ce_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_tl$0), _cd_],
      _cf_ = [0, caml_call1(variant_name, n), _ce_],
      _cg_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_diff_match_diff_with),
         _cf_],
      _ch_ = [0, t(n, 0), _cg_],
      _ci_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_let), _ch_];
     return caml_call1(Ppx_string_runtime[1][4], _ci_);
    }
    function get_diff(n){
     var
      _b1_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_diff_in), 0],
      _b2_ = [0, caml_call1(variant_name, n), _b1_],
      _b3_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_with_None_diff_Some_d),
         _b2_],
      _b4_ = [0, to(n, 0), _b3_],
      _b5_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_to$2), _b4_],
      _b6_ = [0, from(n, 0), _b5_],
      _b7_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_from$2), _b6_],
      _b8_ = [0, caml_call1(get, n), _b7_],
      _b9_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_let_diff_match_optional_Op),
         _b8_];
     return caml_call1(Ppx_string_runtime[1][4], _b9_);
    }
    var
     _X_ = caml_call1(Base_Printf[2], _A_),
     _Y_ = caml_call2(Base_List[53], nums$0, _X_),
     _Z_ = caml_call1(Base_Printf[2], _B_),
     ___ = caml_call2(Base_List[53], nums$0, _Z_),
     _$_ = caml_call2(Base[222], ___, _Y_),
     of_sexp_functions = caml_call2(Base_String[68], _C_, _$_);
    function create_args(optional){
     function _bX_(i){
      var _bZ_ = [0, create_arg(i), 0], _b0_ = optional ? cst$27 : cst$28;
      return caml_call1(Ppx_string_runtime[1][4], [0, _b0_, _bZ_]);
     }
     var _bY_ = caml_call2(Base_List[53], nums$0, _bX_);
     return caml_call2(Base_String[68], _D_, _bY_);
    }
    function create_function(value, option_or_optional_diff){
     function maybe_add_diff(i){
      var _bU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_in), 0];
      if(898311236 <= option_or_optional_diff)
       var
        _bK_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_diff), 0],
        _bL_ = [0, caml_call1(variant_name, i), _bK_],
        _bM_ =
          [0,
           caml_call1(Ppx_string_runtime[1][2], cst_with_None_diff_Some_d$0),
           _bL_],
        _bN_ = [0, caml_call1(value, i), _bM_],
        _bO_ =
          [0,
           caml_call1
            (Ppx_string_runtime[1][2], cst_match_optional_Optional_di),
           _bN_],
        _bV_ = caml_call1(Ppx_string_runtime[1][4], _bO_);
      else
       var
        _bP_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_diff$0), 0],
        _bQ_ = [0, caml_call1(variant_name, i), _bP_],
        _bR_ =
          [0,
           caml_call1(Ppx_string_runtime[1][2], cst_with_None_diff_Some_d$1),
           _bQ_],
        _bS_ = [0, caml_call1(value, i), _bR_],
        _bT_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_match), _bS_],
        _bV_ = caml_call1(Ppx_string_runtime[1][4], _bT_);
      var
       _bW_ =
         [0,
          caml_call1(Ppx_string_runtime[1][2], cst_let_diff),
          [0, _bV_, _bU_]];
      return caml_call1(Ppx_string_runtime[1][4], _bW_);
     }
     var
      _bG_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_diff$0), 0],
      _bH_ = caml_call2(Base_List[66], nums$0, maybe_add_diff),
      _bI_ = [0, caml_call2(Base_String[68], _E_, _bH_), _bG_],
      _bJ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_let_diff_in), _bI_];
     return caml_call1(Ppx_string_runtime[1][4], _bJ_);
    }
    function diff_of_list(i){
     var
      _bv_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_d_acc_tl), 0],
      _bw_ = [0, caml_call1(variant_name, i), _bv_],
      _bx_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_d_ds_with_None_loop_acc_tl),
         _bw_],
      _by_ = [0, caml_call1(of_list, i), _bx_],
      _bz_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_x_x_assert_false_in_match_),
         _by_],
      _bA_ = [0, caml_call1(variant_name, i), _bz_],
      _bB_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_true_false_in_let_ds_List_),
         _bA_],
      _bC_ = [0, caml_call1(variant_name, i), _bB_],
      _bD_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_d_tl_let_ds_tl_List_split_),
         _bC_],
      _bE_ = [0, caml_call1(variant_name, i), _bD_],
      _bF_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$29), _bE_];
     return caml_call1(Ppx_string_runtime[1][4], _bF_);
    }
    function function_implementations(local){
     var
      maybe_local = local ? cst_local$2 : cst$31,
      _aZ_ =
        [0,
         maybe_local,
         [0,
          caml_call1(Ppx_string_runtime[1][2], cst_failwith_BUG_non_empty_dif),
          0]],
      _a0_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$30), _aZ_];
     function _a1_(_bu_){return t(_bu_, local);}
     var
      _a2_ = caml_call2(Base_List[53], nums$0, _a1_),
      _a3_ =
        [0, maybe_local, [0, caml_call2(Base_String[68], _F_, _a2_), _a0_]],
      _a4_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_match_diff_with), _a3_],
      _a5_ = caml_call2(Base_List[53], nums$0, apply_diff),
      _a6_ = [0, caml_call2(Base_String[68], _G_, _a5_), _a4_],
      _a7_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_derived_on_in), _a6_];
     function _a8_(_bt_){return derived_on(_bt_, local);}
     var
      _a9_ = caml_call2(Base_List[53], nums$0, _a8_),
      _a__ = [0, caml_call2(Base_String[68], _H_, _a9_), _a7_],
      _a$_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_derived_on_diff_let),
         _a__],
      _ba_ = caml_call2(Base_List[53], nums$0, apply),
      _bb_ = [0, caml_call2(Base_String[68], _I_, _ba_), _a$_],
      _bc_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_match_diff_with_local_Opti),
         _bb_],
      _bd_ = caml_call2(Base_List[66], nums$0, get_diff),
      _be_ = [0, caml_call2(Base_String[68], _J_, _bd_), _bc_],
      _bf_ =
        [0, caml_call1(Ppx_string_runtime[1][2], cst_to_in_let_diff_in), _be_];
     function _bg_(_bs_){return to(_bs_, local);}
     var
      _bh_ = caml_call2(Base_List[53], nums$0, _bg_),
      _bi_ = [0, caml_call2(Base_String[68], _K_, _bh_), _bf_],
      _bj_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_from_in_let), _bi_];
     function _bk_(_br_){return from(_br_, local);}
     var
      _bl_ = caml_call2(Base_List[53], nums$0, _bk_),
      _bm_ = [0, caml_call2(Base_String[68], _L_, _bl_), _bj_],
      _bn_ =
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_from_to_if_Base_phys_equal),
         _bm_],
      _bo_ = caml_call2(Base_List[53], nums$0, get),
      _bp_ = [0, caml_call2(Base_String[68], _M_, _bo_), _bn_],
      _bq_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_let_get), _bp_];
     return caml_call1(Ppx_string_runtime[1][4], _bq_);
    }
    function _aa_(x){
     var
      _aX_ = caml_call1(apply, x),
      _aY_ = [0, caml_call2(Base_Printf[2], _N_, _aX_), 0];
     return [0, caml_call1(of_list, x), _aY_];
    }
    var
     _ab_ = caml_call2(Base_List[14], nums$0, _aa_),
     of_list_and_apply_functions = caml_call2(Base_String[68], _O_, _ab_),
     _ac_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_in_local_Optional_diff_ret),
        0],
     _ad_ = caml_call2(Base_List[53], nums$0, diff_of_list),
     _ae_ = [0, caml_call2(Base_String[68], _P_, _ad_), _ac_],
     _af_ =
       [0,
        of_list_and_apply_functions,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_ts_match_ts_with_local_Opt),
         _ae_]],
     _ag_ =
       [0, caml_call1(Ppx_string_runtime[1][2], cst_let_of_list_exn), _af_],
     of_list_function = caml_call1(Ppx_string_runtime[1][4], _ag_);
    function create_arg_of_variant(i){
     var
      _aR_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$32), 0],
      _aS_ = [0, create_arg(i), _aR_],
      _aT_ =
        [0,
         entry_diff_module_name,
         [0, caml_call1(Ppx_string_runtime[1][2], cst_Variants), _aS_]],
      _aU_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$33), _aT_],
      _aV_ = [0, create_arg(i), _aU_],
      _aW_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$34), _aV_];
     return caml_call1(Ppx_string_runtime[1][4], _aW_);
    }
    var
     _ah_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_let_of_list_exn_of_list_ex),
        0],
     _ai_ = [0, function_implementations(1), _ah_],
     _aj_ =
       [0,
        entry_diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst$35), _ai_]],
     _ak_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_open$0), _aj_]],
     _al_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_open$1), _ak_],
     _am_ = [0, for_inlined_tuple_diff_type_de(size), _al_],
     _an_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$0), _am_]],
     _ao_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$3), _an_],
     _ap_ = [0, for_inlined_tuple_type_declara(size), _ao_],
     _aq_ =
       [0,
        for_inlined_tuple_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$1), _ap_]],
     _ar_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_end_module$0), _aq_],
     _as_ = [0, create_function(create_arg_of_variant, 898311236), _ar_],
     _at_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$36), _as_],
     _au_ = [0, create_args(0), _at_],
     _av_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_let_create_of_variants),
        _au_],
     _aw_ = [0, create_function(create_arg, 729469813), _av_],
     _ax_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$37), _aw_],
     _ay_ = [0, create_args(1), _ax_],
     _az_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_name_dup_let_c),
         _ay_]],
     _aA_ =
       [0,
        of_sexp_functions,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_sexp_List_sort_compare_com),
         _az_]],
     _aB_ =
       [0,
        of_sexp_functions,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_sexp_let_l_t_of_sexp),
         _aA_]],
     _aC_ =
       [0,
        of_list_function,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_let_singleton_entry_diff_e),
         _aB_]],
     _aD_ = [0, caml_call1(Ppx_string_runtime[1][2], cst$38), _aC_],
     _aE_ = [0, function_implementations(0), _aD_],
     _aF_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t2),
         _aE_]],
     _aG_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t1),
         _aF_]],
     _aH_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t2_let_eq),
         _aG_]],
     _aI_ =
       [0,
        entry_diff_module_name,
        [0,
         caml_call1(Ppx_string_runtime[1][2], cst_Variants_to_rank_t1$0),
         _aH_]],
     _aJ_ =
       [0,
        caml_call1(Ppx_string_runtime[1][2], cst_let_compare_rank_t1_t2_Int),
        _aI_],
     _aK_ = [0, diff_type_declarations(size, 0), _aJ_],
     _aL_ =
       [0,
        diff_module_name,
        [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$2), _aK_]],
     _aM_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$4), _aL_],
     _aN_ = [0, type_declaration(size), _aM_],
     _aO_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_struct$3), _aN_],
     _aP_ = [0, module_name(size), _aO_],
     _aQ_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_module$5), _aP_];
    return caml_call1(Ppx_string_runtime[1][4], _aQ_);
   }
   var
    _Q_ = caml_call1(Base[242], max_supported),
    l = caml_call5(Base_List[132], 0, _S_, _R_, 2, _Q_);
   function tuples_mli(param){
    var _W_ = caml_call2(Base_List[53], l, tuple_mli);
    return caml_call2(Base_String[68], _T_, _W_);
   }
   function tuples_ml(param){
    var _V_ = caml_call2(Base_List[53], l, tuple_ml);
    return caml_call2(Base_String[68], _U_, _V_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_diffable_cinaps);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Diffable_cinaps_Tuple_help);
   var
    Diffable_cinaps_Tuple_helpers = [0, max_supported, tuples_mli, tuples_ml];
   runtime.caml_register_global
    (220, Diffable_cinaps_Tuple_helpers, cst_Diffable_cinaps_Tuple_help$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Diffable_cinaps
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Diffable_cinaps = "Diffable_cinaps",
    cst_diffable_cinaps = "diffable_cinaps";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Diffable_cinaps);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_diffable_cinaps);
   caml_call1(Ppx_expect_runtime[1][1], "lib/cinaps/diffable_cinaps.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_diffable_cinaps, "diffable_cinaps.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_diffable_cinaps);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Diffable_cinaps);
   var Diffable_cinaps = [0];
   runtime.caml_register_global(11, Diffable_cinaps, cst_Diffable_cinaps);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkaWZmYWJsZV9jaW5hcHMuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImRpZmZfbW9kdWxlX25hbWUiLCJlbnRyeV9kaWZmX21vZHVsZV9uYW1lIiwiZm9yX2lubGluZWRfdHVwbGVfbW9kdWxlX25hbWUiLCJtYXhfc3VwcG9ydGVkIiwibW9kdWxlX25hbWUiLCJzaXplIiwibnVtcyIsInZhciQwIiwiaSIsImRpZmZfdmFyIiwiY3JlYXRlX2FyZyIsImdlbCIsInZhcnMiLCJkaWZmX3ZhcnMiLCJ0eXBlIiwibmFtZSIsInRfdHlwZSIsImRlcml2ZWRfb25fdHlwZSIsImVudHJ5X2RpZmZfdHlwZSIsImRpZmZfdHlwZSIsInZhcmlhbnRfbmFtZSIsInR5cGVfZGVjbGFyYXRpb24iLCJ0dXBsZSIsImRpZmZfdHlwZV9kZWNsYXJhdGlvbnMiLCJzaWduYXR1cmUiLCJtYXliZV9wcml2YXRlIiwibWF5YmVfb3Blbl9lbnRyeV9kaWZmIiwiZm9yX2lubGluZWRfdHVwbGVfdHlwZV9kZWNsYXJhIiwiZm9yX2lubGluZWRfdHVwbGVfZGlmZl90eXBlX2RlIiwidHVwbGVfbWxpIiwibnVtcyQwIiwiZGVyaXZlZF9vbl90eXBlJDAiLCJkaWZmX3R5cGUkMCIsImdldF9mdW5jdGlvbnMiLCJhcHBseV9mdW5jdGlvbnMiLCJhcHBseV9mdW5jdGlvbnMkMCIsIm9mX2xpc3RfZnVuY3Rpb25zIiwieSIsIngiLCJvZl9saXN0X2FuZF9hcHBseV9mdW5jdGlvbnMiLCJmdW5jdGlvbl9kZWNsYXJhdGlvbnMiLCJsb2NhbCIsImNyZWF0ZV9vZl92YXJpYW50c19hcmdzIiwidHVwbGVfbWwiLCJnZXQiLCJhcHBseSIsIm9mX2xpc3QiLCJtYXliZV9nZWwiLCJzIiwiYmFzZSIsImZyb20iLCJ0byIsImRlcml2ZWRfb24iLCJ0IiwiYXBwbHlfZGlmZiIsIm4iLCJnZXRfZGlmZiIsIm9mX3NleHBfZnVuY3Rpb25zIiwiY3JlYXRlX2FyZ3MiLCJvcHRpb25hbCIsImNyZWF0ZV9mdW5jdGlvbiIsInZhbHVlIiwib3B0aW9uX29yX29wdGlvbmFsX2RpZmYiLCJtYXliZV9hZGRfZGlmZiIsImRpZmZfb2ZfbGlzdCIsImZ1bmN0aW9uX2ltcGxlbWVudGF0aW9ucyIsIm1heWJlX2xvY2FsIiwib2ZfbGlzdF9mdW5jdGlvbiIsImNyZWF0ZV9hcmdfb2ZfdmFyaWFudCIsImwiLCJ0dXBsZXNfbWxpIiwidHVwbGVzX21sIl0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3BweF9kaWZmL2RpZmZhYmxlX2NpbmFwcy9kaWZmYWJsZV9jaW5hcHNfXy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9wcHhfZGlmZi9kaWZmYWJsZV9jaW5hcHMvdHVwbGVfaGVscGVycy5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQUsyQjs7SUFBQTs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDRHZCQTtJQUNBQztJQUNBQztJQXVVQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUExVUFDLFlBQWFDLE1BQU8sT0FBQSxnQ0FBUEEsTUFBNkI7WUFJMUNDLEtBQU1EO0lBQXlCLG9CO0lBQUEsT0FBQSwwQkFBekJBO0dBQWtDO1lBQ3hDRSxNQUFJQyxHQUFJLE9BQUEsZ0NBQUpBLEdBQW9CO1lBQ3hCQyxTQUFTRDtJQUFJLFdBRGJELE1BQ1NDO0lBQUksT0FB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O0lBQUEsTUFBQSxzQkFEcERGO0lBQ0FrRSxJQUFJO1lBQ0pDO0lBQWdCLFVBQUEsMEJBRGhCRCxHQXhRQXhDO0lBeVFnQixPQUFBO0dBQW9EO1lBQ3BFMEM7SUFBZSxVQUFBLDBCQUZmRixHQTNMQTFCO0lBNkxlLE9BQUE7R0FBbUQ7Ozs7Ozt3Q0FIbEV4QyxlQUVBbUUsWUFDQUM7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgRGlmZmFibGVfY2luYXBzLlR1cGxlX2hlbHBlcnMgKilcbm1vZHVsZSBUdXBsZV9oZWxwZXJzID0gRGlmZmFibGVfY2luYXBzX19UdXBsZV9oZWxwZXJzXG5cbm1vZHVsZSBEaWZmYWJsZV9jaW5hcHNfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQmFzZVxub3BlbiBQcmludGZcblxubGV0IG1vZHVsZV9uYW1lIH5zaXplID0gc3ByaW50ZiBcIlR1cGxlJWlcIiBzaXplXG5sZXQgZGlmZl9tb2R1bGVfbmFtZSA9IFwiRGlmZlwiXG5sZXQgZW50cnlfZGlmZl9tb2R1bGVfbmFtZSA9IFwiRW50cnlfZGlmZlwiXG5sZXQgZm9yX2lubGluZWRfdHVwbGVfbW9kdWxlX25hbWUgPSBcIkZvcl9pbmxpbmVkX3R1cGxlXCJcbmxldCBudW1zIH5zaXplID0gTGlzdC5pbml0IHNpemUgfmY6KCggKyApIDEpXG5sZXQgdmFyIGkgPSBzcHJpbnRmIFwiJ2ElaVwiIGlcbmxldCBkaWZmX3ZhciBpID0gdmFyIGkgXiBcIl9kaWZmXCJcbmxldCBjcmVhdGVfYXJnIGkgPSBzcHJpbnRmIFwidCVpXCIgaVxubGV0IGdlbCBpID0gc3ByaW50ZiBcIiVzIEdlbC50XCIgKHZhciBpKVxubGV0IHZhcnMgfnNpemUgPSBMaXN0Lm1hcCAobnVtcyB+c2l6ZSkgfmY6dmFyXG5sZXQgZGlmZl92YXJzIH5zaXplID0gdmFycyB+c2l6ZSBAIExpc3QubWFwIChudW1zIH5zaXplKSB+ZjpkaWZmX3ZhclxuXG5sZXQgdHlwZV8gfm5hbWUgfnZhcnMgfnNpemUgPVxuICBzcHJpbnRmIFwiKCVzKSAlc1wiIChTdHJpbmcuY29uY2F0ICh2YXJzIH5zaXplKSB+c2VwOlwiLCBcIikgbmFtZVxuOztcblxubGV0IHRfdHlwZSA9IHR5cGVfIH5uYW1lOlwidFwiIH52YXJzXG5sZXQgZGVyaXZlZF9vbl90eXBlID0gdHlwZV8gfm5hbWU6XCJkZXJpdmVkX29uXCIgfnZhcnNcbmxldCBlbnRyeV9kaWZmX3R5cGUgPSB0eXBlXyB+bmFtZTpbJXN0cmluZyBcIiV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX0udFwiXSB+dmFyczpkaWZmX3ZhcnNcbmxldCBkaWZmX3R5cGUgPSB0eXBlXyB+bmFtZTpcInRcIiB+dmFyczpkaWZmX3ZhcnNcbmxldCBkaWZmX3R5cGVfcmVmZXJlbmNlID0gdHlwZV8gfm5hbWU6KHNwcmludGYgXCIlcy50XCIgZGlmZl9tb2R1bGVfbmFtZSkgfnZhcnM6ZGlmZl92YXJzXG5sZXQgdmFyaWFudF9uYW1lID0gc3ByaW50ZiBcIlQlaVwiXG5cbmxldCB0eXBlX2RlY2xhcmF0aW9uIH5zaXplID1cbiAgbGV0IHR1cGxlID0gU3RyaW5nLmNvbmNhdCAodmFycyB+c2l6ZSkgfnNlcDpcIiAqIFwiIGluXG4gIFslc3RyaW5nIHt8dHlwZSAle3RfdHlwZSB+c2l6ZX0gPSAle3R1cGxlfSBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW9dfH1dXG47O1xuXG5sZXQgZGlmZl90eXBlX2RlY2xhcmF0aW9ucyB+c2l6ZSB+c2lnbmF0dXJlID1cbiAgbGV0IG1heWJlX3ByaXZhdGUgPSBpZiBzaWduYXR1cmUgdGhlbiBcIiBwcml2YXRlXCIgZWxzZSBcIlwiIGluXG4gIGxldCB2YXJpYW50cyB+c2l6ZSA9XG4gICAgTGlzdC5tYXAgKG51bXMgfnNpemUpIH5mOihmdW4gaSAtPiBzcHJpbnRmIFwifCAlcyBvZiAlc1wiICh2YXJpYW50X25hbWUgaSkgKGRpZmZfdmFyIGkpKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiXG4gIGluXG4gIGxldCBtYXliZV9vcGVuX2VudHJ5X2RpZmYgPVxuICAgIGlmIHNpZ25hdHVyZSB0aGVuIFwiXCIgZWxzZSBbJXN0cmluZyB7fG9wZW4gJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfXx9XVxuICBpblxuICBbJXN0cmluZ1xuICAgIHt8XG4gICAgICB0eXBlICV7ZGVyaXZlZF9vbl90eXBlIH5zaXplfSA9ICV7dF90eXBlIH5zaXplfVxuXG4gICAgICBtb2R1bGUgJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfSAle2lmIHNpZ25hdHVyZSB0aGVuIFwiOiBzaWdcIiBlbHNlIFwiPSBzdHJ1Y3RcIn1cbiAgICAgICAgdHlwZSAle2RpZmZfdHlwZSB+c2l6ZX0gPVxuICAgICAgICAgICV7dmFyaWFudHMgfnNpemV9XG4gICAgICAgIFtAQGRlcml2aW5nIHZhcmlhbnRzLCBzZXhwLCBiaW5faW8sIHF1aWNrY2hlY2tdXG4gICAgICBlbmRcbiAgICAgICV7bWF5YmVfb3Blbl9lbnRyeV9kaWZmfVxuXG4gICAgICB0eXBlICV7ZGlmZl90eXBlIH5zaXplfSA9JXttYXliZV9wcml2YXRlfSAle2VudHJ5X2RpZmZfdHlwZSB+c2l6ZX0gbGlzdCBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW8sIHF1aWNrY2hlY2tdXG5cbnx9XVxuOztcblxubGV0IGZvcl9pbmxpbmVkX3R1cGxlX3R5cGVfZGVjbGFyYXRpb24gfnNpemUgPVxuICBbJXN0cmluZ1xuICAgIHt8IHR5cGUgJXt0X3R5cGUgfnNpemV9ID0gJXtMaXN0Lm1hcCAobnVtcyB+c2l6ZSkgfmY6Z2VsIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiAqIFwifSBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW9dfH1dXG47O1xuXG5sZXQgZm9yX2lubGluZWRfdHVwbGVfZGlmZl90eXBlX2RlY2xhcmF0aW9ucyB+c2l6ZSA9XG4gIFslc3RyaW5nXG4gICAge3xcbiAgICAgIHR5cGUgJXtkZXJpdmVkX29uX3R5cGUgfnNpemV9ID0gJXt0X3R5cGUgfnNpemV9XG5cbiAgICAgIHR5cGUgJXtkaWZmX3R5cGUgfnNpemV9ID0gJXtkaWZmX3R5cGVfcmVmZXJlbmNlIH5zaXplfSBbQEBkZXJpdmluZyBzZXhwLCBiaW5faW8sIHF1aWNrY2hlY2tdXG4gIHx9XVxuOztcblxubGV0IHR1cGxlX21saSBzaXplID1cbiAgbGV0IG51bXMgPSBudW1zIH5zaXplIGluXG4gIGxldCBkZXJpdmVkX29uX3R5cGUgPSBkZXJpdmVkX29uX3R5cGUgfnNpemUgaW5cbiAgbGV0IGRpZmZfdHlwZSA9IGRpZmZfdHlwZSB+c2l6ZSBpblxuICBsZXQgZ2V0X2Z1bmN0aW9ucyA9XG4gICAgTGlzdC5tYXAgbnVtcyB+ZjooZnVuIGkgLT5cbiAgICAgIFslc3RyaW5nXG4gICAgICAgIHt8KGZyb206ICV7dmFyIGl9IC0+IHRvXzogJXt2YXIgaX0gLT4gbG9jYWxfICV7ZGlmZl92YXIgaX0gT3B0aW9uYWxfZGlmZi50KXx9XSlcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG4gLT4gXCJcbiAgaW5cbiAgbGV0IGFwcGx5X2Z1bmN0aW9ucycgPVxuICAgIExpc3QubWFwIG51bXMgfmY6KGZ1biBpIC0+IFslc3RyaW5nIHt8KCV7dmFyIGl9IC0+ICV7ZGlmZl92YXIgaX0gLT4gJXt2YXIgaX0pfH1dKVxuICBpblxuICBsZXQgYXBwbHlfZnVuY3Rpb25zID0gYXBwbHlfZnVuY3Rpb25zJyB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG4gLT4gXCIgaW5cbiAgbGV0IG9mX2xpc3RfZnVuY3Rpb25zJyA9XG4gICAgTGlzdC5tYXAgbnVtcyB+ZjooZnVuIGkgLT5cbiAgICAgIFslc3RyaW5nIHt8KCV7ZGlmZl92YXIgaX0gbGlzdCAtPiBsb2NhbF8gJXtkaWZmX3ZhciBpfSBPcHRpb25hbF9kaWZmLnQpfH1dKVxuICBpblxuICBsZXQgb2ZfbGlzdF9hbmRfYXBwbHlfZnVuY3Rpb25zID1cbiAgICBMaXN0LnppcF9leG4gb2ZfbGlzdF9mdW5jdGlvbnMnIGFwcGx5X2Z1bmN0aW9ucydcbiAgICB8PiBMaXN0LmNvbmNhdF9tYXAgfmY6KGZ1biAoeCwgeSkgLT4gWyB4OyB5IF0pXG4gICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuIC0+IFwiXG4gIGluXG4gIGxldCBmdW5jdGlvbl9kZWNsYXJhdGlvbnMgfmxvY2FsID1cbiAgICBsZXQgZGVyaXZlZF9vbl90eXBlID1cbiAgICAgIGlmIGxvY2FsIHRoZW4gc3ByaW50ZiBcImxvY2FsXyAlc1wiIGRlcml2ZWRfb25fdHlwZSBlbHNlIGRlcml2ZWRfb25fdHlwZVxuICAgIGluXG4gICAgWyVzdHJpbmdcbiAgICAgIHt8XG4gICAgICAgIHZhbCBnZXQgOiAle2dldF9mdW5jdGlvbnN9IC0+IGZyb206ICV7ZGVyaXZlZF9vbl90eXBlfSAtPiB0b186ICV7ZGVyaXZlZF9vbl90eXBlfSAtPiBsb2NhbF8gJXtkaWZmX3R5cGV9IE9wdGlvbmFsX2RpZmYudFxuXG4gICAgICAgIHZhbCBhcHBseV9leG4gOiAle2FwcGx5X2Z1bmN0aW9uc30gLT4gJXtkZXJpdmVkX29uX3R5cGV9IC0+ICV7ZGlmZl90eXBlfSAtPiAle2Rlcml2ZWRfb25fdHlwZX1cblxuICAgICAgICB2YWwgb2ZfbGlzdF9leG4gOiAle29mX2xpc3RfYW5kX2FwcGx5X2Z1bmN0aW9uc30gLT4gJXtkaWZmX3R5cGV9IGxpc3QgLT4gbG9jYWxfICV7ZGlmZl90eXBlfSBPcHRpb25hbF9kaWZmLnRcbiAgICAgICAgIHx9XVxuICBpblxuICBsZXQgY3JlYXRlX2FyZ3Mgfm9wdGlvbmFsID1cbiAgICBMaXN0Lm1hcCBudW1zIH5mOihmdW4gaSAtPlxuICAgICAgaWYgb3B0aW9uYWxcbiAgICAgIHRoZW4gWyVzdHJpbmcge3w/JXtjcmVhdGVfYXJnIGl9OiV7ZGlmZl92YXIgaX18fV1cbiAgICAgIGVsc2UgWyVzdHJpbmcge3wle2NyZWF0ZV9hcmcgaX06JXtkaWZmX3ZhciBpfSBvcHRpb258fV0pXG4gICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiIC0+IFwiXG4gIGluXG4gIGxldCBjcmVhdGVfb2ZfdmFyaWFudHNfYXJncyA9XG4gICAgTGlzdC5tYXAgbnVtcyB+ZjooZnVuIGkgLT5cbiAgICAgIFslc3RyaW5nXG4gICAgICAgIHt8JXtjcmVhdGVfYXJnIGl9OmxvY2FsXyAoKCV7ZGlmZl92YXIgaX0sICV7ZW50cnlfZGlmZl90eXBlIH5zaXplfSkgT2ZfdmFyaWFudC50KSB8fV0pXG4gICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiIC0+IFwiXG4gIGluXG4gIFslc3RyaW5nXG4gICAge3xcbiAgICBtb2R1bGUgJXttb2R1bGVfbmFtZSB+c2l6ZX0gOiBzaWdcbiAgICAgICV7dHlwZV9kZWNsYXJhdGlvbiB+c2l6ZX1cbiAgICAgIG1vZHVsZSAle2RpZmZfbW9kdWxlX25hbWV9IDogc2lnXG4gICAgICAgICV7ZGlmZl90eXBlX2RlY2xhcmF0aW9ucyB+c2l6ZSB+c2lnbmF0dXJlOnRydWV9XG5cbiAgICAgICAgJXtmdW5jdGlvbl9kZWNsYXJhdGlvbnMgfmxvY2FsOmZhbHNlfVxuXG4gICAgICAgIHZhbCBzaW5nbGV0b24gOiAle2VudHJ5X2RpZmZfdHlwZSB+c2l6ZX0gLT4gJXtkaWZmX3R5cGV9XG5cbiAgICAgICAgdmFsIGNyZWF0ZSA6ICV7Y3JlYXRlX2FyZ3Mgfm9wdGlvbmFsOnRydWV9IC0+IHVuaXQgLT4gJXtkaWZmX3R5cGV9XG5cbiAgICAgICAgdmFsIGNyZWF0ZV9vZl92YXJpYW50cyA6ICV7Y3JlYXRlX29mX3ZhcmlhbnRzX2FyZ3N9IC0+ICV7ZGlmZl90eXBlfVxuICAgICAgZW5kXG5cbiAgICAgIG1vZHVsZSAle2Zvcl9pbmxpbmVkX3R1cGxlX21vZHVsZV9uYW1lfSA6IHNpZ1xuICAgICAgICAle2Zvcl9pbmxpbmVkX3R1cGxlX3R5cGVfZGVjbGFyYXRpb24gfnNpemV9XG5cbiAgICAgICAgbW9kdWxlICV7ZGlmZl9tb2R1bGVfbmFtZX0gOiBzaWdcbiAgICAgICAgICAle2Zvcl9pbmxpbmVkX3R1cGxlX2RpZmZfdHlwZV9kZWNsYXJhdGlvbnMgfnNpemV9XG4gICAgICAgICAgJXtmdW5jdGlvbl9kZWNsYXJhdGlvbnMgfmxvY2FsOnRydWV9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgICAgfH1dXG47O1xuXG5sZXQgdHVwbGVfbWwgc2l6ZSA9XG4gIGxldCBudW1zID0gbnVtcyB+c2l6ZSBpblxuICBsZXQgZ2V0ID0gc3ByaW50ZiBcImdldCVpXCIgaW5cbiAgbGV0IGFwcGx5ID0gc3ByaW50ZiBcImFwcGx5JWlfZXhuXCIgaW5cbiAgbGV0IG9mX2xpc3QgPSBzcHJpbnRmIFwib2ZfbGlzdCVpX2V4blwiIGluXG4gIGxldCBtYXliZV9nZWwgcyBpIH5nZWwgPVxuICAgIGxldCBiYXNlID0gc3ByaW50ZiBcIiVzJWlcIiBzIGkgaW5cbiAgICBpZiBub3QgZ2VsIHRoZW4gYmFzZSBlbHNlIHNwcmludGYgXCJ7R2VsLmcgPSAlc31cIiBiYXNlXG4gIGluXG4gIGxldCBmcm9tID0gbWF5YmVfZ2VsIFwiZnJvbV9cIiBpblxuICBsZXQgdG9fID0gbWF5YmVfZ2VsIFwidG9fXCIgaW5cbiAgbGV0IGRlcml2ZWRfb24gPSBtYXliZV9nZWwgXCJkZXJpdmVkX29uXCIgaW5cbiAgbGV0IHQgPSBtYXliZV9nZWwgXCJ0XCIgaW5cbiAgbGV0IGFwcGx5X2RpZmYgbiA9XG4gICAgWyVzdHJpbmdcbiAgICAgIHt8IGxldCAle3QgbiB+Z2VsOmZhbHNlfSwgZGlmZiA9XG4gICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgIHwgJXt2YXJpYW50X25hbWUgbn0gZCA6OiB0bCAtPiAle2FwcGx5IG59ICV7ZGVyaXZlZF9vbiBuIH5nZWw6ZmFsc2V9IGQsIHRsXG4gICAgICAgICAgfCBfIC0+ICV7ZGVyaXZlZF9vbiBuIH5nZWw6ZmFsc2V9LCBkaWZmXG4gICAgICAgICBpblxuICAgICAgICAgfH1dXG4gIGluXG4gIGxldCBnZXRfZGlmZiBuID1cbiAgICBbJXN0cmluZ1xuICAgICAge3wgbGV0IGRpZmYgPVxuICAgICAgICAgICAgbWF0Y2glb3B0aW9uYWwuT3B0aW9uYWxfZGlmZiAle2dldCBufSB+ZnJvbTole2Zyb20gbiB+Z2VsOmZhbHNlfSB+dG9fOiV7dG9fIG4gfmdlbDpmYWxzZX0gd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGRpZmZcbiAgICAgICAgICAgIHwgU29tZSBkIC0+ICV7dmFyaWFudF9uYW1lIG59IGQgOjogZGlmZlxuICAgICAgICAgIGluXG4gICAgICAgfH1dXG4gIGluXG4gIGxldCBvZl9zZXhwX2Z1bmN0aW9ucyA9XG4gICAgTGlzdC5tYXAgbnVtcyB+Zjooc3ByaW50ZiBcImElaV9vZl9zZXhwXCIpXG4gICAgQCBMaXN0Lm1hcCBudW1zIH5mOihzcHJpbnRmIFwiYSVpX2RpZmZfb2Zfc2V4cFwiKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiBcIlxuICBpblxuICBsZXQgY3JlYXRlX2FyZ3Mgfm9wdGlvbmFsID1cbiAgICBMaXN0Lm1hcCBudW1zIH5mOihmdW4gaSAtPlxuICAgICAgWyVzdHJpbmcge3wle2lmIG9wdGlvbmFsIHRoZW4gXCI/XCIgZWxzZSBcIn5cIn0le2NyZWF0ZV9hcmcgaX18fV0pXG4gICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiIFwiXG4gIGluXG4gIGxldCBjcmVhdGVfZnVuY3Rpb24gfnZhbHVlIG9wdGlvbl9vcl9vcHRpb25hbF9kaWZmID1cbiAgICBsZXQgbWF5YmVfYWRkX2RpZmYgaSA9XG4gICAgICBsZXQgbWF5YmVfYWRkIGkgPVxuICAgICAgICBtYXRjaCBvcHRpb25fb3Jfb3B0aW9uYWxfZGlmZiB3aXRoXG4gICAgICAgIHwgYG9wdGlvbiAtPlxuICAgICAgICAgIFslc3RyaW5nXG4gICAgICAgICAgICB7fCBtYXRjaCAle3ZhbHVlIGl9IHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPiBkaWZmXG4gICAgICAgICAgICAgICB8IFNvbWUgZCAtPiAle3ZhcmlhbnRfbmFtZSBpfSBkIDo6IGRpZmZcbiAgICAgICAgICAgfH1dXG4gICAgICAgIHwgYG9wdGlvbmFsX2RpZmYgLT5cbiAgICAgICAgICBbJXN0cmluZ1xuICAgICAgICAgICAge3wgbWF0Y2glb3B0aW9uYWwuT3B0aW9uYWxfZGlmZiAle3ZhbHVlIGl9IHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPiBkaWZmXG4gICAgICAgICAgICAgICB8IFNvbWUgZCAtPiAle3ZhcmlhbnRfbmFtZSBpfSBkIDo6IGRpZmZcbiAgICAgICAgICAgIHx9XVxuICAgICAgaW5cbiAgICAgIFslc3RyaW5nIHt8bGV0IGRpZmYgPVxuICAgICAgICAgICAgJXttYXliZV9hZGQgaX1cbiAgICAgICAgICBpblxuICAgICAgICB8fV1cbiAgICBpblxuICAgIFslc3RyaW5nXG4gICAgICB7fGxldCBkaWZmID0gW10gaW5cbiAgICAgICV7TGlzdC5yZXZfbWFwIG51bXMgfmY6bWF5YmVfYWRkX2RpZmYgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXCJ9XG4gICAgICBkaWZmfH1dXG4gIGluXG4gIGxldCBkaWZmX29mX2xpc3QgaSA9XG4gICAgWyVzdHJpbmdcbiAgICAgIHt8XG4gICAgICB8ICV7dmFyaWFudF9uYW1lIGl9IGQgOjogdGwgLT5cbiAgICAgICAgbGV0IGRzLCB0bCA9IExpc3Quc3BsaXRfd2hpbGUgdGwgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCAle3ZhcmlhbnRfbmFtZSBpfSBfIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gZmFsc2UpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBkcyA9IExpc3QubWFwIGRzIH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgJXt2YXJpYW50X25hbWUgaX0geCAtPiB4XG4gICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgICAgICAgaW5cbiAgICAgICAgKG1hdGNoJW9wdGlvbmFsLk9wdGlvbmFsX2RpZmYgJXtvZl9saXN0IGl9IChkIDo6IGRzKSB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gbG9vcCBhY2MgdGxcbiAgICAgICAgIHwgU29tZSBkIC0+IGxvb3AgKCV7dmFyaWFudF9uYW1lIGl9IGQgOjogYWNjKSB0bClcbiAgICAgICAgIHx9XVxuICBpblxuICBsZXQgZnVuY3Rpb25faW1wbGVtZW50YXRpb25zIH5sb2NhbCA9XG4gICAgbGV0IG1heWJlX2xvY2FsID0gaWYgbG9jYWwgdGhlbiBcImxvY2FsXyBcIiBlbHNlIFwiXCIgaW5cbiAgICBsZXQgZ2VsID0gbG9jYWwgaW5cbiAgICBbJXN0cmluZ1xuICAgICAge3xcbiAgICAgICAgbGV0IGdldCAle0xpc3QubWFwIG51bXMgfmY6Z2V0IHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiBcIn0gfmZyb20gfnRvXyA9XG4gICAgICAgICAgaWYgQmFzZS5waHlzX2VxdWFsIGZyb20gdG9fXG4gICAgICAgICAgdGhlbiBsb2NhbF8gT3B0aW9uYWxfZGlmZi5ub25lXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgJXtMaXN0Lm1hcCBudW1zIH5mOihmcm9tIH5nZWwpIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiwgXCJ9ID0gZnJvbSBpblxuICAgICAgICAgICAgbGV0ICV7TGlzdC5tYXAgbnVtcyB+ZjoodG9fIH5nZWwpIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiwgXCJ9ID0gdG9fIGluXG4gICAgICAgICAgICBsZXQgZGlmZiA9IFtdIGluXG4gICAgICAgICAgICAle0xpc3QucmV2X21hcCBudW1zIH5mOmdldF9kaWZmIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlwifVxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IFtdIC0+IGxvY2FsXyBPcHRpb25hbF9kaWZmLm5vbmVcbiAgICAgICAgICAgIHwgXyA6OiBfIC0+IGxvY2FsXyBPcHRpb25hbF9kaWZmLnJldHVybiBkaWZmKVxuXG5cbiAgICAgICAgbGV0IGFwcGx5X2V4biAle0xpc3QubWFwIG51bXMgfmY6YXBwbHkgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiIFwifSBkZXJpdmVkX29uIGRpZmYgPVxuICAgICAgICAgIGxldCAle0xpc3QubWFwIG51bXMgfmY6KGRlcml2ZWRfb24gfmdlbCkgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLCBcIn0gPSBkZXJpdmVkX29uIGluXG4gICAgICAgICAgJXtMaXN0Lm1hcCBudW1zIH5mOmFwcGx5X2RpZmYgfD4gU3RyaW5nLmNvbmNhdCAgfnNlcDpcIlwifVxuICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgIHwgW10gLT4gJXttYXliZV9sb2NhbH0le0xpc3QubWFwIG51bXMgfmY6KHQgfmdlbCkgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLFwifVxuICAgICAgICAgIHwgXyA6OiBfIC0+ICV7bWF5YmVfbG9jYWx9ZmFpbHdpdGggXCJCVUc6IG5vbi1lbXB0eSBkaWZmIGFmdGVyIGFwcGx5XCJcbiAgICAgICAgfH1dXG4gIGluXG4gIGxldCBvZl9saXN0X2FuZF9hcHBseV9mdW5jdGlvbnMgPVxuICAgIExpc3QuY29uY2F0X21hcCBudW1zIH5mOihmdW4geCAtPiBbIG9mX2xpc3QgeDsgc3ByaW50ZiBcIl8lc1wiIChhcHBseSB4KSBdKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiBcIlxuICBpblxuICBsZXQgb2ZfbGlzdF9mdW5jdGlvbiA9XG4gICAgWyVzdHJpbmdcbiAgICAgIHt8XG4gICAgICBsZXQgb2ZfbGlzdF9leG4gJXtvZl9saXN0X2FuZF9hcHBseV9mdW5jdGlvbnN9IHRzID1cbiAgICAgICAgbWF0Y2ggdHMgd2l0aFxuICAgICAgICB8IFtdIC0+IGxvY2FsXyBPcHRpb25hbF9kaWZmLm5vbmVcbiAgICAgICAgfCBfIDo6IF8gLT5cbiAgICAgICAgICBtYXRjaCBMaXN0LmNvbmNhdCB0cyB8PiBMaXN0LnN0YWJsZV9zb3J0IH5jb21wYXJlOmNvbXBhcmVfcmFuayB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBsb2NhbF8gT3B0aW9uYWxfZGlmZi5yZXR1cm4gW11cbiAgICAgICAgICB8IF8gOjogXyBhcyBkaWZmIC0+XG4gICAgICAgICAgICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBbXSAtPiBMaXN0LnJldiBhY2NcbiAgICAgICAgICAgICAgICV7TGlzdC5tYXAgbnVtcyB+ZjpkaWZmX29mX2xpc3QgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXCJ9XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbG9jYWxfIE9wdGlvbmFsX2RpZmYucmV0dXJuIChsb29wIFtdIGRpZmYpXG4gICAgICAgICB8fV1cbiAgaW5cbiAgbGV0IGNyZWF0ZV9hcmdfb2ZfdmFyaWFudCBpID1cbiAgICBbJXN0cmluZyB7fCgle2NyZWF0ZV9hcmcgaX0gJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfS5WYXJpYW50cy4le2NyZWF0ZV9hcmcgaX0pfH1dXG4gIGluXG4gIFslc3RyaW5nXG4gICAge3xcbiAgICBtb2R1bGUgJXttb2R1bGVfbmFtZSB+c2l6ZX0gPSBzdHJ1Y3RcbiAgICAgICV7dHlwZV9kZWNsYXJhdGlvbiB+c2l6ZX1cbiAgICAgIG1vZHVsZSAle2RpZmZfbW9kdWxlX25hbWV9ID0gc3RydWN0XG4gICAgICAgICV7ZGlmZl90eXBlX2RlY2xhcmF0aW9ucyB+c2l6ZSB+c2lnbmF0dXJlOmZhbHNlfVxuXG4gICAgICAgIGxldCBjb21wYXJlX3JhbmsgdDEgdDIgPVxuICAgICAgICAgIEludC5jb21wYXJlICgle2VudHJ5X2RpZmZfbW9kdWxlX25hbWV9LlZhcmlhbnRzLnRvX3JhbmsgdDEpICgle2VudHJ5X2RpZmZfbW9kdWxlX25hbWV9LlZhcmlhbnRzLnRvX3JhbmsgdDIpXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IGVxdWFsX3JhbmsgdDEgdDIgPVxuICAgICAgICAgIEludC5lcXVhbCAoJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfS5WYXJpYW50cy50b19yYW5rIHQxKSAoJXtlbnRyeV9kaWZmX21vZHVsZV9uYW1lfS5WYXJpYW50cy50b19yYW5rIHQyKVxuICAgICAgICA7O1xuXG4gICAgICAgICV7ZnVuY3Rpb25faW1wbGVtZW50YXRpb25zIH5sb2NhbDpmYWxzZX1cblxuICAgICAgICAle29mX2xpc3RfZnVuY3Rpb259XG5cbiAgICAgICAgbGV0IHNpbmdsZXRvbiBlbnRyeV9kaWZmID0gW2VudHJ5X2RpZmZdXG5cbiAgICAgICAgbGV0IHRfb2Zfc2V4cCAle29mX3NleHBfZnVuY3Rpb25zfSBzZXhwID1cbiAgICAgICAgICBsZXQgbCA9IHRfb2Zfc2V4cCAle29mX3NleHBfZnVuY3Rpb25zfSBzZXhwIHw+IExpc3Quc29ydCB+Y29tcGFyZTpjb21wYXJlX3JhbmsgaW5cbiAgICAgICAgICBtYXRjaCBMaXN0LmZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIGwgfmVxdWFsOmVxdWFsX3Jhbmsgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBsXG4gICAgICAgICAgfCBTb21lIChkdXAsIF8pIC0+XG4gICAgICAgICAgIGZhaWx3aXRoIChcIkR1cGxpY2F0ZSBlbnRyeSBpbiB0dXBsZSBkaWZmOiBcIiBeICV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX0uVmFyaWFudHMudG9fbmFtZSBkdXApXG5cbiAgICAgICAgbGV0IGNyZWF0ZSAle2NyZWF0ZV9hcmdzIH5vcHRpb25hbDp0cnVlfSAoKSA9XG4gICAgICAgICAgJXtjcmVhdGVfZnVuY3Rpb24gfnZhbHVlOmNyZWF0ZV9hcmcgYG9wdGlvbn1cblxuICAgICAgICBsZXQgY3JlYXRlX29mX3ZhcmlhbnRzICV7Y3JlYXRlX2FyZ3Mgfm9wdGlvbmFsOmZhbHNlfSA9XG4gICAgICAgICAgICV7Y3JlYXRlX2Z1bmN0aW9uIH52YWx1ZTpjcmVhdGVfYXJnX29mX3ZhcmlhbnQgYG9wdGlvbmFsX2RpZmZ9XG4gICAgICBlbmRcblxuICAgICAgbW9kdWxlICV7Zm9yX2lubGluZWRfdHVwbGVfbW9kdWxlX25hbWV9ID0gc3RydWN0XG4gICAgICAgICV7Zm9yX2lubGluZWRfdHVwbGVfdHlwZV9kZWNsYXJhdGlvbiB+c2l6ZX1cblxuICAgICAgICBtb2R1bGUgJXtkaWZmX21vZHVsZV9uYW1lfSA9IHN0cnVjdFxuICAgICAgICAgICV7Zm9yX2lubGluZWRfdHVwbGVfZGlmZl90eXBlX2RlY2xhcmF0aW9ucyB+c2l6ZX1cbiAgICAgICAgICBvcGVuICV7ZGlmZl9tb2R1bGVfbmFtZX1cbiAgICAgICAgICBvcGVuICV7ZW50cnlfZGlmZl9tb2R1bGVfbmFtZX1cbiAgICAgICAgICAle2Z1bmN0aW9uX2ltcGxlbWVudGF0aW9ucyB+bG9jYWw6dHJ1ZX1cblxuICAgICAgICAgIGxldCBvZl9saXN0X2V4biA9IG9mX2xpc3RfZXhuXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgICAgfH1dXG47O1xuXG5sZXQgbWF4X3N1cHBvcnRlZCA9IDYsIFslaGVyZV1cbmxldCBsID0gTGlzdC5yYW5nZSB+c3RhcnQ6YGluY2x1c2l2ZSB+c3RvcDpgaW5jbHVzaXZlIDIgKGZzdCBtYXhfc3VwcG9ydGVkKVxubGV0IHR1cGxlc19tbGkgKCkgPSBMaXN0Lm1hcCBsIH5mOnR1cGxlX21saSB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG5cXG5cIlxubGV0IHR1cGxlc19tbCAoKSA9IExpc3QubWFwIGwgfmY6dHVwbGVfbWwgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXFxuXCJcbiJdfQ==
