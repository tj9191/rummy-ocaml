// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Typerep_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib = [0];
   runtime.caml_register_global(0, Typerep_lib, "Typerep_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Named_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Named_intf = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Named_intf, "Typerep_lib__Named_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, refl = 0;
   function conv(param, x){return x;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   var Typerep_lib_Type_equal = [0, conv, refl, Lift];
   runtime.caml_register_global
    (0, Typerep_lib_Type_equal, "Typerep_lib__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typename
//# unitInfo: Requires: Base, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printf, Typerep_lib__Type_equal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Base = global_data.Base,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   global_data.Stdlib__List;
   var
    _a_ =
      [0,
       [11, "Typename.Same_witness_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "Typename.Same_witness_exn %S %S"],
    cst_Typename_same_witness_exn = "Typename.same_witness_exn",
    cst_Typename_create = "Typename.create",
    cst_static = "static";
   function compare(a, b){return runtime.caml_int_compare(a[1], b[1]);}
   function equal(a, b){return a[1] === b[1] ? 1 : 0;}
   var uid = [0, 0];
   function next(name){var code = uid[1]; uid[1]++; return [0, code, name];}
   function hash(a){return caml_call1(Stdlib_Hashtbl[28], a[1]);}
   function name(a){return a[2];}
   var static$0 = next(cst_static);
   function compare$0(k1, k2){
    if(k1 === k2) return 0;
    var cmp = compare(k1[1], k2[1]);
    if(0 !== cmp) return cmp;
    var b$0 = k2[2], a$0 = k1[2], a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = compare$0(x, y);
     if(0 !== n) return n;
     var a = xs, b = ys;
    }
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var hash$0 = Stdlib_Hashtbl[28], static$1 = [0, static$0, 0];
   function key(t){return t;}
   function uid$0(t){return t[1];}
   function name$0(t){return t[1][2];}
   function create(opt, param){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Typename_create;
    return [0, next(name), 0];
   }
   function same(nm1, nm2){return 0 === compare$0(nm1, nm2) ? 1 : 0;}
   function same_witness(nm1, nm2){
    return 0 === compare$0(nm1, nm2) ? [0, Typerep_lib_Type_equal[2]] : 0;
   }
   function same_witness_exn(nm1, nm2){
    return 0 === compare$0(nm1, nm2)
            ? Typerep_lib_Type_equal[2]
            : caml_call1(Stdlib[2], cst_Typename_same_witness_exn);
   }
   var Key_table = caml_call1(Stdlib_Hashtbl[26], [0, equal$0, hash$0]);
   function Table(X){
    function create(int$0){return caml_call1(Key_table[1], int$0);}
    function mem(table, name){return caml_call2(Key_table[11], table, name);}
    function set(table, name, data){
     return caml_call3(Key_table[10], table, name, [0, name, data]);
    }
    function find(table, name){
     try{var _h_ = [0, caml_call2(Key_table[7], table, name)], data = _h_;}
     catch(_i_){
      var _g_ = caml_wrap_exception(_i_);
      if(_g_[1] !== Base[248] && _g_ !== Stdlib[8])
       throw caml_maybe_attach_backtrace(_g_, 0);
      var data = 0;
     }
     if(! data) return 0;
     var match = data[1], data$0 = match[2], name$0 = match[1];
     same_witness_exn(name$0, name);
     return [0, data$0];
    }
    return [0, create, mem, set, find];
   }
   function fail(uid_a, uid_b){
    var msg = caml_call3(Stdlib_Printf[4], _a_, uid_a[2], uid_b[2]);
    return caml_call1(Stdlib[2], msg);
   }
   function Same_witness_exn_1(A, B){
    var
     uid_a = caml_call1(A[1], static$1)[1],
     uid_b = caml_call1(B[1], static$1)[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_2(A, B){
    var
     uid_a = caml_call2(A[1], static$1, static$1)[1],
     uid_b = caml_call2(B[1], static$1, static$1)[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_3(A, B){
    var
     uid_a = caml_call3(A[1], static$1, static$1, static$1)[1],
     uid_b = caml_call3(B[1], static$1, static$1, static$1)[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_4(A, B){
    var
     uid_a = caml_call4(A[1], static$1, static$1, static$1, static$1)[1],
     uid_b = caml_call4(B[1], static$1, static$1, static$1, static$1)[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_5(A, B){
    var
     uid_a =
       caml_call5(A[1], static$1, static$1, static$1, static$1, static$1)[1],
     uid_b =
       caml_call5(B[1], static$1, static$1, static$1, static$1, static$1)[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function _b_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c, d, e){
     return [0, uid, [0, a, [0, b, [0, c, [0, d, [0, e, 0]]]]]];
    }
    return [0, typename_of_t];
   }
   function _c_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c, d){
     return [0, uid, [0, a, [0, b, [0, c, [0, d, 0]]]]];
    }
    return [0, typename_of_t];
   }
   function _d_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c){
     return [0, uid, [0, a, [0, b, [0, c, 0]]]];
    }
    return [0, typename_of_t];
   }
   function _e_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b){return [0, uid, [0, a, [0, b, 0]]];}
    return [0, typename_of_t];
   }
   function _f_(X){
    var uid = next(X[1]);
    function typename_of_t(a){return [0, uid, [0, a, 0]];}
    return [0, typename_of_t];
   }
   var
    Typerep_lib_Typename =
      [0,
       create,
       static$1,
       same,
       same_witness,
       same_witness_exn,
       [0, compare$0, equal$0, hash$0],
       key,
       [0, compare, equal, hash, name],
       uid$0,
       name$0,
       function(X){
        var uid = next(X[1]), typename_of_t = [0, uid, 0];
        return [0, typename_of_t];
       },
       _f_,
       _e_,
       _d_,
       _c_,
       _b_,
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
   runtime.caml_register_global
    (10, Typerep_lib_Typename, "Typerep_lib__Typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Variant_and_record_intf
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function M(X){
    var Tag_internal = [0];
    function label(t){return t[1];}
    function arity(t){return t[3];}
    function args_labels(t){return t[4];}
    function index(t){return t[5];}
    function ocaml_repr(t){return t[6];}
    function create(t){return t[8];}
    function tyid(t){return t[7];}
    function traverse(t){return t[2];}
    function internal_use_only(t){return t;}
    var
     Tag =
       [0,
        label,
        arity,
        args_labels,
        index,
        ocaml_repr,
        create,
        tyid,
        traverse,
        internal_use_only],
     Variant_internal = [0];
    function typename_of_t(t){return t[1];}
    function length(t){return t[2].length - 1;}
    function tag(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function is_polymorphic(t){return t[3];}
    function value(t){return t[4];}
    function fold(t, init, f){
     return caml_call3(Stdlib_Array[17], f, init, t[2]);
    }
    function internal_use_only$0(t){return t;}
    var
     Variant =
       [0,
        typename_of_t,
        length,
        tag,
        is_polymorphic,
        value,
        fold,
        internal_use_only$0],
     Field_internal = [0];
    function label$0(t){return t[1];}
    function index$0(t){return t[3];}
    function get(t){return t[5];}
    function is_mutable(t){return t[6];}
    function tyid$0(t){return t[4];}
    function traverse$0(t){return t[2];}
    function internal_use_only$1(t){return t;}
    var
     Field =
       [0,
        label$0,
        index$0,
        get,
        is_mutable,
        tyid$0,
        traverse$0,
        internal_use_only$1],
     Record_internal = [0];
    function typename_of_t$0(t){return t[1];}
    function length$0(t){return t[2].length - 1;}
    function field(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function has_double_array_tag(t){return t[3];}
    function create$0(t){return t[4];}
    function fold$0(t, init, f){
     return caml_call3(Stdlib_Array[17], f, init, t[2]);
    }
    function internal_use_only$2(t){return t;}
    var
     Record =
       [0,
        typename_of_t$0,
        length$0,
        field,
        has_double_array_tag,
        create$0,
        fold$0,
        internal_use_only$2];
    return [0,
            Tag_internal,
            Tag,
            Variant_internal,
            Variant,
            Field_internal,
            Field,
            Record_internal,
            Record];
   }
   var Typerep_lib_Variant_and_record = [0, M];
   runtime.caml_register_global
    (1,
     Typerep_lib_Variant_and_record,
     "Typerep_lib__Variant_and_record_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std_internal
//# unitInfo: Requires: Base__Int63, CamlinternalLazy, CamlinternalMod, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_std_internal_ml = "lib/std_internal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "int",
    name$0 = "int32",
    name$1 = "int64",
    name$2 = "nativeint",
    name$3 = "char",
    name$4 = "float",
    name$5 = "string",
    name$6 = "bytes",
    name$7 = "bool",
    name$8 = "unit",
    name$9 = "option",
    name$10 = "list",
    name$11 = "array",
    name$12 = "lazy_t",
    name$13 = "ref",
    name$14 = "function",
    name$15 = "tuple0",
    name$16 = "tuple2",
    name$17 = "tuple3",
    name$18 = "tuple4",
    name$19 = "tuple5",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    CamlinternalMod = global_data.CamlinternalMod,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    Base_Int63 = global_data.Base__Int63,
    typename_of_int = caml_call1(Typerep_lib_Typename[11], [0, name])[1],
    typename_of_int32 = caml_call1(Typerep_lib_Typename[11], [0, name$0])[1],
    typename_of_int64 = caml_call1(Typerep_lib_Typename[11], [0, name$1])[1],
    typename_of_nativeint =
      caml_call1(Typerep_lib_Typename[11], [0, name$2])[1],
    typename_of_char = caml_call1(Typerep_lib_Typename[11], [0, name$3])[1],
    typename_of_float = caml_call1(Typerep_lib_Typename[11], [0, name$4])[1],
    typename_of_string = caml_call1(Typerep_lib_Typename[11], [0, name$5])[1],
    typename_of_bytes = caml_call1(Typerep_lib_Typename[11], [0, name$6])[1],
    typename_of_bool = caml_call1(Typerep_lib_Typename[11], [0, name$7])[1],
    typename_of_unit = caml_call1(Typerep_lib_Typename[11], [0, name$8])[1],
    M_option = caml_call1(Typerep_lib_Typename[12], [0, name$9]),
    typename_of_option = M_option[1],
    M_list = caml_call1(Typerep_lib_Typename[12], [0, name$10]),
    typename_of_list = M_list[1],
    M_array = caml_call1(Typerep_lib_Typename[12], [0, name$11]),
    typename_of_array = M_array[1],
    M_lazy_t = caml_call1(Typerep_lib_Typename[12], [0, name$12]),
    typename_of_lazy_t = M_lazy_t[1],
    M_ref = caml_call1(Typerep_lib_Typename[12], [0, name$13]),
    typename_of_ref = M_ref[1],
    M_function = caml_call1(Typerep_lib_Typename[13], [0, name$14]),
    typename_of_function = M_function[1],
    M_tuple0 = caml_call1(Typerep_lib_Typename[11], [0, name$15]),
    typename_of_tuple0 = M_tuple0[1],
    M_tuple2 = caml_call1(Typerep_lib_Typename[13], [0, name$16]),
    typename_of_tuple2 = M_tuple2[1],
    M_tuple3 = caml_call1(Typerep_lib_Typename[14], [0, name$17]),
    typename_of_tuple3 = M_tuple3[1],
    M_tuple4 = caml_call1(Typerep_lib_Typename[15], [0, name$18]),
    typename_of_tuple4 = M_tuple4[1],
    M_tuple5 = caml_call1(Typerep_lib_Typename[16], [0, name$19]),
    typename_of_tuple5 = M_tuple5[1],
    Typerep =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_lib_std_internal_ml, 401, 6],
        [0,
         [0,
          [0, [0, 0, 0, 0]],
          [0, [0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          0,
          0,
          0,
          0,
          0]]),
    _a_ = [0, 0],
    _b_ = [0, 0],
    _c_ = [0, 0],
    _d_ = [0, 0],
    _e_ = [0, 0],
    _f_ = [0, 0],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _i_ = [0, 0],
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 0],
    _p_ = [0, cst_lib_std_internal_ml, 802, 14],
    _q_ =
      [0,
       [0,
        [0, [0, 0, 0, 0]],
        [0, [0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        0,
        0,
        0,
        0,
        0]];
   function arity(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t(param){
    switch(param[0]){
      case 0:
       var rep = param[1]; return rep[2];
      case 1:
       var rep$0 = param[1]; return rep$0[3];
      case 2:
       var rep$1 = param[1]; return rep$1[4];
      case 3:
       var rep$2 = param[1]; return rep$2[5];
      case 4:
       var rep$3 = param[1]; return rep$3[6];
      default: var rep$4 = param[1]; return rep$4[7];
    }
   }
   function name$20(rep){
    var
     ___ = typename_of_t(rep),
     _$_ = caml_call1(Typerep_lib_Typename[9], ___);
    return caml_call1(Typerep_lib_Typename[8][4], _$_);
   }
   var Named = [0, arity, typename_of_t, name$20];
   function arity$0(param){
    switch(param[0]){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t$0(param){
    switch(param[0]){
      case 0:
       var
        match = param[1],
        b = match[2],
        a = match[1],
        _Q_ = caml_call1(Typerep[14], b);
       return caml_call2(typename_of_tuple2, caml_call1(Typerep[14], a), _Q_);
      case 1:
       var
        match$0 = param[1],
        c = match$0[3],
        b$0 = match$0[2],
        a$0 = match$0[1],
        _R_ = caml_call1(Typerep[14], c),
        _S_ = caml_call1(Typerep[14], b$0);
       return caml_call3
               (typename_of_tuple3, caml_call1(Typerep[14], a$0), _S_, _R_);
      case 2:
       var
        match$1 = param[1],
        d = match$1[4],
        c$0 = match$1[3],
        b$1 = match$1[2],
        a$1 = match$1[1],
        _T_ = caml_call1(Typerep[14], d),
        _U_ = caml_call1(Typerep[14], c$0),
        _V_ = caml_call1(Typerep[14], b$1);
       return caml_call4
               (typename_of_tuple4,
                caml_call1(Typerep[14], a$1),
                _V_,
                _U_,
                _T_);
      default:
       var
        match$2 = param[1],
        e = match$2[5],
        d$0 = match$2[4],
        c$1 = match$2[3],
        b$2 = match$2[2],
        a$2 = match$2[1],
        _W_ = caml_call1(Typerep[14], e),
        _X_ = caml_call1(Typerep[14], d$0),
        _Y_ = caml_call1(Typerep[14], c$1),
        _Z_ = caml_call1(Typerep[14], b$2);
       return caml_call5
               (typename_of_tuple5,
                caml_call1(Typerep[14], a$2),
                _Z_,
                _Y_,
                _X_,
                _W_);
    }
   }
   var
    Tuple = [0, arity$0, typename_of_t$0],
    include = caml_call1(Typerep_lib_Variant_and_record[1], [0]),
    Tag_internal = include[1],
    Tag = include[2],
    Variant_internal = include[3],
    Variant = include[4],
    Field_internal = include[5],
    Field = include[6],
    Record_internal = include[7],
    Record = include[8];
   function typename_of_t$1(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return typename_of_int;
       case 1:
        return typename_of_int32;
       case 2:
        return typename_of_int64;
       case 3:
        return typename_of_nativeint;
       case 4:
        return typename_of_char;
       case 5:
        return typename_of_float;
       case 6:
        return typename_of_string;
       case 7:
        return typename_of_bytes;
       case 8:
        return typename_of_bool;
       default: return typename_of_unit;
     }
    switch(param[0]){
      case 0:
       var rep = param[1];
       return caml_call1(typename_of_option, typename_of_t$1(rep));
      case 1:
       var rep$0 = param[1];
       return caml_call1(typename_of_list, typename_of_t$1(rep$0));
      case 2:
       var rep$1 = param[1];
       return caml_call1(typename_of_array, typename_of_t$1(rep$1));
      case 3:
       var rep$2 = param[1];
       return caml_call1(typename_of_lazy_t, typename_of_t$1(rep$2));
      case 4:
       var rep$3 = param[1];
       return caml_call1(typename_of_ref, typename_of_t$1(rep$3));
      case 5:
       var
        match = param[1],
        rng = match[2],
        dom = match[1],
        _P_ = typename_of_t$1(rng);
       return caml_call2(typename_of_function, typename_of_t$1(dom), _P_);
      case 6:
       var rep$4 = param[1]; return caml_call1(Typerep[2][2], rep$4);
      case 7:
       var rep$5 = param[1]; return caml_call1(Typerep[10][1], rep$5);
      case 8:
       var rep$6 = param[1]; return caml_call1(Typerep[6][1], rep$6);
      default: var name = param[1][1]; return caml_call1(Named[2], name);
    }
   }
   function same_witness(t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     a:
     {
      if(typeof t1$0 === "number")
       switch(t1$0){
         case 0:
          if(typeof t2$0 === "number"){if(0 === t2$0) return _a_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 1:
          if(typeof t2$0 === "number"){if(1 === t2$0) return _b_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 2:
          if(typeof t2$0 === "number"){if(2 === t2$0) return _c_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 3:
          if(typeof t2$0 === "number"){if(3 === t2$0) return _d_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 4:
          if(typeof t2$0 === "number"){if(4 === t2$0) return _e_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 5:
          if(typeof t2$0 === "number"){if(5 === t2$0) return _f_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 6:
          if(typeof t2$0 === "number"){if(6 === t2$0) return _g_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 7:
          if(typeof t2$0 === "number"){if(7 === t2$0) return _h_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 8:
          if(typeof t2$0 === "number"){if(8 === t2$0) return _i_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         default:
          if(typeof t2$0 === "number"){if(9 === t2$0) return _j_; break a;}
          if(9 !== t2$0[0]) break a;
       }
      else
       b:
       switch(t1$0[0]){
         case 0:
          var r1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 0:
              var r2$0 = t2$0[1], x = same_witness(r1, r2$0);
              return x ? x : x;
             case 9:
              break b;
           }
          break a;
         case 1:
          var r1$0 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 1:
              var r2$1 = t2$0[1], x$0 = same_witness(r1$0, r2$1);
              return x$0 ? x$0 : x$0;
             case 9:
              break b;
           }
          break a;
         case 2:
          var r1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 2:
              var r2$2 = t2$0[1], x$1 = same_witness(r1$1, r2$2);
              return x$1 ? x$1 : x$1;
             case 9:
              break b;
           }
          break a;
         case 3:
          var r1$2 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 3:
              var r2$3 = t2$0[1], x$2 = same_witness(r1$2, r2$3);
              return x$2 ? x$2 : x$2;
             case 9:
              break b;
           }
          break a;
         case 4:
          var r1$3 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 4:
              var r2$4 = t2$0[1], x$3 = same_witness(r1$3, r2$4);
              return x$3 ? x$3 : x$3;
             case 9:
              break b;
           }
          break a;
         case 5:
          var _w_ = t1$0[1], rng1 = _w_[2], dom1 = _w_[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 5:
              var
               match = t2$0[1],
               rng2 = match[2],
               dom2 = match[1],
               match$0 = same_witness(dom1, dom2),
               match$1 = same_witness(rng1, rng2);
              if(match$0 && match$1) return _k_;
              return 0;
             case 9:
              break b;
           }
          break a;
         case 6:
          var t1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 6:
              var t2$2 = t2$0[1];
              switch(t1$1[0]){
                case 0:
                 var _x_ = t1$1[1];
                 if(0 !== t2$2[0]) return 0;
                 var
                  match$2 = t2$2[1],
                  b2 = match$2[2],
                  a2 = match$2[1],
                  b1 = _x_[2],
                  a1 = _x_[1],
                  match$3 = same_witness(a1, a2),
                  match$4 = same_witness(b1, b2);
                 if(match$3 && match$4) return _l_;
                 return 0;
                case 1:
                 var _y_ = t1$1[1];
                 if(1 !== t2$2[0]) return 0;
                 var
                  match$5 = t2$2[1],
                  c2 = match$5[3],
                  b2$0 = match$5[2],
                  a2$0 = match$5[1],
                  c1 = _y_[3],
                  b1$0 = _y_[2],
                  a1$0 = _y_[1],
                  match$6 = same_witness(a1$0, a2$0),
                  match$7 = same_witness(b1$0, b2$0),
                  match$8 = same_witness(c1, c2);
                 if(match$6 && match$7 && match$8) return _m_;
                 return 0;
                case 2:
                 var _z_ = t1$1[1];
                 if(2 !== t2$2[0]) return 0;
                 var
                  match$9 = t2$2[1],
                  d2 = match$9[4],
                  c2$0 = match$9[3],
                  b2$1 = match$9[2],
                  a2$1 = match$9[1],
                  d1 = _z_[4],
                  c1$0 = _z_[3],
                  b1$1 = _z_[2],
                  a1$1 = _z_[1],
                  match$10 = same_witness(a1$1, a2$1),
                  match$11 = same_witness(b1$1, b2$1),
                  match$12 = same_witness(c1$0, c2$0),
                  match$13 = same_witness(d1, d2);
                 if(match$10 && match$11 && match$12 && match$13) return _n_;
                 return 0;
                default:
                 var _A_ = t1$1[1];
                 if(3 !== t2$2[0]) return 0;
                 var
                  match$14 = t2$2[1],
                  e2 = match$14[5],
                  d2$0 = match$14[4],
                  c2$1 = match$14[3],
                  b2$2 = match$14[2],
                  a2$2 = match$14[1],
                  e1 = _A_[5],
                  d1$0 = _A_[4],
                  c1$1 = _A_[3],
                  b1$2 = _A_[2],
                  a1$2 = _A_[1],
                  match$15 = same_witness(a1$2, a2$2),
                  match$16 = same_witness(b1$2, b2$2),
                  match$17 = same_witness(c1$1, c2$1),
                  match$18 = same_witness(d1$0, d2$0),
                  match$19 = same_witness(e1, e2);
                 if(match$15 && match$16 && match$17 && match$18 && match$19)
                  return _o_;
                 return 0;
              }
             case 9:
              break b;
           }
          break a;
         case 7:
          var r1$4 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 7:
              var
               r2$5 = t2$0[1],
               _B_ = caml_call1(Typerep[10][1], r2$5),
               _C_ = caml_call1(Typerep[10][1], r1$4);
              return caml_call2(Typerep_lib_Typename[4], _C_, _B_);
             case 9:
              break b;
           }
          break a;
         case 8:
          var r1$5 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 8:
              var
               r2$6 = t2$0[1],
               _D_ = caml_call1(Typerep[6][1], r2$6),
               _E_ = caml_call1(Typerep[6][1], r1$5);
              return caml_call2(Typerep_lib_Typename[4], _E_, _D_);
             case 9:
              break b;
           }
          break a;
         default:
          var match$20 = t1$0[1], name1 = match$20[1];
          if(typeof t2$0 !== "number" && 9 === t2$0[0]){
           var
            match$21 = t2$0[1],
            r2$7 = match$21[2],
            name2 = match$21[1],
            r1$7 = match$20[2],
            _H_ = caml_call1(Named[2], name2),
            _I_ = caml_call1(Named[2], name1),
            x$4 = caml_call2(Typerep_lib_Typename[4], _I_, _H_);
           if(x$4) return x$4;
           if(r1$7){
            var _J_ = r1$7[1], _K_ = caml_obj_tag(_J_);
            c:
            if(250 === _K_)
             var t1$3 = _J_[1];
            else{
             if(246 !== _K_ && 244 !== _K_){var t1$3 = _J_; break c;}
             var t1$3 = caml_call1(CamlinternalLazy[2], _J_);
            }
            if(! r2$7){var t1$0 = t1$3; continue;}
            var _L_ = r2$7[1], _M_ = caml_obj_tag(_L_);
            c:
            if(250 === _M_)
             var t2$3 = _L_[1];
            else{
             if(246 !== _M_ && 244 !== _M_){var t2$3 = _L_; break c;}
             var t2$3 = caml_call1(CamlinternalLazy[2], _L_);
            }
            var t1$0 = t1$3, t2$0 = t2$3;
            continue;
           }
           if(! r2$7) return 0;
           var _N_ = r2$7[1], _O_ = caml_obj_tag(_N_);
           c:
           if(250 === _O_)
            var t2$4 = _N_[1];
           else{
            if(246 !== _O_ && 244 !== _O_){var t2$4 = _N_; break c;}
            var t2$4 = caml_call1(CamlinternalLazy[2], _N_);
           }
           var t2$0 = t2$4;
           continue;
          }
          var r1$6 = match$20[2];
          if(! r1$6) return 0;
          var _F_ = r1$6[1], _G_ = caml_obj_tag(_F_);
          c:
          if(250 === _G_)
           var t1$2 = _F_[1];
          else{
           if(246 !== _G_ && 244 !== _G_){var t1$2 = _F_; break c;}
           var t1$2 = caml_call1(CamlinternalLazy[2], _F_);
          }
          var t1$0 = t1$2;
          continue;
       }
      var r2 = t2$0[1][2];
      if(! r2) return 0;
      var _u_ = r2[1], _v_ = caml_obj_tag(_u_);
      b:
      if(250 === _v_)
       var t2$1 = _u_[1];
      else{
       if(246 !== _v_ && 244 !== _v_){var t2$1 = _u_; break b;}
       var t2$1 = caml_call1(CamlinternalLazy[2], _u_);
      }
      var t2$0 = t2$1;
      continue;
     }
     if(typeof t1$0 === "number")
      switch(t1$0){
        case 0: break;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        case 8:
         return 0;
        default: return 0;
      }
     else
      switch(t1$0[0]){
        case 9: break;
        case 0:
         return 0;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        default: return 0;
      }
     return 0;
    }
   }
   function same(a, b){return 0 !== same_witness(a, b) ? 1 : 0;}
   function same_witness_exn(a, b){
    var match = same_witness(a, b);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var proof = match[1];
    return proof;
   }
   function head(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 !== "number" && 9 === t$0[0]){
      var _r_ = t$0[1][2];
      if(_r_){
       var _s_ = _r_[1], _t_ = caml_obj_tag(_s_);
       a:
       if(250 === _t_)
        var t$1 = _s_[1];
       else{
        if(246 !== _t_ && 244 !== _t_){var t$1 = _s_; break a;}
        var t$1 = caml_call1(CamlinternalLazy[2], _s_);
       }
       var t$0 = t$1;
       continue;
      }
     }
     return t$0;
    }
   }
   caml_call3
    (CamlinternalMod[2],
     _q_,
     Typerep,
     [0,
      Named,
      Tuple,
      Tag_internal,
      Tag,
      Variant_internal,
      Variant,
      Field_internal,
      Field,
      Record_internal,
      Record,
      same,
      same_witness,
      same_witness_exn,
      typename_of_t$1,
      head]);
   var
    typerep_of_int = 0,
    typerep_of_int32 = 1,
    typerep_of_int64 = 2,
    typerep_of_nativeint = 3,
    typerep_of_char = 4,
    typerep_of_float = 5,
    typerep_of_string = 6,
    typerep_of_bytes = 7,
    typerep_of_bool = 8,
    typerep_of_unit = 9;
   function typerep_of_option(rep){return [0, rep];}
   function typerep_of_list(rep){return [1, rep];}
   function typerep_of_array(rep){return [2, rep];}
   function typerep_of_lazy_t(rep){return [3, rep];}
   function typerep_of_ref(rep){return [4, rep];}
   function typerep_of_function(dom, rng){return [5, [0, dom, rng]];}
   var typerep_of_tuple0 = 9;
   function typerep_of_tuple2(a, b){return [6, [0, [0, a, b]]];}
   function typerep_of_tuple3(a, b, c){return [6, [1, [0, a, b, c]]];}
   function typerep_of_tuple4(a, b, c, d){return [6, [2, [0, a, b, c, d]]];}
   function typerep_of_tuple5(a, b, c, d, e){return [6, [3, [0, a, b, c, d, e]]];
   }
   var
    value_tuple0 = 0,
    match =
      Base_Int63[118][2]
       ? [0, typerep_of_int64, typename_of_int64]
       : [0, typerep_of_int, typename_of_int],
    typename_of_int63 = match[2],
    typerep_of_int63 = match[1],
    Typerep_lib_Std_internal =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global
    (46, Typerep_lib_Std_internal, "Typerep_lib__Std_internal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerepable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Typerepable = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Typerepable, "Typerep_lib__Typerepable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerep_obj
//# unitInfo: Requires: Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_typerep_obj_ml = "lib/typerep_obj.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, cst_lib_typerep_obj_ml, 9, 4],
    _a_ = [0, cst_lib_typerep_obj_ml, 11, 4],
    cst_Latency_stats = "Latency_stats",
    _h_ = [0, cst_lib_typerep_obj_ml, 28, 9],
    cst_zero = "zero",
    _g_ = [0, cst_lib_typerep_obj_ml, 29, 9],
    _f_ = [0, cst_lib_typerep_obj_ml, 49, 2],
    _e_ = [0, cst_lib_typerep_obj_ml, 50, 2];
   function repr_of_poly_variant(variant){
    if(typeof variant === "number") return variant;
    var size = variant.length - 1;
    if(2 !== size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var repr = variant[1];
    if(typeof repr === "number") return repr;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function hash_variant(s){
    var
     accu = [0, 0],
     _k_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _l_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _l_ | 0;
      var _m_ = i + 1 | 0;
      if(_k_ === i) break;
      var i = _m_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    return 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
   }
   var _c_ = hash_variant(cst_Latency_stats);
   if(repr_of_poly_variant(-894644482) !== _c_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var _d_ = hash_variant(cst_zero);
   if(repr_of_poly_variant(-789508312) !== _d_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   function double_array_value(param){return 0.;}
   function has_double_array_tag(a){
    var _i_ = runtime.caml_obj_tag(a);
    return Stdlib_Obj[17] === _i_ ? 1 : 0;
   }
   var double$0 = [254, 0., 0.], simple = [0, 0., 0.];
   if(! has_double_array_tag(double$0))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   if(has_double_array_tag(simple))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   var
    Typerep_lib_Typerep_obj =
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
   runtime.caml_register_global
    (11, Typerep_lib_Typerep_obj, "Typerep_lib__Typerep_obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function M(X){return [0];}
   var Typerep_lib_Type_generic_intf = [0, M];
   runtime.caml_register_global
    (0, Typerep_lib_Type_generic_intf, "Typerep_lib__Type_generic_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic
//# unitInfo: Requires: Base, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Lazy, Stdlib__List, Stdlib__Printf, Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Type_generic_intf, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_type_generic_ml = "lib/type_generic.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Typerep_lib_Type_generic_intf = global_data.Typerep_lib__Type_generic_intf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    cst_Typerep_lib_Type_generic_M$0 =
      "Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented",
    _c_ =
      [0,
       [11,
        "Type_generic ",
        [3,
         0,
         [11, " requires ", [3, 0, [11, " for uid ", [3, 0, [12, 10, 0]]]]]]],
       "Type_generic %S requires %S for uid %S\n"],
    _a_ = [0, cst_lib_type_generic_ml, 185, 16],
    _b_ = [0, cst_lib_type_generic_ml, 187, 69],
    cst_Typerep_lib_Type_generic_M =
      "Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined",
    cst_Typerep_lib_Type_generic_I =
      "Typerep_lib.Type_generic.Ident.Broken_dependency";
   function Helper(A, B){
    function map_variant(param, variant){
     var
      map = param[1],
      typename = caml_call1(A[4][1], variant),
      polymorphic = caml_call1(A[4][4], variant);
     function _az_(index$0){
      var
       tag$0 = caml_call2(A[4][3], variant, index$0),
       tag = tag$0[1],
       label = caml_call1(A[2][1], tag),
       rep = caml_call1(map, caml_call1(A[2][8], tag)),
       arity = caml_call1(A[2][2], tag),
       args_labels = caml_call1(A[2][3], tag),
       index = caml_call1(A[2][4], tag),
       ocaml_repr = caml_call1(A[2][5], tag),
       tyid = caml_call1(A[2][7], tag),
       param = caml_call1(A[2][6], tag);
      if(0 === param[0])
       var fct = param[1], create = [0, fct];
      else
       var k = param[1], create = [1, k];
      return [0,
              caml_call1
               (B[2][9],
                [0,
                 label,
                 rep,
                 arity,
                 args_labels,
                 index,
                 ocaml_repr,
                 tyid,
                 create])];
     }
     var
      _aA_ = caml_call1(A[4][2], variant),
      tags = caml_call2(Stdlib_Array[1], _aA_, _az_);
     function value(a){
      var
       match = caml_call2(A[4][5], variant, a),
       a$0 = match[2],
       atag = match[1],
       _aB_ = caml_call1(A[2][4], atag),
       btag = caml_check_bound(tags, _aB_)[1 + _aB_][1],
       _aC_ = caml_call1(B[2][7], btag),
       _aD_ = caml_call1(A[2][7], atag);
      caml_call2(Typerep_lib_Typename[5], _aD_, _aC_);
      return [0, btag, a$0];
     }
     return caml_call1(B[4][7], [0, typename, tags, polymorphic, value]);
    }
    function map_record(param, record){
     var
      map = param[1],
      typename = caml_call1(A[8][1], record),
      has_double_array_tag = caml_call1(A[8][4], record);
     function _au_(index$0){
      var
       field$0 = caml_call2(A[8][3], record, index$0),
       field = field$0[1],
       label = caml_call1(A[6][1], field),
       rep = caml_call1(map, caml_call1(A[6][6], field)),
       index = caml_call1(A[6][2], field),
       is_mutable = caml_call1(A[6][4], field),
       tyid = caml_call1(A[6][5], field),
       get = caml_call1(A[6][3], field);
      return [0,
              caml_call1
               (B[6][7], [0, label, rep, index, tyid, get, is_mutable])];
     }
     var
      _av_ = caml_call1(A[8][2], record),
      fields = caml_call2(Stdlib_Array[1], _av_, _au_);
     function create(param){
      var get = param[1];
      function get$0(afield){
       var
        _aw_ = caml_call1(A[6][2], afield),
        bfield = caml_check_bound(fields, _aw_)[1 + _aw_][1],
        _ax_ = caml_call1(B[6][5], bfield),
        _ay_ = caml_call1(A[6][5], afield);
       caml_call2(Typerep_lib_Typename[5], _ay_, _ax_);
       return caml_call1(get, bfield);
      }
      return caml_call2(A[8][5], record, [0, get$0]);
     }
     return caml_call1
             (B[8][7], [0, typename, fields, has_double_array_tag, create]);
    }
    return [0, map_variant, map_record];
   }
   var
    Broken_dependency =
      [248, cst_Typerep_lib_Type_generic_I, caml_fresh_oo_id(0)],
    _d_ = Typerep_lib_Typename[6];
   caml_call1(Stdlib_Hashtbl[26], [0, _d_[2], _d_[3]]);
   function _e_(X){
    var required = X[2], name = X[1];
    caml_call1(Typerep_lib_Type_generic_intf[1], [0]);
    var
     _k_ = Typerep_lib_Typename[8],
     include = caml_call1(Stdlib_Hashtbl[26], [0, _k_[2], _k_[3]]),
     create = include[1],
     replace = include[10],
     mem = include[11],
     _l_ = include[7];
    function find(table, key){
     if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
     var _aq_ = caml_obj_tag(table);
     a:
     if(250 === _aq_)
      var table$0 = table[1];
     else{
      if(246 !== _aq_ && 244 !== _aq_){var table$0 = table; break a;}
      var table$0 = caml_call1(CamlinternalLazy[2], table);
     }
     try{var _as_ = [0, caml_call2(_l_, table$0, key)]; return _as_;}
     catch(_at_){
      var _ar_ = caml_wrap_exception(_at_);
      if(_ar_[1] !== Base[248] && _ar_ !== Stdlib[8])
       throw caml_maybe_attach_backtrace(_ar_, 0);
      return 0;
     }
    }
    var
     check_dependencies =
       required
        ? function
         (uid){
          function _an_(param){
           var
            implements$0 = param[2],
            name$0 = param[1],
            _ao_ = 1 - caml_call1(implements$0, uid);
           if(! _ao_) return _ao_;
           var
            _ap_ = caml_call1(Typerep_lib_Typename[8][4], uid),
            message = caml_call4(Stdlib_Printf[4], _c_, name, name$0, _ap_);
           caml_call1(Stdlib[53], message);
           throw caml_maybe_attach_backtrace
                  ([0, Broken_dependency, message], 1);
          }
          return caml_call2(Stdlib_List[18], _an_, required);
         }
        : function(param){return;};
    function replace$0(table, key, value){
     check_dependencies(key);
     var _al_ = caml_obj_tag(table);
     a:
     if(250 === _al_)
      var _am_ = table[1];
     else{
      if(246 !== _al_ && 244 !== _al_){var _am_ = table; break a;}
      var _am_ = caml_call1(CamlinternalLazy[2], table);
     }
     return caml_call3(replace, _am_, key, value);
    }
    function mem$0(table, key){
     if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
     var _ak_ = caml_obj_tag(table);
     a:
     if(250 === _ak_)
      var table$0 = table[1];
     else{
      if(246 !== _ak_ && 244 !== _ak_){var table$0 = table; break a;}
      var table$0 = caml_call1(CamlinternalLazy[2], table);
     }
     return caml_call2(mem, table$0, key);
    }
    var
     size = 256,
     table0 = [246, function(_aj_){return caml_call1(create, size);}],
     table1 = [246, function(_ai_){return caml_call1(create, size);}],
     table2 = [246, function(_ah_){return caml_call1(create, size);}],
     table3 = [246, function(_ag_){return caml_call1(create, size);}],
     table4 = [246, function(_af_){return caml_call1(create, size);}],
     table5 = [246, function(_ae_){return caml_call1(create, size);}];
    function is_registered(uid){
     var ___ = mem$0(table0, uid);
     if(___)
      var _$_ = ___;
     else{
      var _aa_ = mem$0(table1, uid);
      if(_aa_)
       var _$_ = _aa_;
      else{
       var _ab_ = mem$0(table2, uid);
       if(_ab_)
        var _$_ = _ab_;
       else{
        var _ac_ = mem$0(table3, uid);
        if(_ac_)
         var _$_ = _ac_;
        else{
         var _ad_ = mem$0(table4, uid);
         if(! _ad_) return mem$0(table5, uid);
         var _$_ = _ad_;
        }
       }
      }
     }
     return _$_;
    }
    var ident = [0, name, is_registered], unit = Typerep_lib_Typename[2];
    function register0(compute){
     var uid = caml_call1(Typerep_lib_Typename[9], compute[2]);
     return replace$0(table0, uid, compute);
    }
    function register1(compute){
     var
      _Z_ = caml_call1(compute[2], unit),
      uid = caml_call1(Typerep_lib_Typename[9], _Z_);
     return replace$0(table1, uid, compute);
    }
    function register2(compute){
     var
      _Y_ = caml_call2(compute[2], unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _Y_);
     return replace$0(table2, uid, compute);
    }
    function register3(compute){
     var
      _X_ = caml_call3(compute[2], unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _X_);
     return replace$0(table3, uid, compute);
    }
    function register4(compute){
     var
      _W_ = caml_call4(compute[2], unit, unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _W_);
     return replace$0(table4, uid, compute);
    }
    function register5(compute){
     var
      _V_ = caml_call5(compute[2], unit, unit, unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _V_);
     return replace$0(table5, uid, compute);
    }
    function register(typerep_of_a, compute){
     var
      typename_of_t =
        caml_call1(Typerep_lib_Std_internal[1][14], typerep_of_a);
     return register0([0, typerep_of_a, typename_of_t, compute]);
    }
    var
     Not_implemented =
       [248, cst_Typerep_lib_Type_generic_M$0, caml_fresh_oo_id(0)],
     Memo = caml_call1(Typerep_lib_Typename[17], [0]),
     _m_ = Typerep_lib_Std_internal[1],
     Helper$0 =
       Helper
        ([0, _m_[3], _m_[4], _m_[5], _m_[6], _m_[7], _m_[8], _m_[9], _m_[10]],
         [0, X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10]]);
    function of_typerep(rep){
     var
      context = caml_call1(X[33][1][1], 0),
      memo_table = caml_call1(Memo[1], 32);
     function of_typerep(param){
      var param$0 = param;
      for(;;){
       if(typeof param$0 === "number")
        switch(param$0){
          case 0:
           return X[11];
          case 1:
           return X[12];
          case 2:
           return X[13];
          case 3:
           return X[14];
          case 4:
           return X[15];
          case 5:
           return X[16];
          case 6:
           return X[17];
          case 7:
           return X[18];
          case 8:
           return X[19];
          default: return X[20];
        }
       switch(param$0[0]){
         case 0:
          var rep$11 = param$0[1], _J_ = of_typerep(rep$11);
          return caml_call1(X[21], _J_);
         case 1:
          var rep$12 = param$0[1], _K_ = of_typerep(rep$12);
          return caml_call1(X[22], _K_);
         case 2:
          var rep$13 = param$0[1], _L_ = of_typerep(rep$13);
          return caml_call1(X[23], _L_);
         case 3:
          var rep$14 = param$0[1], _M_ = of_typerep(rep$14);
          return caml_call1(X[24], _M_);
         case 4:
          var rep$15 = param$0[1], _N_ = of_typerep(rep$15);
          return caml_call1(X[25], _N_);
         case 5:
          var
           match$11 = param$0[1],
           rng = match$11[2],
           dom = match$11[1],
           _O_ = of_typerep(rng),
           _P_ = of_typerep(dom);
          return caml_call2(X[26], _P_, _O_);
         case 6:
          var tuple = param$0[1];
          switch(tuple[0]){
            case 0:
             var
              match$12 = tuple[1],
              b = match$12[2],
              a = match$12[1],
              ra = of_typerep(a),
              rb = of_typerep(b);
             return caml_call2(X[27], ra, rb);
            case 1:
             var
              match$13 = tuple[1],
              c = match$13[3],
              b$0 = match$13[2],
              a$0 = match$13[1],
              ra$0 = of_typerep(a$0),
              rb$0 = of_typerep(b$0),
              rc = of_typerep(c);
             return caml_call3(X[28], ra$0, rb$0, rc);
            case 2:
             var
              match$14 = tuple[1],
              d = match$14[4],
              c$0 = match$14[3],
              b$1 = match$14[2],
              a$1 = match$14[1],
              ra$1 = of_typerep(a$1),
              rb$1 = of_typerep(b$1),
              rc$0 = of_typerep(c$0),
              rd = of_typerep(d);
             return caml_call4(X[29], ra$1, rb$1, rc$0, rd);
            default:
             var
              match$15 = tuple[1],
              e = match$15[5],
              d$0 = match$15[4],
              c$1 = match$15[3],
              b$2 = match$15[2],
              a$2 = match$15[1],
              ra$2 = of_typerep(a$2),
              rb$2 = of_typerep(b$2),
              rc$1 = of_typerep(c$1),
              rd$0 = of_typerep(d$0),
              re = of_typerep(e);
             return caml_call5(X[30], ra$2, rb$2, rc$1, rd$0, re);
          }
         case 7:
          var
           record = param$0[1],
           _Q_ = caml_call2(Helper$0[2], [0, of_typerep], record);
          return caml_call1(X[31], _Q_);
         case 8:
          var
           variant = param$0[1],
           _R_ = caml_call2(Helper$0[1], [0, of_typerep], variant);
          return caml_call1(X[32], _R_);
         default:
          var
           match$16 = param$0[1],
           content = match$16[2],
           named = match$16[1],
           typename = caml_call1(Typerep_lib_Std_internal[1][1][2], named),
           match$17 = caml_call2(Memo[4], memo_table, typename);
          if(match$17){
           var shared = match$17[1];
           return caml_call1(X[33][3], shared);
          }
          switch(named[0]){
            case 0:
             var
              rep$5 = named[1],
              match =
                find(table0, caml_call1(Typerep_lib_Typename[9], rep$5[2]));
             if(match)
              var
               rep = match[1],
               witness = caml_call2(Typerep_lib_Typename[5], rep[2], rep$5[1]),
               L = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _n_ = rep[3],
               _o_ = caml_call1(L[1], witness),
               match$5 = [0, caml_call2(Typerep_lib_Type_equal[1], _o_, _n_)];
             else
              var match$5 = 0;
             if(match$5)
              var custom = match$5[1], match$18 = [0, custom];
             else
              var match$18 = 0;
             break;
            case 1:
             var
              rep$6 = named[1],
              match$0 =
                find(table1, caml_call1(Typerep_lib_Typename[9], rep$6[3]));
             if(match$0)
              var
               rep$0 = match$0[1],
               typename_of_t = rep$6[2],
               Conv =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[18], [0, rep$0[2]]),
                   [0, typename_of_t]),
               L$0 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _p_ = rep$0[3],
               _q_ = caml_call1(L$0[1], Conv[1][1]),
               match$6 = [0, caml_call2(Typerep_lib_Type_equal[1], _q_, _p_)];
             else
              var match$6 = 0;
             if(match$6)
              var
               custom$0 = match$6[1],
               custom$1 = caml_call1(custom$0, of_typerep(rep$6[1])),
               match$18 = [0, custom$1];
             else
              var match$18 = 0;
             break;
            case 2:
             var
              rep$7 = named[1],
              match$1 =
                find(table2, caml_call1(Typerep_lib_Typename[9], rep$7[4]));
             if(match$1)
              var
               rep$1 = match$1[1],
               typename_of_t$0 = rep$7[3],
               Conv$0 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[19], [0, rep$1[2]]),
                   [0, typename_of_t$0]),
               L$1 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _r_ = rep$1[3],
               _s_ = caml_call1(L$1[1], Conv$0[1][1]),
               match$7 = [0, caml_call2(Typerep_lib_Type_equal[1], _s_, _r_)];
             else
              var match$7 = 0;
             if(match$7)
              var
               custom$2 = match$7[1],
               _z_ = of_typerep(rep$7[2]),
               custom$3 = caml_call2(custom$2, of_typerep(rep$7[1]), _z_),
               match$18 = [0, custom$3];
             else
              var match$18 = 0;
             break;
            case 3:
             var
              rep$8 = named[1],
              match$2 =
                find(table3, caml_call1(Typerep_lib_Typename[9], rep$8[5]));
             if(match$2)
              var
               rep$2 = match$2[1],
               typename_of_t$1 = rep$8[4],
               Conv$1 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[20], [0, rep$2[2]]),
                   [0, typename_of_t$1]),
               L$2 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _t_ = rep$2[3],
               _u_ = caml_call1(L$2[1], Conv$1[1][1]),
               match$8 = [0, caml_call2(Typerep_lib_Type_equal[1], _u_, _t_)];
             else
              var match$8 = 0;
             if(match$8)
              var
               custom$4 = match$8[1],
               _A_ = of_typerep(rep$8[3]),
               _B_ = of_typerep(rep$8[2]),
               custom$5 = caml_call3(custom$4, of_typerep(rep$8[1]), _B_, _A_),
               match$18 = [0, custom$5];
             else
              var match$18 = 0;
             break;
            case 4:
             var
              rep$9 = named[1],
              match$3 =
                find(table4, caml_call1(Typerep_lib_Typename[9], rep$9[6]));
             if(match$3)
              var
               rep$3 = match$3[1],
               typename_of_t$2 = rep$9[5],
               Conv$2 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[21], [0, rep$3[2]]),
                   [0, typename_of_t$2]),
               L$3 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _v_ = rep$3[3],
               _w_ = caml_call1(L$3[1], Conv$2[1][1]),
               match$9 = [0, caml_call2(Typerep_lib_Type_equal[1], _w_, _v_)];
             else
              var match$9 = 0;
             if(match$9)
              var
               custom$6 = match$9[1],
               _C_ = of_typerep(rep$9[4]),
               _D_ = of_typerep(rep$9[3]),
               _E_ = of_typerep(rep$9[2]),
               custom$7 =
                 caml_call4(custom$6, of_typerep(rep$9[1]), _E_, _D_, _C_),
               match$18 = [0, custom$7];
             else
              var match$18 = 0;
             break;
            default:
             var
              rep$10 = named[1],
              match$4 =
                find(table5, caml_call1(Typerep_lib_Typename[9], rep$10[7]));
             if(match$4)
              var
               rep$4 = match$4[1],
               typename_of_t$3 = rep$10[6],
               Conv$3 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[22], [0, rep$4[2]]),
                   [0, typename_of_t$3]),
               L$4 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _x_ = rep$4[3],
               _y_ = caml_call1(L$4[1], Conv$3[1][1]),
               match$10 = [0, caml_call2(Typerep_lib_Type_equal[1], _y_, _x_)];
             else
              var match$10 = 0;
             if(match$10)
              var
               custom$8 = match$10[1],
               _F_ = of_typerep(rep$10[5]),
               _G_ = of_typerep(rep$10[4]),
               _H_ = of_typerep(rep$10[3]),
               _I_ = of_typerep(rep$10[2]),
               custom$9 =
                 caml_call5
                  (custom$8, of_typerep(rep$10[1]), _I_, _H_, _G_, _F_),
               match$18 = [0, custom$9];
             else
              var match$18 = 0;
          }
          if(match$18){var computation = match$18[1]; return computation;}
          if(! content){
           var
            _U_ = caml_call1(Typerep_lib_Typename[9], typename),
            string = caml_call1(Typerep_lib_Typename[8][4], _U_);
           throw caml_maybe_attach_backtrace
                  ([0, Not_implemented, name, string], 1);
          }
          var _S_ = content[1], _T_ = caml_obj_tag(_S_);
          a:
          if(250 === _T_)
           var content$0 = _S_[1];
          else{
           if(246 !== _T_ && 244 !== _T_){var content$0 = _S_; break a;}
           var content$0 = caml_call1(CamlinternalLazy[2], _S_);
          }
          if(caml_call1(X[33][5], content$0)){
           var shared$0 = caml_call2(X[33][2], context, typename);
           caml_call3(Memo[3], memo_table, typename, shared$0);
           var computation$0 = of_typerep(content$0);
           return caml_call2(X[33][4], shared$0, computation$0);
          }
          var param$0 = content$0;
       }
      }
     }
     var computation = of_typerep(rep);
     return [0, 911962647, computation];
    }
    return [0,
            ident,
            Not_implemented,
            register0,
            register1,
            register2,
            register3,
            register4,
            register5,
            register,
            of_typerep,
            [0,
             X[3],
             X[4],
             X[5],
             X[6],
             X[7],
             X[8],
             X[9],
             X[10],
             X[11],
             X[12],
             X[13],
             X[14],
             X[15],
             X[16],
             X[17],
             X[18],
             X[19],
             X[20],
             X[21],
             X[22],
             X[23],
             X[24],
             X[25],
             X[26],
             X[27],
             X[28],
             X[29],
             X[30],
             X[31],
             X[32],
             X[33]]];
   }
   var
    _f_ = [0],
    Typerep_lib_Type_generic =
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(_g_){
        function create(_j_){return 0;}
        var
         Context = [0, create],
         Undefined =
           [248, cst_Typerep_lib_Type_generic_M, caml_fresh_oo_id(0)];
        function init(param, name){
         var
          _h_ = caml_call1(Typerep_lib_Typename[9], name),
          path = caml_call1(Typerep_lib_Typename[8][4], _h_),
          r =
            [0,
             function(param){
              throw caml_maybe_attach_backtrace([0, Undefined, path], 1);
             }],
          _i_ = [0, 0];
         return [0, function(input){return caml_call1(r[1], input);}, r, _i_];
        }
        function get_wip_computation(shared){
         var match = shared[3][1];
         if(! match) return shared[1];
         var clos = match[1];
         return clos;
        }
        function set_final_computation(shared, computation){
         var compiletime_dereference = shared[3];
         if(compiletime_dereference[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         if(shared[1] === computation)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         compiletime_dereference[1] = [0, computation];
         shared[2][1] = computation;
         return computation;
        }
        function share(param){return 1;}
        return [0,
                Context,
                init,
                get_wip_computation,
                set_final_computation,
                share];
       },
       _f_,
       _e_];
   runtime.caml_register_global
    (20, Typerep_lib_Type_generic, "Typerep_lib__Type_generic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Make_typename
//# unitInfo: Requires: Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename;
   function _a_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[16], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3, of_p4, of_p5){
     var
      _p_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p5),
      _q_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
      _r_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _s_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _t_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call5(Name_of_x[1], _t_, _s_, _r_, _q_, _p_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [5,
             [0,
              of_p1,
              of_p2,
              of_p3,
              of_p4,
              of_p5,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _b_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[15], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3, of_p4){
     var
      _l_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
      _m_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _n_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _o_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call4(Name_of_x[1], _o_, _n_, _m_, _l_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [4,
             [0,
              of_p1,
              of_p2,
              of_p3,
              of_p4,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _c_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[14], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3){
     var
      _i_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _j_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _k_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call3(Name_of_x[1], _k_, _j_, _i_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [3,
             [0,
              of_p1,
              of_p2,
              of_p3,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _d_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[13], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2){
     var
      _g_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _h_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call2(Name_of_x[1], _h_, _g_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [2, [0, of_p1, of_p2, typename_of_named, typename_of_t, witness]];
    }
    return [0, named, typename_of_t];
   }
   function _e_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[12], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1){
     var
      _f_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call1(Name_of_x[1], _f_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [1, [0, of_p1, typename_of_named, typename_of_t, witness]];
    }
    return [0, named, typename_of_t];
   }
   var
    Typerep_lib_Make_typename =
      [0,
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[11], X),
         typename_of_t = Name_of_x[1],
         typename_of_named = Name_of_x[1],
         witness = Typerep_lib_Type_equal[2],
         named = [0, [0, typename_of_named, typename_of_t, witness]];
        return [0, named, typename_of_t];
       },
       _e_,
       _d_,
       _c_,
       _b_,
       _a_];
   runtime.caml_register_global
    (3, Typerep_lib_Make_typename, "Typerep_lib__Make_typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_abstract
//# unitInfo: Requires: Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   function Make0(X){
    var
     M = caml_call1(Typerep_lib_Make_typename[1], X),
     typerep_of_t = [9, [0, M[1], 0]],
     typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make1(X){
    var M = caml_call1(Typerep_lib_Make_typename[2], X);
    function typerep_of_t(of_p1){return [9, [0, caml_call1(M[1], of_p1), 0]];}
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make2(X){
    var M = caml_call1(Typerep_lib_Make_typename[3], X);
    function typerep_of_t(of_p1, of_p2){
     return [9, [0, caml_call2(M[1], of_p1, of_p2), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make3(X){
    var M = caml_call1(Typerep_lib_Make_typename[4], X);
    function typerep_of_t(of_p1, of_p2, of_p3){
     return [9, [0, caml_call3(M[1], of_p1, of_p2, of_p3), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make4(X){
    var M = caml_call1(Typerep_lib_Make_typename[5], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4){
     return [9, [0, caml_call4(M[1], of_p1, of_p2, of_p3, of_p4), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make5(X){
    var M = caml_call1(Typerep_lib_Make_typename[6], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4, of_p5){
     return [9, [0, caml_call5(M[1], of_p1, of_p2, of_p3, of_p4, of_p5), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   var
    Typerep_lib_Type_abstract = [0, Make0, Make1, Make2, Make3, Make4, Make5];
   runtime.caml_register_global
    (1, Typerep_lib_Type_abstract, "Typerep_lib__Type_abstract");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std
//# unitInfo: Requires: Typerep_lib__Std_internal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep = Typerep_lib_Std_internal[1],
    typerep_of_int = Typerep_lib_Std_internal[2],
    typerep_of_int32 = Typerep_lib_Std_internal[3],
    typerep_of_int64 = Typerep_lib_Std_internal[4],
    typerep_of_nativeint = Typerep_lib_Std_internal[5],
    typerep_of_int63 = Typerep_lib_Std_internal[6],
    typerep_of_char = Typerep_lib_Std_internal[7],
    typerep_of_float = Typerep_lib_Std_internal[8],
    typerep_of_string = Typerep_lib_Std_internal[9],
    typerep_of_bytes = Typerep_lib_Std_internal[10],
    typerep_of_bool = Typerep_lib_Std_internal[11],
    typerep_of_unit = Typerep_lib_Std_internal[12],
    value_tuple0 = Typerep_lib_Std_internal[13],
    typerep_of_option = Typerep_lib_Std_internal[14],
    typerep_of_list = Typerep_lib_Std_internal[15],
    typerep_of_array = Typerep_lib_Std_internal[16],
    typerep_of_lazy_t = Typerep_lib_Std_internal[17],
    typerep_of_ref = Typerep_lib_Std_internal[18],
    typerep_of_function = Typerep_lib_Std_internal[19],
    typerep_of_tuple0 = Typerep_lib_Std_internal[20],
    typerep_of_tuple2 = Typerep_lib_Std_internal[21],
    typerep_of_tuple3 = Typerep_lib_Std_internal[22],
    typerep_of_tuple4 = Typerep_lib_Std_internal[23],
    typerep_of_tuple5 = Typerep_lib_Std_internal[24],
    typename_of_int = Typerep_lib_Std_internal[25],
    typename_of_int32 = Typerep_lib_Std_internal[26],
    typename_of_int64 = Typerep_lib_Std_internal[27],
    typename_of_nativeint = Typerep_lib_Std_internal[28],
    typename_of_int63 = Typerep_lib_Std_internal[29],
    typename_of_char = Typerep_lib_Std_internal[30],
    typename_of_float = Typerep_lib_Std_internal[31],
    typename_of_string = Typerep_lib_Std_internal[32],
    typename_of_bytes = Typerep_lib_Std_internal[33],
    typename_of_bool = Typerep_lib_Std_internal[34],
    typename_of_unit = Typerep_lib_Std_internal[35],
    typename_of_option = Typerep_lib_Std_internal[36],
    typename_of_list = Typerep_lib_Std_internal[37],
    typename_of_array = Typerep_lib_Std_internal[38],
    typename_of_lazy_t = Typerep_lib_Std_internal[39],
    typename_of_ref = Typerep_lib_Std_internal[40],
    typename_of_function = Typerep_lib_Std_internal[41],
    typename_of_tuple0 = Typerep_lib_Std_internal[42],
    typename_of_tuple2 = Typerep_lib_Std_internal[43],
    typename_of_tuple3 = Typerep_lib_Std_internal[44],
    typename_of_tuple4 = Typerep_lib_Std_internal[45],
    typename_of_tuple5 = Typerep_lib_Std_internal[46],
    Typerep_lib_Std =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global(1, Typerep_lib_Std, "Typerep_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicmVmbCIsImNvbnYiLCJ4IiwibGlmdCIsImNvbXBhcmUiLCJhIiwiYiIsImVxdWFsIiwidWlkIiwibmV4dCIsIm5hbWUiLCJjb2RlIiwiaGFzaCIsInN0YXRpYyQwIiwiY29tcGFyZSQwIiwiazEiLCJrMiIsImNtcCIsImIkMCIsImEkMCIsInlzIiwieSIsInhzIiwibiIsImVxdWFsJDAiLCJoYXNoJDAiLCJzdGF0aWMkMSIsImtleSIsInQiLCJ1aWQkMCIsIm5hbWUkMCIsImNyZWF0ZSIsIm9wdCIsInN0aCIsInNhbWUiLCJubTEiLCJubTIiLCJzYW1lX3dpdG5lc3MiLCJzYW1lX3dpdG5lc3NfZXhuIiwiaW50JDAiLCJtZW0iLCJ0YWJsZSIsInNldCIsImRhdGEiLCJmaW5kIiwiZGF0YSQwIiwiZmFpbCIsInVpZF9hIiwidWlkX2IiLCJtc2ciLCJlcSIsIndpdG5lc3MiLCJ0eXBlbmFtZV9vZl90IiwiYyIsImQiLCJlIiwibGFiZWwiLCJhcml0eSIsImFyZ3NfbGFiZWxzIiwiaW5kZXgiLCJvY2FtbF9yZXByIiwidHlpZCIsInRyYXZlcnNlIiwiaW50ZXJuYWxfdXNlX29ubHkiLCJsZW5ndGgiLCJ0YWciLCJpc19wb2x5bW9ycGhpYyIsInZhbHVlIiwiZm9sZCIsImluaXQiLCJmIiwiaW50ZXJuYWxfdXNlX29ubHkkMCIsImxhYmVsJDAiLCJpbmRleCQwIiwiZ2V0IiwiaXNfbXV0YWJsZSIsInR5aWQkMCIsInRyYXZlcnNlJDAiLCJpbnRlcm5hbF91c2Vfb25seSQxIiwidHlwZW5hbWVfb2ZfdCQwIiwibGVuZ3RoJDAiLCJmaWVsZCIsImhhc19kb3VibGVfYXJyYXlfdGFnIiwiY3JlYXRlJDAiLCJmb2xkJDAiLCJpbnRlcm5hbF91c2Vfb25seSQyIiwibmFtZSQxIiwibmFtZSQyIiwibmFtZSQzIiwibmFtZSQ0IiwibmFtZSQ1IiwibmFtZSQ2IiwibmFtZSQ3IiwibmFtZSQ4IiwibmFtZSQ5IiwibmFtZSQxMCIsIm5hbWUkMTEiLCJuYW1lJDEyIiwibmFtZSQxMyIsIm5hbWUkMTQiLCJuYW1lJDE1IiwibmFtZSQxNiIsIm5hbWUkMTciLCJuYW1lJDE4IiwibmFtZSQxOSIsInR5cGVuYW1lX29mX2ludCIsInR5cGVuYW1lX29mX2ludDMyIiwidHlwZW5hbWVfb2ZfaW50NjQiLCJ0eXBlbmFtZV9vZl9uYXRpdmVpbnQiLCJ0eXBlbmFtZV9vZl9jaGFyIiwidHlwZW5hbWVfb2ZfZmxvYXQiLCJ0eXBlbmFtZV9vZl9zdHJpbmciLCJ0eXBlbmFtZV9vZl9ieXRlcyIsInR5cGVuYW1lX29mX2Jvb2wiLCJ0eXBlbmFtZV9vZl91bml0IiwidHlwZW5hbWVfb2Zfb3B0aW9uIiwidHlwZW5hbWVfb2ZfbGlzdCIsInR5cGVuYW1lX29mX2FycmF5IiwidHlwZW5hbWVfb2ZfbGF6eV90IiwidHlwZW5hbWVfb2ZfcmVmIiwidHlwZW5hbWVfb2ZfZnVuY3Rpb24iLCJ0eXBlbmFtZV9vZl90dXBsZTAiLCJ0eXBlbmFtZV9vZl90dXBsZTIiLCJ0eXBlbmFtZV9vZl90dXBsZTMiLCJ0eXBlbmFtZV9vZl90dXBsZTQiLCJ0eXBlbmFtZV9vZl90dXBsZTUiLCJyZXAiLCJyZXAkMCIsInJlcCQxIiwicmVwJDIiLCJyZXAkMyIsInJlcCQ0IiwibmFtZSQyMCIsImFyaXR5JDAiLCJjJDAiLCJiJDEiLCJhJDEiLCJkJDAiLCJjJDEiLCJiJDIiLCJhJDIiLCJ0eXBlbmFtZV9vZl90JDEiLCJybmciLCJkb20iLCJyZXAkNSIsInJlcCQ2IiwidDEiLCJ0MiIsInQxJDAiLCJ0MiQwIiwicjEiLCJyMiQwIiwicjEkMCIsInIyJDEiLCJ4JDAiLCJyMSQxIiwicjIkMiIsIngkMSIsInIxJDIiLCJyMiQzIiwieCQyIiwicjEkMyIsInIyJDQiLCJ4JDMiLCJybmcxIiwiZG9tMSIsInJuZzIiLCJkb20yIiwidDEkMSIsInQyJDIiLCJiMiIsImEyIiwiYjEiLCJhMSIsImMyIiwiYjIkMCIsImEyJDAiLCJjMSIsImIxJDAiLCJhMSQwIiwiZDIiLCJjMiQwIiwiYjIkMSIsImEyJDEiLCJkMSIsImMxJDAiLCJiMSQxIiwiYTEkMSIsImUyIiwiZDIkMCIsImMyJDEiLCJiMiQyIiwiYTIkMiIsImUxIiwiZDEkMCIsImMxJDEiLCJiMSQyIiwiYTEkMiIsInIxJDQiLCJyMiQ1IiwicjEkNSIsInIyJDYiLCJuYW1lMSIsInIyJDciLCJuYW1lMiIsInIxJDciLCJ4JDQiLCJ0MSQzIiwidDIkMyIsInQyJDQiLCJyMSQ2IiwidDEkMiIsInIyIiwidDIkMSIsInByb29mIiwiaGVhZCIsInQkMCIsInQkMSIsInR5cGVyZXBfb2ZfaW50IiwidHlwZXJlcF9vZl9pbnQzMiIsInR5cGVyZXBfb2ZfaW50NjQiLCJ0eXBlcmVwX29mX25hdGl2ZWludCIsInR5cGVyZXBfb2ZfY2hhciIsInR5cGVyZXBfb2ZfZmxvYXQiLCJ0eXBlcmVwX29mX3N0cmluZyIsInR5cGVyZXBfb2ZfYnl0ZXMiLCJ0eXBlcmVwX29mX2Jvb2wiLCJ0eXBlcmVwX29mX3VuaXQiLCJ0eXBlcmVwX29mX29wdGlvbiIsInR5cGVyZXBfb2ZfbGlzdCIsInR5cGVyZXBfb2ZfYXJyYXkiLCJ0eXBlcmVwX29mX2xhenlfdCIsInR5cGVyZXBfb2ZfcmVmIiwidHlwZXJlcF9vZl9mdW5jdGlvbiIsInR5cGVyZXBfb2ZfdHVwbGUwIiwidHlwZXJlcF9vZl90dXBsZTIiLCJ0eXBlcmVwX29mX3R1cGxlMyIsInR5cGVyZXBfb2ZfdHVwbGU0IiwidHlwZXJlcF9vZl90dXBsZTUiLCJ2YWx1ZV90dXBsZTAiLCJ0eXBlbmFtZV9vZl9pbnQ2MyIsInR5cGVyZXBfb2ZfaW50NjMiLCJyZXByX29mX3BvbHlfdmFyaWFudCIsInZhcmlhbnQiLCJzaXplIiwicmVwciIsImhhc2hfdmFyaWFudCIsInMiLCJhY2N1IiwiaSIsImRvdWJsZV9hcnJheV92YWx1ZSIsImRvdWJsZSQwIiwic2ltcGxlIiwibWFwX3ZhcmlhbnQiLCJtYXAiLCJ0eXBlbmFtZSIsInBvbHltb3JwaGljIiwidGFnJDAiLCJmY3QiLCJrIiwidGFncyIsImF0YWciLCJidGFnIiwibWFwX3JlY29yZCIsInJlY29yZCIsImZpZWxkJDAiLCJmaWVsZHMiLCJnZXQkMCIsImFmaWVsZCIsImJmaWVsZCIsInJlcXVpcmVkIiwidGFibGUkMCIsImNoZWNrX2RlcGVuZGVuY2llcyIsImltcGxlbWVudHMkMCIsIm1lc3NhZ2UiLCJyZXBsYWNlJDAiLCJtZW0kMCIsInRhYmxlMCIsInRhYmxlMSIsInRhYmxlMiIsInRhYmxlMyIsInRhYmxlNCIsInRhYmxlNSIsImlzX3JlZ2lzdGVyZWQiLCJpZGVudCIsInVuaXQiLCJyZWdpc3RlcjAiLCJjb21wdXRlIiwicmVnaXN0ZXIxIiwicmVnaXN0ZXIyIiwicmVnaXN0ZXIzIiwicmVnaXN0ZXI0IiwicmVnaXN0ZXI1IiwicmVnaXN0ZXIiLCJ0eXBlcmVwX29mX2EiLCJvZl90eXBlcmVwIiwiY29udGV4dCIsIm1lbW9fdGFibGUiLCJyZXAkMTEiLCJyZXAkMTIiLCJyZXAkMTMiLCJyZXAkMTQiLCJyZXAkMTUiLCJ0dXBsZSIsInJhIiwicmIiLCJyYSQwIiwicmIkMCIsInJjIiwicmEkMSIsInJiJDEiLCJyYyQwIiwicmQiLCJyYSQyIiwicmIkMiIsInJjJDEiLCJyZCQwIiwicmUiLCJjb250ZW50IiwibmFtZWQiLCJzaGFyZWQiLCJjdXN0b20iLCJjdXN0b20kMCIsImN1c3RvbSQxIiwicmVwJDciLCJjdXN0b20kMiIsImN1c3RvbSQzIiwicmVwJDgiLCJjdXN0b20kNCIsImN1c3RvbSQ1IiwicmVwJDkiLCJ0eXBlbmFtZV9vZl90JDIiLCJjdXN0b20kNiIsImN1c3RvbSQ3IiwicmVwJDEwIiwidHlwZW5hbWVfb2ZfdCQzIiwiY3VzdG9tJDgiLCJjdXN0b20kOSIsImNvbXB1dGF0aW9uIiwic3RyaW5nIiwiY29udGVudCQwIiwic2hhcmVkJDAiLCJjb21wdXRhdGlvbiQwIiwicGF0aCIsInIiLCJpbnB1dCIsImdldF93aXBfY29tcHV0YXRpb24iLCJjbG9zIiwic2V0X2ZpbmFsX2NvbXB1dGF0aW9uIiwiY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UiLCJzaGFyZSIsIm9mX3AxIiwib2ZfcDIiLCJvZl9wMyIsIm9mX3A0Iiwib2ZfcDUiLCJ0eXBlbmFtZV9vZl9uYW1lZCIsInR5cGVyZXBfb2ZfdCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi90eXBlcmVwL3R5cGVfZXF1YWwubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdHlwZXJlcC90eXBlbmFtZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi90eXBlcmVwL3ZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3R5cGVyZXAvc3RkX2ludGVybmFsLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3R5cGVyZXAvdHlwZXJlcF9vYmoubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdHlwZXJlcC90eXBlX2dlbmVyaWNfaW50Zi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi90eXBlcmVwL3R5cGVfZ2VuZXJpYy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi90eXBlcmVwL21ha2VfdHlwZW5hbWUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdHlwZXJlcC90eXBlX2Fic3RyYWN0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7RTs7Ozs7OzBDQUdJQTtZQUNBQyxZQUE0Q0MsR0FBSyxPQUFMQSxFQUFNOzZCQU1oREMsWUFBb0QsU0FBQyxFQUQzRCxXQUNNQTtvQ0FORkYsTUFEQUQ7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQzhCRUksUUFBUUMsR0FBRUMsR0FBSSxnQ0FBTkQsTUFBRUMsTUFBaUM7WUFD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RUFqVDtTQVJONFEsZ0JBTU1xQyxtQkFSTmhULGVBVU1EO21CQVJONFEsT0FGQTNROzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUNBZTs7S0FBZmlUO0tBQ0FqVDtJQUpnRSxXQUdoRWlULGNBQ0FqVDs7OzthQU1BaVQsYUFBYU4sT0FBUSxlQUFlLGlCQUF2QkEsWUFBMkM7UUFDeEQzUztJQUp1RSxXQUd2RWlULGNBQ0FqVDs7OzthQU9BaVQsYUFBYU4sT0FBTUM7S0FBUSxlQUFlLGlCQUE3QkQsT0FBTUM7SUFBaUQ7UUFDcEU1UztJQUpOLFdBR01pVCxjQUNBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DLE9BQU1DO0tBQVEsZUFBZSxpQkFBbkNGLE9BQU1DLE9BQU1DO0lBQXVEO1FBQ2hGN1M7SUFKMEQsV0FHMURpVCxjQUNBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DLE9BQU1DLE9BQU1DO0tBQ2pDLGVBQWUsaUJBREFILE9BQU1DLE9BQU1DLE9BQU1DO0lBQ29CO1FBR25EOVM7SUFQa0UsV0FHbEVpVCxjQUlBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DLE9BQU1DLE9BQU1DLE9BQU1DO0tBQ3ZDLGVBQWUsaUJBREFKLE9BQU1DLE9BQU1DLE9BQU1DLE9BQU1DO0lBQ29CO1FBR3pEL1M7SUFQMEUsV0FHMUVpVCxjQUlBalQ7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBCYXNlLlR5cGVfZXF1YWwudCA9IFQgOiAoJ2EsICdhKSB0XG50eXBlICgnYSwgJ2IpIGVxdWFsID0gKCdhLCAnYikgdFxuXG5sZXQgcmVmbCA9IFRcbmxldCBjb252IDogdHlwZSBhIGIuIChhLCBiKSB0IC0+IGEgLT4gYiA9IGZ1biBUIHggLT4geFxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYSBYLnQsIGIgWC50KSB0ID0gVFxuZW5kXG4iLCIoKiB0aGlzIGxpYiBzaG91bGQgbm90IGRlcGVuZCBvbiBjb3JlICopXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICBsZXQgY29tcGFyZSBjbXAgYSBiID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gMFxuICAgICAgfCBbXSwgXyAtPiAtMVxuICAgICAgfCBfLCBbXSAtPiAxXG4gICAgICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICAgICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgICAgIGlmIG4gPSAwIHRoZW4gbG9vcCB4cyB5cyBlbHNlIG5cbiAgICBpblxuICAgIGxvb3AgYSBiXG4gIDs7XG5lbmRcblxubW9kdWxlIFVpZCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIG5leHQgOiBzdHJpbmcgLT4gdFxuICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIHZhbCBuYW1lIDogdCAtPiBzdHJpbmdcbiAgdmFsIHN0YXRpYyA6IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgY29kZSA6IGludFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIH1cblxuICBsZXQgY29tcGFyZSBhIGIgPSBjb21wYXJlIChhLmNvZGUgOiBpbnQpIGIuY29kZVxuICBsZXQgZXF1YWwgYSBiID0gKGEuY29kZSA6IGludCkgPSBiLmNvZGVcbiAgbGV0IHVpZCA9IHJlZiAwXG5cbiAgbGV0IG5leHQgbmFtZSA9XG4gICAgbGV0IGNvZGUgPSAhdWlkIGluXG4gICAgaW5jciB1aWQ7XG4gICAgeyBjb2RlOyBuYW1lIH1cbiAgOztcblxuICBsZXQgaGFzaCBhID0gSGFzaHRibC5oYXNoIGEuY29kZVxuICBsZXQgbmFtZSBhID0gYS5uYW1lXG4gIGxldCBzdGF0aWMgPSBuZXh0IFwic3RhdGljXCJcbmVuZFxuXG5tb2R1bGUgS2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyB1aWQgOiBVaWQudFxuICAgIDsgcGFyYW1zIDogdCBsaXN0XG4gICAgfVxuXG4gIGxldCByZWMgY29tcGFyZSBrMSBrMiA9XG4gICAgaWYgazEgPT0gazJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBjbXAgPSBVaWQuY29tcGFyZSBrMS51aWQgazIudWlkIGluXG4gICAgICBpZiBjbXAgPD4gMCB0aGVuIGNtcCBlbHNlIExpc3QuY29tcGFyZSBjb21wYXJlIGsxLnBhcmFtcyBrMi5wYXJhbXMpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuICBsZXQgaGFzaCA9IChIYXNodGJsLmhhc2ggOiB0IC0+IGludClcbiAgbGV0IHN0YXRpYyA9IHsgdWlkID0gVWlkLnN0YXRpYzsgcGFyYW1zID0gW10gfVxuZW5kXG5cbnR5cGUgJ2EgdCA9IEtleS50XG50eXBlICdhIHR5cGVuYW1lID0gJ2EgdFxuXG5sZXQga2V5IHQgPSB0XG5sZXQgdWlkIHQgPSB0LktleS51aWRcbmxldCBuYW1lIHQgPSBVaWQubmFtZSB0LktleS51aWRcbmxldCBzdGF0aWMgPSBLZXkuc3RhdGljXG5sZXQgY3JlYXRlID8obmFtZSA9IFwiVHlwZW5hbWUuY3JlYXRlXCIpICgpID0geyBLZXkudWlkID0gVWlkLm5leHQgbmFtZTsgcGFyYW1zID0gW10gfVxuXG5pbmNsdWRlIHN0cnVjdFxuICAoKiBUaGUgYXJndW1lbnQgZm9yIE9iai5tYWdpYyBoZXJlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gY29yZS90eXBlX2VxdWFsICopXG5cbiAgbGV0IHNhbWUgKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9IEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG5cbiAgbGV0IHNhbWVfd2l0bmVzcyAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID1cbiAgICBpZiBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuICAgIHRoZW4gU29tZSAoT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpXG4gICAgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHNhbWVfd2l0bmVzc19leG4gKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9XG4gICAgaWYgS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcbiAgICB0aGVuIChPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIDogKGEsIGIpIFR5cGVfZXF1YWwudClcbiAgICBlbHNlIGZhaWx3aXRoIFwiVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4blwiXG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYiB0eXBlbmFtZSAtPiAoJ2EsICdiKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdHlwZW5hbWUgLT4gJ2IgdHlwZW5hbWUgLT4gJ2MgdHlwZW5hbWUgLT4gKCdhLCAnYiwgJ2MpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90XG4gICAgOiAgJ2EgdHlwZW5hbWVcbiAgICAtPiAnYiB0eXBlbmFtZVxuICAgIC0+ICdjIHR5cGVuYW1lXG4gICAgLT4gJ2QgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdFxuICAgIDogICdhIHR5cGVuYW1lXG4gICAgLT4gJ2IgdHlwZW5hbWVcbiAgICAtPiAnYyB0eXBlbmFtZVxuICAgIC0+ICdkIHR5cGVuYW1lXG4gICAgLT4gJ2UgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gW10gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGIgXSB9XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjOyBkIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCBlID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGM7IGQ7IGUgXSB9XG5lbmRcblxubW9kdWxlIEtleV90YWJsZSA9IEhhc2h0YmwuTWFrZSAoS2V5KVxuXG5tb2R1bGUgVGFibGUgKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlIGRhdGEgPSBEYXRhIDogJ2EgdCAqICdhIFgudCAtPiBkYXRhXG4gIHR5cGUgdCA9IGRhdGEgS2V5X3RhYmxlLnRcblxuICBsZXQgY3JlYXRlIGludCA9IEtleV90YWJsZS5jcmVhdGUgaW50XG4gIGxldCBtZW0gdGFibGUgbmFtZSA9IEtleV90YWJsZS5tZW0gdGFibGUgKGtleSBuYW1lKVxuICBsZXQgc2V0IHRhYmxlIG5hbWUgZGF0YSA9IEtleV90YWJsZS5yZXBsYWNlIHRhYmxlIChrZXkgbmFtZSkgKERhdGEgKG5hbWUsIGRhdGEpKVxuXG4gIGxldCBmaW5kICh0eXBlIGEpIHRhYmxlIChuYW1lIDogYSB0eXBlbmFtZSkgPVxuICAgIGxldCBkYXRhID1cbiAgICAgIHRyeSBTb21lIChLZXlfdGFibGUuZmluZCB0YWJsZSAoa2V5IG5hbWUpKSB3aXRoXG4gICAgICB8IEJhc2UuTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggZGF0YSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKERhdGEgKG5hbWUnLCBkYXRhKSkgLT5cbiAgICAgIChmdW4gKHR5cGUgYikgKG5hbWUnIDogYiB0eXBlbmFtZSkgKGRhdGEgOiBiIFgudCkgLT5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSAoc2FtZV93aXRuZXNzX2V4biBuYW1lJyBuYW1lIDogKGIsIGEpIFR5cGVfZXF1YWwudCkgaW5cbiAgICAgICAgIFNvbWUgKGRhdGEgOiBhIFgudCkpXG4gICAgICAgIG5hbWUnXG4gICAgICAgIGRhdGFcbiAgOztcbmVuZFxuXG5sZXQgZmFpbCB1aWRfYSB1aWRfYiA9XG4gIGxldCBtc2cgPVxuICAgIFByaW50Zi5zcHJpbnRmIFwiVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4biAlUyAlU1wiIChVaWQubmFtZSB1aWRfYSkgKFVpZC5uYW1lIHVpZF9iKVxuICBpblxuICBmYWlsd2l0aCBtc2dcbjs7XG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzEgKEEgOiBTMSkgKEIgOiBTMSkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhLiAoJ2EgQS50LCAnYSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMpIGluXG4gICAgbGV0IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8yIChBIDogUzIpIChCIDogUzIpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYSAnYi4gKCgnYSwgJ2IpIEEudCwgKCdhLCAnYikgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8zIChBIDogUzMpIChCIDogUzMpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYSAnYiAnYy4gKCgnYSwgJ2IsICdjKSBBLnQsICgnYSwgJ2IsICdjKSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fNCAoQSA6IFM0KSAoQiA6IFM0KSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IgJ2MgJ2QuICgoJ2EsICdiLCAnYywgJ2QpIEEudCwgKCdhLCAnYiwgJ2MsICdkKSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl81IChBIDogUzUpIChCIDogUzUpID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBlcSA6XG4gICAgICAgICdhICdiICdjICdkICdlLiAoKCdhLCAnYiwgJ2MsICdkLCAnZSkgQS50LCAoJ2EsICdiLCAnYywgJ2QsICdlKSBCLnQpIFR5cGVfZXF1YWwudFxuICAgIH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcbiIsIigqKlxuICAgUGxhY2UgaG9sZGVyIGZvciBjb21tb24gVmFyaWFudHMgYW5kIEZpZWxkcyBpbnRlcmZhY2VcbiopXG5cbm1vZHVsZSBNIChYIDogc2lnXG4gICgqKlxuICAgICAgIFRoaXMgZnVuY3RvciBpcyBlc3NlbnRpYWxseSB0aGVyZSBiZWNhdXNlIHdlIHVzZSB0aGlzIHNhbWUgaW50ZXJmYWNlIGluIGRpZmZlcmVudFxuICAgICAgIGNvbnRleHRzLCB3aXRoIGRpZmZlcmVudCB0eXBlcyBmb3IgWydhIHRdLlxuXG4gICAgICAgMSkgT25lIHVzZSBjYXNlIGZvciBpdCBpcyB3aGVyZSBbJ2EgWC50ID0gJ2EgVHlwZXJlcC50XS4gIFRoZXNlIGludGVyZmFjZXMgYXJlIHRoZW5cbiAgICAgICBwYXJ0IG9mIHRoZSB0eXBlIHdpdG5lc3MgYnVpbHQgZm9yIGEgdHlwZSBjb250YWluaW5nIGEgcmVjb3JkIG9yIGEgdmFyaWFudCBpbiBpdHNcbiAgICAgICBzdHJ1Y3R1cmUuIFt0cmF2ZXJzZV0gd2lsbCBnaXZlIGEgd2F5IG9mIGFjY2Vzc2luZyB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlXG4gICAgICAgYXJndW1lbnRzIG9mIGEgdmFyaWFudCBvciByZWNvcmQgdHlwZS5cblxuICAgICAgIDIpIEFub3RoZXIgdXNlIGNhc2UgaXMgZm9yIGJ1aWxkaW5nIFwic3RhZ2VkIGdlbmVyaWMgY29tcHV0YXRpb25zXCIuIEluIHRoYXQgY2FzZSwgdGhlXG4gICAgICAgdHlwZSBbJ2EgWC50XSBpcyB0aGUgdHlwZSBvZiB0aGUgY29tcHV0YXRpb24gdGhhdCBpcyBiZWluZyBidWlsdC4gIFt0cmF2ZXJzZV1cbiAgICAgICByZXR1cm5zIHRoZSBjb21wdXRhdGlvbiBidWlsdCBmb3IgdGhlIGFyZ3VtZW50LiBUaGUgaW50ZXJmYWNlIG5vIGxvbmdlciBleHBvcnRzXG4gICAgICAgdGhlIHR5cGVyZXAgb2YgdGhlIGFyZ3VtZW50cyBpbiBob3BlcyBvZiBlbmZvcmNpbmcgdGhhdCBubyB0eXBlcmVwIHRyYXZlcnNhbFxuICAgICAgIGhhcHBlbnMgYXQgcnVudGltZSBpZiB0aGUgY29tcHV0YXRpb24gaGFwcGVuIHRvIGJlIGEgZnVuY3Rpb24uXG4gICAgKilcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICAoKiBUaGUgZnVuY3Rpb25zIHByZWZpeGVkIGJ5IFtpbnRlcm5hbF0gYXMgd2VsbCBhcyB0aGUgbW9kdWxlIHN1ZmZpeGVkIGJ5IFtfaW50ZXJuYWxdXG4gICAgIGFyZSB1c2VkIGJ5IHRoZSBjb2RlIGdlbmVyYXRlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiBbd2l0aCB0eXBlcmVwXSBhcyB3ZWxsIGFzIHNvbWVcbiAgICAgaW50ZXJuYWxzIG9mIHRoZSB0eXBlcmVwIGxpYnJhcnkuIERvIG5vdCBjb25zaWRlciB1c2luZyB0aGVzZSBzb21ld2hlcmUgZWxzZS4gIFRoZXlcbiAgICAgc2hvdWxkIGlkZWFsbHkgbm90IGJlIGV4cG9ydGVkIG91dHNpZGUgdGhlIHR5cGVyZXAgbGlicmFyeSwgYnV0IHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICBuZWVkcyBzb21laG93IHRvIGFjY2VzcyB0aGlzLCBldmVuIG91dHNpZGUuICopXG5cbiAgbW9kdWxlIFRhZ19pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgY3JlYXRlID1cbiAgICAgIHwgQXJncyBvZiAoJ2FyZ3MgLT4gJ3ZhcmlhbnQpXG4gICAgICB8IENvbnN0IG9mICd2YXJpYW50XG5cbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIHQgPVxuICAgICAgeyBsYWJlbCA6IHN0cmluZ1xuICAgICAgOyByZXAgOiAnYXJncyBYLnRcbiAgICAgIDsgYXJpdHkgOiBpbnRcbiAgICAgIDsgYXJnc19sYWJlbHMgOiBzdHJpbmcgbGlzdFxuICAgICAgOyBpbmRleCA6IGludFxuICAgICAgOyBvY2FtbF9yZXByIDogaW50XG4gICAgICA7IHR5aWQgOiAnYXJncyBUeXBlbmFtZS50XG4gICAgICA7IGNyZWF0ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZVxuICAgICAgfVxuICBlbmRcblxuICAoKipcbiAgICAgV2l0bmVzcyBvZiBhIHRhZywgdGhhdCBpcyBhbiBpdGVtIGluIGEgdmFyaWFudCB0eXBlLCBhbHNvIGNhbGxlZCBhbiBcImFwcGxpZWRcbiAgICAgdmFyaWFudCBDb25zdHJ1Y3RvclwiXG5cbiAgICAgVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgdmFyaWFudCB0eXBlLCB0aGUgc2Vjb25kIGlzIHRoZSB0eXBlIG9mIHRoZSB0YWdcbiAgICAgcGFyYW1ldGVycy4gIEV4YW1wbGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPVxuICAgICAgICAgfCBBIG9mIChpbnQgKiBzdHJpbmcpXG4gICAgICAgICB8IEIgb2Ygc3RyaW5nXG4gICAgICAgICB8IEMgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH1cbiAgICAgXX1cblxuICAgICB0aGlzIHR5cGUgaGFzIHRocmVlIGNvbnN0cnVjdG9ycy4gRm9yIGVhY2ggb2YgdGhlbSB3ZSdsbCBoYXZlIGEgY29ycmVzcG9uZGluZ1xuICAgICBbVGFnLnRdOlxuXG4gICAgIHtbXG4gICAgICAgdmFsIHRhZ19BIDogKHQsIChpbnQgKiBzdHJpbmcpKSBUYWcudFxuICAgICAgIHZhbCB0YWdfQiA6ICh0LCBzdHJpbmcgICAgICAgICkgVGFnLnRcbiAgICAgICB2YWwgdGFnX0MgOiAodCwgKGludCAqIHN0cmluZykpIFRhZy50XG4gICAgIF19XG5cbiAgICAgTm90ZSwgaW5saW5lIHJlY29yZCBpbiB2YXJpYW50IGFyZSB0eXBlZCBhcyBpZiB0aGVpciBkZWZpbml0aW9uIHdhcyB1c2luZyB0dXBsZXMsXG4gICAgIHdpdGhvdXQgdGhlIHBhcmVudGhlc2lzLiAgVGhpcyBpcyBjb25zaXN0ZW50IHdpdGggdGhlaXIgcnVudGltZSByZXByZXNlbnRhdGlvbi4gIEJ1dFxuICAgICB0aGUgZGlzdGluY3Rpb24gaXMgY2FycmllZCBhbmQgYXZhaWxhYmxlIGZvciBpbnRyb3NwZWN0aW9uIGFzIHBhcnQgb2YgdGhlIFtUYWcudF0uXG4gICAgIFNlZSBbYXJnc19sYWJlbHNdLiAqKVxuICBtb2R1bGUgVGFnIDogc2lnXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGUgPVxuICAgICAgfCBBcmdzIG9mICgnYXJncyAtPiAndmFyaWFudClcbiAgICAgIHwgQ29uc3Qgb2YgJ3ZhcmlhbnRcblxuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgdFxuXG4gICAgKCoqXG4gICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yIGFzIGl0IGlzIGdpdmVuIGluIHRoZSBjb25jcmV0ZSBzeW50YXhcbiAgICAgICBFeGFtcGxlczpcblxuICAgICAgIHt2XG4gICAgICAgICBDb25zdHJ1Y3RvciAgICAgICAgfCBsYWJlbFxuICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgfCBBIG9mIGludCAgICAgICAgIHwgIFwiQVwiXG4gICAgICAgICB8IGBhIG9mIGludCAgICAgICAgfCAgXCJhXCJcbiAgICAgICAgIHwgYEEgb2YgaW50ICAgICAgICB8ICBcIkFcIlxuICAgICAgICAgfCBBIG9mIHsgeCA6IGludCB9IHwgIFwiQVwiXG4gICAgICAgdn1cblxuICAgICAgIGZvciBzdGFuZGFyZCB2YXJpYW50LCB0aGUgb2NhbWwgc3ludGF4IGltcGxpZXMgdGhhdCB0aGlzIGxhYmVsIHdpbGwgYWx3YXlzIHN0YXJ0c1xuICAgICAgIHdpdGggYSBjYXBpdGFsIGxldHRlci4gRm9yIHBvbHltb3JwaGljIHZhcmlhbnRzLCB0aGlzIG1pZ2h0IGJlIGEgbG93ZXJjYXNlIGNoYXIuXG4gICAgICAgRm9yIHBvbHltb3JwaGljIHZhcmlhbnQsIHRoaXMgbGFiZWwgZG9lcyBub3QgaW5jbHVkZSB0aGUgW2BdIGNoYXJhY3Rlci5cbiAgICAqKVxuICAgIHZhbCBsYWJlbCA6IChfLCBfKSB0IC0+IHN0cmluZ1xuXG4gICAgKCoqXG4gICAgICAgVGhlIHNpemUgb2YgdGhlIG9jYW1sIGhlYXAgYmxvY2sgY29udGFpbmluZyB0aGUgYXJndW1lbnRzXG5cbiAgICAgICBFeGFtcGxlczpcbiAgICAgICB7dlxuICAgICAgICAgIDA6IHwgQSB8ICdBXG4gICAgICAgICAgMTogfCBBIG9mIGludCB8IGBBIG9mIGludCB8IEEgb2YgKGludCAqIGludCkgfCBgQSBvZiAoaW50ICogaW50KVxuICAgICAgICAgICAgIHwgYEEgb2YgaW50ICogaW50XG4gICAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludH1cbiAgICAgICAgICAyOiB8IEEgb2YgaW50ICogZmxvYXRcbiAgICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH1cbiAgICAgICAgICBldGMuXG4gICAgICAgdn1cbiAgICAqKVxuICAgIHZhbCBhcml0eSA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqIFRoZSBsYWJlbCBvZiB0aGUgZmllbGRzIGZvciBpbmxpbmUgcmVjb3Jkcy4gIEZvciBvdGhlciBmb3JtcyBvZiB0YWdzLCB0aGlzIGlzIHRoZVxuICAgICAgICBlbXB0eSBsaXN0LiAgV2hlbiB0aGlzIHJldHVybnMgYSBub24gZW1wdHkgbGlzdCwgdGhlIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgbGlzdFxuICAgICAgICBpcyBlcXVhbCB0byB0aGUgYXJpdHkuXG5cbiAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICB7dlxuICAgICAgICAgKDEpIEVtcHR5OlxuXG4gICAgICAgICAgIHwgQSB8ICdBXG4gICAgICAgICAgIHwgQSBvZiBpbnQgfCBgQSBvZiBpbnQgfCBBIG9mIChpbnQgKiBpbnQpIHwgYEEgb2YgKGludCAqIGludClcbiAgICAgICAgICAgfCBgQSBvZiBpbnQgKiBpbnRcbiAgICAgICAgICAgfCBBIG9mIGludCAqIGZsb2F0XG5cbiAgICAgICAgICgyKSBOb24gZW1wdHk6XG5cbiAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludCB9ICAgICAgICAgICAgICAgLT4gWyBcInhcIiBdXG4gICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfSAgIC0+IFsgXCJ4XCIgOyBcInlcIiBdXG4gICAgICAgdn1cbiAgICAqKVxuICAgIHZhbCBhcmdzX2xhYmVscyA6IChfLCBfKSB0IC0+IHN0cmluZyBsaXN0XG5cbiAgICAoKipcbiAgICAgICBUaGUgaW5kZXggb2YgdGhlIGNvbnN0cnVjdG9yIGluIHRoZSBsaXN0IG9mIGFsbCB0aGUgdmFyaWFudCB0eXBlJ3MgY29uc3RydWN0b3JzXG4gICAgICAgRXhhbXBsZXM6XG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9XG4gICAgICAgICAgIHwgQSBvZiBpbnQgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEIgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBDIG9mIGludCAgICAgICAgICAoKiAyICopXG4gICAgICAgICAgIHwgRCBvZiBjaGFyICAgICAgICAgKCogMyAqKVxuICAgICAgICAgICB8IEUgb2YgeyB4IDogaW50IH0gICgqIDQgKilcbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGluZGV4IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBvY2FtbF9yZXByIGlzIHJlbGF0ZWQgdG8gdGhlIHJ1bnRpbWUgb2Ygb2JqZWN0cy4gdGhpcyBpcyBlc3NlbnRpYWxseSBhIHdheSBvZlxuICAgICAgIGdpdmluZyBvbmUgdGhlIGFiaWxpdHkgdG8gcmVidWlsZCBkeW5hbWljYWxseSBhbiBbT2JqLnRdIHJlcHJlc2VudGluZyBhIHRhZy5cblxuICAgICAgIFBvbHltb3JwaGljIHZhcmlhbnRzOlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgW29jYW1sX3JlcHJdIGlzIHRoZSBoYXNoIG9mIHRoZSBsYWJlbCwgYXMgZG9uZSBieSB0aGUgY29tcGlsZXIuXG4gICAgICAgRXhhbXBsZTpcbiAgICAgICBwcmludF9pbnQgKE9iai5tYWdpYyBgYmFyKSAgKCogNDg5NTE4NyAqKVxuICAgICAgIHByaW50X2ludCAoT2JqLm1hZ2ljICdmb28pICAoKiA1MDk3MjIyICopXG5cbiAgICAgICBTdGFuZGFyZHMgdmFyaWFudHM6XG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgW29jYW1sX3JlcHJdIGlzIHRoZSB0YWcgY29ycmVzcG9uZGluZyB0byB0aGUgY29uc3RydWN0b3Igd2l0aGluIHRoZSB0eXBlLlxuICAgICAgIHRoZSB3YXkgaXQgd29ya3MgaW4gdGhlIG9jYW1sIHJ1bnRpbWUgaXMgYnkgcGFydGl0aW9uaW5nIHRoZSBjb25zdHJ1Y3RvcnMgcmVnYXJkaW5nXG4gICAgICAgaWYgdGhleSBoYXZlIHNvbWUgYXJndW1lbnRzIG9yIG5vdCwgcHJlc2VydmluZyB0aGUgb3JkZXIsIHRoZW4gYXNzaWduIGluY3JlYXNpbmdcbiAgICAgICBpbmRleCB3aXRoaW5nIGVhY2ggcGFydGl0aW9uLlxuICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID0gICAgICAgICAgICAgICAgICAoKiBubyBhcmcgKikgICgqIGFyZ3MgKilcbiAgICAgICAgICAgfCBBICAgICAgICAgICAgICAgICAgICAgICAoKiAwICopXG4gICAgICAgICAgIHwgQiBvZiBpbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAwICopXG4gICAgICAgICAgIHwgQyAgICAgICAgICAgICAgICAgICAgICAgKCogMSAqKVxuICAgICAgICAgICB8IEQgb2YgKGZsb2F0ICogc3RyaW5nKSAgICAgICAgICAgICAgICAgKCogMSAqKVxuICAgICAgICAgICB8IEUgICAgICAgICAgICAgICAgICAgICAgICgqIDIgKilcbiAgICAgICAgICAgfCBGICAgICAgICAgICAgICAgICAgICAgICAoKiAzICopXG4gICAgICAgICAgIHwgRyBvZiBzdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAyICopXG4gICAgICAgICAgIHwgSCBvZiB7IHggOiBpbnQgfSAgICAgICAgICAgICAgICAgICAgICAoKiAzICopXG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBvY2FtbF9yZXByIDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHaXZlIGJhY2sgYSB3YXkgb2YgY29uc3RydWN0aW5nIGEgdmFsdWUgb2YgdGhhdCBjb25zdHJ1Y3RvciBmcm9tIGl0cyBhcmd1bWVudHMuXG5cbiAgICAgICBFeGFtcGxlczpcblxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPVxuICAgICAgICAgICB8IEEgb2YgKGludCAqIHN0cmluZylcbiAgICAgICAgICAgfCBCIG9mIGludCAqIGZsb2F0XG4gICAgICAgICAgIHwgQ1xuICAgICAgICAgICB8IEQgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH1cbiAgICAgICBdfVxuXG4gICAgICAgW2NyZWF0ZV0gd2lsbCByZXR1cm4gc29tZXRoaW5nIGVxdWl2YWxlbnQgdG86XG4gICAgICAgdGFnX0EgOiBbQXJncyAoZnVuIChkIDogKGludCAqIHN0cmluZykgLT4gQSBkKV1cbiAgICAgICB0YWdfQiA6IFtBcmdzIChmdW4gKGksIGYpIC0+IEIgKGksIGYpKV1cbiAgICAgICB0YWdfQyA6IFtDb25zdCBDXVxuICAgICAgIHRhZ19EIDogW0FyZ3MgKGZ1biAoeCwgeSkgLT4gRCB7IHg7IHkgfSldXG4gICAgKilcbiAgICB2YWwgY3JlYXRlIDogKCd2YXJpYW50LCAnYXJncykgdCAtPiAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGVcblxuICAgICgqKiByZXR1cm4gdGhlIHR5cGVfbmFtZSBvZiB0aGUgYXJndW1lbnRzLiBtaWdodCBiZSB1c2VkIHRvIHBlcmZvcm0gc29tZSBsb29rdXAgYmFzZWRcbiAgICAgICAgb24gaXQgd2hpbGUgYnVpbGRpbmcgYSBjb21wdXRhdGlvbiBmb3IgZXhhbXBsZSAqKVxuICAgIHZhbCB0eWlkIDogKF8sICdhcmdzKSB0IC0+ICdhcmdzIFR5cGVuYW1lLnRcblxuICAgICgqKiBnZXQgdGhlIHJlcHJlc2VudGF0aW9uL2NvbXB1dGF0aW9uIG9mIHRoZSBhcmd1bWVudHMgKilcbiAgICB2YWwgdHJhdmVyc2UgOiAoXywgJ2FyZ3MpIHQgLT4gJ2FyZ3MgWC50XG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAoJ2EsICdiKSBUYWdfaW50ZXJuYWwudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVGFnX2ludGVybmFsXG5cbiAgICBsZXQgbGFiZWwgdCA9IHQubGFiZWxcbiAgICBsZXQgYXJpdHkgdCA9IHQuYXJpdHlcbiAgICBsZXQgYXJnc19sYWJlbHMgdCA9IHQuYXJnc19sYWJlbHNcbiAgICBsZXQgaW5kZXggdCA9IHQuaW5kZXhcbiAgICBsZXQgb2NhbWxfcmVwciB0ID0gdC5vY2FtbF9yZXByXG4gICAgbGV0IGNyZWF0ZSB0ID0gdC5jcmVhdGVcbiAgICBsZXQgdHlpZCB0ID0gdC50eWlkXG4gICAgbGV0IHRyYXZlcnNlIHQgPSB0LnJlcFxuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcblxuICBtb2R1bGUgVmFyaWFudF9pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgXyB0YWcgPSBUYWcgOiAoJ3ZhcmlhbnQsICdhKSBUYWcudCAtPiAndmFyaWFudCB0YWdcbiAgICB0eXBlIF8gdmFsdWUgPSBWYWx1ZSA6ICgndmFyaWFudCwgJ2EpIFRhZy50ICogJ2EgLT4gJ3ZhcmlhbnQgdmFsdWVcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IHR5cGVuYW1lIDogJ2EgVHlwZW5hbWUudFxuICAgICAgOyB0YWdzIDogJ2EgdGFnIGFycmF5XG4gICAgICA7IHBvbHltb3JwaGljIDogYm9vbFxuICAgICAgOyB2YWx1ZSA6ICdhIC0+ICdhIHZhbHVlXG4gICAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBWYXJpYW50IDogc2lnXG4gICAgKCoqXG4gICAgICAgQW4gZXhpc3RlbnRpYWwgdHlwZSB1c2VkIHRvIGdhdGhlciBhbGwgdGhlIHRhZ3MgY29uc3RpdHVpbmcgYSB2YXJpYW50XG4gICAgICAgdHlwZS4gdGhlIFsndmFyaWFudF0gcGFyYW1ldGVyIGlzIHRoZSB2YXJpYW50IHR5cGUsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgdGhlXG4gICAgICAgY29uc3RydWN0b3JzIG9mIHRoYXQgdmFyaWFudCB0eXBlLiBUaGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVycyBtaWdodCBiZSBkaWZmZXJlbnRcbiAgICAgICBmb3IgZWFjaCBjb25zdHJ1Y3RvciBhbmQgaXMgdGh1cyBleGlzdGVudGlhbFxuICAgICopXG4gICAgdHlwZSBfIHRhZyA9IFRhZyA6ICgndmFyaWFudCwgJ2FyZ3MpIFRhZy50IC0+ICd2YXJpYW50IHRhZ1xuXG4gICAgKCoqXG4gICAgICAgQSBzaW1pbGFyIGV4aXN0ZW50aWFsIGNvbnN0cnVjdG9yIHRvIFtfIHRhZ10gYnV0IHRoaXMgb25lIGhvbGRzIGEgdmFsdWUgd2hvc2UgdHlwZVxuICAgICAgIGlzIHRoZSBhcmd1bWVudHMgb2YgdGhlIHRhZyBjb25zdHJ1Y3Rvci4gIEEgdmFsdWUgb2YgdHlwZSBbJ2EgdmFsdWVdIGlzIGEgcGFpciBvZlxuICAgICAgICgxKSBhIHZhbHVlIG9mIHZhcmlhbnQgdHlwZSBbJ2FdIGFsb25nIHdpdGggKDIpIHNvbWUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICAgICAgY29uc3RydWN0b3Igd2l0aGluIHRoZSB0eXBlIFsnYV1cbiAgICAqKVxuICAgIHR5cGUgXyB2YWx1ZSA9IFZhbHVlIDogKCd2YXJpYW50LCAnYXJncykgVGFnLnQgKiAnYXJncyAtPiAndmFyaWFudCB2YWx1ZVxuXG4gICAgKCoqXG4gICAgICAgV2l0bmVzcyBvZiBhIHZhcmlhbnQgdHlwZS4gVGhlIHBhcmFtZXRlciBpcyB0aGUgdHlwZSBvZiB0aGUgdmFyaWFudCB0eXBlIHdpdG5lc3NlZC5cbiAgICAqKVxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcblxuICAgICgqKlxuICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiB0YWdzIG9mIHRoaXMgdmFyaWFudCB0eXBlIGRlZmluaXRpb24uXG4gICAgKilcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIEdldCB0aGUgbnRoIHRhZyBvZiB0aGlzIHZhcmlhbnQgdHlwZSwgaW5kZXhlZCBmcm9tIDAuXG4gICAgKilcbiAgICB2YWwgdGFnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgdGFnXG5cbiAgICAoKipcbiAgICAgICBEaXN0aW5ndWlzaCBwb2x5bW9ycGhpYyB2YXJpYW50cyBhbmQgc3RhbmRhcmQgdmFyaWFudHMuIFR5cGljYWxseSwgcG9seW1vcnBoaWNcbiAgICAgICB2YXJpYW50cyB0YWdzIHN0YXJ0cyB3aXRoIHRoZSBbYF0gY2hhcmFjdGVyLlxuICAgICAgIEV4YW1wbGVcbiAgICAgICBwb2x5bW9ycGhpYyB2YXJpYW50OiB0eXBlIHQgPSBbIGBBIHwgYEIgXVxuICAgICAgIHN0YW5kYXJkIHZhcmlhbnQ6ICAgIHR5cGUgdCA9IEEgfCBCXG4gICAgKilcbiAgICB2YWwgaXNfcG9seW1vcnBoaWMgOiBfIHQgLT4gYm9vbFxuXG4gICAgKCoqXG4gICAgICAgUGF0dGVybiBtYXRjaGluZyBvbiBhIHZhbHVlIG9mIHRoaXMgdmFyaWFudCB0eXBlLlxuICAgICopXG4gICAgdmFsIHZhbHVlIDogJ2EgdCAtPiAnYSAtPiAnYSB2YWx1ZVxuXG4gICAgKCoqXG4gICAgICAgZm9sZGluZyBhbG9uZyB0aGUgdGFncyBvZiB0aGUgdmFyaWFudCB0eXBlXG4gICAgKilcbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgdGFnIC0+ICdhY2MpIC0+ICdhY2NcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICdhIFZhcmlhbnRfaW50ZXJuYWwudCAtPiAnYSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVmFyaWFudF9pbnRlcm5hbFxuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgdCA9IHQudHlwZW5hbWVcbiAgICBsZXQgbGVuZ3RoIHQgPSBBcnJheS5sZW5ndGggdC50YWdzXG4gICAgbGV0IHRhZyB0IGluZGV4ID0gdC50YWdzLihpbmRleClcbiAgICBsZXQgaXNfcG9seW1vcnBoaWMgdCA9IHQucG9seW1vcnBoaWNcbiAgICBsZXQgdmFsdWUgdCA9IHQudmFsdWVcbiAgICBsZXQgZm9sZCB0IH5pbml0IH5mID0gQXJyYXkuZm9sZF9sZWZ0IGYgaW5pdCB0LnRhZ3NcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIEZpZWxkX2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSB0ID1cbiAgICAgIHsgbGFiZWwgOiBzdHJpbmdcbiAgICAgIDsgcmVwIDogJ2ZpZWxkIFgudFxuICAgICAgOyBpbmRleCA6IGludFxuICAgICAgOyB0eWlkIDogJ2ZpZWxkIFR5cGVuYW1lLnRcbiAgICAgIDsgZ2V0IDogJ3JlY29yZCAtPiAnZmllbGRcbiAgICAgIDsgKCogc2V0IDogKCdyZWNvcmQgLT4gJ2ZpZWxkIC0+IHVuaXQpIG9wdGlvbjsgKFxcKiBtdXRhYmxlIGZpZWxkICpcXCkgKilcbiAgICAgICAgaXNfbXV0YWJsZSA6IGJvb2xcbiAgICAgIH1cbiAgZW5kXG5cbiAgKCoqXG4gICAgIFdpdG5lc3Mgb2YgYSBmaWVsZCwgdGhhdCBpcyBhbiBpdGVtIGluIGEgcmVjb3JkIHR5cGUuXG4gICAgIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHJlY29yZCB0eXBlLCB0aGUgc2Vjb25kIGlzIHRoZSB0eXBlIG9mIHRoZSBmaWVsZC5cbiAgICAgRXhhbXBsZTpcbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQgOyB5IDogc3RyaW5nIH1cbiAgICAgXX1cbiAgICAgVGhpcyB0eXBlIGhhcyB0d28gZmllbGRzLiBmb3IgZWFjaCBvZiB0aGVtIHdlJ2xsIGhhdmUgYSBjb3JyZXNwb25kaW5nIFtGaWVsZC50XVxuXG4gICAgIHZhbCBmaWVsZF94IDogKHQsIGludCkgRmllbGQudFxuICAgICB2YWwgZmllbGRfeSA6ICh0LCBzdHJpbmcpIEZpZWxkLnRcbiAgKilcbiAgbW9kdWxlIEZpZWxkIDogc2lnXG4gICAgdHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSB0XG5cbiAgICAoKipcbiAgICAgICBUaGUgbmFtZSBvZiB0aGUgZmllbGQgYXMgaXQgaXMgZ2l2ZW4gaW4gdGhlIGNvbmNyZXRlIHN5bnRheFxuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB7IHggICA6IGludDsgICAgICgqIFwieFwiICopXG4gICAgICAgICAgIGZvbyA6IHN0cmluZzsgICgqIFwiZm9vXCIgKilcbiAgICAgICAgICAgYmFyIDogZmxvYXQ7ICAgKCogXCJiYXJcIiAqKVxuICAgICAgICAgfVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSAwLWJhc2VkIGluZGV4IG9mIHRoZSBmaWVsZCBpbiB0aGUgbGlzdCBvZiBhbGwgZmllbGRzIGZvciB0aGlzIHJlY29yZCB0eXBlLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9IHtcbiAgICAgICAgICAgeCAgIDogaW50OyAgICAgKCogMCAqKVxuICAgICAgICAgICBmb28gOiBzdHJpbmc7ICAoKiAxICopXG4gICAgICAgICAgIGJhciA6IHN0cmluZzsgICgqIDIgKilcbiAgICAgICAgIH1cbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGluZGV4IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBGaWVsZCBhY2Nlc3NvcnMuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGRvdCBvcGVyYXRpb24uXG4gICAgICAgW0ZpZWxkLmdldCBiYXJfZmllbGQgdF0gcmV0dXJucyB0aGUgZmllbGQgW2Jhcl0gb2YgdGhlIHJlY29yZCB2YWx1ZSBbdF0sIGp1c3QgdGhlXG4gICAgICAgc2FtZSBhcyBbdC5iYXJdXG4gICAgKilcbiAgICB2YWwgZ2V0IDogKCdyZWNvcmQsICdmaWVsZCkgdCAtPiAncmVjb3JkIC0+ICdmaWVsZFxuXG4gICAgKCoqIHJldHVybiB3aGV0aGVyIHRoZSBmaWVsZCBpcyBtdXRhYmxlLCBpLmUuIHdoZXRoZXIgaXRzIGRlY2xhcmF0aW9uIGlzIHByZWZpeGVkIHdpdGhcbiAgICAgICAgdGhlIGtleXdvcmQgW211dGFibGVdICopXG4gICAgdmFsIGlzX211dGFibGUgOiAoXywgXykgdCAtPiBib29sXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gIE1pZ2h0IGJlIHVzZWQgdG8gcGVyZm9ybSBzb21lIGxvb2t1cCBiYXNlZFxuICAgICAgICBvbiBpdCAqKVxuICAgIHZhbCB0eWlkIDogKF8sICdmaWVsZCkgdCAtPiAnZmllbGQgVHlwZW5hbWUudFxuXG4gICAgKCoqIGdldCB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGFyZ3VtZW50cyAqKVxuICAgIHZhbCB0cmF2ZXJzZSA6IChfLCAnZmllbGQpIHQgLT4gJ2ZpZWxkIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgRmllbGRfaW50ZXJuYWwudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRmllbGRfaW50ZXJuYWxcblxuICAgIGxldCBsYWJlbCB0ID0gdC5sYWJlbFxuICAgIGxldCBpbmRleCB0ID0gdC5pbmRleFxuICAgIGxldCBnZXQgdCA9IHQuZ2V0XG4gICAgbGV0IGlzX211dGFibGUgdCA9IHQuaXNfbXV0YWJsZVxuICAgIGxldCB0eWlkIHQgPSB0LnR5aWRcbiAgICBsZXQgdHJhdmVyc2UgdCA9IHQucmVwXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBSZWNvcmRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gZmllbGQgPSBGaWVsZCA6ICgncmVjb3JkLCAnYSkgRmllbGQudCAtPiAncmVjb3JkIGZpZWxkXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgZmllbGRzIDogJ2EgZmllbGQgYXJyYXlcbiAgICAgIDsgaGFzX2RvdWJsZV9hcnJheV90YWcgOiBib29sXG4gICAgICA7IGNyZWF0ZSA6ICdhIGZpZWxkcyAtPiAnYVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgUmVjb3JkIDogc2lnXG4gICAgKCoqXG4gICAgICAgQW4gZXhpc3RlbnRpYWwgdHlwZSB1c2VkIHRvIGdhdGhlciBhbGwgdGhlIGZpZWxkcyBjb25zdGl0dWluZyBhIHJlY29yZCB0eXBlLiB0aGVcbiAgICAgICBbJ3JlY29yZF0gcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB0aGUgZmllbGQgb2YgdGhhdFxuICAgICAgIHJlY29yZCB0eXBlLiBUaGUgdHlwZSBvZiB0aGUgZmllbGRzIG1pZ2h0IGJlIGRpZmZlcmVudCBmb3IgZWFjaCBmaWVsZCBhbmQgaXMgdGh1c1xuICAgICAgIGV4aXN0ZW50aWFsLlxuICAgICopXG4gICAgdHlwZSBfIGZpZWxkID0gRmllbGQgOiAoJ3JlY29yZCwgJ2EpIEZpZWxkLnQgLT4gJ3JlY29yZCBmaWVsZFxuXG4gICAgKCoqXG4gICAgICAgWydyZWNvcmQgZmllbGRzXSBpcyBhIHR5cGUgaXNvbW9ycGhpYyB0byBbJ3JlY29yZF0uICBUaGlzIGdpdmVzIGEgd2F5IHRvIGdldCB0aGVcbiAgICAgICBmaWVsZCB2YWx1ZSBmb3IgZWFjaCBmaWVsZCBvZiB0aGUgcmVjb3JkLiAgVGhlIGFkdmFudGFnZSBvZiB0aGlzIHJlcHJlc2VudGF0aW9uIGlzXG4gICAgICAgdGhhdCBpdCBpcyBjb252ZW5pZW50IGZvciB3cml0aW5nIGdlbmVyaWMgY29tcHV0YXRpb25zLlxuICAgICopXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICAoKipcbiAgICAgICBXaXRuZXNzIG9mIGEgcmVjb3JkIHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHJlY29yZCB0eXBlIHdpdG5lc3NlZC5cbiAgICAqKVxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcblxuICAgICgqKlxuICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBmaWVsZHMgb2YgdGhpcyByZWNvcmQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCBmaWVsZCBvZiB0aGlzIHJlY29yZCB0eXBlLCBpbmRleGVkIGZyb20gMC5cbiAgICAqKVxuICAgIHZhbCBmaWVsZCA6ICdhIHQgLT4gaW50IC0+ICdhIGZpZWxkXG5cbiAgICAoKipcbiAgICAgICBUaGlzIGlzIGEgbG93IGxldmVsIG1ldGFkYXRhIHJlZ2FyZGluZyB0aGUgd2F5IHRoZSBvY2FtbCBjb21waWxlciByZXByZXNlbnQgdGhlXG4gICAgICAgYXJyYXkgdW5kZXJuZWF0aCB0aGF0IGlzIHRoZSBydW50aW1lIHZhbHVlIG9mIGEgcmVjb3JkIG9mIHR5cGUgWydhXSBnaXZlbiBhIHdpdG5lc3NcbiAgICAgICBvZiB0eXBlIFsnYSB0XS4gW2hhc19kb3VibGVfYXJyYXlfdGFnIHddIHJldHVybnMgW3RydWVdIGlmIHRoZSBhcnJheSB0aGF0XG4gICAgICAgcmVwcmVzZW50cyBydW50aW1lIHZhbHVlcyBvZiB0aGlzIHR5cGUgaXMgYW4gb3B0aW1pemVkIG9jYW1sIGZsb2F0IGFycmF5LlxuICAgICAgIFR5cGljYWxseSwgdGhpcyB3aWxsIGJlIHRydWUgZm9yIHJlY29yZCB3aGVyZSBhbGwgZmllbGRzIGFyZSBzdGF0aWNhbGx5IGtub3duIGFzIHRvXG4gICAgICAgYmUgW2Zsb2F0c10uXG5cbiAgICAgICBOb3RlIHRoYXQgeW91IGNhbid0IGdldCB0aGlzIGluZm9ybWF0aW9uIGR5bmFtaWNhbGx5IGJ5IGluc3BlY3RpbmcgdGhlIHR5cGVyZXAgb25jZVxuICAgICAgIGl0IGlzIGFwcGxpZWQsIGJlY2F1c2UgdGhlcmUgaXMgYXQgdGhpcyBwb2ludCBubyB3YXkgdG8gdGVsbCB3aGV0aGVyIG9uZSBvZiB0aGVcbiAgICAgICBmaWVsZCBpcyBwb2x5bW9ycGhpYyBpbiB0aGUgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGhhc19kb3VibGVfYXJyYXlfdGFnIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIEV4cG9zZSBvbmUgZGlyZWN0aW9uIG9mIHRoZSBpc29tb3JwaGlzbSBiZXR3ZWVuIGEgdmFsdWUgb2YgdHlwZSBbJ2FdIGFuZCBhIHZhbHVlIG9mXG4gICAgICAgdHlwZSBbJ2EgZmllbGRzXS4gQmFzaWNhbGx5LCBnaXZlbiBhbiBlbmNvZGluZyB3YXkgb2YgYWNjZXNzaW5nIHRoZSB2YWx1ZSBvZiBhbGxcbiAgICAgICB0aGUgZmllbGRzIG9mIGEgcmVjb3JkLCBjcmVhdGUgdGhhdCByZWNvcmQgYW5kIHJldHVybiBpdC5cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiAnYSB0IC0+ICdhIGZpZWxkcyAtPiAnYVxuXG4gICAgKCoqXG4gICAgICAgZm9sZGluZyBhbG9uZyB0aGUgdGFncyBvZiB0aGUgdmFyaWFudCB0eXBlXG4gICAgKilcbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgZmllbGQgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogJ2EgUmVjb3JkX2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJlY29yZF9pbnRlcm5hbFxuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgdCA9IHQudHlwZW5hbWVcbiAgICBsZXQgbGVuZ3RoIHQgPSBBcnJheS5sZW5ndGggdC5maWVsZHNcbiAgICBsZXQgZmllbGQgdCBpbmRleCA9IHQuZmllbGRzLihpbmRleClcbiAgICBsZXQgaGFzX2RvdWJsZV9hcnJheV90YWcgdCA9IHQuaGFzX2RvdWJsZV9hcnJheV90YWdcbiAgICBsZXQgY3JlYXRlIHQgPSB0LmNyZWF0ZVxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPSBBcnJheS5mb2xkX2xlZnQgZiBpbml0IHQuZmllbGRzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICB0eXBlICdhIHJlcCA9ICdhIHRcbiAgICB0eXBlICdhIHQgPSAnYSByZXBcbiAgZW5kKVxuZW5kXG4iLCJtb2R1bGUgTmFtZV9vZiA9IHN0cnVjdFxuICBsZXQgdHlwZW5hbWVfb2ZfaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQzMiA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50MzJcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50MzJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2ludDY0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnQ2NFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJpbnQ2NFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfbmF0aXZlaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBuYXRpdmVpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwibmF0aXZlaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9jaGFyID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBjaGFyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImNoYXJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Zsb2F0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBmbG9hdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJmbG9hdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2Zfc3RyaW5nID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgICBsZXQgbmFtZSA9IFwic3RyaW5nXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ieXRlcyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gYnl0ZXNcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Jvb2wgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJvb2xcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYm9vbFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdW5pdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJ1bml0XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIG1vZHVsZSBNX29wdGlvbiA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICAgIGxldCBuYW1lID0gXCJvcHRpb25cIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX29wdGlvbiA9IE1fb3B0aW9uLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9saXN0ID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgIGxldCBuYW1lID0gXCJsaXN0XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9saXN0ID0gTV9saXN0LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9hcnJheSA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBhcnJheVxuXG4gICAgbGV0IG5hbWUgPSBcImFycmF5XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9hcnJheSA9IE1fYXJyYXkudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2xhenlfdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuICAgIGxldCBuYW1lID0gXCJsYXp5X3RcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2xhenlfdCA9IE1fbGF6eV90LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9yZWYgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgcmVmXG5cbiAgICBsZXQgbmFtZSA9IFwicmVmXCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9yZWYgPSBNX3JlZi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fZnVuY3Rpb24gPSBUeXBlbmFtZS5NYWtlMiAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgLT4gJ2JcblxuICAgIGxldCBuYW1lID0gXCJmdW5jdGlvblwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfZnVuY3Rpb24gPSBNX2Z1bmN0aW9uLnR5cGVuYW1lX29mX3RcblxuICB0eXBlIHR1cGxlMCA9IHVuaXRcblxuICBtb2R1bGUgTV90dXBsZTAgPSBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgdHlwZSB0ID0gdHVwbGUwXG5cbiAgICBsZXQgbmFtZSA9IFwidHVwbGUwXCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTAgPSBNX3R1cGxlMC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUyID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhICogJ2JcblxuICAgIGxldCBuYW1lID0gXCJ0dXBsZTJcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMiA9IE1fdHVwbGUyLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTMgPSBUeXBlbmFtZS5NYWtlMyAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdhICogJ2IgKiAnY1xuXG4gICAgbGV0IG5hbWUgPSBcInR1cGxlM1wiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUzID0gTV90dXBsZTMudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNCA9IFR5cGVuYW1lLk1ha2U0IChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA9ICdhICogJ2IgKiAnYyAqICdkXG5cbiAgICBsZXQgbmFtZSA9IFwidHVwbGU0XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTQgPSBNX3R1cGxlNC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGU1ID0gVHlwZW5hbWUuTWFrZTUgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA9ICdhICogJ2IgKiAnYyAqICdkICogJ2VcblxuICAgIGxldCBuYW1lID0gXCJ0dXBsZTVcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlNSA9IE1fdHVwbGU1LnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgcmVjIFR5cGVyZXAgOiBzaWdcbiAgdHlwZSBfIHQgPVxuICAgIHwgSW50IDogaW50IHRcbiAgICB8IEludDMyIDogaW50MzIgdFxuICAgIHwgSW50NjQgOiBpbnQ2NCB0XG4gICAgfCBOYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICAgIHwgQ2hhciA6IGNoYXIgdFxuICAgIHwgRmxvYXQgOiBmbG9hdCB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgQnl0ZXMgOiBieXRlcyB0XG4gICAgfCBCb29sIDogYm9vbCB0XG4gICAgfCBVbml0IDogdW5pdCB0XG4gICAgfCBPcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gICAgfCBMaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgICB8IEFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gICAgfCBMYXp5IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICAgIHwgUmVmIDogJ2EgdCAtPiAnYSByZWYgdFxuICAgIHwgRnVuY3Rpb24gOiAoJ2RvbSB0ICogJ3JuZyB0KSAtPiAoJ2RvbSAtPiAncm5nKSB0XG4gICAgfCBUdXBsZSA6ICdhIFR5cGVyZXAuVHVwbGUudCAtPiAnYSB0XG4gICAgfCBSZWNvcmQgOiAnYSBUeXBlcmVwLlJlY29yZC50IC0+ICdhIHRcbiAgICB8IFZhcmlhbnQgOiAnYSBUeXBlcmVwLlZhcmlhbnQudCAtPiAnYSB0XG4gICAgfCBOYW1lZCA6ICgnYSBUeXBlcmVwLk5hbWVkLnQgKiAnYSB0IGxhenlfdCBvcHRpb24pIC0+ICdhIHRcblxuICB0eXBlIHBhY2tlZCA9IFQgOiAnYSB0IC0+IHBhY2tlZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFQwID0gc2lnXG4gICAgICB0eXBlIG5hbWVkXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQxID0gc2lnXG4gICAgICB0eXBlICdhIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgYSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMiA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2IgVHlwZW5hbWUudCAtPiAoJ2EsICdiKSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQzID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYykgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ0ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNSA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBlXG5cbiAgICAgIHZhbCBlIDogZSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdlIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQsIGUpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgICgqIHRoZXJlIHRoZSBtb2R1bGUgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byBkZWFsIHdpdGggYSB0eXBlIFt0XSB3aXRoXG4gICAgICAgcGFyYW1ldGVycyB3aG9zZSBraW5kIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgdHlwZSB2YXJpYWJsZTogWydhICd0XSwgZXZlbiB3aXRoXG4gICAgICAgYSBnYWR0LiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IFQwIG9mIChtb2R1bGUgVDAgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDEgb2YgKG1vZHVsZSBUMSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMiBvZiAobW9kdWxlIFQyIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQzIG9mIChtb2R1bGUgVDMgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDQgb2YgKG1vZHVsZSBUNCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNSBvZiAobW9kdWxlIFQ1IHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIFR1cGxlIDogc2lnXG4gICAgKCogdGhlc2UgY29uc3RydWN0b3JzIGNvdWxkIGJlIHBsdW5nZWQgYXQgdG9wbGV2ZWwgb2YgVHlwZXJlcC50LCBob3dldmVyIGl0IGlzIGxlc3NcbiAgICAgICB2ZXJib3NlIHRoYXQgd2F5ICopXG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBUMiA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQpIC0+ICgnYSAqICdiKSB0XG4gICAgICB8IFQzIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCkgLT4gKCdhICogJ2IgKiAnYykgdFxuICAgICAgfCBUNCA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgICAgIHwgVDUgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQgKiAnZSBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkICogJ2UpIHRcblxuICAgIHZhbCBhcml0eSA6IF8gdCAtPiBpbnRcbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVHlwZXJlcC50XG5cbiAgdmFsIHNhbWUgOiBfIHQgLT4gXyB0IC0+IGJvb2xcbiAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnQgb3B0aW9uXG4gIHZhbCBzYW1lX3dpdG5lc3NfZXhuIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSwgJ2IpIFR5cGVfZXF1YWwudFxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICB2YWwgaGVhZCA6ICdhIHQgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IGFyaXR5ID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgXyAtPiAwXG4gICAgICB8IFQxIF8gLT4gMVxuICAgICAgfCBUMiBfIC0+IDJcbiAgICAgIHwgVDMgXyAtPiAzXG4gICAgICB8IFQ0IF8gLT4gNFxuICAgICAgfCBUNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgKHR5cGUgYSkgPSBmdW5jdGlvblxuICAgICAgfCBUMCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMiByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMiB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMyByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMyB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgbmFtZSByZXAgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkICh0eXBlbmFtZV9vZl90IHJlcCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA9IHN0cnVjdFxuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGlzIHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICBsZXQgYXJpdHkgOiB0eXBlIGEuIGEgdCAtPiBpbnQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIF8gLT4gMlxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQzIF8gLT4gM1xuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ0IF8gLT4gNFxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IF8gLT4gNVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgICB8IFQyIChhLCBiKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlMiAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgIHwgVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGUzXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICB8IFQ0IChhLCBiLCBjLCBkKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNFxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgIHwgVDUgKGEsIGIsIGMsIGQsIGUpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGU1XG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBkKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZSlcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLk0gKHN0cnVjdFxuICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIHJlcFxuICBlbmQpXG5cbiAgbGV0IHJlYyB0eXBlbmFtZV9vZl90IDogdHlwZSBhLiBhIHQgLT4gYSBUeXBlbmFtZS50ID0gZnVuY3Rpb25cbiAgICB8IEludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2ludFxuICAgIHwgSW50MzIgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQzMlxuICAgIHwgSW50NjQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQ2NFxuICAgIHwgTmF0aXZlaW50IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbmF0aXZlaW50XG4gICAgfCBDaGFyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfY2hhclxuICAgIHwgRmxvYXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9mbG9hdFxuICAgIHwgU3RyaW5nIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfc3RyaW5nXG4gICAgfCBCeXRlcyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2J5dGVzXG4gICAgfCBCb29sIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfYm9vbFxuICAgIHwgVW5pdCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3VuaXRcbiAgICB8IE9wdGlvbiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9vcHRpb24gKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgTGlzdCByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9saXN0ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEFycmF5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2FycmF5ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExhenkgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGF6eV90ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IFJlZiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9yZWYgKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgRnVuY3Rpb24gKGRvbSwgcm5nKSAtPlxuICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl9mdW5jdGlvbiAodHlwZW5hbWVfb2ZfdCBkb20pICh0eXBlbmFtZV9vZl90IHJuZylcbiAgICB8IFR1cGxlIHJlcCAtPiBUeXBlcmVwLlR1cGxlLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBSZWNvcmQgcmVwIC0+IFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBWYXJpYW50IHJlcCAtPiBUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByZXBcbiAgICB8IE5hbWVkIChuYW1lLCBfKSAtPiBOYW1lZC50eXBlbmFtZV9vZl90IG5hbWVcbiAgOztcblxuICBsZXQgcmVjIHNhbWVfd2l0bmVzcyA6IHR5cGUgYSBiLiBhIHQgLT4gYiB0IC0+IChhLCBiKSBUeXBlX2VxdWFsLnQgb3B0aW9uID1cbiAgICBmdW4gdDEgdDIgLT5cbiAgICBsZXQgbW9kdWxlIEUgPSBUeXBlX2VxdWFsIGluXG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IE5hbWVkIChuYW1lMSwgcjEpLCBOYW1lZCAobmFtZTIsIHIyKSAtPlxuICAgICAgKG1hdGNoXG4gICAgICAgICBUeXBlbmFtZS5zYW1lX3dpdG5lc3MgKE5hbWVkLnR5cGVuYW1lX29mX3QgbmFtZTEpIChOYW1lZC50eXBlbmFtZV9vZl90IG5hbWUyKVxuICAgICAgIHdpdGhcbiAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgKG1hdGNoIHIxLCByMiB3aXRoXG4gICAgICAgICAgfCBTb21lIChsYXp5IHQxKSwgU29tZSAobGF6eSB0MikgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgfCBTb21lIChsYXp5IHQxKSwgTm9uZSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICB8IE5vbmUsIFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lKSlcbiAgICB8IE5hbWVkIChfLCByMSksIHQyIC0+XG4gICAgICAobWF0Y2ggcjEgd2l0aFxuICAgICAgIHwgU29tZSAobGF6eSB0MSkgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCB0MSwgTmFtZWQgKF8sIHIyKSAtPlxuICAgICAgKG1hdGNoIHIyIHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgSW50LCBJbnQgLT4gU29tZSBFLlRcbiAgICB8IEludDMyLCBJbnQzMiAtPiBTb21lIEUuVFxuICAgIHwgSW50NjQsIEludDY0IC0+IFNvbWUgRS5UXG4gICAgfCBOYXRpdmVpbnQsIE5hdGl2ZWludCAtPiBTb21lIEUuVFxuICAgIHwgQ2hhciwgQ2hhciAtPiBTb21lIEUuVFxuICAgIHwgRmxvYXQsIEZsb2F0IC0+IFNvbWUgRS5UXG4gICAgfCBTdHJpbmcsIFN0cmluZyAtPiBTb21lIEUuVFxuICAgIHwgQnl0ZXMsIEJ5dGVzIC0+IFNvbWUgRS5UXG4gICAgfCBCb29sLCBCb29sIC0+IFNvbWUgRS5UXG4gICAgfCBVbml0LCBVbml0IC0+IFNvbWUgRS5UXG4gICAgfCBPcHRpb24gcjEsIE9wdGlvbiByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgTGlzdCByMSwgTGlzdCByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgQXJyYXkgcjEsIEFycmF5IHIyIC0+XG4gICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHgpXG4gICAgfCBMYXp5IHIxLCBMYXp5IHIyIC0+XG4gICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHgpXG4gICAgfCBSZWYgcjEsIFJlZiByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgRnVuY3Rpb24gKGRvbTEsIHJuZzEpLCBGdW5jdGlvbiAoZG9tMiwgcm5nMikgLT5cbiAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgZG9tMSBkb20yLCBzYW1lX3dpdG5lc3Mgcm5nMSBybmcyIHdpdGhcbiAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICB8IFR1cGxlIHQxLCBUdXBsZSB0MiAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gVHlwZXJlcC5UdXBsZSBpblxuICAgICAgKG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgfCBULlQyIChhMSwgYjEpLCBULlQyIChhMiwgYjIpIC0+XG4gICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIgd2l0aFxuICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lKVxuICAgICAgIHwgVC5UMyAoYTEsIGIxLCBjMSksIFQuVDMgKGEyLCBiMiwgYzIpIC0+XG4gICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIsIHNhbWVfd2l0bmVzcyBjMSBjMiB3aXRoXG4gICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfLCBfIHwgXywgTm9uZSwgXyB8IF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICB8IFQuVDQgKGExLCBiMSwgYzEsIGQxKSwgVC5UNCAoYTIsIGIyLCBjMiwgZDIpIC0+XG4gICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyLCBzYW1lX3dpdG5lc3MgYzEgYzIsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfLCBfLCBfIHwgXywgTm9uZSwgXywgXyB8IF8sIF8sIE5vbmUsIF8gfCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgfCBULlQ1IChhMSwgYjEsIGMxLCBkMSwgZTEpLCBULlQ1IChhMiwgYjIsIGMyLCBkMiwgZTIpIC0+XG4gICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgICggc2FtZV93aXRuZXNzIGExIGEyXG4gICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBiMSBiMlxuICAgICAgICAgICAgLCBzYW1lX3dpdG5lc3MgYzEgYzJcbiAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGQxIGQyXG4gICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBlMSBlMiApXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfLCBfLCBfLCBfXG4gICAgICAgICAgfCBfLCBOb25lLCBfLCBfLCBfXG4gICAgICAgICAgfCBfLCBfLCBOb25lLCBfLCBfXG4gICAgICAgICAgfCBfLCBfLCBfLCBOb25lLCBfXG4gICAgICAgICAgfCBfLCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgfCBULlQyIF8sIF8gLT4gTm9uZVxuICAgICAgIHwgVC5UMyBfLCBfIC0+IE5vbmVcbiAgICAgICB8IFQuVDQgXywgXyAtPiBOb25lXG4gICAgICAgfCBULlQ1IF8sIF8gLT4gTm9uZSlcbiAgICB8IFJlY29yZCByMSwgUmVjb3JkIHIyIC0+XG4gICAgICBUeXBlbmFtZS5zYW1lX3dpdG5lc3NcbiAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjEpXG4gICAgICAgIChUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHIyKVxuICAgIHwgVmFyaWFudCByMSwgVmFyaWFudCByMiAtPlxuICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMSlcbiAgICAgICAgKFR5cGVyZXAuVmFyaWFudC50eXBlbmFtZV9vZl90IHIyKVxuICAgIHwgSW50LCBfIC0+IE5vbmVcbiAgICB8IEludDMyLCBfIC0+IE5vbmVcbiAgICB8IEludDY0LCBfIC0+IE5vbmVcbiAgICB8IE5hdGl2ZWludCwgXyAtPiBOb25lXG4gICAgfCBDaGFyLCBfIC0+IE5vbmVcbiAgICB8IEZsb2F0LCBfIC0+IE5vbmVcbiAgICB8IFN0cmluZywgXyAtPiBOb25lXG4gICAgfCBCeXRlcywgXyAtPiBOb25lXG4gICAgfCBCb29sLCBfIC0+IE5vbmVcbiAgICB8IFVuaXQsIF8gLT4gTm9uZVxuICAgIHwgT3B0aW9uIF8sIF8gLT4gTm9uZVxuICAgIHwgTGlzdCBfLCBfIC0+IE5vbmVcbiAgICB8IEFycmF5IF8sIF8gLT4gTm9uZVxuICAgIHwgTGF6eSBfLCBfIC0+IE5vbmVcbiAgICB8IFJlZiBfLCBfIC0+IE5vbmVcbiAgICB8IEZ1bmN0aW9uIF8sIF8gLT4gTm9uZVxuICAgIHwgVHVwbGUgXywgXyAtPiBOb25lXG4gICAgfCBSZWNvcmQgXywgXyAtPiBOb25lXG4gICAgfCBWYXJpYW50IF8sIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBzYW1lIGEgYiA9IHNhbWVfd2l0bmVzcyBhIGIgPD4gTm9uZVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIGEgYiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIGEgYiB3aXRoXG4gICAgfCBTb21lIHByb29mIC0+IHByb29mXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgaGVhZCA9IGZ1bmN0aW9uXG4gICAgfCBUeXBlcmVwLk5hbWVkIChfLCBTb21lIChsYXp5IHQpKSAtPiBoZWFkIHRcbiAgICB8IHQgLT4gdFxuICA7O1xuZW5kXG5cbmxldCB0eXBlcmVwX29mX2ludCA9IFR5cGVyZXAuSW50XG5sZXQgdHlwZXJlcF9vZl9pbnQzMiA9IFR5cGVyZXAuSW50MzJcbmxldCB0eXBlcmVwX29mX2ludDY0ID0gVHlwZXJlcC5JbnQ2NFxubGV0IHR5cGVyZXBfb2ZfbmF0aXZlaW50ID0gVHlwZXJlcC5OYXRpdmVpbnRcbmxldCB0eXBlcmVwX29mX2NoYXIgPSBUeXBlcmVwLkNoYXJcbmxldCB0eXBlcmVwX29mX2Zsb2F0ID0gVHlwZXJlcC5GbG9hdFxubGV0IHR5cGVyZXBfb2Zfc3RyaW5nID0gVHlwZXJlcC5TdHJpbmdcbmxldCB0eXBlcmVwX29mX2J5dGVzID0gVHlwZXJlcC5CeXRlc1xubGV0IHR5cGVyZXBfb2ZfYm9vbCA9IFR5cGVyZXAuQm9vbFxubGV0IHR5cGVyZXBfb2ZfdW5pdCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2Zfb3B0aW9uIHJlcCA9IFR5cGVyZXAuT3B0aW9uIHJlcFxubGV0IHR5cGVyZXBfb2ZfbGlzdCByZXAgPSBUeXBlcmVwLkxpc3QgcmVwXG5sZXQgdHlwZXJlcF9vZl9hcnJheSByZXAgPSBUeXBlcmVwLkFycmF5IHJlcFxubGV0IHR5cGVyZXBfb2ZfbGF6eV90IHJlcCA9IFR5cGVyZXAuTGF6eSByZXBcbmxldCB0eXBlcmVwX29mX3JlZiByZXAgPSBUeXBlcmVwLlJlZiByZXBcbmxldCB0eXBlcmVwX29mX2Z1bmN0aW9uIGRvbSBybmcgPSBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZylcbmxldCB0eXBlcmVwX29mX3R1cGxlMCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2ZfdHVwbGUyIGEgYiA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDIgKGEsIGIpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGUzIGEgYiBjID0gVHlwZXJlcC5UdXBsZSAoVHlwZXJlcC5UdXBsZS5UMyAoYSwgYiwgYykpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTQgYSBiIGMgZCA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU1IGEgYiBjIGQgZSA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDUgKGEsIGIsIGMsIGQsIGUpKVxuXG5pbmNsdWRlIE5hbWVfb2ZcblxubGV0IHZhbHVlX3R1cGxlMCA9ICgpXG5cbmxldCB0eXBlcmVwX29mX2ludDYzLCB0eXBlbmFtZV9vZl9pbnQ2MyA9XG4gIGxldCB0eXBlcmVwX2FuZF90eXBlbmFtZV9vZl9pbnQ2M19yZXByXG4gICAgOiB0eXBlIGEgYi4gKGEsIGIpIEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLnQgLT4gYSBUeXBlcmVwLnQgKiBhIFR5cGVuYW1lLnRcbiAgICA9IGZ1bmN0aW9uXG4gICAgfCBCYXNlLkludDYzLlByaXZhdGUuUmVwci5JbnQgLT4gdHlwZXJlcF9vZl9pbnQsIHR5cGVuYW1lX29mX2ludFxuICAgIHwgQmFzZS5JbnQ2My5Qcml2YXRlLlJlcHIuSW50NjQgLT4gdHlwZXJlcF9vZl9pbnQ2NCwgdHlwZW5hbWVfb2ZfaW50NjRcbiAgaW5cbiAgdHlwZXJlcF9hbmRfdHlwZW5hbWVfb2ZfaW50NjNfcmVwciBCYXNlLkludDYzLlByaXZhdGUucmVwclxuOztcbiIsIigqIHVzaW5nIHRoZSBoYXNoX3ZhcmlhbnQgb2YgcGFfdHlwZV9jb252IGF0IGNvbXBpbGUgdGltZSAqKVxubGV0IHJlcHJfb2ZfcG9seV92YXJpYW50IDogWz4gXSAtPiBpbnQgPVxuICBmdW4gdmFyaWFudCAtPlxuICBsZXQgb2JqID0gT2JqLnJlcHIgdmFyaWFudCBpblxuICBpZiBPYmouaXNfaW50IG9ialxuICB0aGVuIE9iai5vYmogb2JqXG4gIGVsc2UgKFxuICAgIGxldCBzaXplID0gT2JqLnNpemUgb2JqIGluXG4gICAgYXNzZXJ0IChzaXplID0gMik7XG4gICAgbGV0IHJlcHIgPSBPYmouZmllbGQgb2JqIDAgaW5cbiAgICBhc3NlcnQgKE9iai5pc19pbnQgcmVwcik7XG4gICAgT2JqLm9iaiByZXByKVxuOztcblxubGV0IGhhc2hfdmFyaWFudCBzID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gKDIyMyAqICFhY2N1KSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKCgxIGxzbCAzMSkgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdVxuOztcblxuKCogYSBmZXcgdW5pdCB0ZXN0cyBvZiBjYXNlcyB0aGF0IGhhdmUgdHJpZ2dlcmVkIGRpZmZzIGluIHRoZSBwYXN0IG9mIHRoaXNcbiAgIGxpYiAqKVxubGV0ICgpID0gYXNzZXJ0IChyZXByX29mX3BvbHlfdmFyaWFudCBgTGF0ZW5jeV9zdGF0cyA9IGhhc2hfdmFyaWFudCBcIkxhdGVuY3lfc3RhdHNcIilcbmxldCAoKSA9IGFzc2VydCAocmVwcl9vZl9wb2x5X3ZhcmlhbnQgYHplcm8gPSBoYXNoX3ZhcmlhbnQgXCJ6ZXJvXCIpXG5sZXRbQGlubGluZSBuZXZlcl0gZG91YmxlX2FycmF5X3ZhbHVlICgpID0gU3lzLm9wYXF1ZV9pZGVudGl0eSAoT2JqLm1hZ2ljIDAuKVxubGV0IGhhc19kb3VibGVfYXJyYXlfdGFnIGEgPSBPYmouZG91YmxlX2FycmF5X3RhZyA9IE9iai50YWcgKE9iai5yZXByIGEpXG5cbmxldCAoKSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgZG91YmxlID1cbiAgICAgIHsgYSA6IGZsb2F0XG4gICAgICA7IGIgOiBmbG9hdFxuICAgICAgfVxuXG4gICAgdHlwZSBzaW1wbGUgPVxuICAgICAgeyBjIDogZmxvYXRcbiAgICAgIDsgZCA6IGludFxuICAgICAgfVxuXG4gICAgbGV0IGRvdWJsZSA9IHsgYSA9IGRvdWJsZV9hcnJheV92YWx1ZSAoKTsgYiA9IGRvdWJsZV9hcnJheV92YWx1ZSAoKSB9XG4gICAgbGV0IHNpbXBsZSA9IHsgYyA9IGRvdWJsZV9hcnJheV92YWx1ZSAoKTsgZCA9IGRvdWJsZV9hcnJheV92YWx1ZSAoKSB9XG4gIGVuZFxuICBpblxuICBhc3NlcnQgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uZG91YmxlKTtcbiAgYXNzZXJ0IChub3QgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uc2ltcGxlKSlcbjs7XG4iLCJtb2R1bGUgTSAoWCA6IHNpZ1xuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6IHQgWC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIHZhbCBjb21wdXRlIDogJ2EgWC50IC0+ICdhIHQgWC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wdXRlIDogJ2EgWC50IC0+ICdiIFgudCAtPiAoJ2EsICdiKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gJ2MgWC50IC0+ICgnYSwgJ2IsICdjKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gJ2MgWC50IC0+ICdkIFgudCAtPiAoJ2EsICdiLCAnYywgJ2QpIHQgWC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFM1ID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM1IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBYLnRcbiAgICAgIC0+ICdiIFgudFxuICAgICAgLT4gJ2MgWC50XG4gICAgICAtPiAnZCBYLnRcbiAgICAgIC0+ICdlIFgudFxuICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCBYLnRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIE0gKHN0cnVjdFxuICAgIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgY29tcHV0YXRpb25cbiAgZW5kKVxuZW5kXG4iLCJvcGVuIFN0ZF9pbnRlcm5hbFxubW9kdWxlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmID0gVmFyaWFudF9hbmRfcmVjb3JkX2ludGZcblxubW9kdWxlIEhlbHBlciAoQSA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpIChCIDogVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUykgPSBzdHJ1Y3RcbiAgdHlwZSBtYXAgPSB7IG1hcCA6ICdhLiAnYSBBLnQgLT4gJ2EgQi50IH1cblxuICBsZXQgbWFwX3ZhcmlhbnQgKHR5cGUgdmFyaWFudCkgeyBtYXAgfSAodmFyaWFudCA6IHZhcmlhbnQgQS5WYXJpYW50LnQpID1cbiAgICBsZXQgbWFwX2NyZWF0ZSA9IGZ1bmN0aW9uXG4gICAgICB8IEEuVGFnLkFyZ3MgZmN0IC0+IEIuVGFnX2ludGVybmFsLkFyZ3MgZmN0XG4gICAgICB8IEEuVGFnLkNvbnN0IGsgLT4gQi5UYWdfaW50ZXJuYWwuQ29uc3Qga1xuICAgIGluXG4gICAgbGV0IG1hcF90YWcgdGFnID1cbiAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICB8IEEuVmFyaWFudC5UYWcgdGFnIC0+XG4gICAgICAgIGxldCBsYWJlbCA9IEEuVGFnLmxhYmVsIHRhZyBpblxuICAgICAgICBsZXQgcmVwID0gbWFwIChBLlRhZy50cmF2ZXJzZSB0YWcpIGluXG4gICAgICAgIGxldCBhcml0eSA9IEEuVGFnLmFyaXR5IHRhZyBpblxuICAgICAgICBsZXQgYXJnc19sYWJlbHMgPSBBLlRhZy5hcmdzX2xhYmVscyB0YWcgaW5cbiAgICAgICAgbGV0IGluZGV4ID0gQS5UYWcuaW5kZXggdGFnIGluXG4gICAgICAgIGxldCBvY2FtbF9yZXByID0gQS5UYWcub2NhbWxfcmVwciB0YWcgaW5cbiAgICAgICAgbGV0IHR5aWQgPSBBLlRhZy50eWlkIHRhZyBpblxuICAgICAgICBsZXQgY3JlYXRlID0gbWFwX2NyZWF0ZSAoQS5UYWcuY3JlYXRlIHRhZykgaW5cbiAgICAgICAgQi5WYXJpYW50X2ludGVybmFsLlRhZ1xuICAgICAgICAgIChCLlRhZy5pbnRlcm5hbF91c2Vfb25seVxuICAgICAgICAgICAgIHsgQi5UYWdfaW50ZXJuYWwubGFiZWxcbiAgICAgICAgICAgICA7IHJlcFxuICAgICAgICAgICAgIDsgYXJpdHlcbiAgICAgICAgICAgICA7IGFyZ3NfbGFiZWxzXG4gICAgICAgICAgICAgOyBpbmRleFxuICAgICAgICAgICAgIDsgb2NhbWxfcmVwclxuICAgICAgICAgICAgIDsgdHlpZFxuICAgICAgICAgICAgIDsgY3JlYXRlXG4gICAgICAgICAgICAgfSlcbiAgICBpblxuICAgIGxldCB0eXBlbmFtZSA9IEEuVmFyaWFudC50eXBlbmFtZV9vZl90IHZhcmlhbnQgaW5cbiAgICBsZXQgcG9seW1vcnBoaWMgPSBBLlZhcmlhbnQuaXNfcG9seW1vcnBoaWMgdmFyaWFudCBpblxuICAgIGxldCB0YWdzID1cbiAgICAgIEFycmF5LmluaXQgKEEuVmFyaWFudC5sZW5ndGggdmFyaWFudCkgKGZ1biBpbmRleCAtPlxuICAgICAgICBtYXBfdGFnIChBLlZhcmlhbnQudGFnIHZhcmlhbnQgaW5kZXgpKVxuICAgIGluXG4gICAgbGV0IHZhbHVlIChhIDogdmFyaWFudCkgPVxuICAgICAgbWF0Y2ggQS5WYXJpYW50LnZhbHVlIHZhcmlhbnQgYSB3aXRoXG4gICAgICB8IEEuVmFyaWFudC5WYWx1ZSAoYXRhZywgYSkgLT5cbiAgICAgICAgKGZ1biAodHlwZSBhcmdzKSAoYXRhZyA6ICh2YXJpYW50LCBhcmdzKSBBLlRhZy50KSAoYSA6IGFyZ3MpIC0+XG4gICAgICAgICAgbGV0IChCLlZhcmlhbnRfaW50ZXJuYWwuVGFnIGJ0YWcpID0gdGFncy4oQS5UYWcuaW5kZXggYXRhZykgaW5cbiAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYnRhZyA6ICh2YXJpYW50LCBleCkgQi5UYWcudCkgLT5cbiAgICAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPVxuICAgICAgICAgICAgICBUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuIChBLlRhZy50eWlkIGF0YWcpIChCLlRhZy50eWlkIGJ0YWcpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IGJ0YWcgPSAoYnRhZyA6ICh2YXJpYW50LCBhcmdzKSBCLlRhZy50KSBpblxuICAgICAgICAgICAgQi5WYXJpYW50X2ludGVybmFsLlZhbHVlIChidGFnLCBhKSlcbiAgICAgICAgICAgIGJ0YWcpXG4gICAgICAgICAgYXRhZ1xuICAgICAgICAgIGFcbiAgICBpblxuICAgIEIuVmFyaWFudC5pbnRlcm5hbF91c2Vfb25seSB7IEIuVmFyaWFudF9pbnRlcm5hbC50eXBlbmFtZTsgdGFnczsgcG9seW1vcnBoaWM7IHZhbHVlIH1cbiAgOztcblxuICBsZXQgbWFwX3JlY29yZCAodHlwZSByZWNvcmQpIHsgbWFwIH0gKHJlY29yZCA6IHJlY29yZCBBLlJlY29yZC50KSA9XG4gICAgbGV0IG1hcF9maWVsZCBmaWVsZCA9XG4gICAgICBtYXRjaCBmaWVsZCB3aXRoXG4gICAgICB8IEEuUmVjb3JkLkZpZWxkIGZpZWxkIC0+XG4gICAgICAgIGxldCBsYWJlbCA9IEEuRmllbGQubGFiZWwgZmllbGQgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5GaWVsZC50cmF2ZXJzZSBmaWVsZCkgaW5cbiAgICAgICAgbGV0IGluZGV4ID0gQS5GaWVsZC5pbmRleCBmaWVsZCBpblxuICAgICAgICBsZXQgaXNfbXV0YWJsZSA9IEEuRmllbGQuaXNfbXV0YWJsZSBmaWVsZCBpblxuICAgICAgICBsZXQgdHlpZCA9IEEuRmllbGQudHlpZCBmaWVsZCBpblxuICAgICAgICBsZXQgZ2V0ID0gQS5GaWVsZC5nZXQgZmllbGQgaW5cbiAgICAgICAgQi5SZWNvcmRfaW50ZXJuYWwuRmllbGRcbiAgICAgICAgICAoQi5GaWVsZC5pbnRlcm5hbF91c2Vfb25seVxuICAgICAgICAgICAgIHsgQi5GaWVsZF9pbnRlcm5hbC5sYWJlbDsgcmVwOyBpbmRleDsgaXNfbXV0YWJsZTsgdHlpZDsgZ2V0IH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlJlY29yZC50eXBlbmFtZV9vZl90IHJlY29yZCBpblxuICAgIGxldCBoYXNfZG91YmxlX2FycmF5X3RhZyA9IEEuUmVjb3JkLmhhc19kb3VibGVfYXJyYXlfdGFnIHJlY29yZCBpblxuICAgIGxldCBmaWVsZHMgPVxuICAgICAgQXJyYXkuaW5pdCAoQS5SZWNvcmQubGVuZ3RoIHJlY29yZCkgKGZ1biBpbmRleCAtPlxuICAgICAgICBtYXBfZmllbGQgKEEuUmVjb3JkLmZpZWxkIHJlY29yZCBpbmRleCkpXG4gICAgaW5cbiAgICBsZXQgY3JlYXRlIHsgQi5SZWNvcmRfaW50ZXJuYWwuZ2V0IH0gPVxuICAgICAgbGV0IGdldCAodHlwZSBhKSAoYWZpZWxkIDogKF8sIGEpIEEuRmllbGQudCkgPVxuICAgICAgICBtYXRjaCBmaWVsZHMuKEEuRmllbGQuaW5kZXggYWZpZWxkKSB3aXRoXG4gICAgICAgIHwgQi5SZWNvcmRfaW50ZXJuYWwuRmllbGQgYmZpZWxkIC0+XG4gICAgICAgICAgKGZ1biAodHlwZSBleCkgKGJmaWVsZCA6IChyZWNvcmQsIGV4KSBCLkZpZWxkLnQpIC0+XG4gICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5GaWVsZC50eWlkIGFmaWVsZCkgKEIuRmllbGQudHlpZCBiZmllbGQpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IGJmaWVsZCA9IChiZmllbGQgOiAocmVjb3JkLCBhKSBCLkZpZWxkLnQpIGluXG4gICAgICAgICAgICBnZXQgYmZpZWxkKVxuICAgICAgICAgICAgYmZpZWxkXG4gICAgICBpblxuICAgICAgQS5SZWNvcmQuY3JlYXRlIHJlY29yZCB7IEEuUmVjb3JkLmdldCB9XG4gICAgaW5cbiAgICBCLlJlY29yZC5pbnRlcm5hbF91c2Vfb25seVxuICAgICAgeyBCLlJlY29yZF9pbnRlcm5hbC50eXBlbmFtZTsgZmllbGRzOyBoYXNfZG91YmxlX2FycmF5X3RhZzsgY3JlYXRlIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBOYW1lZCA9IHNpZ1xuICB0eXBlICdhIGNvbXB1dGF0aW9uXG5cbiAgbW9kdWxlIENvbnRleHQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjcmVhdGUgOiB1bml0IC0+IHRcbiAgZW5kXG5cbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGluaXQgOiBDb250ZXh0LnQgLT4gJ2EgVHlwZW5hbWUudCAtPiAnYSB0XG4gIHZhbCBnZXRfd2lwX2NvbXB1dGF0aW9uIDogJ2EgdCAtPiAnYSBjb21wdXRhdGlvblxuICB2YWwgc2V0X2ZpbmFsX2NvbXB1dGF0aW9uIDogJ2EgdCAtPiAnYSBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICB2YWwgc2hhcmUgOiBfIFR5cGVyZXAudCAtPiBib29sXG5lbmRcblxubW9kdWxlIHR5cGUgQ29tcHV0YXRpb24gPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgaW50IDogaW50IHRcbiAgdmFsIGludDMyIDogaW50MzIgdFxuICB2YWwgaW50NjQgOiBpbnQ2NCB0XG4gIHZhbCBuYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICB2YWwgY2hhciA6IGNoYXIgdFxuICB2YWwgZmxvYXQgOiBmbG9hdCB0XG4gIHZhbCBzdHJpbmcgOiBzdHJpbmcgdFxuICB2YWwgYnl0ZXMgOiBieXRlcyB0XG4gIHZhbCBib29sIDogYm9vbCB0XG4gIHZhbCB1bml0IDogdW5pdCB0XG4gIHZhbCBvcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gIHZhbCBsaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgdmFsIGFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gIHZhbCBsYXp5X3QgOiAnYSB0IC0+ICdhIGxhenlfdCB0XG4gIHZhbCByZWZfIDogJ2EgdCAtPiAnYSByZWYgdFxuICB2YWwgZnVuY3Rpb25fIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAtPiAnYikgdFxuICB2YWwgdHVwbGUyIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAqICdiKSB0XG4gIHZhbCB0dXBsZTMgOiAnYSB0IC0+ICdiIHQgLT4gJ2MgdCAtPiAoJ2EgKiAnYiAqICdjKSB0XG4gIHZhbCB0dXBsZTQgOiAnYSB0IC0+ICdiIHQgLT4gJ2MgdCAtPiAnZCB0IC0+ICgnYSAqICdiICogJ2MgKiAnZCkgdFxuICB2YWwgdHVwbGU1IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAnZSB0IC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG4gIHZhbCByZWNvcmQgOiAnYSBSZWNvcmQudCAtPiAnYSB0XG4gIHZhbCB2YXJpYW50IDogJ2EgVmFyaWFudC50IC0+ICdhIHRcblxuICBtb2R1bGUgTmFtZWQgOiBOYW1lZCB3aXRoIHR5cGUgJ2EgY29tcHV0YXRpb24gOj0gJ2EgdFxuZW5kXG5cbigqIHNwZWNpYWwgZnVuY3RvciBhcHBsaWNhdGlvbiBmb3IgY29tcHV0YXRpb24gYXMgY2xvc3VyZSBvZiB0aGUgZm9ybSBbYSAtPiBiXSAqKVxubW9kdWxlIE1ha2VfbmFtZWRfZm9yX2Nsb3N1cmUgKFggOiBzaWdcbiAgdHlwZSAnYSBpbnB1dFxuICB0eXBlICdhIG91dHB1dFxuICB0eXBlICdhIHQgPSAnYSBpbnB1dCAtPiAnYSBvdXRwdXRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb250ZXh0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGlnbm9yZVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudFxuICAgIDsgcnVudGltZV9yZWZlcmVuY2UgOiAnYSBYLnQgcmVmXG4gICAgOyBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudCBvcHRpb24gcmVmXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBVbmRlZmluZWQgb2Ygc3RyaW5nXG5cbiAgbGV0IGluaXQgKCkgbmFtZSA9XG4gICAgbGV0IHBhdGggPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIG5hbWUpIGluXG4gICAgbGV0IHIgPSByZWYgKGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWQgcGF0aCkpIGluXG4gICAgeyBydW50aW1lX2RlcmVmZXJlbmNlID0gKGZ1biBpbnB1dCAtPiAhciBpbnB1dClcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlID0gclxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSByZWYgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWQgPVxuICAgIG1hdGNoIHNoYXJlZC5jb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIGNsb3MgLT4gY2xvc1xuICAgIHwgTm9uZSAtPiBzaGFyZWQucnVudGltZV9kZXJlZmVyZW5jZVxuICA7O1xuXG4gIGxldCBzZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uID1cbiAgICBsZXQgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgaW5cbiAgICBtYXRjaCBjb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBOb25lIC0+XG4gICAgICBpZiBCYXNlLnBoeXNfZXF1YWwgc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2UgY29tcHV0YXRpb24gdGhlbiBhc3NlcnQgZmFsc2U7XG4gICAgICBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6PSBTb21lIGNvbXB1dGF0aW9uO1xuICAgICAgc2hhcmVkLnJ1bnRpbWVfcmVmZXJlbmNlIDo9IGNvbXB1dGF0aW9uO1xuICAgICAgY29tcHV0YXRpb25cbiAgOztcblxuICBsZXQgc2hhcmUgXyA9IHRydWVcbmVuZFxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGltcGxlbWVudHMgOiBUeXBlbmFtZS5VaWQudCAtPiBib29sXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBCcm9rZW5fZGVwZW5kZW5jeSBvZiBzdHJpbmdcblxuICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzIG5hbWUgcmVxdWlyZWQgPVxuICAgIG1hdGNoIHJlcXVpcmVkIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+ICgpXG4gICAgfCBfIC0+XG4gICAgICBmdW4gdWlkIC0+XG4gICAgICAgIExpc3QuaXRlclxuICAgICAgICAgIChmdW4geyBuYW1lID0gbmFtZSc7IGltcGxlbWVudHMgfSAtPlxuICAgICAgICAgICAgaWYgbm90IChpbXBsZW1lbnRzIHVpZClcbiAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAoKiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgc2V0IHVwLCB0aGlzIGlzIGFuIGVycm9yIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uIG9mIHRoZSBwcm9ncmFtLCB3ZSByYXRoZXIgZmFpbCB3aXRoIGEgaHVtYW5cbiAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIG91dHB1dCAqKVxuICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgICAgIFwiVHlwZV9nZW5lcmljICVTIHJlcXVpcmVzICVTIGZvciB1aWQgJVNcXG5cIlxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgbmFtZSdcbiAgICAgICAgICAgICAgICAgIChUeXBlbmFtZS5VaWQubmFtZSB1aWQpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIHByZXJyX2VuZGxpbmUgbWVzc2FnZTtcbiAgICAgICAgICAgICAgcmFpc2UgKEJyb2tlbl9kZXBlbmRlbmN5IG1lc3NhZ2UpKSlcbiAgICAgICAgICByZXF1aXJlZFxuICA7O1xuZW5kXG5cbigqIEV4dGVuZGluZyBhbiBleGlzdGluZyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBFeHRlbmRpbmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgdmFsIGlkZW50IDogSWRlbnQudFxuXG4gICgqIGdlbmVyaWNfaWRlbnQgKiB0eXBlbmFtZSBvciBpbmZvICopXG4gIGV4Y2VwdGlvbiBOb3RfaW1wbGVtZW50ZWQgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIGNvbXB1dGF0aW9uIC0+ICdhIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYiBjb21wdXRhdGlvbiAtPiAoJ2EsICdiKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBjb21wdXRhdGlvblxuICAgICAgLT4gJ2IgY29tcHV0YXRpb25cbiAgICAgIC0+ICdjIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICdlIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIHZhbCByZWdpc3RlcjAgOiAobW9kdWxlIFMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMSA6IChtb2R1bGUgUzEpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMiA6IChtb2R1bGUgUzIpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMyA6IChtb2R1bGUgUzMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNCA6IChtb2R1bGUgUzQpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNSA6IChtb2R1bGUgUzUpIC0+IHVuaXRcblxuICAoKiBzcGVjaWFsIGxlc3Mgc2NhcnkgdHlwZSB3aGVuIHRoZSB0eXBlIGhhcyBubyBwYXJhbWV0ZXJzICopXG4gIHZhbCByZWdpc3RlciA6ICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiAtPiB1bml0XG5cbiAgKCpcbiAgICAgRXNzZW50aWFsbHkgYmVjYXVzZSB3ZSBjYW5ub3QgdGFsayBhYm91dCBhIHZhcmlhYmxlIG9mIGtpbmQgKiAtPiBrXG4gICAgIHZhbCByZWdpc3RlcjEgOiAnYSAndCBUeXBlcmVwLnQgLT4gKCdhIGNvbXB1dGF0aW9uIC0+ICdhICd0IGNvbXB1dGF0aW9uKSAtPiB1bml0XG4gICAgIC4uLlxuICAqKVxuZW5kXG5cbigqIEltcGxlbWVudGluZyBhIG5ldyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBTX2ltcGxlbWVudGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgRXh0ZW5kaW5nXG5cbiAgKCogcmFpc2UgdXNpbmcgdGhlIGN1cnJlbnQgaWRlbnQgKilcbiAgdmFsIHJhaXNlX25vdF9pbXBsZW1lbnRlZCA6IHN0cmluZyAtPiAnYVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICAoKlxuICAgICBTdGFuZGFyZCBjYXNlLCBmaW5kIGEgZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24sIG9yIGxvb2sgaW4gdGhlIGNvbnRlbnRcbiAgKilcbiAgdmFsIF91c2luZ19leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgVHlwZXJlcC50IGxhenlfdCBvcHRpb25cbiAgICAtPiAnYSBjb21wdXRhdGlvblxuXG4gICgqXG4gICAgIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSBtb3JlIGNvbnRyb2wgb24gd2hhdCB5b3Ugd2FudCB0byBkb1xuICAqKVxuICB2YWwgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgY29tcHV0YXRpb24gb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gIHZhbCBvZl90eXBlcmVwIDogJ2EgVHlwZXJlcC50IC0+IFsgYGdlbmVyaWMgb2YgJ2EgY29tcHV0YXRpb24gXVxuXG4gIG1vZHVsZSBDb21wdXRhdGlvbiA6IENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG5lbmQpIDogU19pbXBsZW1lbnRhdGlvbiB3aXRoIHR5cGUgJ2EgdCA9ICdhIFgudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBYLnRcbiAgdHlwZSAnYSBjb21wdXRhdGlvbiA9ICdhIHRcblxuICBpbmNsdWRlIFR5cGVfZ2VuZXJpY19pbnRmLk0gKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gIGVuZClcblxuICAoKiB3ZSBkbyBub3QgdXNlIGNvcmUgc2luY2Ugd2UgYXJlIGVhcmxpZXIgaW4gdGhlIGRlcGVuZGVuY2llcyBncmFwaCAqKVxuICBtb2R1bGUgVWlkX3RhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLlVpZClcblxuICAgIGxldCBmaW5kIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgdHJ5IFNvbWUgKGZpbmQgdGFibGUga2V5KSB3aXRoXG4gICAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lKVxuICAgICAgZWxzZSBOb25lXG4gICAgOztcblxuICAgIGxldCBjaGVja19kZXBlbmRlbmNpZXMgPSBJZGVudC5jaGVja19kZXBlbmRlbmNpZXMgWC5uYW1lIFgucmVxdWlyZWRcblxuICAgIGxldCByZXBsYWNlIHRhYmxlIGtleSB2YWx1ZSA9XG4gICAgICBjaGVja19kZXBlbmRlbmNpZXMga2V5O1xuICAgICAgcmVwbGFjZSAoTGF6eS5mb3JjZSB0YWJsZSkga2V5IHZhbHVlXG4gICAgOztcblxuICAgIGxldCBtZW0gdGFibGUga2V5ID1cbiAgICAgIGlmIExhenkuaXNfdmFsIHRhYmxlXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRhYmxlID0gTGF6eS5mb3JjZSB0YWJsZSBpblxuICAgICAgICBtZW0gdGFibGUga2V5KVxuICAgICAgZWxzZSBmYWxzZVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBzaXplID0gMjU2XG4gIGxldCB0YWJsZTAgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTEgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTIgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTMgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTQgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTUgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG5cbiAgbGV0IGlzX3JlZ2lzdGVyZWQgdWlkID1cbiAgICBVaWRfdGFibGUubWVtIHRhYmxlMCB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMSB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMiB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMyB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlNCB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlNSB1aWRcbiAgOztcblxuICBsZXQgaWRlbnQgPSB7IElkZW50Lm5hbWUgPSBYLm5hbWU7IGltcGxlbWVudHMgPSBpc19yZWdpc3RlcmVkIH1cblxuICBtb2R1bGUgRmluZDAgKFQgOiBUeXBlcmVwLk5hbWVkLlQwKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlIDogdW5pdCAtPiBULm5hbWVkIGNvbXB1dGF0aW9uIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTAgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUyA9ICh2YWwgcmVwIDogUykgaW5cbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuIFMudHlwZW5hbWVfb2ZfdCBULnR5cGVuYW1lX29mX25hbWVkIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCB3aXRuZXNzKSBTLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQxIChUIDogVHlwZXJlcC5OYW1lZC5UMSkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgb3B0aW9uXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBjb21wdXRlICgpID1cbiAgICAgIG1hdGNoIFVpZF90YWJsZS5maW5kIHRhYmxlMSAoVHlwZW5hbWUudWlkIFQudHlwZW5hbWVfb2ZfdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgcmVwIDogUzEpIGluXG4gICAgICAgIGxldCBtb2R1bGUgQ29udiA9XG4gICAgICAgICAgVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4bl8xXG4gICAgICAgICAgICAoUzEpXG4gICAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID0gVC5hIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzEuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDIgKFQgOiBUeXBlcmVwLk5hbWVkLlQyKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiAoVC5hLCBULmIpIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTIgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIHJlcCA6IFMyKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMlxuICAgICAgICAgICAgKFMyKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMi5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMyAoVCA6IFR5cGVyZXAuTmFtZWQuVDMpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYykgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTMgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIHJlcCA6IFMzKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fM1xuICAgICAgICAgICAgKFMzKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiBULmMgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNCAoVCA6IFR5cGVyZXAuTmFtZWQuVDQpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgb3B0aW9uXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBjb21wdXRlICgpID1cbiAgICAgIG1hdGNoIFVpZF90YWJsZS5maW5kIHRhYmxlNCAoVHlwZW5hbWUudWlkIFQudHlwZW5hbWVfb2ZfdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBTNCA9ICh2YWwgcmVwIDogUzQpIGluXG4gICAgICAgIGxldCBtb2R1bGUgQ29udiA9XG4gICAgICAgICAgVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4bl80XG4gICAgICAgICAgICAoUzQpXG4gICAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0ID0gKCdhLCAnYiwgJ2MsICdkKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgICAgICAgIFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFM0LmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQ1IChUIDogVHlwZXJlcC5OYW1lZC5UNSkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuYiBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuZSBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IChULmEsIFQuYiwgVC5jLCBULmQsIFQuZSkgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTUgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIHJlcCA6IFM1KSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fNVxuICAgICAgICAgICAgKFM1KVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgPSAoJ2EsICdiLCAnYywgJ2QsICdlKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgICAgICAgIFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmUgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTNS5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB1bml0ID0gVHlwZW5hbWUuc3RhdGljXG5cbiAgbGV0IHJlZ2lzdGVyMCBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFMgPSAodmFsIGNvbXB1dGUgOiBTKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgUy50eXBlbmFtZV9vZl90IGluXG4gICAgVWlkX3RhYmxlLnJlcGxhY2UgdGFibGUwIHVpZCBjb21wdXRlXG4gIDs7XG5cbiAgbGV0IHJlZ2lzdGVyMSBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFMxID0gKHZhbCBjb21wdXRlIDogUzEpIGluXG4gICAgbGV0IHVpZCA9IFR5cGVuYW1lLnVpZCAoUzEudHlwZW5hbWVfb2ZfdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMSB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjIgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMiA9ICh2YWwgY29tcHV0ZSA6IFMyKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMyLnR5cGVuYW1lX29mX3QgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMiB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjMgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMyA9ICh2YWwgY29tcHV0ZSA6IFMzKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMzLnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQpIGluXG4gICAgVWlkX3RhYmxlLnJlcGxhY2UgdGFibGUzIHVpZCBjb21wdXRlXG4gIDs7XG5cbiAgbGV0IHJlZ2lzdGVyNCBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFM0ID0gKHZhbCBjb21wdXRlIDogUzQpIGluXG4gICAgbGV0IHVpZCA9IFR5cGVuYW1lLnVpZCAoUzQudHlwZW5hbWVfb2ZfdCB1bml0IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlNCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjUgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNSA9ICh2YWwgY29tcHV0ZSA6IFM1KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM1LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlNSB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlciAodHlwZSBhKSB0eXBlcmVwX29mX2EgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBhXG5cbiAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVHlwZXJlcC50eXBlbmFtZV9vZl90IHR5cGVyZXBfb2ZfYVxuICAgICAgbGV0IHR5cGVyZXBfb2ZfdCA9IHR5cGVyZXBfb2ZfYVxuICAgICAgbGV0IGNvbXB1dGUgPSBjb21wdXRlXG4gICAgZW5kXG4gICAgaW5cbiAgICByZWdpc3RlcjAgKG1vZHVsZSBTIDogUylcbiAgOztcblxuICAoKiBJTVBMRU1FTlRBVElPTiAqKVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICBsZXQgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiAodHlwZSBhKSBhdXggPSBmdW5jdGlvblxuICAgIHwgVHlwZXJlcC5OYW1lZC5UMCByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQwIChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gVC53aXRuZXNzIGluXG4gICAgICAgICBTb21lIChjdXN0b20gOiBhIGNvbXB1dGF0aW9uKVxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgVHlwZXJlcC5OYW1lZC5UMSByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQxIChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgY3VzdG9tID0gKGN1c3RvbSAoYXV4LmdlbmVyaWMgVC5hKSA6IFQuYSBULm5hbWVkIGNvbXB1dGF0aW9uKSBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDIgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDIgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMiAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgOiAoVC5hLCBULmIpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDMgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMyAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgKGF1eC5nZW5lcmljIFQuYylcbiAgICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ0IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ0IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDQgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICAgOiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ1IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ1IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDUgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmEpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmIpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmMpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmUpXG4gICAgICAgICAgICAgOiAoVC5hLCBULmIsIFQuYywgVC5kLCBULmUpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgOztcblxuICBleGNlcHRpb24gTm90X2ltcGxlbWVudGVkIG9mIHN0cmluZyAqIHN0cmluZ1xuXG4gIGxldCByYWlzZV9ub3RfaW1wbGVtZW50ZWQgc3RyaW5nID0gcmFpc2UgKE5vdF9pbXBsZW1lbnRlZCAoWC5uYW1lLCBzdHJpbmcpKVxuXG4gIGxldCBfdXNpbmdfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gYXV4IHJlcCBjb250ZW50ID1cbiAgICBtYXRjaCBmaW5kX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgd2l0aFxuICAgIHwgU29tZSBjb21wdXRhdGlvbiAtPiBjb21wdXRhdGlvblxuICAgIHwgTm9uZSAtPlxuICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPiBhdXguZ2VuZXJpYyBjb250ZW50XG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBsZXQgdHlwZW5hbWUgPSBUeXBlcmVwLk5hbWVkLnR5cGVuYW1lX29mX3QgcmVwIGluXG4gICAgICAgICBsZXQgbmFtZSA9IFR5cGVuYW1lLlVpZC5uYW1lIChUeXBlbmFtZS51aWQgdHlwZW5hbWUpIGluXG4gICAgICAgICByYWlzZV9ub3RfaW1wbGVtZW50ZWQgbmFtZSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgXyA9IEhhc2h0YmwuTWFrZSAoVHlwZW5hbWUuS2V5KVxuXG5tb2R1bGUgTWFrZSAoWCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbmFtZSA6IHN0cmluZ1xuICB2YWwgcmVxdWlyZWQgOiBJZGVudC50IGxpc3RcblxuICBpbmNsdWRlIENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb21wdXRhdGlvbiA9IFhcbiAgaW5jbHVkZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFgpXG5cbiAgbW9kdWxlIE1lbW8gPSBUeXBlbmFtZS5UYWJsZSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgWC5OYW1lZC50XG4gIGVuZClcblxuICBtb2R1bGUgSGVscGVyID0gSGVscGVyIChUeXBlcmVwKSAoQ29tcHV0YXRpb24pXG5cbiAgbGV0IG9mX3R5cGVyZXAgcmVwID1cbiAgICBsZXQgY29udGV4dCA9IFguTmFtZWQuQ29udGV4dC5jcmVhdGUgKCkgaW5cbiAgICBsZXQgbWVtb190YWJsZSA9IE1lbW8uY3JlYXRlIDMyIGluXG4gICAgbGV0IHJlYyBvZl90eXBlcmVwIDogdHlwZSBhLiBhIFR5cGVyZXAudCAtPiBhIHQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLkludCAtPiBYLmludFxuICAgICAgfCBUeXBlcmVwLkludDMyIC0+IFguaW50MzJcbiAgICAgIHwgVHlwZXJlcC5JbnQ2NCAtPiBYLmludDY0XG4gICAgICB8IFR5cGVyZXAuTmF0aXZlaW50IC0+IFgubmF0aXZlaW50XG4gICAgICB8IFR5cGVyZXAuQ2hhciAtPiBYLmNoYXJcbiAgICAgIHwgVHlwZXJlcC5GbG9hdCAtPiBYLmZsb2F0XG4gICAgICB8IFR5cGVyZXAuU3RyaW5nIC0+IFguc3RyaW5nXG4gICAgICB8IFR5cGVyZXAuQnl0ZXMgLT4gWC5ieXRlc1xuICAgICAgfCBUeXBlcmVwLkJvb2wgLT4gWC5ib29sXG4gICAgICB8IFR5cGVyZXAuVW5pdCAtPiBYLnVuaXRcbiAgICAgIHwgVHlwZXJlcC5PcHRpb24gcmVwIC0+IFgub3B0aW9uIChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MaXN0IHJlcCAtPiBYLmxpc3QgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkFycmF5IHJlcCAtPiBYLmFycmF5IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MYXp5IHJlcCAtPiBYLmxhenlfdCAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuUmVmIHJlcCAtPiBYLnJlZl8gKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZykgLT4gWC5mdW5jdGlvbl8gKG9mX3R5cGVyZXAgZG9tKSAob2ZfdHlwZXJlcCBybmcpXG4gICAgICB8IFR5cGVyZXAuVHVwbGUgdHVwbGUgLT5cbiAgICAgICAgKCogZG8gTk9UIHdyaXRlIFtYLnR1cGxlMiAob2ZfdHlwZXJlcCBhKSAob2ZfdHlwZXJlcCBiKV1cbiAgICAgICAgICAgYmVjYXVzZSBvZl90eXBlcmVwIGNhbiBjb250YWluIGEgc2lkZSBlZmZlY3QgYW5kIFthXSBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgYmVmb3JlIFtiXSAqKVxuICAgICAgICAobWF0Y2ggdHVwbGUgd2l0aFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIFgudHVwbGUyIHJhIHJiXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIFgudHVwbGUzIHJhIHJiIHJjXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIGxldCByZCA9IG9mX3R5cGVyZXAgZCBpblxuICAgICAgICAgICBYLnR1cGxlNCByYSByYiByYyByZFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBsZXQgcmQgPSBvZl90eXBlcmVwIGQgaW5cbiAgICAgICAgICAgbGV0IHJlID0gb2ZfdHlwZXJlcCBlIGluXG4gICAgICAgICAgIFgudHVwbGU1IHJhIHJiIHJjIHJkIHJlKVxuICAgICAgfCBUeXBlcmVwLlJlY29yZCByZWNvcmQgLT5cbiAgICAgICAgWC5yZWNvcmQgKEhlbHBlci5tYXBfcmVjb3JkIHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSByZWNvcmQpXG4gICAgICB8IFR5cGVyZXAuVmFyaWFudCB2YXJpYW50IC0+XG4gICAgICAgIFgudmFyaWFudCAoSGVscGVyLm1hcF92YXJpYW50IHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSB2YXJpYW50KVxuICAgICAgfCBUeXBlcmVwLk5hbWVkIChuYW1lZCwgY29udGVudCkgLT5cbiAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IG5hbWVkIGluXG4gICAgICAgIChtYXRjaCBNZW1vLmZpbmQgbWVtb190YWJsZSB0eXBlbmFtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgc2hhcmVkIC0+IFguTmFtZWQuZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWRcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiB7IGdlbmVyaWMgPSBvZl90eXBlcmVwIH0gbmFtZWQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGNvbXB1dGF0aW9uIC0+IGNvbXB1dGF0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgIGxldCBuYW1lID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCB0eXBlbmFtZSkgaW5cbiAgICAgICAgICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWVcbiAgICAgICAgICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPlxuICAgICAgICAgICAgICAgICBpZiBYLk5hbWVkLnNoYXJlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgbGV0IHNoYXJlZCA9IFguTmFtZWQuaW5pdCBjb250ZXh0IHR5cGVuYW1lIGluXG4gICAgICAgICAgICAgICAgICAgTWVtby5zZXQgbWVtb190YWJsZSB0eXBlbmFtZSBzaGFyZWQ7XG4gICAgICAgICAgICAgICAgICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCBjb250ZW50IGluXG4gICAgICAgICAgICAgICAgICAgWC5OYW1lZC5zZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICAgICAgICBlbHNlIG9mX3R5cGVyZXAgY29udGVudCkpKVxuICAgIGluXG4gICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCByZXAgaW5cbiAgICBgZ2VuZXJpYyBjb21wdXRhdGlvblxuICA7O1xuZW5kXG4iLCJvcGVuIFN0ZF9pbnRlcm5hbFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTAgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCA9XG4gICAgVHlwZXJlcC5OYW1lZC5UMFxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBuYW1lZCA9IFgudFxuICAgICAgICB0eXBlIHQgPSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDBcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UxIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEpIG9mX3AxID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90IChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSBuYW1lZCA9ICdhIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIHQgPSBwMSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDFcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBwMSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIpIG9mX3AxIG9mX3AyID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdCAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKSAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMlxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZCA9ICgnYSwgJ2IpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDJcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyKSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMpIG9mX3AxIG9mX3AyIG9mX3AzID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UM1xuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWQgPSAoJ2EsICdiLCAnYykgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDNcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMykgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlNCAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzIHA0KSBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNClcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDRcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCkgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgZCA9IHA0XG5cbiAgICAgICAgbGV0IGQgPSBvZl9wNFxuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCkgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQ0XG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0KSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2U1IChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMgcDQgcDUpIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A0KVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A1KVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UNVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIGQgPSBwNFxuXG4gICAgICAgIGxldCBkID0gb2ZfcDRcblxuICAgICAgICB0eXBlIGUgPSBwNVxuXG4gICAgICAgIGxldCBlID0gb2ZfcDVcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDVcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnQpXG4gIDs7XG5lbmRcbiIsIm9wZW4gU3RkX2ludGVybmFsXG5cbm1vZHVsZSBNYWtlMCAoWCA6IE5hbWVkX2ludGYuUzApIDogVHlwZXJlcGFibGUuUyB3aXRoIHR5cGUgdCA6PSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UwIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3QgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpIDogVHlwZXJlcGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMSAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBOYW1lZF9pbnRmLlMyKSA6IFR5cGVyZXBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIFgudCA9XG5zdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IE5hbWVkX2ludGYuUzMpIDpcbiAgVHlwZXJlcGFibGUuUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpIDpcbiAgVHlwZXJlcGFibGUuUzQgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA6PSAoJ2EsICdiLCAnYywgJ2QpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTQgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCwgTm9uZSlcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpIDpcbiAgVHlwZXJlcGFibGUuUzUgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlNSAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1LCBOb25lKVxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcbiJdfQ==
