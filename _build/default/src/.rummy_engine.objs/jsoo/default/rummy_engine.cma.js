// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Rummy_engine
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Rummy_engine = [0];
   runtime.caml_register_global(0, Rummy_engine, "Rummy_engine");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Rummy_engine__Types
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Rummy_engine_Types$0 = "Rummy_engine__Types",
    cst_rummy_engine$0 = "rummy_engine";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\xe2\x99\xa5",
    cst$0 = "\xe2\x99\xa0",
    cst$1 = "\xe2\x99\xa6",
    cst$2 = "\xe2\x99\xa3",
    Stdlib_Printf = global_data.Stdlib__Printf,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Rummy_engine_Types$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_rummy_engine$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/types.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_rummy_engine$0, "types.ml");
   var
    _a_ = [0, [2, 0, [2, 0, 0]], "%s%s"],
    cst_2 = "2",
    cst_3 = "3",
    cst_4 = "4",
    cst_5 = "5",
    cst_6 = "6",
    cst_7 = "7",
    cst_8 = "8",
    cst_9 = "9",
    cst_10 = "10",
    cst_J = "J",
    cst_Q = "Q",
    cst_K = "K",
    cst_A = "A",
    cst_rummy_engine = cst_rummy_engine$0,
    cst_Rummy_engine_Types = cst_Rummy_engine_Types$0;
   function string_of_suit(param){
    switch(param){
      case 0:
       return cst;
      case 1:
       return cst$0;
      case 2:
       return cst$1;
      default: return cst$2;
    }
   }
   function string_of_rank(param){
    switch(param){
      case 0:
       return cst_2;
      case 1:
       return cst_3;
      case 2:
       return cst_4;
      case 3:
       return cst_5;
      case 4:
       return cst_6;
      case 5:
       return cst_7;
      case 6:
       return cst_8;
      case 7:
       return cst_9;
      case 8:
       return cst_10;
      case 9:
       return cst_J;
      case 10:
       return cst_Q;
      case 11:
       return cst_K;
      default: return cst_A;
    }
   }
   function string_of_card(c){
    var _b_ = string_of_suit(c[1]), _c_ = string_of_rank(c[2]);
    return caml_call3(Stdlib_Printf[4], _a_, _c_, _b_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_rummy_engine);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Rummy_engine_Types);
   var
    Rummy_engine_Types = [0, string_of_suit, string_of_rank, string_of_card];
   runtime.caml_register_global
    (30, Rummy_engine_Types, cst_Rummy_engine_Types$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Rummy_engine__Setup
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdlib__Array, Stdlib__List, Stdlib__Printf, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Rummy_engine_Setup$0 = "Rummy_engine__Setup",
    cst_rummy_engine$0 = "rummy_engine",
    caml_list_of_js_array = runtime.caml_list_of_js_array;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    suits = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    ranks = caml_list_of_js_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Random = global_data.Stdlib__Random,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Rummy_engine_Setup$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_rummy_engine$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/setup.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_rummy_engine$0, "setup.ml");
   var
    cst_Computer = "Computer",
    _b_ = [0, [11, "Player ", [4, 0, 0, 0, 0]], "Player %d"],
    _c_ = [0, 0],
    cst_rummy_engine = cst_rummy_engine$0,
    cst_Rummy_engine_Setup = cst_Rummy_engine_Setup$0;
   function _a_(s){
    function _m_(r){return [0, s, r];}
    return caml_call2(Stdlib_List[20], _m_, ranks);
   }
   var all_cards = caml_call2(Stdlib_List[24], _a_, suits);
   function shuffle(xs){
    caml_call1(Stdlib_Random[3], 0);
    function _f_(x){return [0, caml_call1(Stdlib_Random[4], 0), x];}
    var _g_ = caml_call2(Stdlib_List[20], _f_, xs);
    function _h_(param, _l_){
     var b = _l_[1], a = param[1];
     return runtime.caml_int_compare(a, b);
    }
    var _i_ = caml_call2(Stdlib_List[59], _h_, _g_);
    function _j_(_k_){return _k_[2];}
    return caml_call2(Stdlib_List[20], _j_, _i_);
   }
   function deal_n(n, deck){
    var k = n, acc = 0, d = deck;
    for(;;){
     if(0 === k) return [0, caml_call1(Stdlib_List[10], acc), d];
     if(! d) return [0, caml_call1(Stdlib_List[10], acc), 0];
     var
      xs = d[2],
      x = d[1],
      acc$0 = [0, x, acc],
      k$0 = k - 1 | 0,
      k = k$0,
      acc = acc$0,
      d = xs;
    }
   }
   function init_state(num_players, vs_computer){
    var
     deck0 = shuffle(all_cards),
     k = num_players,
     deck_after = deck0,
     acc = 0,
     hand_size = 7;
    for(;;){
     if(0 === k){
      var
       hands = caml_call1(Stdlib_List[10], acc),
       _d_ =
         function(i, h){
          if(vs_computer && 1 === i) return [0, i, cst_Computer, h];
          return [0, i, caml_call2(Stdlib_Printf[4], _b_, i + 1 | 0), h];
         },
       _e_ = caml_call2(Stdlib_List[21], _d_, hands),
       players = caml_call1(Stdlib_Array[10], _e_);
      return [0,
              deck_after,
              0,
              0,
              players,
              0,
              0,
              0,
              _c_,
              0,
              runtime.caml_make_vect(num_players, 0)];
     }
     var
      match = deal_n(hand_size, deck_after),
      deck = match[2],
      h = match[1],
      acc$0 = [0, h, acc],
      k$0 = k - 1 | 0,
      k = k$0,
      deck_after = deck,
      acc = acc$0;
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_rummy_engine);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Rummy_engine_Setup);
   var Rummy_engine_Setup = [0, all_cards, shuffle, deal_n, init_state];
   runtime.caml_register_global
    (20, Rummy_engine_Setup, cst_Rummy_engine_Setup$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Rummy_engine__Rules
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdlib__List, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Rummy_engine_Rules$0 = "Rummy_engine__Rules",
    cst_rummy_engine$0 = "rummy_engine";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Set = global_data.Stdlib__Set,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Rummy_engine_Rules$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_rummy_engine$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/rules.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_rummy_engine$0, "rules.ml");
   var
    cst_rummy_engine = cst_rummy_engine$0,
    cst_Rummy_engine_Rules = cst_Rummy_engine_Rules$0;
   function all_same_rank(cs){
    if(cs){
     var c = cs[1];
     if(cs[2]){
      var rest = cs[2], _m_ = function(x){return x[2] === c[2] ? 1 : 0;};
      return caml_call2(Stdlib_List[33], _m_, rest);
     }
    }
    return 0;
   }
   function distinct_suits(cs){
    var
     compare = runtime.caml_compare,
     S = caml_call1(Stdlib_Set[1], [0, compare]),
     _j_ = S[1];
    function _k_(acc, c){return caml_call2(S[2], c[1], acc);}
    var
     s = caml_call3(Stdlib_List[26], _k_, _j_, cs),
     _l_ = caml_call1(Stdlib_List[1], cs);
    return caml_call1(S[9], s) === _l_ ? 1 : 0;
   }
   function rank_value(ace_policy, param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 5;
      case 4:
       return 6;
      case 5:
       return 7;
      case 6:
       return 8;
      case 7:
       return 9;
      case 8:
       return 10;
      case 9:
       return 11;
      case 10:
       return 12;
      case 11:
       return 13;
      default: return ace_policy ? 14 : 1;
    }
   }
   function is_consecutive_ints(param){
    var param$0 = param;
    for(;;){
     if(param$0){
      var match = param$0[2];
      if(match){
       var
        rest = match[2],
        b = match[1],
        a = param$0[1],
        _i_ = b === (a + 1 | 0) ? 1 : 0;
       if(! _i_) return _i_;
       var param$0 = [0, b, rest];
       continue;
      }
     }
     return 1;
    }
   }
   function is_set(cs){
    var _f_ = 3 <= caml_call1(Stdlib_List[1], cs) ? 1 : 0;
    if(_f_){
     var _g_ = all_same_rank(cs);
     if(_g_) return distinct_suits(cs);
     var _h_ = _g_;
    }
    else
     var _h_ = _f_;
    return _h_;
   }
   function is_run(ace_policy, cs){
    if(cs){
     var c = cs[1], _b_ = cs[2];
     if(_b_ && _b_[2]){
      var
       rest = cs[2],
       _c_ = function(x){return x[1] === c[1] ? 1 : 0;},
       same_suit = caml_call2(Stdlib_List[33], _c_, rest);
      if(! same_suit) return 0;
      var
       _d_ = function(x){return rank_value(ace_policy, x[2]);},
       _e_ = caml_call2(Stdlib_List[20], _d_, cs);
      return is_consecutive_ints
              (caml_call2(Stdlib_List[59], runtime.caml_int_compare, _e_));
     }
    }
    return 0;
   }
   function valid_meld(ace_policy, cards){
    var _a_ = is_set(cards);
    return _a_ ? _a_ : is_run(ace_policy, cards);
   }
   function can_layoff(ace_policy, c, m){
    return valid_meld(ace_policy, [0, c, m[2]]);
   }
   function deadwood_points(hand){return 0;}
   caml_call1(Ppx_inline_test_lib[7], cst_rummy_engine);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Rummy_engine_Rules);
   var
    Rummy_engine_Rules =
      [0,
       all_same_rank,
       distinct_suits,
       rank_value,
       is_consecutive_ints,
       is_set,
       is_run,
       valid_meld,
       can_layoff,
       deadwood_points];
   runtime.caml_register_global
    (13, Rummy_engine_Rules, cst_Rummy_engine_Rules$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Rummy_engine__Engine
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Rummy_engine__Rules, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Rummy_engine_Engine$0 = "Rummy_engine__Engine",
    cst_card_not_in_hand = "card not in hand",
    cst_cards_not_all_in_hand = "cards not all in hand",
    cst_invalid_meld_index = "invalid meld index",
    cst_meld_index_out_of_range = "meld index out of range",
    cst_rummy_engine$0 = "rummy_engine",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Rummy_engine_Rules = global_data.Rummy_engine__Rules,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Rummy_engine_Engine$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_rummy_engine$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/engine.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_rummy_engine$0, "engine.ml");
   var
    cst_last_exn_empty_list = "last_exn: empty list",
    _s_ = [2, [2, "You must use the required card before discarding."]],
    _t_ = [2, [2, cst_card_not_in_hand]],
    _r_ =
      [1,
       [1, "You must use the bottom picked discard card before discarding."]],
    _n_ = [2, 1],
    _o_ = [2, 0],
    _q_ = [2, [1, "N must be \xe2\x89\xa5 1"]],
    _p_ = [2, 1],
    _k_ = [1, [1, "cannot lay off on that meld"]],
    _j_ = [1, [1, cst_invalid_meld_index]],
    _l_ = [1, [1, cst_invalid_meld_index]],
    _m_ = [1, [1, "layoff card not in hand"]],
    _i_ = [1, [1, "run must have \xe2\x89\xa53 cards"]],
    _h_ = [1, [1, "not a valid run"]],
    _g_ = [1, [1, cst_cards_not_all_in_hand]],
    _f_ = [1, [1, "set must have \xe2\x89\xa53 cards"]],
    _e_ = [1, [1, "not a valid set"]],
    _d_ = [1, [1, cst_cards_not_all_in_hand]],
    _b_ = [1, cst_meld_index_out_of_range],
    _c_ = [1, cst_meld_index_out_of_range],
    _a_ = [1, cst_card_not_in_hand],
    cst_rummy_engine = cst_rummy_engine$0,
    cst_Rummy_engine_Engine = cst_Rummy_engine_Engine$0;
   function top_and_rest(param){
    if(! param) return 0;
    var xs = param[2], x = param[1];
    return [0, [0, x, xs]];
   }
   function with_current(st){
    var _H_ = st[5];
    return caml_check_bound(st[4], _H_)[1 + _H_];
   }
   function replace_current(st, p){
    var _G_ = st[5];
    caml_check_bound(st[4], _G_)[1 + _G_] = p;
    return st;
   }
   function next_player_index(st){
    return runtime.caml_mod(st[5] + 1 | 0, st[4].length - 1);
   }
   function take_n(n, rest){
    if(0 >= n) return [0, 0, rest];
    var k = n, acc = 0, rest$0 = rest;
    for(;;){
     if(0 === k) return [0, caml_call1(Stdlib_List[10], acc), rest$0];
     if(! rest$0) return [0, caml_call1(Stdlib_List[10], acc), 0];
     var
      rest$1 = rest$0[2],
      y = rest$0[1],
      acc$0 = [0, y, acc],
      k$0 = k - 1 | 0,
      k = k$0,
      acc = acc$0,
      rest$0 = rest$1;
    }
   }
   function last_exn(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return caml_call1(Stdlib[2], cst_last_exn_empty_list);
     var x = param$0[1];
     if(! param$0[2]) return x;
     var xs = param$0[2], param$0 = xs;
    }
   }
   function remove_one(hand, c){
    var acc = 0, param = hand;
    for(;;){
     if(! param) return _a_;
     var xs = param[2], x = param[1];
     if(caml_equal(x, c)) return [0, caml_call2(Stdlib_List[13], acc, xs)];
     var acc$0 = [0, x, acc], acc = acc$0, param = xs;
    }
   }
   function remove_many(hand, to_take){
    var _E_ = [0, hand];
    function _F_(acc, c){
     if(0 === acc[0]){var h = acc[1]; return remove_one(h, c);}
     var e = acc[1];
     return [1, e];
    }
    return caml_call3(Stdlib_List[26], _F_, _E_, to_take);
   }
   function replace_nth(xs, idx, x){
    if(0 > idx) return _c_;
    var i = idx, acc = 0, param = xs;
    for(;;){
     if(! param) return _b_;
     var y = param[1], xs$0 = param[2];
     if(0 === i){
      var _D_ = caml_call1(Stdlib_List[10], acc);
      return [0, caml_call2(Stdlib[37], _D_, [0, x, xs$0])];
     }
     var
      xs$1 = param[2],
      acc$0 = [0, y, acc],
      i$0 = i - 1 | 0,
      i = i$0,
      acc = acc$0,
      param = xs$1;
    }
   }
   function clear_required_if_used(st, used){
    var match = st[9];
    if(! match) return st;
    var r = match[1];
    function _B_(_C_){return caml_equal(r, _C_);}
    return caml_call2(Stdlib_List[34], _B_, used)
            ? [0,
              st[1],
              st[2],
              st[3],
              st[4],
              st[5],
              st[6],
              st[7],
              st[8],
              0,
              st[10]]
            : st;
   }
   function apply_make_set(cards, st){
    if(3 > caml_call1(Stdlib_List[1], cards)) return _f_;
    if(! caml_call1(Rummy_engine_Rules[5], cards)) return _e_;
    var p = with_current(st), match = remove_many(p[3], cards);
    if(0 !== match[0]) return _d_;
    var
     new_hand = match[1],
     meld = [0, 0, cards],
     p$0 = [0, p[1], p[2], new_hand],
     st$0 =
       replace_current
        ([0,
          st[1],
          st[2],
          [0, meld, st[3]],
          st[4],
          st[5],
          st[6],
          st[7],
          st[8],
          st[9],
          st[10]],
         p$0),
     st$1 = clear_required_if_used(st$0, cards);
    return [0, st$1];
   }
   function apply_make_run(cards, st){
    if(3 > caml_call1(Stdlib_List[1], cards)) return _i_;
    if(! caml_call2(Rummy_engine_Rules[6], st[7], cards)) return _h_;
    var p = with_current(st), match = remove_many(p[3], cards);
    if(0 !== match[0]) return _g_;
    var
     new_hand = match[1],
     meld = [0, 1, cards],
     p$0 = [0, p[1], p[2], new_hand],
     st$0 =
       replace_current
        ([0,
          st[1],
          st[2],
          [0, meld, st[3]],
          st[4],
          st[5],
          st[6],
          st[7],
          st[8],
          st[9],
          st[10]],
         p$0),
     st$1 = clear_required_if_used(st$0, cards);
    return [0, st$1];
   }
   function apply_layoff(param, st){
    var
     meld_idx = param[2],
     card = param[1],
     p = with_current(st),
     match = remove_one(p[3], card);
    if(0 !== match[0]) return _m_;
    var
     hand_after_pop = match[1],
     match$0 = caml_call2(Stdlib_List[9], st[3], meld_idx);
    if(! match$0) return _l_;
    var m = match$0[1];
    if(! caml_call3(Rummy_engine_Rules[8], st[7], card, m)) return _k_;
    var
     updated_meld = [0, m[1], [0, card, m[2]]],
     match$1 = replace_nth(st[3], meld_idx, updated_meld);
    if(0 !== match$1[0]) return _j_;
    var
     melds = match$1[1],
     p$0 = [0, p[1], p[2], hand_after_pop],
     st$0 =
       replace_current
        ([0,
          st[1],
          st[2],
          melds,
          st[4],
          st[5],
          st[6],
          st[7],
          st[8],
          st[9],
          st[10]],
         p$0),
     st$1 = clear_required_if_used(st$0, [0, card, 0]);
    return [0, st$1];
   }
   function draw(source, st){
    var ph = st[6];
    if(ph) return [2, [0, ph]];
    if(typeof source !== "number"){
     var n = source[1];
     if(0 >= n) return _q_;
     var match$3 = take_n(n, st[2]), rest$1 = match$3[2], taken = match$3[1];
     if(! taken) return _p_;
     var
      bottom = last_exn(taken),
      p$3 = with_current(st),
      _A_ = caml_call2(Stdlib_List[13], taken, p$3[3]),
      p$4 = [0, p$3[1], p$3[2], _A_],
      st$2 =
        replace_current
         ([0,
           st[1],
           rest$1,
           st[3],
           st[4],
           st[5],
           1,
           st[7],
           st[8],
           [0, bottom],
           st[10]],
          p$4);
     return [0, st$2];
    }
    if(source){
     var match = top_and_rest(st[2]);
     if(! match) return _n_;
     var
      match$0 = match[1],
      rest = match$0[2],
      card = match$0[1],
      p = with_current(st),
      p$0 = [0, p[1], p[2], [0, card, p[3]]],
      st$0 =
        replace_current
         ([0,
           st[1],
           rest,
           st[3],
           st[4],
           st[5],
           1,
           st[7],
           st[8],
           st[9],
           st[10]],
          p$0);
     return [0, st$0];
    }
    var match$1 = top_and_rest(st[1]);
    if(! match$1) return st[2] ? _o_ : [1, st];
    var
     match$2 = match$1[1],
     rest$0 = match$2[2],
     card$0 = match$2[1],
     p$1 = with_current(st),
     p$2 = [0, p$1[1], p$1[2], [0, card$0, p$1[3]]],
     st$1 =
       replace_current
        ([0,
          rest$0,
          st[2],
          st[3],
          st[4],
          st[5],
          1,
          st[7],
          st[8],
          st[9],
          st[10]],
         p$2);
    return [0, st$1];
   }
   function play(action, st){
    var ph = st[6];
    if(1 !== ph) return [2, [0, ph]];
    if(typeof action === "number")
     var
      _z_ =
        st[9]
         ? _r_
         : [0,
           [0,
            st[1],
            st[2],
            st[3],
            st[4],
            st[5],
            2,
            st[7],
            st[8],
            st[9],
            st[10]]],
      res = _z_;
    else
     switch(action[0]){
       case 0:
        var cs = action[1], res = apply_make_set(cs, st); break;
       case 1:
        var cs$0 = action[1], res = apply_make_run(cs$0, st); break;
       default:
        var
         idx = action[2],
         card = action[1],
         res = apply_layoff([0, card, idx], st);
     }
    if(0 === res[0]){var st$0 = res[1]; return [0, st$0];}
    var e = res[1];
    return [2, e];
   }
   function discard(action, st){
    var ph = st[6];
    if(2 !== ph) return [2, [0, ph]];
    if(st[9]) return _s_;
    var c = action[1], p = with_current(st), match = remove_one(p[3], c);
    if(0 !== match[0]) return _t_;
    var
     new_hand = match[1],
     p$0 = [0, p[1], p[2], new_hand],
     st$0 =
       replace_current
        ([0,
          st[1],
          [0, c, st[2]],
          st[3],
          st[4],
          st[5],
          3,
          st[7],
          st[8],
          st[9],
          st[10]],
         p$0);
    return [0, st$0];
   }
   function endcheck(st){
    var ph = st[6];
    if(3 > ph) return [2, [0, ph]];
    var p = with_current(st);
    if(0 === p[3]) return [1, st];
    var
     _u_ = st[10],
     _v_ = st[9],
     _w_ = st[8],
     _x_ = st[7],
     _y_ = next_player_index(st),
     st$0 = [0, st[1], st[2], st[3], st[4], _y_, 0, _x_, _w_, _v_, _u_];
    return [0, st$0];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_rummy_engine);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Rummy_engine_Engine);
   var
    Rummy_engine_Engine =
      [0,
       top_and_rest,
       with_current,
       replace_current,
       next_player_index,
       take_n,
       last_exn,
       remove_one,
       remove_many,
       replace_nth,
       clear_required_if_used,
       apply_make_set,
       apply_make_run,
       apply_layoff,
       draw,
       play,
       discard,
       endcheck];
   runtime.caml_register_global
    (35, Rummy_engine_Engine, cst_Rummy_engine_Engine$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Rummy_engine__Ai
//# unitInfo: Requires: Base__Random, Core, Core__Array, Core__Float, Core__List, Core__Option, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Rummy_engine__Engine
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Rummy_engine_Ai$0 = "Rummy_engine__Ai",
    cst_rummy_engine$0 = "rummy_engine",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    skip = [0, 0, 0],
    from_deck = [0, 0, 0],
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Core_Float = global_data.Core__Float,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_Array = global_data.Core__Array,
    Core_Option = global_data.Core__Option,
    Rummy_engine_Engine = global_data.Rummy_engine__Engine,
    Base_Random = global_data.Base__Random,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Rummy_engine_Ai$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_rummy_engine$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/ai.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_rummy_engine$0, "ai.ml");
   var
    _a_ = [0, 0, 0],
    _e_ = [0, 0, 0],
    _d_ = [0, 0, 0],
    _c_ = [0, 0, 0],
    _b_ = [0, 1, 0],
    cst_rummy_engine = cst_rummy_engine$0,
    cst_Rummy_engine_Ai = cst_Rummy_engine_Ai$0;
   function choose_random(rng, xs){
    if(! xs) return 0;
    var
     _au_ = caml_call1(Core_List[45], xs),
     _av_ = caml_call2(Base_Random[19][7], rng, _au_);
    return [0, caml_call2(Core_List[58], xs, _av_)];
   }
   function combinations_k(k, xs){
    if(caml_call2(Core[90], k, 0)) return _a_;
    if(! xs) return 0;
    var ys = xs[2], y = xs[1];
    function _as_(rest){return [0, y, rest];}
    var
     _at_ = combinations_k(k - 1 | 0, ys),
     with_y = caml_call2(Core_List[51], _at_, _as_),
     without = combinations_k(k, ys);
    return caml_call2(Core[156], with_y, without);
   }
   function all_3plus_combos(hand){
    var n = caml_call1(Core_List[45], hand);
    function _aq_(k){return combinations_k(k, hand);}
    var _ar_ = caml_call5(Core_List[128], 0, 0, 0, 3, n + 1 | 0);
    return caml_call2(Core_List[14], _ar_, _aq_);
   }
   function apply_draw(source, st){
    var match = caml_call2(Rummy_engine_Engine[14], source, st);
    if(2 === match[0]) return 0;
    var st$0 = match[1];
    return [0, st$0];
   }
   function apply_play(action, st){
    var match = caml_call2(Rummy_engine_Engine[15], action, st);
    if(2 === match[0]) return 0;
    var st$0 = match[1];
    return [0, st$0];
   }
   function apply_discard(card, st){
    var match = caml_call2(Rummy_engine_Engine[16], [0, card], st);
    if(2 === match[0]) return 0;
    var st$0 = match[1];
    return [0, st$0];
   }
   function apply_endcheck(st){
    var match = caml_call1(Rummy_engine_Engine[17], st);
    if(2 === match[0]) return 0;
    var st$0 = match[1];
    return [0, st$0];
   }
   function candidate_draws(st){
    var
     from_discard1 = caml_call1(Core_List[18], st[2]) ? 0 : _b_,
     len = caml_call1(Core_List[45], st[2]);
    if(caml_call2(Core[89], len, 1))
     var from_discardN = 0;
    else
     var
      _ap_ = function(i){return [0, i + 1 | 0];},
      from_discardN = caml_call2(Core_List[40], len, _ap_);
    var _ao_ = caml_call2(Core[156], from_discard1, from_discardN);
    return caml_call2(Core[156], from_deck, _ao_);
   }
   function candidate_plays(st){
    var _af_ = st[5], p = caml_check_bound(st[4], _af_)[1 + _af_];
    function _ag_(cs){return [0, cs];}
    var
     _ah_ = all_3plus_combos(p[3]),
     set_actions = caml_call2(Core_List[51], _ah_, _ag_);
    function _ai_(cs){return [1, cs];}
    var
     _aj_ = all_3plus_combos(p[3]),
     run_actions = caml_call2(Core_List[51], _aj_, _ai_),
     mcount = caml_call1(Core_List[45], st[3]);
    function _ak_(c){
     function _an_(mi){return [2, c, mi];}
     return caml_call2(Core_List[40], mcount, _an_);
    }
    var
     lay_actions = caml_call2(Core_List[14], p[3], _ak_),
     _al_ = caml_call2(Core[156], lay_actions, skip),
     _am_ = caml_call2(Core[156], run_actions, _al_);
    return caml_call2(Core[156], set_actions, _am_);
   }
   function candidate_discards(st){
    var _ae_ = st[5], p = caml_check_bound(st[4], _ae_)[1 + _ae_];
    return p[3];
   }
   function legalize_draws(st){
    function _aa_(src){
     function _ac_(param){return src;}
     var _ad_ = apply_draw(src, st);
     return caml_call2(Core_Option[34], _ad_, _ac_);
    }
    var _ab_ = candidate_draws(st);
    return caml_call2(Core_List[13], _ab_, _aa_);
   }
   function legalize_plays(st){
    function _Y_(act){
     function ___(param){return act;}
     var _$_ = apply_play(act, st);
     return caml_call2(Core_Option[34], _$_, ___);
    }
    var _Z_ = candidate_plays(st);
    return caml_call2(Core_List[13], _Z_, _Y_);
   }
   function legalize_discards(st){
    function _U_(c){
     function _W_(param){return c;}
     var _X_ = apply_discard(c, st);
     return caml_call2(Core_Option[34], _X_, _W_);
    }
    var _V_ = candidate_discards(st);
    return caml_call2(Core_List[13], _V_, _U_);
   }
   function random_ai(rng, st){
    switch(st[6]){
      case 0:
       var
        draws = legalize_draws(st),
        _O_ = function(src){return apply_draw(src, st);},
        _P_ = choose_random(rng, draws);
       return caml_call2(Core_Option[32], _P_, _O_);
      case 1:
       var
        plays = legalize_plays(st),
        _Q_ = function(act){return apply_play(act, st);},
        _R_ = choose_random(rng, plays);
       return caml_call2(Core_Option[32], _R_, _Q_);
      case 2:
       var
        discards = legalize_discards(st),
        _S_ = function(c){return apply_discard(c, st);},
        _T_ = choose_random(rng, discards);
       return caml_call2(Core_Option[32], _T_, _S_);
      default: return apply_endcheck(st);
    }
   }
   function simulate_to_end(rng, pol0, pol1, st0){
    var steps = 20000, st = st0;
    for(;;){
     if(caml_call2(Core[89], steps, 0)) return st[5];
     var
      current = st[5],
      pol = caml_call2(Core[90], current, 0) ? pol0 : pol1,
      match = caml_call2(pol, rng, st);
     if(match){
      var
       st$0 = match[1],
       _K_ = caml_check_bound(st$0[4], 0)[1][3],
       empty0 = caml_call1(Core_List[18], _K_),
       _L_ = caml_check_bound(st$0[4], 1)[2][3],
       empty1 = caml_call1(Core_List[18], _L_);
      if(empty0 && ! empty1) return 0;
      if(empty1 && ! empty0) return 1;
      var steps$0 = steps - 1 | 0, steps = steps$0, st = st$0;
     }
     else{
      var match$0 = apply_endcheck(st);
      if(! match$0) return current;
      var
       st$1 = match$0[1],
       _M_ = caml_check_bound(st$1[4], 0)[1][3],
       empty0$0 = caml_call1(Core_List[18], _M_),
       _N_ = caml_check_bound(st$1[4], 1)[2][3],
       empty1$0 = caml_call1(Core_List[18], _N_);
      if(empty0$0 && ! empty1$0) return 0;
      if(empty1$0 && ! empty0$0) return 1;
      var steps$1 = steps - 1 | 0, steps = steps$1, st = st$1;
     }
    }
   }
   function timed_pick_draw(rng, st, choices, opponent, time_ms){
    if(! choices) return 0;
    var
     _B_ = caml_call1(Core_Time_ns[1][117], time_ms),
     _C_ = caml_call1(Core_Time_ns[66], 0),
     deadline = caml_call2(Core_Time_ns[67], _C_, _B_);
    function _D_(param){return _c_;}
    var
     _E_ = caml_call2(Core_List[51], choices, _D_),
     scores = caml_call1(Core_Array[24], _E_),
     i_ref = [0, 0];
    for(;;){
     var _F_ = caml_call1(Core_Time_ns[66], 0);
     if(! caml_call2(Core_Time_ns[19], _F_, deadline)){
      var
       _G_ =
         function(i, param, _H_){
          var
           n = _H_[2],
           w = _H_[1],
           best_score = param[2],
           best_i = param[1];
          if(caml_call2(Core[90], n, 0))
           var score = Core_Float[15];
          else
           var
            _I_ = caml_call1(Core_Float[33], n),
            _J_ = caml_call1(Core_Float[33], w),
            score = caml_call2(Core_Float[71], _J_, _I_);
          return caml_call2(Core_Float[129], score, best_score)
                  ? [0, i, score]
                  : [0, best_i, best_score];
         },
       best_i =
         caml_call3(Core_Array[49], scores, [0, 0, Core_Float[15]], _G_)[1];
      return apply_draw(caml_call2(Core_List[58], choices, best_i), st);
     }
     var i = i_ref[1];
     i_ref[1] = caml_call2(Core[237], i + 1 | 0, scores.length - 1);
     var
      src = caml_call2(Core_List[58], choices, i),
      match = apply_draw(src, st);
     if(match){
      var
       st_after = match[1],
       us = st[5],
       winner =
         caml_call2(Core[90], us, 0)
          ? simulate_to_end(rng, random_ai, opponent, st_after)
          : simulate_to_end(rng, opponent, random_ai, st_after),
       match$0 = caml_check_bound(scores, i)[1 + i],
       n = match$0[2],
       w = match$0[1],
       w$0 = caml_call2(Core[90], winner, us) ? w + 1 | 0 : w;
      caml_check_bound(scores, i)[1 + i] = [0, w$0, n + 1 | 0];
     }
    }
   }
   function timed_pick_play(rng, st, choices, opponent, time_ms){
    if(! choices) return 0;
    var
     _s_ = caml_call1(Core_Time_ns[1][117], time_ms),
     _t_ = caml_call1(Core_Time_ns[66], 0),
     deadline = caml_call2(Core_Time_ns[67], _t_, _s_);
    function _u_(param){return _d_;}
    var
     _v_ = caml_call2(Core_List[51], choices, _u_),
     scores = caml_call1(Core_Array[24], _v_),
     i_ref = [0, 0];
    for(;;){
     var _w_ = caml_call1(Core_Time_ns[66], 0);
     if(! caml_call2(Core_Time_ns[19], _w_, deadline)){
      var
       _x_ =
         function(i, param, _y_){
          var
           n = _y_[2],
           w = _y_[1],
           best_score = param[2],
           best_i = param[1];
          if(caml_call2(Core[90], n, 0))
           var score = Core_Float[15];
          else
           var
            _z_ = caml_call1(Core_Float[33], n),
            _A_ = caml_call1(Core_Float[33], w),
            score = caml_call2(Core_Float[71], _A_, _z_);
          return caml_call2(Core_Float[129], score, best_score)
                  ? [0, i, score]
                  : [0, best_i, best_score];
         },
       best_i =
         caml_call3(Core_Array[49], scores, [0, 0, Core_Float[15]], _x_)[1];
      return apply_play(caml_call2(Core_List[58], choices, best_i), st);
     }
     var i = i_ref[1];
     i_ref[1] = caml_call2(Core[237], i + 1 | 0, scores.length - 1);
     var
      act = caml_call2(Core_List[58], choices, i),
      match = apply_play(act, st);
     if(match){
      var
       st_after = match[1],
       us = st[5],
       winner =
         caml_call2(Core[90], us, 0)
          ? simulate_to_end(rng, random_ai, opponent, st_after)
          : simulate_to_end(rng, opponent, random_ai, st_after),
       match$0 = caml_check_bound(scores, i)[1 + i],
       n = match$0[2],
       w = match$0[1],
       w$0 = caml_call2(Core[90], winner, us) ? w + 1 | 0 : w;
      caml_check_bound(scores, i)[1 + i] = [0, w$0, n + 1 | 0];
     }
    }
   }
   function timed_pick_discard(rng, st, choices, opponent, time_ms){
    if(! choices) return 0;
    var
     _j_ = caml_call1(Core_Time_ns[1][117], time_ms),
     _k_ = caml_call1(Core_Time_ns[66], 0),
     deadline = caml_call2(Core_Time_ns[67], _k_, _j_);
    function _l_(param){return _e_;}
    var
     _m_ = caml_call2(Core_List[51], choices, _l_),
     scores = caml_call1(Core_Array[24], _m_),
     i_ref = [0, 0];
    for(;;){
     var _n_ = caml_call1(Core_Time_ns[66], 0);
     if(! caml_call2(Core_Time_ns[19], _n_, deadline)){
      var
       _o_ =
         function(i, param, _p_){
          var
           n = _p_[2],
           w = _p_[1],
           best_score = param[2],
           best_i = param[1];
          if(caml_call2(Core[90], n, 0))
           var score = Core_Float[15];
          else
           var
            _q_ = caml_call1(Core_Float[33], n),
            _r_ = caml_call1(Core_Float[33], w),
            score = caml_call2(Core_Float[71], _r_, _q_);
          return caml_call2(Core_Float[129], score, best_score)
                  ? [0, i, score]
                  : [0, best_i, best_score];
         },
       best_i =
         caml_call3(Core_Array[49], scores, [0, 0, Core_Float[15]], _o_)[1];
      return apply_discard(caml_call2(Core_List[58], choices, best_i), st);
     }
     var i = i_ref[1];
     i_ref[1] = caml_call2(Core[237], i + 1 | 0, scores.length - 1);
     var
      c = caml_call2(Core_List[58], choices, i),
      match = apply_discard(c, st);
     if(match){
      var
       st_after = match[1],
       us = st[5],
       winner =
         caml_call2(Core[90], us, 0)
          ? simulate_to_end(rng, random_ai, opponent, st_after)
          : simulate_to_end(rng, opponent, random_ai, st_after),
       match$0 = caml_check_bound(scores, i)[1 + i],
       n = match$0[2],
       w = match$0[1],
       w$0 = caml_call2(Core[90], winner, us) ? w + 1 | 0 : w;
      caml_check_bound(scores, i)[1 + i] = [0, w$0, n + 1 | 0];
     }
    }
   }
   function timed_ai(opt, opponent, rng, st){
    if(opt) var sth = opt[1], time_ms = sth; else var time_ms = 2000;
    switch(st[6]){
      case 0:
       var cands = legalize_draws(st);
       return timed_pick_draw(rng, st, cands, opponent, time_ms);
      case 1:
       var cands$0 = legalize_plays(st);
       return timed_pick_play(rng, st, cands$0, opponent, time_ms);
      case 2:
       var cands$1 = legalize_discards(st);
       return timed_pick_discard(rng, st, cands$1, opponent, time_ms);
      default: return apply_endcheck(st);
    }
   }
   function simulate_game(rng, p0, p1, st0){
    var steps = 50000, st = st0, max_steps = 50000;
    for(;;){
     if(caml_call2(Core[89], steps, 0)) return [0, st[5], max_steps];
     var
      cur = st[5],
      pol = caml_call2(Core[90], cur, 0) ? p0 : p1,
      match = caml_call2(pol, rng, st);
     if(match){
      var
       st$0 = match[1],
       _h_ = caml_check_bound(st$0[4], 0)[1][3],
       empty0 = caml_call1(Core_List[18], _h_),
       _i_ = caml_check_bound(st$0[4], 1)[2][3],
       empty1 = caml_call1(Core_List[18], _i_);
      if(empty0 && ! empty1) return [0, 0, (50000 - steps | 0) + 1 | 0];
      if(empty1 && ! empty0) return [0, 1, (50000 - steps | 0) + 1 | 0];
      var steps$0 = steps - 1 | 0, steps = steps$0, st = st$0;
     }
     else{
      var match$0 = apply_endcheck(st);
      if(! match$0) return [0, cur, 50000 - steps | 0];
      var
       st$1 = match$0[1],
       steps$1 = steps - 1 | 0,
       steps = steps$1,
       st = st$1;
     }
    }
   }
   function simulate_games(rng, games, mk_initial, p0, p1){
    var wins0 = [0, 0], wins1 = [0, 0], _f_ = 1;
    if(games >= 1){
     var for$0 = _f_;
     for(;;){
      var
       st0 = caml_call1(mk_initial, 0),
       r = simulate_game(rng, p0, p1, st0);
      if(caml_call2(Core[90], r[1], 0)) wins0[1]++; else wins1[1]++;
      var _g_ = for$0 + 1 | 0;
      if(games === for$0) break;
      var for$0 = _g_;
     }
    }
    return [0, wins0[1], wins1[1]];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_rummy_engine);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Rummy_engine_Ai);
   var
    Rummy_engine_Ai =
      [0,
       choose_random,
       combinations_k,
       all_3plus_combos,
       apply_draw,
       apply_play,
       apply_discard,
       apply_endcheck,
       candidate_draws,
       candidate_plays,
       candidate_discards,
       legalize_draws,
       legalize_plays,
       legalize_discards,
       random_ai,
       simulate_to_end,
       timed_pick_draw,
       timed_pick_play,
       timed_pick_discard,
       timed_ai,
       simulate_game,
       simulate_games];
   runtime.caml_register_global(26, Rummy_engine_Ai, cst_Rummy_engine_Ai$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIucnVtbXlfZW5naW5lLm9ianMvanNvby9kZWZhdWx0L3J1bW15X2VuZ2luZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic3RyaW5nX29mX3N1aXQiLCJzdHJpbmdfb2ZfcmFuayIsInN0cmluZ19vZl9jYXJkIiwiYyIsInN1aXRzIiwicmFua3MiLCJzIiwiciIsImFsbF9jYXJkcyIsInNodWZmbGUiLCJ4cyIsIngiLCJiIiwiYSIsImRlYWxfbiIsIm4iLCJkZWNrIiwiayIsImFjYyIsImQiLCJhY2MkMCIsImskMCIsImluaXRfc3RhdGUiLCJudW1fcGxheWVycyIsInZzX2NvbXB1dGVyIiwiZGVjazAiLCJkZWNrX2FmdGVyIiwiaGFuZF9zaXplIiwiaGFuZHMiLCJpIiwiaCIsInBsYXllcnMiLCJhbGxfc2FtZV9yYW5rIiwiY3MiLCJyZXN0IiwiZGlzdGluY3Rfc3VpdHMiLCJjb21wYXJlIiwicmFua192YWx1ZSIsImFjZV9wb2xpY3kiLCJpc19jb25zZWN1dGl2ZV9pbnRzIiwiaXNfc2V0IiwiaXNfcnVuIiwic2FtZV9zdWl0IiwidmFsaWRfbWVsZCIsImNhcmRzIiwiY2FuX2xheW9mZiIsIm0iLCJkZWFkd29vZF9wb2ludHMiLCJoYW5kIiwidG9wX2FuZF9yZXN0Iiwid2l0aF9jdXJyZW50Iiwic3QiLCJyZXBsYWNlX2N1cnJlbnQiLCJwIiwibmV4dF9wbGF5ZXJfaW5kZXgiLCJ0YWtlX24iLCJyZXN0JDAiLCJyZXN0JDEiLCJ5IiwibGFzdF9leG4iLCJyZW1vdmVfb25lIiwicmVtb3ZlX21hbnkiLCJ0b190YWtlIiwiZSIsInJlcGxhY2VfbnRoIiwiaWR4IiwieHMkMCIsInhzJDEiLCJjbGVhcl9yZXF1aXJlZF9pZl91c2VkIiwidXNlZCIsImFwcGx5X21ha2Vfc2V0IiwibmV3X2hhbmQiLCJtZWxkIiwicCQwIiwic3QkMCIsInN0JDEiLCJhcHBseV9tYWtlX3J1biIsImFwcGx5X2xheW9mZiIsIm1lbGRfaWR4IiwiY2FyZCIsImhhbmRfYWZ0ZXJfcG9wIiwidXBkYXRlZF9tZWxkIiwibWVsZHMiLCJkcmF3Iiwic291cmNlIiwicGgiLCJ0YWtlbiIsImJvdHRvbSIsInAkMyIsInAkNCIsInN0JDIiLCJjYXJkJDAiLCJwJDEiLCJwJDIiLCJwbGF5IiwiYWN0aW9uIiwicmVzIiwiY3MkMCIsImRpc2NhcmQiLCJlbmRjaGVjayIsInNraXAiLCJmcm9tX2RlY2siLCJjaG9vc2VfcmFuZG9tIiwicm5nIiwiY29tYmluYXRpb25zX2siLCJ5cyIsIndpdGhfeSIsIndpdGhvdXQiLCJhbGxfM3BsdXNfY29tYm9zIiwiYXBwbHlfZHJhdyIsImFwcGx5X3BsYXkiLCJhcHBseV9kaXNjYXJkIiwiYXBwbHlfZW5kY2hlY2siLCJjYW5kaWRhdGVfZHJhd3MiLCJmcm9tX2Rpc2NhcmQxIiwibGVuIiwiZnJvbV9kaXNjYXJkTiIsImNhbmRpZGF0ZV9wbGF5cyIsInNldF9hY3Rpb25zIiwicnVuX2FjdGlvbnMiLCJtY291bnQiLCJtaSIsImxheV9hY3Rpb25zIiwiY2FuZGlkYXRlX2Rpc2NhcmRzIiwibGVnYWxpemVfZHJhd3MiLCJzcmMiLCJsZWdhbGl6ZV9wbGF5cyIsImFjdCIsImxlZ2FsaXplX2Rpc2NhcmRzIiwicmFuZG9tX2FpIiwiZHJhd3MiLCJwbGF5cyIsImRpc2NhcmRzIiwic2ltdWxhdGVfdG9fZW5kIiwicG9sMCIsInBvbDEiLCJzdDAiLCJzdGVwcyIsImN1cnJlbnQiLCJwb2wiLCJlbXB0eTAiLCJlbXB0eTEiLCJzdGVwcyQwIiwiZW1wdHkwJDAiLCJlbXB0eTEkMCIsInN0ZXBzJDEiLCJ0aW1lZF9waWNrX2RyYXciLCJjaG9pY2VzIiwib3Bwb25lbnQiLCJ0aW1lX21zIiwiZGVhZGxpbmUiLCJzY29yZXMiLCJpX3JlZiIsInciLCJiZXN0X3Njb3JlIiwiYmVzdF9pIiwic2NvcmUiLCJzdF9hZnRlciIsInVzIiwid2lubmVyIiwidyQwIiwidGltZWRfcGlja19wbGF5IiwidGltZWRfcGlja19kaXNjYXJkIiwidGltZWRfYWkiLCJvcHQiLCJzdGgiLCJjYW5kcyIsImNhbmRzJDAiLCJjYW5kcyQxIiwic2ltdWxhdGVfZ2FtZSIsInAwIiwicDEiLCJtYXhfc3RlcHMiLCJjdXIiLCJzaW11bGF0ZV9nYW1lcyIsImdhbWVzIiwibWtfaW5pdGlhbCIsIndpbnMwIiwid2luczEiXSwic291cmNlcyI6WyIvd29ya3NwYWNlX3Jvb3Qvc3JjL3R5cGVzLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9zZXR1cC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvcnVsZXMubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2VuZ2luZS5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvYWkubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBOERJQTtJQUFpQjs7T0FDUDs7T0FBa0I7O09BQW9CO2VBQWlCOztHQUFLO1lBRXRFQztJQUFpQjs7T0FDWjs7T0FBVzs7T0FBVTs7T0FBVTs7T0FBUzs7T0FBVzs7T0FDakQ7O09BQVU7O09BQVM7O09BQVc7O09BQVc7O09BQVU7ZUFBUzs7R0FBRztZQUV0RUMsZUFBZUM7SUFBSSxJQUE4QyxNQVBqRUgsZUFPZUcsT0FBMEIsTUFKekNGLGVBSWVFO0lBQWtELE9BQUE7R0FBdUI7Ozs7Ozs2QkFQeEZILGdCQUdBQyxnQkFJQUM7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0lDakVFRTtJQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBR2lCQztpQkFBbUJDLEdBQUssV0FBeEJELEdBQW1CQyxHQUEyQjtJQUFuRSxPQUFBLGlDQUhJRjtHQUdzRTtHQUExRSxJQUxFRyxZQUtGLGlDQUpJSjtZQU1GSyxRQUFTQztJQUNYO2lCQUNjQyxHQUFLLFdBQUMsaUNBQU5BLEdBQXdCO0lBQXRDLFVBQUEsaUNBRldEOztLQUdFLElBQWFFLFlBQVBDO3FDQUFBQSxHQUFPRDtJQUFxQjtJQUQvQyxVQUFBO3NCO0lBQUEsT0FB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QUFMLGVBQUFBLFFBQUFLLFNBQU0zRixLQUFBdUI7OztNQWNKLGNBbFJic0MsZUFvUWlCN0Q7b0JBZ0JJLFdBWmYwSCxhQUpLcEM7TUFlVTtPQWZKOUQ7T0FBTnNFLFVBQUFSO09BQUFBLFFBQUFRO09BQU05RixLQUFBd0I7OztHQWtCRDtZQUVoQm1HLGVBQ0V2RSxLQUNBd0UsT0FDQUMsWUFDQU4sSUFDQUM7SUFHSixJQUFJTSxnQkFDQUMsZ0JBQVE7T0FQUkg7OztNQVNRO09BQU52QyxNQUFNLFdBUlJ3QztPQVNFekssSUF4Q0prSyxjQTZCRWxFLEtBR0FtRSxJQUNBQyxJQU1FbkM7TUFFRCxHQUFBLHFCQURDakksVUFKRjBLLGlCQUNBQztNQUNKO1NBUklIOzs7O0lBYUosV0FQSUUsVUFDQUM7R0FNWTs7Ozs7Ozs7T0ExVWQ1RTtPQUtJRTtPQVVKSTtPQUtBQztPQUtBQztPQUtBQztPQUtBQztPQVNBQztPQVVBSTtPQWdCQU07T0FLQUM7T0FLQUU7T0FLQUU7T0FZQUM7T0FpQkFJO09BbUNBYTtPQXNDQWU7T0FzQ0FDO09Bc0NBQztPQXdCQU07T0E0QkFLOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIHR5cGVzLm1sICopXG5cbigqID09PT09PT09IENhcmRzLCBQbGF5ZXJzLCBNZWxkcyA9PT09PT09PSAqKVxuXG50eXBlIHN1aXQgPSBIZWFydHMgfCBTcGFkZXMgfCBEaWFtb25kcyB8IENsdWJzXG5cbnR5cGUgcmFuayA9XG4gIHwgVHdvIHwgVGhyZWUgfCBGb3VyIHwgRml2ZSB8IFNpeCB8IFNldmVuXG4gIHwgRWlnaHQgfCBOaW5lIHwgVGVuIHwgSmFjayB8IFF1ZWVuIHwgS2luZyB8IEFjZVxuXG50eXBlIGNhcmQgPSB7IHN1aXQgOiBzdWl0OyByYW5rIDogcmFuayB9XG5cbnR5cGUgbWVsZF9raW5kID0gU2V0IHwgUnVuXG50eXBlIG1lbGQgPSB7IGtpbmQgOiBtZWxkX2tpbmQ7IGNhcmRzIDogY2FyZCBsaXN0IH1cblxudHlwZSBwbGF5ZXIgPSB7XG4gIGlkIDogaW50O1xuICBuYW1lIDogc3RyaW5nO1xuICBoYW5kIDogY2FyZCBsaXN0O1xufVxuXG4oKiA9PT09PT09PSBDb25maWcgLyBQb2xpY3kgPT09PT09PT0gKilcblxudHlwZSBhY2VfcG9saWN5ID0gTG93IHwgSGlnaFxudHlwZSBzY29yaW5nID0ge1xuICBkZWFkd29vZF90aHJlc2hvbGQgOiBpbnQgb3B0aW9uO1xufVxuXG4oKiA9PT09PT09PSBUdXJuIFBoYXNlcyAmIEFjdGlvbnMgPT09PT09PT0gKilcblxudHlwZSBwaGFzZSA9IERyYXcgfCBQbGF5IHwgRGlzY2FyZCB8IEVuZENoZWNrXG5cbnR5cGUgcGxheV9hY3Rpb24gPVxuICB8IE1ha2Vfc2V0IG9mIGNhcmQgbGlzdFxuICB8IE1ha2VfcnVuIG9mIGNhcmQgbGlzdFxuICB8IExheV9vZmYgb2YgY2FyZCAqIGludCAgICgqIGNhcmQsIG1lbGQgaW5kZXggKilcbiAgfCBTa2lwX3RvX2Rpc2NhcmRcblxudHlwZSBkaXNjYXJkX2FjdGlvbiA9IERpc2NhcmRfY2FyZCBvZiBjYXJkXG5cbigqID09PT09PT09IFdob2xlIEdhbWUgU3RhdGUgPT09PT09PT0gKilcblxudHlwZSBkcmF3X3NvdXJjZSA9XG4gIHwgRnJvbURlY2tcbiAgfCBGcm9tRGlzY2FyZFxuICB8IEZyb21EaXNjYXJkTiBvZiBpbnRcblxudHlwZSBzdGF0ZSA9IHtcbiAgZGVjayA6IGNhcmQgbGlzdDtcbiAgZGlzY2FyZCA6IGNhcmQgbGlzdDtcbiAgbWVsZHMgOiBtZWxkIGxpc3Q7XG4gIHBsYXllcnMgOiBwbGF5ZXIgYXJyYXk7XG4gIGN1cnJlbnQgOiBpbnQ7XG4gIHBoYXNlIDogcGhhc2U7XG4gIGFjZV9wb2xpY3kgOiBhY2VfcG9saWN5O1xuICBzY29yaW5nIDogc2NvcmluZztcbiAgcmVxdWlyZWRfdG9fdXNlIDogY2FyZCBvcHRpb247XG4gIHNjb3JlcyA6IGludCBhcnJheTtcbn1cblxuKCogPT09PT09PT0gUHJldHR5IGhlbHBlcnMgPT09PT09PT0gKilcblxubGV0IHN0cmluZ19vZl9zdWl0ID0gZnVuY3Rpb25cbiAgfCBIZWFydHMgLT4gXCLimaVcIiB8IFNwYWRlcyAtPiBcIuKZoFwiIHwgRGlhbW9uZHMgLT4gXCLimaZcIiB8IENsdWJzIC0+IFwi4pmjXCJcblxubGV0IHN0cmluZ19vZl9yYW5rID0gZnVuY3Rpb25cbiAgfCBUd28tPlwiMlwifFRocmVlLT5cIjNcInxGb3VyLT5cIjRcInxGaXZlLT5cIjVcInxTaXgtPlwiNlwifFNldmVuLT5cIjdcIlxuICB8IEVpZ2h0LT5cIjhcInxOaW5lLT5cIjlcInxUZW4tPlwiMTBcInxKYWNrLT5cIkpcInxRdWVlbi0+XCJRXCJ8S2luZy0+XCJLXCJ8QWNlLT5cIkFcIlxuXG5sZXQgc3RyaW5nX29mX2NhcmQgYyA9IFByaW50Zi5zcHJpbnRmIFwiJXMlc1wiIChzdHJpbmdfb2ZfcmFuayBjLnJhbmspIChzdHJpbmdfb2Zfc3VpdCBjLnN1aXQpIiwiKCogc3JjL3NldHVwLm1sICopXG5vcGVuIFR5cGVzXG5cbmxldCBhbGxfY2FyZHMgOiBjYXJkIGxpc3QgPVxuICBsZXQgc3VpdHMgPSBbSGVhcnRzOyBTcGFkZXM7IERpYW1vbmRzOyBDbHVic10gaW5cbiAgbGV0IHJhbmtzID1cbiAgICBbIFR3bzsgVGhyZWU7IEZvdXI7IEZpdmU7IFNpeDsgU2V2ZW47IEVpZ2h0OyBOaW5lOyBUZW47IEphY2s7IFF1ZWVuOyBLaW5nOyBBY2UgXVxuICBpblxuICBMaXN0LmNvbmNhdF9tYXAgKGZ1biBzIC0+IExpc3QubWFwIChmdW4gciAtPiB7IHN1aXQgPSBzOyByYW5rID0gciB9KSByYW5rcykgc3VpdHNcblxubGV0IHNodWZmbGUgKHhzIDogJ2EgbGlzdCkgOiAnYSBsaXN0ID1cbiAgUmFuZG9tLnNlbGZfaW5pdCAoKTtcbiAgTGlzdC5tYXAgKGZ1biB4IC0+IChSYW5kb20uYml0cyAoKSwgeCkpIHhzXG4gIHw+IExpc3Quc29ydCAoZnVuIChhLCBfKSAoYiwgXykgLT4gY29tcGFyZSBhIGIpXG4gIHw+IExpc3QubWFwIHNuZFxuXG5sZXQgZGVhbF9uIG4gZGVjayA9XG4gIGxldCByZWMgdGFrZSBrIGFjYyBkID1cbiAgICBpZiBrID0gMCB0aGVuIChMaXN0LnJldiBhY2MsIGQpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFtdIC0+IChMaXN0LnJldiBhY2MsIFtdKVxuICAgICAgfCB4IDo6IHhzIC0+IHRha2UgKGsgLSAxKSAoeCA6OiBhY2MpIHhzXG4gIGluXG4gIHRha2UgbiBbXSBkZWNrXG5cbmxldCBpbml0X3N0YXRlIChudW1fcGxheWVycyA6IGludCkgfih2c19jb21wdXRlciA6IGJvb2wpIDogc3RhdGUgPVxuICBsZXQgaGFuZF9zaXplID0gNyBpblxuICBsZXQgcmVjIGRlYWxfa19oYW5kcyBrIGRlY2sgYWNjID1cbiAgICBpZiBrID0gMCB0aGVuIChMaXN0LnJldiBhY2MsIGRlY2spXG4gICAgZWxzZVxuICAgICAgbGV0IChoLCBkZWNrJykgPSBkZWFsX24gaGFuZF9zaXplIGRlY2sgaW5cbiAgICAgIGRlYWxfa19oYW5kcyAoayAtIDEpIGRlY2snIChoIDo6IGFjYylcbiAgaW5cbiAgbGV0IGRlY2swID0gc2h1ZmZsZSBhbGxfY2FyZHMgaW5cbiAgbGV0IChoYW5kcywgZGVja19hZnRlcikgPSBkZWFsX2tfaGFuZHMgbnVtX3BsYXllcnMgZGVjazAgW10gaW5cbiAgbGV0IHBsYXllcnMgPVxuICAgIGhhbmRzXG4gICAgfD4gTGlzdC5tYXBpIChmdW4gaSBoIC0+XG4gICAgICAgICAgIGlmIHZzX2NvbXB1dGVyICYmIGkgPSAxIHRoZW5cbiAgICAgICAgICAgICB7IGlkID0gaTsgbmFtZSA9IFwiQ29tcHV0ZXJcIjsgaGFuZCA9IGggfVxuICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgeyBpZCA9IGk7IG5hbWUgPSBQcmludGYuc3ByaW50ZiBcIlBsYXllciAlZFwiIChpICsgMSk7IGhhbmQgPSBoIH0pXG4gICAgfD4gQXJyYXkub2ZfbGlzdFxuICBpblxuICB7XG4gICAgZGVjayA9IGRlY2tfYWZ0ZXI7XG4gICAgZGlzY2FyZCA9IFtdO1xuICAgIG1lbGRzID0gW107XG4gICAgcGxheWVycztcbiAgICBjdXJyZW50ID0gMDtcbiAgICBwaGFzZSA9IERyYXc7XG4gICAgYWNlX3BvbGljeSA9IExvdztcbiAgICBzY29yaW5nID0geyBkZWFkd29vZF90aHJlc2hvbGQgPSBOb25lIH07XG4gICAgcmVxdWlyZWRfdG9fdXNlID0gTm9uZTtcbiAgICBzY29yZXMgPSBBcnJheS5tYWtlIG51bV9wbGF5ZXJzIDA7XG4gIH0iLCIoKiBydWxlcy5tbCAqKVxub3BlbiBUeXBlc1xuXG4oKiAtLS0tLS0tLS0tIEhlbHBlcnMgLS0tLS0tLS0tLSAqKVxuXG5sZXQgYWxsX3NhbWVfcmFuayAoY3MgOiBjYXJkIGxpc3QpID1cbiAgbWF0Y2ggY3Mgd2l0aFxuICB8IFtdIHwgW19dIC0+IGZhbHNlXG4gIHwgYyA6OiByZXN0IC0+IExpc3QuZm9yX2FsbCAoZnVuIHggLT4geC5yYW5rID0gYy5yYW5rKSByZXN0XG5cbmxldCBkaXN0aW5jdF9zdWl0cyAoY3MgOiBjYXJkIGxpc3QpID1cbiAgbGV0IG1vZHVsZSBTID0gU2V0Lk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN1aXQgbGV0IGNvbXBhcmUgPSBjb21wYXJlIGVuZCkgaW5cbiAgbGV0IHMgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyBjIC0+IFMuYWRkIGMuc3VpdCBhY2MpIFMuZW1wdHkgY3MgaW5cbiAgUy5jYXJkaW5hbCBzID0gTGlzdC5sZW5ndGggY3NcblxubGV0IHJhbmtfdmFsdWUgfmFjZV9wb2xpY3kgPSBmdW5jdGlvblxuICB8IFR3by0+MiB8IFRocmVlLT4zIHwgRm91ci0+NCB8IEZpdmUtPjUgfCBTaXgtPjYgfCBTZXZlbi0+N1xuICB8IEVpZ2h0LT44IHwgTmluZS0+OSB8IFRlbi0+MTAgfCBKYWNrLT4xMSB8IFF1ZWVuLT4xMiB8IEtpbmctPjEzXG4gIHwgQWNlIC0+IChtYXRjaCBhY2VfcG9saWN5IHdpdGggTG93IC0+IDEgfCBIaWdoIC0+IDE0KVxuXG5sZXQgcmVjIGlzX2NvbnNlY3V0aXZlX2ludHMgPSBmdW5jdGlvblxuICB8IFtdIHwgW19dIC0+IHRydWVcbiAgfCBhIDo6IGIgOjogcmVzdCAtPiAoYiA9IGEgKyAxKSAmJiBpc19jb25zZWN1dGl2ZV9pbnRzIChiIDo6IHJlc3QpXG5cbigqIC0tLS0tLS0tLS0gTWVsZCBwcmVkaWNhdGVzIC0tLS0tLS0tLS0gKilcblxubGV0IGlzX3NldCAoY3MgOiBjYXJkIGxpc3QpIDogYm9vbCA9XG4gIExpc3QubGVuZ3RoIGNzID49IDMgJiYgYWxsX3NhbWVfcmFuayBjcyAmJiBkaXN0aW5jdF9zdWl0cyBjc1xuXG5sZXQgaXNfcnVuIH5hY2VfcG9saWN5IChjcyA6IGNhcmQgbGlzdCkgOiBib29sID1cbiAgbWF0Y2ggY3Mgd2l0aFxuICB8IFtdIHwgW19dIHwgW187IF9dIC0+IGZhbHNlXG4gIHwgYyA6OiByZXN0IC0+XG4gICAgICBsZXQgc2FtZV9zdWl0ID0gTGlzdC5mb3JfYWxsIChmdW4geCAtPiB4LnN1aXQgPSBjLnN1aXQpIHJlc3QgaW5cbiAgICAgIGlmIG5vdCBzYW1lX3N1aXQgdGhlbiBmYWxzZVxuICAgICAgZWxzZVxuICAgICAgICBjc1xuICAgICAgICB8PiBMaXN0Lm1hcCAoZnVuIHggLT4gcmFua192YWx1ZSB+YWNlX3BvbGljeSB4LnJhbmspXG4gICAgICAgIHw+IExpc3Quc29ydCBjb21wYXJlXG4gICAgICAgIHw+IGlzX2NvbnNlY3V0aXZlX2ludHNcblxubGV0IHZhbGlkX21lbGQgfmFjZV9wb2xpY3kgY2FyZHMgPVxuICBpc19zZXQgY2FyZHMgfHwgaXNfcnVuIH5hY2VfcG9saWN5IGNhcmRzXG5cbmxldCBjYW5fbGF5b2ZmIH5hY2VfcG9saWN5IChjIDogY2FyZCkgKG0gOiBtZWxkKSA6IGJvb2wgPVxuICB2YWxpZF9tZWxkIH5hY2VfcG9saWN5IChjIDo6IG0uY2FyZHMpXG5cbigqIElmIHlvdSBzdGlsbCBoYXZlIHRoaXMgc3R1YiBoZXJlLCBrZWVwIGl0OyBpdCdzIGhhcm1sZXNzLiAqKVxubGV0IGRlYWR3b29kX3BvaW50cyAoX2hhbmQgOiBjYXJkIGxpc3QpIDogaW50ID0gMCIsIm9wZW4gVHlwZXNcblxuKCogLS0tLS0tLS0tLSBFcnJvcnMgJiBzdGVwIHJlc3VsdCAtLS0tLS0tLS0tICopXG5cbnR5cGUgZXJyb3IgPVxuICB8IElsbGVnYWxfcGhhc2Ugb2YgcGhhc2VcbiAgfCBFbXB0eV9kZWNrXG4gIHwgRW1wdHlfZGlzY2FyZFxuICB8IEJvdGhfc291cmNlc19lbXB0eVxuICB8IElsbGVnYWxfcGxheSBvZiBzdHJpbmdcbiAgfCBJbGxlZ2FsX2Rpc2NhcmQgb2Ygc3RyaW5nXG5cbnR5cGUgc3RlcF9yZXN1bHQgPVxuICB8IE9rIG9mIHN0YXRlXG4gIHwgRW5kX3JvdW5kIG9mIHN0YXRlXG4gIHwgRXJyb3Igb2YgZXJyb3JcblxuKCogLS0tLS0tLS0tLSBDb3JlIHV0aWxzIC0tLS0tLS0tLS0gKilcblxubGV0IHRvcF9hbmRfcmVzdCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogeHMgLT4gU29tZSAoeCwgeHMpXG5cbmxldCB3aXRoX2N1cnJlbnQgKHN0IDogc3RhdGUpIDogcGxheWVyID1cbiAgc3QucGxheWVycy4oc3QuY3VycmVudClcblxubGV0IHJlcGxhY2VfY3VycmVudCAoc3QgOiBzdGF0ZSkgKHAgOiBwbGF5ZXIpIDogc3RhdGUgPVxuICBzdC5wbGF5ZXJzLihzdC5jdXJyZW50KSA8LSBwOyBzdFxuXG5sZXQgbmV4dF9wbGF5ZXJfaW5kZXggKHN0IDogc3RhdGUpID1cbiAgKHN0LmN1cnJlbnQgKyAxKSBtb2QgQXJyYXkubGVuZ3RoIHN0LnBsYXllcnNcblxuKCogdGFrZSB0aGUgZmlyc3QgbiBlbGVtZW50cyBhbmQgdGhlIHJlc3QgKilcbmxldCB0YWtlX24gbiB4cyA9XG4gIGxldCByZWMgZ28gayBhY2MgcmVzdCA9XG4gICAgaWYgayA9IDAgdGhlbiAoTGlzdC5yZXYgYWNjLCByZXN0KVxuICAgIGVsc2UgbWF0Y2ggcmVzdCB3aXRoXG4gICAgICB8IFtdIC0+IChMaXN0LnJldiBhY2MsIFtdKVxuICAgICAgfCB5IDo6IHlzIC0+IGdvIChrIC0gMSkgKHkgOjogYWNjKSB5c1xuICBpblxuICBpZiBuIDw9IDAgdGhlbiAoW10sIHhzKSBlbHNlIGdvIG4gW10geHNcblxubGV0IHJlYyBsYXN0X2V4biA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFpbHdpdGggXCJsYXN0X2V4bjogZW1wdHkgbGlzdFwiXG4gIHwgW3hdIC0+IHhcbiAgfCBfIDo6IHhzIC0+IGxhc3RfZXhuIHhzXG5cbigqIC0tLS0tLS0tLS0gSGFuZCBoZWxwZXJzIChtdWx0aXNldC1hd2FyZSkgLS0tLS0tLS0tLSAqKVxuXG5sZXQgcmVtb3ZlX29uZSAoaGFuZCA6IGNhcmQgbGlzdCkgKGMgOiBjYXJkKSA6IChjYXJkIGxpc3QsIHN0cmluZykgcmVzdWx0ID1cbiAgbGV0IHJlYyBnbyBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gUmVzdWx0LkVycm9yIFwiY2FyZCBub3QgaW4gaGFuZFwiXG4gICAgfCB4IDo6IHhzIC0+XG4gICAgICAgIGlmIHggPSBjIHRoZW4gUmVzdWx0Lk9rIChMaXN0LnJldl9hcHBlbmQgYWNjIHhzKVxuICAgICAgICBlbHNlIGdvICh4IDo6IGFjYykgeHNcbiAgaW5cbiAgZ28gW10gaGFuZFxuXG5sZXQgcmVtb3ZlX21hbnkgKGhhbmQgOiBjYXJkIGxpc3QpICh0b190YWtlIDogY2FyZCBsaXN0KSA6IChjYXJkIGxpc3QsIHN0cmluZykgcmVzdWx0ID1cbiAgTGlzdC5mb2xkX2xlZnRcbiAgICAoZnVuIGFjYyBjIC0+XG4gICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgICB8IFJlc3VsdC5FcnJvciBlIC0+IFJlc3VsdC5FcnJvciBlXG4gICAgICAgfCBSZXN1bHQuT2sgaCAtPiByZW1vdmVfb25lIGggYylcbiAgICAoUmVzdWx0Lk9rIGhhbmQpIHRvX3Rha2VcblxubGV0IHJlcGxhY2VfbnRoICh4cyA6ICdhIGxpc3QpIChpZHggOiBpbnQpICh4IDogJ2EpIDogKCdhIGxpc3QsIHN0cmluZykgcmVzdWx0ID1cbiAgbGV0IHJlYyBnbyBpIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBSZXN1bHQuRXJyb3IgXCJtZWxkIGluZGV4IG91dCBvZiByYW5nZVwiXG4gICAgfCBfIDo6IHhzIHdoZW4gaSA9IDAgLT4gUmVzdWx0Lk9rIChMaXN0LnJldiBhY2MgQCAoeCA6OiB4cykpXG4gICAgfCB5IDo6IHhzIC0+IGdvIChpIC0gMSkgKHkgOjogYWNjKSB4c1xuICBpblxuICBpZiBpZHggPCAwIHRoZW4gUmVzdWx0LkVycm9yIFwibWVsZCBpbmRleCBvdXQgb2YgcmFuZ2VcIiBlbHNlIGdvIGlkeCBbXSB4c1xuXG4oKiBXaGVuIGEgbWVsZC9ydW4vbGF5b2ZmIHVzZXMgY2FyZHMsIGNsZWFyIHRoZSBcInJlcXVpcmVkX3RvX3VzZVwiIGlmIHNhdGlzZmllZCAqKVxubGV0IGNsZWFyX3JlcXVpcmVkX2lmX3VzZWQgKHN0IDogc3RhdGUpICh1c2VkIDogY2FyZCBsaXN0KSA6IHN0YXRlID1cbiAgbWF0Y2ggc3QucmVxdWlyZWRfdG9fdXNlIHdpdGhcbiAgfCBOb25lIC0+IHN0XG4gIHwgU29tZSByIC0+XG4gICAgICBpZiBMaXN0LmV4aXN0cyAoKD0pIHIpIHVzZWRcbiAgICAgIHRoZW4geyBzdCB3aXRoIHJlcXVpcmVkX3RvX3VzZSA9IE5vbmUgfVxuICAgICAgZWxzZSBzdFxuXG4oKiAtLS0tLS0tLS0tIFBsYXkgYWN0aW9ucyAtLS0tLS0tLS0tICopXG5cbmxldCBhcHBseV9tYWtlX3NldCAoY2FyZHMgOiBjYXJkIGxpc3QpIChzdCA6IHN0YXRlKSA6IChzdGF0ZSwgZXJyb3IpIHJlc3VsdCA9XG4gIGlmIExpc3QubGVuZ3RoIGNhcmRzIDwgMyB0aGVuIEVycm9yIChJbGxlZ2FsX3BsYXkgXCJzZXQgbXVzdCBoYXZlIOKJpTMgY2FyZHNcIikgZWxzZVxuICBpZiBub3QgKFJ1bGVzLmlzX3NldCBjYXJkcykgdGhlbiBFcnJvciAoSWxsZWdhbF9wbGF5IFwibm90IGEgdmFsaWQgc2V0XCIpIGVsc2VcbiAgbGV0IHAgPSB3aXRoX2N1cnJlbnQgc3QgaW5cbiAgbWF0Y2ggcmVtb3ZlX21hbnkgcC5oYW5kIGNhcmRzIHdpdGhcbiAgfCBSZXN1bHQuRXJyb3IgXyAtPiBFcnJvciAoSWxsZWdhbF9wbGF5IFwiY2FyZHMgbm90IGFsbCBpbiBoYW5kXCIpXG4gIHwgUmVzdWx0Lk9rIG5ld19oYW5kIC0+XG4gICAgICBsZXQgbWVsZCA9IHsga2luZCA9IFNldDsgY2FyZHMgfSBpblxuICAgICAgbGV0IHAnID0geyBwIHdpdGggaGFuZCA9IG5ld19oYW5kIH0gaW5cbiAgICAgIGxldCBzdCcgPSByZXBsYWNlX2N1cnJlbnQgeyBzdCB3aXRoIG1lbGRzID0gbWVsZCA6OiBzdC5tZWxkcyB9IHAnIGluXG4gICAgICBsZXQgc3QnJyA9IGNsZWFyX3JlcXVpcmVkX2lmX3VzZWQgc3QnIGNhcmRzIGluXG4gICAgICBPayBzdCcnXG5cbmxldCBhcHBseV9tYWtlX3J1biAoY2FyZHMgOiBjYXJkIGxpc3QpIChzdCA6IHN0YXRlKSA6IChzdGF0ZSwgZXJyb3IpIHJlc3VsdCA9XG4gIGlmIExpc3QubGVuZ3RoIGNhcmRzIDwgMyB0aGVuIEVycm9yIChJbGxlZ2FsX3BsYXkgXCJydW4gbXVzdCBoYXZlIOKJpTMgY2FyZHNcIikgZWxzZVxuICBpZiBub3QgKFJ1bGVzLmlzX3J1biB+YWNlX3BvbGljeTpzdC5hY2VfcG9saWN5IGNhcmRzKSB0aGVuXG4gICAgRXJyb3IgKElsbGVnYWxfcGxheSBcIm5vdCBhIHZhbGlkIHJ1blwiKVxuICBlbHNlXG4gICAgbGV0IHAgPSB3aXRoX2N1cnJlbnQgc3QgaW5cbiAgICBtYXRjaCByZW1vdmVfbWFueSBwLmhhbmQgY2FyZHMgd2l0aFxuICAgIHwgUmVzdWx0LkVycm9yIF8gLT4gRXJyb3IgKElsbGVnYWxfcGxheSBcImNhcmRzIG5vdCBhbGwgaW4gaGFuZFwiKVxuICAgIHwgUmVzdWx0Lk9rIG5ld19oYW5kIC0+XG4gICAgICAgIGxldCBtZWxkID0geyBraW5kID0gUnVuOyBjYXJkcyB9IGluXG4gICAgICAgIGxldCBwJyA9IHsgcCB3aXRoIGhhbmQgPSBuZXdfaGFuZCB9IGluXG4gICAgICAgIGxldCBzdCcgPSByZXBsYWNlX2N1cnJlbnQgeyBzdCB3aXRoIG1lbGRzID0gbWVsZCA6OiBzdC5tZWxkcyB9IHAnIGluXG4gICAgICAgIGxldCBzdCcnID0gY2xlYXJfcmVxdWlyZWRfaWZfdXNlZCBzdCcgY2FyZHMgaW5cbiAgICAgICAgT2sgc3QnJ1xuXG5sZXQgYXBwbHlfbGF5b2ZmIChjYXJkLCBtZWxkX2lkeCkgKHN0IDogc3RhdGUpIDogKHN0YXRlLCBlcnJvcikgcmVzdWx0ID1cbiAgbGV0IHAgPSB3aXRoX2N1cnJlbnQgc3QgaW5cbiAgKCogMSkgY2FyZCBtdXN0IGJlIGluIGhhbmQgKilcbiAgbWF0Y2ggcmVtb3ZlX29uZSBwLmhhbmQgY2FyZCB3aXRoXG4gIHwgUmVzdWx0LkVycm9yIF8gLT4gRXJyb3IgKElsbGVnYWxfcGxheSBcImxheW9mZiBjYXJkIG5vdCBpbiBoYW5kXCIpXG4gIHwgUmVzdWx0Lk9rIGhhbmRfYWZ0ZXJfcG9wIC0+XG4gICAgICAoKiAyKSBmZXRjaCB0YXJnZXQgbWVsZCAqKVxuICAgICAgKG1hdGNoIExpc3QubnRoX29wdCBzdC5tZWxkcyBtZWxkX2lkeCB3aXRoXG4gICAgICAgfCBOb25lIC0+IEVycm9yIChJbGxlZ2FsX3BsYXkgXCJpbnZhbGlkIG1lbGQgaW5kZXhcIilcbiAgICAgICB8IFNvbWUgbSAtPlxuICAgICAgICAgICAoKiAzKSBhZGRpbmcgY2FyZCBtdXN0IGtlZXAgbWVsZCB2YWxpZCAqKVxuICAgICAgICAgICBpZiBub3QgKFJ1bGVzLmNhbl9sYXlvZmYgfmFjZV9wb2xpY3k6c3QuYWNlX3BvbGljeSBjYXJkIG0pXG4gICAgICAgICAgIHRoZW4gRXJyb3IgKElsbGVnYWxfcGxheSBcImNhbm5vdCBsYXkgb2ZmIG9uIHRoYXQgbWVsZFwiKVxuICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgbGV0IHVwZGF0ZWRfbWVsZCA9IHsgbSB3aXRoIGNhcmRzID0gY2FyZCA6OiBtLmNhcmRzIH0gaW5cbiAgICAgICAgICAgICAoKiA0KSByZXBsYWNlIG1lbGQgaW4gbGlzdCAqKVxuICAgICAgICAgICAgIChtYXRjaCByZXBsYWNlX250aCBzdC5tZWxkcyBtZWxkX2lkeCB1cGRhdGVkX21lbGQgd2l0aFxuICAgICAgICAgICAgICB8IFJlc3VsdC5FcnJvciBfIC0+IEVycm9yIChJbGxlZ2FsX3BsYXkgXCJpbnZhbGlkIG1lbGQgaW5kZXhcIilcbiAgICAgICAgICAgICAgfCBSZXN1bHQuT2sgbWVsZHMnIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgcCcgPSB7IHAgd2l0aCBoYW5kID0gaGFuZF9hZnRlcl9wb3AgfSBpblxuICAgICAgICAgICAgICAgICAgbGV0IHN0JyA9IHJlcGxhY2VfY3VycmVudCB7IHN0IHdpdGggbWVsZHMgPSBtZWxkcycgfSBwJyBpblxuICAgICAgICAgICAgICAgICAgbGV0IHN0JycgPSBjbGVhcl9yZXF1aXJlZF9pZl91c2VkIHN0JyBbY2FyZF0gaW5cbiAgICAgICAgICAgICAgICAgIE9rIHN0JycpKVxuXG4oKiAtLS0tLS0tLS0tIERyYXcgdHJhbnNpdGlvbiAtLS0tLS0tLS0tICopXG5cbmxldCBkcmF3IH4oc291cmNlIDogZHJhd19zb3VyY2UpIChzdCA6IHN0YXRlKSA6IHN0ZXBfcmVzdWx0ID1cbiAgbWF0Y2ggc3QucGhhc2Ugd2l0aFxuICB8IERyYXcgLT4gKFxuICAgICAgbWF0Y2ggc291cmNlIHdpdGhcbiAgICAgIHwgRnJvbURlY2sgLT4gKFxuICAgICAgICAgIG1hdGNoIHRvcF9hbmRfcmVzdCBzdC5kZWNrIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIHN0LmRpc2NhcmQgd2l0aFxuICAgICAgICAgICAgICAgfCBbXSAtPiBFbmRfcm91bmQgc3RcbiAgICAgICAgICAgICAgIHwgXyAgLT4gRXJyb3IgRW1wdHlfZGVjaylcbiAgICAgICAgICB8IFNvbWUgKGNhcmQsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGxldCBwICA9IHdpdGhfY3VycmVudCBzdCBpblxuICAgICAgICAgICAgICBsZXQgcCcgPSB7IHAgd2l0aCBoYW5kID0gY2FyZCA6OiBwLmhhbmQgfSBpblxuICAgICAgICAgICAgICBsZXQgc3QnID0gcmVwbGFjZV9jdXJyZW50IHsgc3Qgd2l0aCBkZWNrID0gcmVzdDsgcGhhc2UgPSBQbGF5IH0gcCcgaW5cbiAgICAgICAgICAgICAgT2sgc3QnXG4gICAgICAgIClcbiAgICAgIHwgRnJvbURpc2NhcmQgLT4gKFxuICAgICAgICAgIG1hdGNoIHRvcF9hbmRfcmVzdCBzdC5kaXNjYXJkIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRXJyb3IgRW1wdHlfZGlzY2FyZFxuICAgICAgICAgIHwgU29tZSAoY2FyZCwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgbGV0IHAgID0gd2l0aF9jdXJyZW50IHN0IGluXG4gICAgICAgICAgICAgIGxldCBwJyA9IHsgcCB3aXRoIGhhbmQgPSBjYXJkIDo6IHAuaGFuZCB9IGluXG4gICAgICAgICAgICAgIGxldCBzdCcgPVxuICAgICAgICAgICAgICAgIHJlcGxhY2VfY3VycmVudFxuICAgICAgICAgICAgICAgICAgeyBzdCB3aXRoIGRpc2NhcmQgPSByZXN0OyBwaGFzZSA9IFBsYXkgfVxuICAgICAgICAgICAgICAgICAgcCdcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgT2sgc3QnXG4gICAgICAgIClcbiAgICAgIHwgRnJvbURpc2NhcmROIG4gLT4gKFxuICAgICAgICAgIGlmIG4gPD0gMCB0aGVuIEVycm9yIChJbGxlZ2FsX3BsYXkgXCJOIG11c3QgYmUg4omlIDFcIikgZWxzZVxuICAgICAgICAgIGxldCAodGFrZW4sIHJlc3QpID0gdGFrZV9uIG4gc3QuZGlzY2FyZCBpblxuICAgICAgICAgIG1hdGNoIHRha2VuIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IEVycm9yIEVtcHR5X2Rpc2NhcmRcbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGxhc3RfZXhuIHRha2VuIGluXG4gICAgICAgICAgICAgIGxldCBwID0gd2l0aF9jdXJyZW50IHN0IGluXG4gICAgICAgICAgICAgICgqIHB1dCB0YWtlbiBvbiB0b3Agb2YgaGFuZDsgb3JkZXIgZG9lc24ndCBtYXR0ZXIgZm9yIHJ1bGVzICopXG4gICAgICAgICAgICAgIGxldCBwJyA9IHsgcCB3aXRoIGhhbmQgPSBMaXN0LnJldl9hcHBlbmQgdGFrZW4gcC5oYW5kIH0gaW5cbiAgICAgICAgICAgICAgbGV0IHN0JyA9XG4gICAgICAgICAgICAgICAgcmVwbGFjZV9jdXJyZW50XG4gICAgICAgICAgICAgICAgICB7IHN0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICBkaXNjYXJkID0gcmVzdDtcbiAgICAgICAgICAgICAgICAgICAgICBwaGFzZSA9IFBsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRfdG9fdXNlID0gU29tZSBib3R0b207XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwJ1xuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBPayBzdCdcbiAgICAgICAgKVxuICAgIClcbiAgfCBwaCAtPiBFcnJvciAoSWxsZWdhbF9waGFzZSBwaClcblxuKCogLS0tLS0tLS0tLSBQbGF5IHRyYW5zaXRpb24gLS0tLS0tLS0tLSAqKVxuXG5sZXQgcGxheSB+KGFjdGlvbiA6IHBsYXlfYWN0aW9uKSAoc3QgOiBzdGF0ZSkgOiBzdGVwX3Jlc3VsdCA9XG4gIG1hdGNoIHN0LnBoYXNlIHdpdGhcbiAgfCBQbGF5IC0+XG4gICAgICBsZXQgcmVzID1cbiAgICAgICAgbWF0Y2ggYWN0aW9uIHdpdGhcbiAgICAgICAgfCBNYWtlX3NldCBjcyAtPiBhcHBseV9tYWtlX3NldCBjcyBzdFxuICAgICAgICB8IE1ha2VfcnVuIGNzIC0+IGFwcGx5X21ha2VfcnVuIGNzIHN0XG4gICAgICAgIHwgTGF5X29mZiAoY2FyZCwgaWR4KSAtPiBhcHBseV9sYXlvZmYgKGNhcmQsIGlkeCkgc3RcbiAgICAgICAgfCBTa2lwX3RvX2Rpc2NhcmQgLT5cbiAgICAgICAgICAgIChtYXRjaCBzdC5yZXF1aXJlZF90b191c2Ugd2l0aFxuICAgICAgICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICAgICAgICAgIEVycm9yIChJbGxlZ2FsX3BsYXkgXCJZb3UgbXVzdCB1c2UgdGhlIGJvdHRvbSBwaWNrZWQgZGlzY2FyZCBjYXJkIGJlZm9yZSBkaXNjYXJkaW5nLlwiKVxuICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICBPayB7IHN0IHdpdGggcGhhc2UgPSBEaXNjYXJkIH0pXG4gICAgICBpblxuICAgICAgKG1hdGNoIHJlcyB3aXRoXG4gICAgICAgfCBPayBzdCcgLT4gT2sgc3QnICAgICAgICAgICAoKiByZW1haW4gaW4gUGxheSBhZnRlciBtZWxkL2xheW9mZi9vayBza2lwICopXG4gICAgICAgfCBFcnJvciBlIC0+IEVycm9yIGUpXG4gIHwgcGggLT4gRXJyb3IgKElsbGVnYWxfcGhhc2UgcGgpXG5cbigqIC0tLS0tLS0tLS0gRGlzY2FyZCB0cmFuc2l0aW9uIC0tLS0tLS0tLS0gKilcblxubGV0IGRpc2NhcmQgfihhY3Rpb24gOiBkaXNjYXJkX2FjdGlvbikgKHN0IDogc3RhdGUpIDogc3RlcF9yZXN1bHQgPVxuICBtYXRjaCBzdC5waGFzZSB3aXRoXG4gIHwgRGlzY2FyZCAtPlxuICAgICAgKG1hdGNoIHN0LnJlcXVpcmVkX3RvX3VzZSB3aXRoXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICAgRXJyb3IgKElsbGVnYWxfZGlzY2FyZCBcIllvdSBtdXN0IHVzZSB0aGUgcmVxdWlyZWQgY2FyZCBiZWZvcmUgZGlzY2FyZGluZy5cIilcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgbGV0IChEaXNjYXJkX2NhcmQgYykgPSBhY3Rpb24gaW5cbiAgICAgICAgICAgbGV0IHAgPSB3aXRoX2N1cnJlbnQgc3QgaW5cbiAgICAgICAgICAgKG1hdGNoIHJlbW92ZV9vbmUgcC5oYW5kIGMgd2l0aFxuICAgICAgICAgICAgfCBSZXN1bHQuRXJyb3IgXyAtPiBFcnJvciAoSWxsZWdhbF9kaXNjYXJkIFwiY2FyZCBub3QgaW4gaGFuZFwiKVxuICAgICAgICAgICAgfCBSZXN1bHQuT2sgbmV3X2hhbmQgLT5cbiAgICAgICAgICAgICAgICBsZXQgcCcgPSB7IHAgd2l0aCBoYW5kID0gbmV3X2hhbmQgfSBpblxuICAgICAgICAgICAgICAgIGxldCBzdCcgPVxuICAgICAgICAgICAgICAgICAgcmVwbGFjZV9jdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIHsgc3Qgd2l0aCBkaXNjYXJkID0gYyA6OiBzdC5kaXNjYXJkOyBwaGFzZSA9IEVuZENoZWNrIH1cbiAgICAgICAgICAgICAgICAgICAgcCdcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIE9rIHN0JykpXG4gIHwgcGggLT4gRXJyb3IgKElsbGVnYWxfcGhhc2UgcGgpXG5cbigqIC0tLS0tLS0tLS0gRW5kQ2hlY2sgdHJhbnNpdGlvbiAtLS0tLS0tLS0tICopXG5cbmxldCBlbmRjaGVjayAoc3QgOiBzdGF0ZSkgOiBzdGVwX3Jlc3VsdCA9XG4gIG1hdGNoIHN0LnBoYXNlIHdpdGhcbiAgfCBFbmRDaGVjayAtPlxuICAgICAgbGV0IHAgPSB3aXRoX2N1cnJlbnQgc3QgaW5cbiAgICAgIGlmIHAuaGFuZCA9IFtdIHRoZW5cbiAgICAgICAgRW5kX3JvdW5kIHN0ICAgKCog4pyFIHBsYXllciB3ZW50IG91dCAqKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3QnID0geyBzdCB3aXRoIGN1cnJlbnQgPSBuZXh0X3BsYXllcl9pbmRleCBzdDsgcGhhc2UgPSBEcmF3IH0gaW5cbiAgICAgICAgT2sgc3QnXG4gIHwgcGggLT4gRXJyb3IgKElsbGVnYWxfcGhhc2UgcGgpIiwiKCogc3JjL2FpLm1sICopXG5cbm9wZW4gVHlwZXMgICgqIGJyaW5nIHJlY29yZCBsYWJlbHMgbGlrZSBbY3VycmVudF0sIFtwbGF5ZXJzXSwgW2Rpc2NhcmRdLCBldGMuIGludG8gc2NvcGUgKilcbm9wZW4hIENvcmVcbm1vZHVsZSBUID0gVHlwZXNcbm1vZHVsZSBFID0gRW5naW5lXG5tb2R1bGUgUiA9IFJ1bGVzXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG4oKiBVdGlsaXRpZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IGNob29zZV9yYW5kb20gKHJuZyA6IFJhbmRvbS5TdGF0ZS50KSAoeHMgOiAnYSBsaXN0KSA6ICdhIG9wdGlvbiA9XG4gIG1hdGNoIHhzIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyAgLT4gU29tZSAoTGlzdC5udGhfZXhuIHhzIChSYW5kb20uU3RhdGUuaW50IHJuZyAoTGlzdC5sZW5ndGggeHMpKSlcblxubGV0IHJlYyBjb21iaW5hdGlvbnNfayAoayA6IGludCkgKHhzIDogJ2EgbGlzdCkgOiAnYSBsaXN0IGxpc3QgPVxuICBpZiBrID0gMCB0aGVuIFsgW10gXVxuICBlbHNlXG4gICAgbWF0Y2ggeHMgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IHkgOjogeXMgLT5cbiAgICAgICAgbGV0IHdpdGhfeSAgPSBMaXN0Lm1hcCAoY29tYmluYXRpb25zX2sgKGsgLSAxKSB5cykgfmY6KGZ1biByZXN0IC0+IHkgOjogcmVzdCkgaW5cbiAgICAgICAgbGV0IHdpdGhvdXQgPSBjb21iaW5hdGlvbnNfayBrIHlzIGluXG4gICAgICAgIHdpdGhfeSBAIHdpdGhvdXRcblxubGV0IGFsbF8zcGx1c19jb21ib3MgKGhhbmQgOiAnYSBsaXN0KSA6ICdhIGxpc3QgbGlzdCA9XG4gIGxldCBuID0gTGlzdC5sZW5ndGggaGFuZCBpblxuICBMaXN0LmNvbmNhdF9tYXAgKExpc3QucmFuZ2UgMyAobiArIDEpKSB+ZjooZnVuIGsgLT4gY29tYmluYXRpb25zX2sgayBoYW5kKVxuXG4oKiBBcHBseSBoZWxwZXJzIHRoYXQgcmV0dXJuIGEgKnJlc3VsdGluZyBzdGF0ZSogb3B0aW9uLCBzd2FsbG93aW5nIEVuZF9yb3VuZCBpbnRvIFNvbWUgKilcbmxldCBhcHBseV9kcmF3IH5zb3VyY2UgKHN0IDogVC5zdGF0ZSkgOiBULnN0YXRlIG9wdGlvbiA9XG4gIG1hdGNoIEUuZHJhdyB+c291cmNlIHN0IHdpdGhcbiAgfCBPayBzdCcgfCBFLkVuZF9yb3VuZCBzdCcgLT4gU29tZSBzdCdcbiAgfCBFcnJvciBfIC0+IE5vbmVcblxubGV0IGFwcGx5X3BsYXkgfmFjdGlvbiAoc3QgOiBULnN0YXRlKSA6IFQuc3RhdGUgb3B0aW9uID1cbiAgbWF0Y2ggRS5wbGF5IH5hY3Rpb24gc3Qgd2l0aFxuICB8IE9rIHN0JyB8IEUuRW5kX3JvdW5kIHN0JyAtPiBTb21lIHN0J1xuICB8IEVycm9yIF8gLT4gTm9uZVxuXG5sZXQgYXBwbHlfZGlzY2FyZCB+Y2FyZCAoc3QgOiBULnN0YXRlKSA6IFQuc3RhdGUgb3B0aW9uID1cbiAgbWF0Y2ggRS5kaXNjYXJkIH5hY3Rpb246KFQuRGlzY2FyZF9jYXJkIGNhcmQpIHN0IHdpdGhcbiAgfCBPayBzdCcgfCBFLkVuZF9yb3VuZCBzdCcgLT4gU29tZSBzdCdcbiAgfCBFcnJvciBfIC0+IE5vbmVcblxubGV0IGFwcGx5X2VuZGNoZWNrIChzdCA6IFQuc3RhdGUpIDogVC5zdGF0ZSBvcHRpb24gPVxuICBtYXRjaCBFLmVuZGNoZWNrIHN0IHdpdGhcbiAgfCBPayBzdCcgfCBFLkVuZF9yb3VuZCBzdCcgLT4gU29tZSBzdCdcbiAgfCBFcnJvciBfIC0+IE5vbmVcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcbigqIEVudW1lcmF0aW5nIGNhbmRpZGF0ZSBtb3ZlcyAgICAgICAgICAgICAgICopXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5sZXQgY2FuZGlkYXRlX2RyYXdzIChzdCA6IFQuc3RhdGUpID1cbiAgbGV0IGZyb21fZGVjayAgICAgPSBbIFQuRnJvbURlY2sgXSBpblxuICBsZXQgZnJvbV9kaXNjYXJkMSA9IGlmIExpc3QuaXNfZW1wdHkgc3QuZGlzY2FyZCB0aGVuIFtdIGVsc2UgWyBULkZyb21EaXNjYXJkIF0gaW5cbiAgbGV0IGZyb21fZGlzY2FyZE4gPVxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBzdC5kaXNjYXJkIGluXG4gICAgaWYgbGVuIDw9IDEgdGhlbiBbXVxuICAgIGVsc2UgTGlzdC5pbml0IGxlbiB+ZjooZnVuIGkgLT4gVC5Gcm9tRGlzY2FyZE4gKGkgKyAxKSlcbiAgaW5cbiAgZnJvbV9kZWNrIEAgZnJvbV9kaXNjYXJkMSBAIGZyb21fZGlzY2FyZE5cblxubGV0IGNhbmRpZGF0ZV9wbGF5cyAoc3QgOiBULnN0YXRlKSA9XG4gIGxldCBwID0gc3QucGxheWVycy4oc3QuY3VycmVudCkgaW5cbiAgbGV0IHNldF9hY3Rpb25zID1cbiAgICBhbGxfM3BsdXNfY29tYm9zIHAuaGFuZCB8PiBMaXN0Lm1hcCB+ZjooZnVuIGNzIC0+IFQuTWFrZV9zZXQgY3MpXG4gIGluXG4gIGxldCBydW5fYWN0aW9ucyA9XG4gICAgYWxsXzNwbHVzX2NvbWJvcyBwLmhhbmQgfD4gTGlzdC5tYXAgfmY6KGZ1biBjcyAtPiBULk1ha2VfcnVuIGNzKVxuICBpblxuICBsZXQgbGF5X2FjdGlvbnMgPVxuICAgIGxldCBtY291bnQgPSBMaXN0Lmxlbmd0aCBzdC5tZWxkcyBpblxuICAgIExpc3QuY29uY2F0X21hcCBwLmhhbmQgfmY6KGZ1biBjIC0+XG4gICAgICBMaXN0LmluaXQgbWNvdW50IH5mOihmdW4gbWkgLT4gVC5MYXlfb2ZmIChjLCBtaSkpKVxuICBpblxuICBsZXQgc2tpcCA9IFsgVC5Ta2lwX3RvX2Rpc2NhcmQgXSBpblxuICBzZXRfYWN0aW9ucyBAIHJ1bl9hY3Rpb25zIEAgbGF5X2FjdGlvbnMgQCBza2lwXG5cbmxldCBjYW5kaWRhdGVfZGlzY2FyZHMgKHN0IDogVC5zdGF0ZSkgPVxuICBsZXQgcCA9IHN0LnBsYXllcnMuKHN0LmN1cnJlbnQpIGluXG4gIHAuaGFuZFxuXG4oKiBLZWVwIG9ubHkgY2FuZGlkYXRlcyB0aGF0IGFjdHVhbGx5IHRyYW5zaXRpb24gdGhlIHN0YXRlICopXG5sZXQgbGVnYWxpemVfZHJhd3MgKHN0IDogVC5zdGF0ZSkgPVxuICBjYW5kaWRhdGVfZHJhd3Mgc3RcbiAgfD4gTGlzdC5maWx0ZXJfbWFwIH5mOihmdW4gc3JjIC0+XG4gICAgICAgT3B0aW9uLm1hcCAoYXBwbHlfZHJhdyB+c291cmNlOnNyYyBzdCkgfmY6KGZ1biBfIC0+IHNyYykpXG5cbmxldCBsZWdhbGl6ZV9wbGF5cyAoc3QgOiBULnN0YXRlKSA9XG4gIGNhbmRpZGF0ZV9wbGF5cyBzdFxuICB8PiBMaXN0LmZpbHRlcl9tYXAgfmY6KGZ1biBhY3QgLT5cbiAgICAgICBPcHRpb24ubWFwIChhcHBseV9wbGF5IH5hY3Rpb246YWN0IHN0KSB+ZjooZnVuIF8gLT4gYWN0KSlcblxubGV0IGxlZ2FsaXplX2Rpc2NhcmRzIChzdCA6IFQuc3RhdGUpID1cbiAgY2FuZGlkYXRlX2Rpc2NhcmRzIHN0XG4gIHw+IExpc3QuZmlsdGVyX21hcCB+ZjooZnVuIGMgLT5cbiAgICAgICBPcHRpb24ubWFwIChhcHBseV9kaXNjYXJkIH5jYXJkOmMgc3QpIH5mOihmdW4gXyAtPiBjKSlcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcbigqIEFJIHBvbGljaWVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG4oKiogQSBwb2xpY3kgY2hvb3NlcyBhbmQgYXBwbGllcyAxIGxlZ2FsIG1vdmUsIHJldHVybmluZyB0aGUgbmV3IHN0YXRlLiAqKVxudHlwZSBwb2xpY3kgPSBSYW5kb20uU3RhdGUudCAtPiBULnN0YXRlIC0+IFQuc3RhdGUgb3B0aW9uXG5cbmxldCByYW5kb21fYWkgOiBwb2xpY3kgPVxuIGZ1biBybmcgc3QgLT5cbiAgbWF0Y2ggc3QuVC5waGFzZSB3aXRoXG4gIHwgVC5EcmF3IC0+XG4gICAgICBsZXQgZHJhd3MgPSBsZWdhbGl6ZV9kcmF3cyBzdCBpblxuICAgICAgT3B0aW9uLmJpbmQgKGNob29zZV9yYW5kb20gcm5nIGRyYXdzKSB+ZjooZnVuIHNyYyAtPiBhcHBseV9kcmF3IH5zb3VyY2U6c3JjIHN0KVxuICB8IFQuUGxheSAtPlxuICAgICAgbGV0IHBsYXlzID0gbGVnYWxpemVfcGxheXMgc3QgaW5cbiAgICAgIE9wdGlvbi5iaW5kIChjaG9vc2VfcmFuZG9tIHJuZyBwbGF5cykgfmY6KGZ1biBhY3QgLT4gYXBwbHlfcGxheSB+YWN0aW9uOmFjdCBzdClcbiAgfCBULkRpc2NhcmQgLT5cbiAgICAgIGxldCBkaXNjYXJkcyA9IGxlZ2FsaXplX2Rpc2NhcmRzIHN0IGluXG4gICAgICBPcHRpb24uYmluZCAoY2hvb3NlX3JhbmRvbSBybmcgZGlzY2FyZHMpIH5mOihmdW4gYyAtPiBhcHBseV9kaXNjYXJkIH5jYXJkOmMgc3QpXG4gIHwgVC5FbmRDaGVjayAtPlxuICAgICAgYXBwbHlfZW5kY2hlY2sgc3RcblxuKCogLS0tLS0tLS0tLSBSb2xsb3V0IGhlbHBlcjogc2ltdWxhdGUgdG8gYW4gZW5kLWlzaCBjb25kaXRpb24gLS0tLS0tLS0tLSAqKVxuXG5sZXQgc2ltdWxhdGVfdG9fZW5kXG4gICAgKHJuZyA6IFJhbmRvbS5TdGF0ZS50KVxuICAgIChwb2wwIDogcG9saWN5KVxuICAgIChwb2wxIDogcG9saWN5KVxuICAgIChzdDAgIDogVC5zdGF0ZSlcbiAgOiBpbnRcbiAgPVxuICBsZXQgbWF4X3N0ZXBzID0gMjBfMDAwIGluXG4gIGxldCByZWMgbG9vcCBzdGVwcyBzdCA9XG4gICAgaWYgc3RlcHMgPD0gMCB0aGVuXG4gICAgICBzdC5jdXJyZW50XG4gICAgZWxzZVxuICAgICAgbGV0IGN1cnJlbnQgPSBzdC5ULmN1cnJlbnQgaW5cbiAgICAgIGxldCBwb2wgPSBpZiBjdXJyZW50ID0gMCB0aGVuIHBvbDAgZWxzZSBwb2wxIGluXG4gICAgICBtYXRjaCBwb2wgcm5nIHN0IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIChtYXRjaCBhcHBseV9lbmRjaGVjayBzdCB3aXRoXG4gICAgICAgICAgIHwgTm9uZSAtPiBjdXJyZW50XG4gICAgICAgICAgIHwgU29tZSBzdCcgLT5cbiAgICAgICAgICAgICAgIGxldCBlbXB0eTAgPSBMaXN0LmlzX2VtcHR5IHN0Jy5wbGF5ZXJzLigwKS5oYW5kIGluXG4gICAgICAgICAgICAgICBsZXQgZW1wdHkxID0gTGlzdC5pc19lbXB0eSBzdCcucGxheWVycy4oMSkuaGFuZCBpblxuICAgICAgICAgICAgICAgaWYgZW1wdHkwICYmIG5vdCBlbXB0eTEgdGhlbiAwXG4gICAgICAgICAgICAgICBlbHNlIGlmIGVtcHR5MSAmJiBub3QgZW1wdHkwIHRoZW4gMVxuICAgICAgICAgICAgICAgZWxzZSBsb29wIChzdGVwcyAtIDEpIHN0JylcbiAgICAgIHwgU29tZSBzdCcgLT5cbiAgICAgICAgICBsZXQgZW1wdHkwID0gTGlzdC5pc19lbXB0eSBzdCcucGxheWVycy4oMCkuaGFuZCBpblxuICAgICAgICAgIGxldCBlbXB0eTEgPSBMaXN0LmlzX2VtcHR5IHN0Jy5wbGF5ZXJzLigxKS5oYW5kIGluXG4gICAgICAgICAgaWYgZW1wdHkwICYmIG5vdCBlbXB0eTEgdGhlbiAwXG4gICAgICAgICAgZWxzZSBpZiBlbXB0eTEgJiYgbm90IGVtcHR5MCB0aGVuIDFcbiAgICAgICAgICBlbHNlIGxvb3AgKHN0ZXBzIC0gMSkgc3QnXG4gIGluXG4gIGxvb3AgbWF4X3N0ZXBzIHN0MFxuXG4oKiAtLS0tLS0tLS0tIFBoYXNlLXNwZWNpZmljIHRpbWVkIHBpY2tlcnMgKG5vIFQuYWN0aW9uIGluIHR5cGVzISkgLS0tLS0tLS0tLSAqKVxuXG5sZXQgdGltZWRfcGlja19kcmF3XG4gICAgKHJuZyA6IFJhbmRvbS5TdGF0ZS50KVxuICAgIChzdCA6IFQuc3RhdGUpXG4gICAgKGNob2ljZXMgOiBULmRyYXdfc291cmNlIGxpc3QpXG4gICAgfihvcHBvbmVudCA6IHBvbGljeSlcbiAgICAodGltZV9tcyA6IGludClcbiAgOiBULnN0YXRlIG9wdGlvbiA9XG4gIG1hdGNoIGNob2ljZXMgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIC0+XG4gICAgICBsZXQgZGVhZGxpbmUgPSBUaW1lX25zLmFkZCAoVGltZV9ucy5ub3cgKCkpIChUaW1lX25zLlNwYW4ub2ZfaW50X21zIHRpbWVfbXMpIGluXG4gICAgICBsZXQgc2NvcmVzID0gQXJyYXkub2ZfbGlzdCAoTGlzdC5tYXAgY2hvaWNlcyB+ZjooZnVuIF8gLT4gMCwgMCkpIGluXG4gICAgICBsZXQgaV9yZWYgPSByZWYgMCBpblxuICAgICAgd2hpbGUgVGltZV9ucy4obm93ICgpIDwgZGVhZGxpbmUpIGRvXG4gICAgICAgIGxldCBpID0gIWlfcmVmIGluXG4gICAgICAgIGlfcmVmIDo9IChpICsgMSkgJSAoQXJyYXkubGVuZ3RoIHNjb3Jlcyk7XG4gICAgICAgIGxldCBzcmMgPSBMaXN0Lm50aF9leG4gY2hvaWNlcyBpIGluXG4gICAgICAgIG1hdGNoIGFwcGx5X2RyYXcgfnNvdXJjZTpzcmMgc3Qgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIHN0X2FmdGVyIC0+XG4gICAgICAgICAgICBsZXQgdXMgPSBzdC5ULmN1cnJlbnQgaW5cbiAgICAgICAgICAgIGxldCB3aW5uZXIgPVxuICAgICAgICAgICAgICBpZiB1cyA9IDBcbiAgICAgICAgICAgICAgdGhlbiBzaW11bGF0ZV90b19lbmQgcm5nIHJhbmRvbV9haSBvcHBvbmVudCBzdF9hZnRlclxuICAgICAgICAgICAgICBlbHNlIHNpbXVsYXRlX3RvX2VuZCBybmcgb3Bwb25lbnQgcmFuZG9tX2FpIHN0X2FmdGVyXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IHcsIG4gPSBzY29yZXMuKGkpIGluXG4gICAgICAgICAgICBsZXQgdycgPSBpZiB3aW5uZXIgPSB1cyB0aGVuIHcgKyAxIGVsc2UgdyBpblxuICAgICAgICAgICAgc2NvcmVzLihpKSA8LSAodycsIG4gKyAxKVxuICAgICAgZG9uZTtcbiAgICAgIGxldCBiZXN0X2ksIF9iZXN0ID1cbiAgICAgICAgQXJyYXkuZm9sZGkgc2NvcmVzIH5pbml0OigwLCBGbG9hdC5uZWdfaW5maW5pdHkpXG4gICAgICAgICAgfmY6KGZ1biBpIChiZXN0X2ksIGJlc3Rfc2NvcmUpICh3LCBuKSAtPlxuICAgICAgICAgICAgbGV0IHNjb3JlID0gaWYgbiA9IDAgdGhlbiBGbG9hdC5uZWdfaW5maW5pdHkgZWxzZSBGbG9hdC4ob2ZfaW50IHcgLyBvZl9pbnQgbikgaW5cbiAgICAgICAgICAgIGlmIEZsb2F0LihzY29yZSA+IGJlc3Rfc2NvcmUpIHRoZW4gKGksIHNjb3JlKSBlbHNlIChiZXN0X2ksIGJlc3Rfc2NvcmUpKVxuICAgICAgaW5cbiAgICAgIGFwcGx5X2RyYXcgfnNvdXJjZTooTGlzdC5udGhfZXhuIGNob2ljZXMgYmVzdF9pKSBzdFxuXG5sZXQgdGltZWRfcGlja19wbGF5XG4gICAgKHJuZyA6IFJhbmRvbS5TdGF0ZS50KVxuICAgIChzdCA6IFQuc3RhdGUpXG4gICAgKGNob2ljZXMgOiBfIGxpc3QpICAoKiBsaXN0IG9mIGFjdGlvbnM7IGxldCB0aGUgdHlwZSBpbmZlciAqKVxuICAgIH4ob3Bwb25lbnQgOiBwb2xpY3kpXG4gICAgKHRpbWVfbXMgOiBpbnQpXG4gIDogVC5zdGF0ZSBvcHRpb24gPVxuICBtYXRjaCBjaG9pY2VzIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyAtPlxuICAgICAgbGV0IGRlYWRsaW5lID0gVGltZV9ucy5hZGQgKFRpbWVfbnMubm93ICgpKSAoVGltZV9ucy5TcGFuLm9mX2ludF9tcyB0aW1lX21zKSBpblxuICAgICAgbGV0IHNjb3JlcyA9IEFycmF5Lm9mX2xpc3QgKExpc3QubWFwIGNob2ljZXMgfmY6KGZ1biBfIC0+IDAsIDApKSBpblxuICAgICAgbGV0IGlfcmVmID0gcmVmIDAgaW5cbiAgICAgIHdoaWxlIFRpbWVfbnMuKG5vdyAoKSA8IGRlYWRsaW5lKSBkb1xuICAgICAgICBsZXQgaSA9ICFpX3JlZiBpblxuICAgICAgICBpX3JlZiA6PSAoaSArIDEpICUgKEFycmF5Lmxlbmd0aCBzY29yZXMpO1xuICAgICAgICBsZXQgYWN0ID0gTGlzdC5udGhfZXhuIGNob2ljZXMgaSBpblxuICAgICAgICBtYXRjaCBhcHBseV9wbGF5IH5hY3Rpb246YWN0IHN0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBzdF9hZnRlciAtPlxuICAgICAgICAgICAgbGV0IHVzID0gc3QuVC5jdXJyZW50IGluXG4gICAgICAgICAgICBsZXQgd2lubmVyID1cbiAgICAgICAgICAgICAgaWYgdXMgPSAwXG4gICAgICAgICAgICAgIHRoZW4gc2ltdWxhdGVfdG9fZW5kIHJuZyByYW5kb21fYWkgb3Bwb25lbnQgc3RfYWZ0ZXJcbiAgICAgICAgICAgICAgZWxzZSBzaW11bGF0ZV90b19lbmQgcm5nIG9wcG9uZW50IHJhbmRvbV9haSBzdF9hZnRlclxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxldCB3LCBuID0gc2NvcmVzLihpKSBpblxuICAgICAgICAgICAgbGV0IHcnID0gaWYgd2lubmVyID0gdXMgdGhlbiB3ICsgMSBlbHNlIHcgaW5cbiAgICAgICAgICAgIHNjb3Jlcy4oaSkgPC0gKHcnLCBuICsgMSlcbiAgICAgIGRvbmU7XG4gICAgICBsZXQgYmVzdF9pLCBfYmVzdCA9XG4gICAgICAgIEFycmF5LmZvbGRpIHNjb3JlcyB+aW5pdDooMCwgRmxvYXQubmVnX2luZmluaXR5KVxuICAgICAgICAgIH5mOihmdW4gaSAoYmVzdF9pLCBiZXN0X3Njb3JlKSAodywgbikgLT5cbiAgICAgICAgICAgIGxldCBzY29yZSA9IGlmIG4gPSAwIHRoZW4gRmxvYXQubmVnX2luZmluaXR5IGVsc2UgRmxvYXQuKG9mX2ludCB3IC8gb2ZfaW50IG4pIGluXG4gICAgICAgICAgICBpZiBGbG9hdC4oc2NvcmUgPiBiZXN0X3Njb3JlKSB0aGVuIChpLCBzY29yZSkgZWxzZSAoYmVzdF9pLCBiZXN0X3Njb3JlKSlcbiAgICAgIGluXG4gICAgICBhcHBseV9wbGF5IH5hY3Rpb246KExpc3QubnRoX2V4biBjaG9pY2VzIGJlc3RfaSkgc3RcblxubGV0IHRpbWVkX3BpY2tfZGlzY2FyZFxuICAgIChybmcgOiBSYW5kb20uU3RhdGUudClcbiAgICAoc3QgOiBULnN0YXRlKVxuICAgIChjaG9pY2VzIDogVC5jYXJkIGxpc3QpXG4gICAgfihvcHBvbmVudCA6IHBvbGljeSlcbiAgICAodGltZV9tcyA6IGludClcbiAgOiBULnN0YXRlIG9wdGlvbiA9XG4gIG1hdGNoIGNob2ljZXMgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIC0+XG4gICAgICBsZXQgZGVhZGxpbmUgPSBUaW1lX25zLmFkZCAoVGltZV9ucy5ub3cgKCkpIChUaW1lX25zLlNwYW4ub2ZfaW50X21zIHRpbWVfbXMpIGluXG4gICAgICBsZXQgc2NvcmVzID0gQXJyYXkub2ZfbGlzdCAoTGlzdC5tYXAgY2hvaWNlcyB+ZjooZnVuIF8gLT4gMCwgMCkpIGluXG4gICAgICBsZXQgaV9yZWYgPSByZWYgMCBpblxuICAgICAgd2hpbGUgVGltZV9ucy4obm93ICgpIDwgZGVhZGxpbmUpIGRvXG4gICAgICAgIGxldCBpID0gIWlfcmVmIGluXG4gICAgICAgIGlfcmVmIDo9IChpICsgMSkgJSAoQXJyYXkubGVuZ3RoIHNjb3Jlcyk7XG4gICAgICAgIGxldCBjID0gTGlzdC5udGhfZXhuIGNob2ljZXMgaSBpblxuICAgICAgICBtYXRjaCBhcHBseV9kaXNjYXJkIH5jYXJkOmMgc3Qgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIHN0X2FmdGVyIC0+XG4gICAgICAgICAgICBsZXQgdXMgPSBzdC5ULmN1cnJlbnQgaW5cbiAgICAgICAgICAgIGxldCB3aW5uZXIgPVxuICAgICAgICAgICAgICBpZiB1cyA9IDBcbiAgICAgICAgICAgICAgdGhlbiBzaW11bGF0ZV90b19lbmQgcm5nIHJhbmRvbV9haSBvcHBvbmVudCBzdF9hZnRlclxuICAgICAgICAgICAgICBlbHNlIHNpbXVsYXRlX3RvX2VuZCBybmcgb3Bwb25lbnQgcmFuZG9tX2FpIHN0X2FmdGVyXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IHcsIG4gPSBzY29yZXMuKGkpIGluXG4gICAgICAgICAgICBsZXQgdycgPSBpZiB3aW5uZXIgPSB1cyB0aGVuIHcgKyAxIGVsc2UgdyBpblxuICAgICAgICAgICAgc2NvcmVzLihpKSA8LSAodycsIG4gKyAxKVxuICAgICAgZG9uZTtcbiAgICAgIGxldCBiZXN0X2ksIF9iZXN0ID1cbiAgICAgICAgQXJyYXkuZm9sZGkgc2NvcmVzIH5pbml0OigwLCBGbG9hdC5uZWdfaW5maW5pdHkpXG4gICAgICAgICAgfmY6KGZ1biBpIChiZXN0X2ksIGJlc3Rfc2NvcmUpICh3LCBuKSAtPlxuICAgICAgICAgICAgbGV0IHNjb3JlID0gaWYgbiA9IDAgdGhlbiBGbG9hdC5uZWdfaW5maW5pdHkgZWxzZSBGbG9hdC4ob2ZfaW50IHcgLyBvZl9pbnQgbikgaW5cbiAgICAgICAgICAgIGlmIEZsb2F0LihzY29yZSA+IGJlc3Rfc2NvcmUpIHRoZW4gKGksIHNjb3JlKSBlbHNlIChiZXN0X2ksIGJlc3Rfc2NvcmUpKVxuICAgICAgaW5cbiAgICAgIGFwcGx5X2Rpc2NhcmQgfmNhcmQ6KExpc3QubnRoX2V4biBjaG9pY2VzIGJlc3RfaSkgc3RcblxubGV0IHRpbWVkX2FpID8odGltZV9tcyA9IDIwMDApIH4ob3Bwb25lbnQgOiBwb2xpY3kpIDogcG9saWN5ID1cbiAgZnVuIHJuZyBzdCAtPlxuICAgIG1hdGNoIHN0LlQucGhhc2Ugd2l0aFxuICAgIHwgVC5EcmF3IC0+XG4gICAgICAgIGxldCBjYW5kcyA9IGxlZ2FsaXplX2RyYXdzIHN0IGluXG4gICAgICAgIHRpbWVkX3BpY2tfZHJhdyBybmcgc3QgY2FuZHMgfm9wcG9uZW50IHRpbWVfbXNcbiAgICB8IFQuUGxheSAtPlxuICAgICAgICBsZXQgY2FuZHMgPSBsZWdhbGl6ZV9wbGF5cyBzdCBpblxuICAgICAgICB0aW1lZF9waWNrX3BsYXkgcm5nIHN0IGNhbmRzIH5vcHBvbmVudCB0aW1lX21zXG4gICAgfCBULkRpc2NhcmQgLT5cbiAgICAgICAgbGV0IGNhbmRzID0gbGVnYWxpemVfZGlzY2FyZHMgc3QgaW5cbiAgICAgICAgdGltZWRfcGlja19kaXNjYXJkIHJuZyBzdCBjYW5kcyB+b3Bwb25lbnQgdGltZV9tc1xuICAgIHwgVC5FbmRDaGVjayAtPlxuICAgICAgICBhcHBseV9lbmRjaGVjayBzdFxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuKCogU2ltdWxhdGlvbiBoYXJuZXNzIGZvciBIVzQgICAgICAgICAgICAgICAgKilcbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbnR5cGUgZ2FtZV9yZXN1bHQgPVxuICB7IHdpbm5lciAgICAgIDogaW50ICAgICAgICAgICAgKCogMCBvciAxICopXG4gIDsgc3RlcHNfdGFrZW4gOiBpbnRcbiAgfVxuXG5sZXQgc2ltdWxhdGVfZ2FtZVxuICAgIH4ocm5nIDogUmFuZG9tLlN0YXRlLnQpXG4gICAgfihwMCA6IHBvbGljeSlcbiAgICB+KHAxIDogcG9saWN5KVxuICAgIChzdDAgOiBULnN0YXRlKVxuICA6IGdhbWVfcmVzdWx0XG4gID1cbiAgbGV0IG1heF9zdGVwcyA9IDUwXzAwMCBpblxuICBsZXQgcmVjIGxvb3Agc3RlcHMgc3QgPVxuICAgIGlmIHN0ZXBzIDw9IDAgdGhlblxuICAgICAgeyB3aW5uZXIgPSBzdC5jdXJyZW50OyBzdGVwc190YWtlbiA9IG1heF9zdGVwcyB9XG4gICAgZWxzZVxuICAgICAgbGV0IGN1ciA9IHN0LlQuY3VycmVudCBpblxuICAgICAgbGV0IHBvbCA9IGlmIGN1ciA9IDAgdGhlbiBwMCBlbHNlIHAxIGluXG4gICAgICBtYXRjaCBwb2wgcm5nIHN0IHdpdGhcbiAgICAgIHwgU29tZSBzdCcgLT5cbiAgICAgICAgICBsZXQgZW1wdHkwID0gTGlzdC5pc19lbXB0eSBzdCcucGxheWVycy4oMCkuaGFuZCBpblxuICAgICAgICAgIGxldCBlbXB0eTEgPSBMaXN0LmlzX2VtcHR5IHN0Jy5wbGF5ZXJzLigxKS5oYW5kIGluXG4gICAgICAgICAgaWYgZW1wdHkwICYmIG5vdCBlbXB0eTEgdGhlbiB7IHdpbm5lciA9IDA7IHN0ZXBzX3Rha2VuID0gbWF4X3N0ZXBzIC0gc3RlcHMgKyAxIH1cbiAgICAgICAgICBlbHNlIGlmIGVtcHR5MSAmJiBub3QgZW1wdHkwIHRoZW4geyB3aW5uZXIgPSAxOyBzdGVwc190YWtlbiA9IG1heF9zdGVwcyAtIHN0ZXBzICsgMSB9XG4gICAgICAgICAgZWxzZSBsb29wIChzdGVwcyAtIDEpIHN0J1xuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKG1hdGNoIGFwcGx5X2VuZGNoZWNrIHN0IHdpdGhcbiAgICAgICAgICAgfCBTb21lIHN0JyAtPiBsb29wIChzdGVwcyAtIDEpIHN0J1xuICAgICAgICAgICB8IE5vbmUgICAgIC0+IHsgd2lubmVyID0gY3VyOyBzdGVwc190YWtlbiA9IG1heF9zdGVwcyAtIHN0ZXBzIH0pXG4gIGluXG4gIGxvb3AgbWF4X3N0ZXBzIHN0MFxuXG5sZXQgc2ltdWxhdGVfZ2FtZXNcbiAgICB+KHJuZyA6IFJhbmRvbS5TdGF0ZS50KVxuICAgIH4oZ2FtZXMgOiBpbnQpXG4gICAgfihta19pbml0aWFsIDogdW5pdCAtPiBULnN0YXRlKVxuICAgIH4ocDAgOiBwb2xpY3kpXG4gICAgfihwMSA6IHBvbGljeSlcbiAgOiAoaW50ICogaW50KSA9XG4gICgqIHJldHVybnMgKHdpbnMwLCB3aW5zMSkgKilcbiAgbGV0IHdpbnMwID0gcmVmIDAgaW5cbiAgbGV0IHdpbnMxID0gcmVmIDAgaW5cbiAgZm9yIF8gPSAxIHRvIGdhbWVzIGRvXG4gICAgbGV0IHN0MCA9IG1rX2luaXRpYWwgKCkgaW5cbiAgICBsZXQgciA9IHNpbXVsYXRlX2dhbWUgfnJuZyB+cDAgfnAxIHN0MCBpblxuICAgIGlmIHIud2lubmVyID0gMCB0aGVuIGluY3Igd2luczAgZWxzZSBpbmNyIHdpbnMxXG4gIGRvbmU7XG4gICghd2luczAsICF3aW5zMSkiXX0=
